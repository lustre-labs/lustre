/*******************************************************************************
 *
 * This file bundles and contains source code of the following npm packages:
 *
 * - happy-dom@17.4.7, MIT License
 * - @happy-dom/global-registrator@17.4.7, MIT License
 * - whatwg-mimetype@3.0.0, MIT License
 * - webidl-conversions@7.0.0, BSD-2-Clause License
 *
 * You can find the full license texts below.
 *
 *
 * MIT License
 *
 * Copyright (c) 2019 David Ortner (capricorn86)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 * # The BSD 2-Clause License
 *
 * Copyright (c) 2014, Domenic Denicola
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target2, all) => {
  for (var name2 in all)
    __defProp(target2, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));

// node_modules/whatwg-mimetype/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-mimetype/lib/utils.js"(exports) {
    "use strict";
    exports.removeLeadingAndTrailingHTTPWhitespace = (string) => {
      return string.replace(/^[ \t\n\r]+/u, "").replace(/[ \t\n\r]+$/u, "");
    };
    exports.removeTrailingHTTPWhitespace = (string) => {
      return string.replace(/[ \t\n\r]+$/u, "");
    };
    exports.isHTTPWhitespaceChar = (char) => {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    };
    exports.solelyContainsHTTPTokenCodePoints = (string) => {
      return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(string);
    };
    exports.soleyContainsHTTPQuotedStringTokenCodePoints = (string) => {
      return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(string);
    };
    exports.asciiLowercase = (string) => {
      return string.replace(/[A-Z]/ug, (l) => l.toLowerCase());
    };
    exports.collectAnHTTPQuotedString = (input, position) => {
      let value2 = "";
      position++;
      while (true) {
        while (position < input.length && input[position] !== '"' && input[position] !== "\\") {
          value2 += input[position];
          ++position;
        }
        if (position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position];
        ++position;
        if (quoteOrBackslash === "\\") {
          if (position >= input.length) {
            value2 += "\\";
            break;
          }
          value2 += input[position];
          ++position;
        } else {
          break;
        }
      }
      return [value2, position];
    };
  }
});

// node_modules/whatwg-mimetype/lib/mime-type-parameters.js
var require_mime_type_parameters = __commonJS({
  "node_modules/whatwg-mimetype/lib/mime-type-parameters.js"(exports, module) {
    "use strict";
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints
    } = require_utils();
    module.exports = class MIMETypeParameters {
      constructor(map) {
        this._map = map;
      }
      get size() {
        return this._map.size;
      }
      get(name2) {
        name2 = asciiLowercase(String(name2));
        return this._map.get(name2);
      }
      has(name2) {
        name2 = asciiLowercase(String(name2));
        return this._map.has(name2);
      }
      set(name2, value2) {
        name2 = asciiLowercase(String(name2));
        value2 = String(value2);
        if (!solelyContainsHTTPTokenCodePoints(name2)) {
          throw new Error(`Invalid MIME type parameter name "${name2}": only HTTP token code points are valid.`);
        }
        if (!soleyContainsHTTPQuotedStringTokenCodePoints(value2)) {
          throw new Error(`Invalid MIME type parameter value "${value2}": only HTTP quoted-string token code points are valid.`);
        }
        return this._map.set(name2, value2);
      }
      clear() {
        this._map.clear();
      }
      delete(name2) {
        name2 = asciiLowercase(String(name2));
        return this._map.delete(name2);
      }
      forEach(callbackFn, thisArg) {
        this._map.forEach(callbackFn, thisArg);
      }
      keys() {
        return this._map.keys();
      }
      values() {
        return this._map.values();
      }
      entries() {
        return this._map.entries();
      }
      [Symbol.iterator]() {
        return this._map[Symbol.iterator]();
      }
    };
  }
});

// node_modules/whatwg-mimetype/lib/parser.js
var require_parser = __commonJS({
  "node_modules/whatwg-mimetype/lib/parser.js"(exports, module) {
    "use strict";
    var {
      removeLeadingAndTrailingHTTPWhitespace,
      removeTrailingHTTPWhitespace,
      isHTTPWhitespaceChar,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints,
      asciiLowercase,
      collectAnHTTPQuotedString
    } = require_utils();
    module.exports = (input) => {
      input = removeLeadingAndTrailingHTTPWhitespace(input);
      let position = 0;
      let type2 = "";
      while (position < input.length && input[position] !== "/") {
        type2 += input[position];
        ++position;
      }
      if (type2.length === 0 || !solelyContainsHTTPTokenCodePoints(type2)) {
        return null;
      }
      if (position >= input.length) {
        return null;
      }
      ++position;
      let subtype = "";
      while (position < input.length && input[position] !== ";") {
        subtype += input[position];
        ++position;
      }
      subtype = removeTrailingHTTPWhitespace(subtype);
      if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {
        return null;
      }
      const mimeType = {
        type: asciiLowercase(type2),
        subtype: asciiLowercase(subtype),
        parameters: /* @__PURE__ */ new Map()
      };
      while (position < input.length) {
        ++position;
        while (isHTTPWhitespaceChar(input[position])) {
          ++position;
        }
        let parameterName = "";
        while (position < input.length && input[position] !== ";" && input[position] !== "=") {
          parameterName += input[position];
          ++position;
        }
        parameterName = asciiLowercase(parameterName);
        if (position < input.length) {
          if (input[position] === ";") {
            continue;
          }
          ++position;
        }
        let parameterValue = null;
        if (input[position] === '"') {
          [parameterValue, position] = collectAnHTTPQuotedString(input, position);
          while (position < input.length && input[position] !== ";") {
            ++position;
          }
        } else {
          parameterValue = "";
          while (position < input.length && input[position] !== ";") {
            parameterValue += input[position];
            ++position;
          }
          parameterValue = removeTrailingHTTPWhitespace(parameterValue);
          if (parameterValue === "") {
            continue;
          }
        }
        if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    };
  }
});

// node_modules/whatwg-mimetype/lib/serializer.js
var require_serializer = __commonJS({
  "node_modules/whatwg-mimetype/lib/serializer.js"(exports, module) {
    "use strict";
    var { solelyContainsHTTPTokenCodePoints } = require_utils();
    module.exports = (mimeType) => {
      let serialization = `${mimeType.type}/${mimeType.subtype}`;
      if (mimeType.parameters.size === 0) {
        return serialization;
      }
      for (let [name2, value2] of mimeType.parameters) {
        serialization += ";";
        serialization += name2;
        serialization += "=";
        if (!solelyContainsHTTPTokenCodePoints(value2) || value2.length === 0) {
          value2 = value2.replace(/(["\\])/ug, "\\$1");
          value2 = `"${value2}"`;
        }
        serialization += value2;
      }
      return serialization;
    };
  }
});

// node_modules/whatwg-mimetype/lib/mime-type.js
var require_mime_type = __commonJS({
  "node_modules/whatwg-mimetype/lib/mime-type.js"(exports, module) {
    "use strict";
    var MIMETypeParameters = require_mime_type_parameters();
    var parse = require_parser();
    var serialize = require_serializer();
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints
    } = require_utils();
    module.exports = class MIMEType {
      constructor(string) {
        string = String(string);
        const result2 = parse(string);
        if (result2 === null) {
          throw new Error(`Could not parse MIME type string "${string}"`);
        }
        this._type = result2.type;
        this._subtype = result2.subtype;
        this._parameters = new MIMETypeParameters(result2.parameters);
      }
      static parse(string) {
        try {
          return new this(string);
        } catch (e) {
          return null;
        }
      }
      get essence() {
        return `${this.type}/${this.subtype}`;
      }
      get type() {
        return this._type;
      }
      set type(value2) {
        value2 = asciiLowercase(String(value2));
        if (value2.length === 0) {
          throw new Error("Invalid type: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value2)) {
          throw new Error(`Invalid type ${value2}: must contain only HTTP token code points`);
        }
        this._type = value2;
      }
      get subtype() {
        return this._subtype;
      }
      set subtype(value2) {
        value2 = asciiLowercase(String(value2));
        if (value2.length === 0) {
          throw new Error("Invalid subtype: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value2)) {
          throw new Error(`Invalid subtype ${value2}: must contain only HTTP token code points`);
        }
        this._subtype = value2;
      }
      get parameters() {
        return this._parameters;
      }
      toString() {
        return serialize(this);
      }
      isJavaScript({ prohibitParameters = false } = {}) {
        switch (this._type) {
          case "text": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "javascript1.0":
              case "javascript1.1":
              case "javascript1.2":
              case "javascript1.3":
              case "javascript1.4":
              case "javascript1.5":
              case "jscript":
              case "livescript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          case "application": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          default: {
            return false;
          }
        }
      }
      isXML() {
        return this._subtype === "xml" && (this._type === "text" || this._type === "application") || this._subtype.endsWith("+xml");
      }
      isHTML() {
        return this._subtype === "html" && this._type === "text";
      }
    };
  }
});

// node_modules/happy-dom/lib/PropertySymbol.js
var PropertySymbol_exports = {};
__export(PropertySymbol_exports, {
  abort: () => abort,
  aborted: () => aborted,
  accessKey: () => accessKey,
  accessKeyLabel: () => accessKeyLabel,
  activeCues: () => activeCues,
  activeElement: () => activeElement,
  adoptedStyleSheets: () => adoptedStyleSheets,
  affectsCache: () => affectsCache,
  affectsComputedStyleCache: () => affectsComputedStyleCache,
  amplitude: () => amplitude,
  angle: () => angle,
  animVal: () => animVal,
  animatedPoints: () => animatedPoints,
  appendChild: () => appendChild,
  areas: () => areas,
  assignedNodes: () => assignedNodes,
  assignedToSlot: () => assignedToSlot,
  asyncTaskManager: () => asyncTaskManager,
  attributeName: () => attributeName,
  attributeValue: () => attributeValue,
  attributes: () => attributes,
  attributesProxy: () => attributesProxy,
  azimuth: () => azimuth,
  baseFrequencyX: () => baseFrequencyX,
  baseFrequencyY: () => baseFrequencyY,
  baseVal: () => baseVal,
  bias: () => bias,
  bindMethods: () => bindMethods,
  blocking: () => blocking,
  body: () => body,
  bodyBuffer: () => bodyBuffer,
  bodyUsed: () => bodyUsed,
  browserFrames: () => browserFrames,
  bubbles: () => bubbles,
  buffer: () => buffer,
  buffered: () => buffered,
  cache: () => cache,
  cachedResponse: () => cachedResponse,
  callbacks: () => callbacks,
  cancelable: () => cancelable,
  canvas: () => canvas,
  capabilities: () => capabilities,
  cells: () => cells,
  checked: () => checked,
  childNodes: () => childNodes,
  children: () => children,
  classList: () => classList,
  classRegistry: () => classRegistry,
  clearCache: () => clearCache,
  clientHeight: () => clientHeight,
  clientLeft: () => clientLeft,
  clientTop: () => clientTop,
  clientWidth: () => clientWidth,
  clipPathUnits: () => clipPathUnits,
  clonable: () => clonable,
  clone: () => clone,
  cloneNode: () => cloneNode,
  complete: () => complete,
  composed: () => composed,
  computedStyle: () => computedStyle,
  connectedToDocument: () => connectedToDocument,
  connectedToNode: () => connectedToNode,
  constraints: () => constraints,
  content: () => content,
  contentLength: () => contentLength,
  contentType: () => contentType,
  controlsList: () => controlsList,
  credentials: () => credentials,
  crossOrigin: () => crossOrigin,
  cssText: () => cssText,
  cues: () => cues,
  currentScale: () => currentScale,
  currentScript: () => currentScript,
  currentTarget: () => currentTarget,
  currentTime: () => currentTime,
  customElementReactionStack: () => customElementReactionStack,
  cx: () => cx,
  cy: () => cy,
  data: () => data,
  dataset: () => dataset,
  defaultChecked: () => defaultChecked,
  defaultMuted: () => defaultMuted,
  defaultPlaybackRate: () => defaultPlaybackRate,
  defaultPrevented: () => defaultPrevented,
  defaultValue: () => defaultValue,
  defaultView: () => defaultView,
  delegatesFocus: () => delegatesFocus,
  destroy: () => destroy,
  destroyed: () => destroyed,
  detail: () => detail,
  diffuseConstant: () => diffuseConstant,
  dirtyness: () => dirtyness,
  disabled: () => disabled,
  disconnectedFromDocument: () => disconnectedFromDocument,
  disconnectedFromNode: () => disconnectedFromNode,
  dispatchError: () => dispatchError,
  dispatching: () => dispatching,
  divisor: () => divisor,
  domMatrix: () => domMatrix,
  duration: () => duration,
  dx: () => dx,
  dy: () => dy,
  edgeMode: () => edgeMode,
  elementArray: () => elementArray,
  elementIdMap: () => elementIdMap,
  elements: () => elements,
  elevation: () => elevation,
  end: () => end,
  ended: () => ended,
  entries: () => entries,
  error: () => error,
  evaluateCSS: () => evaluateCSS,
  evaluateScript: () => evaluateScript,
  eventPhase: () => eventPhase,
  exceptionObserver: () => exceptionObserver,
  exponent: () => exponent,
  files: () => files,
  filterNode: () => filterNode,
  filterUnits: () => filterUnits,
  flipXSelf: () => flipXSelf,
  flipYSelf: () => flipYSelf,
  formNode: () => formNode,
  forms: () => forms,
  fromArray: () => fromArray,
  fromString: () => fromString,
  fx: () => fx,
  fy: () => fy,
  getAttribute: () => getAttribute,
  getDOMMatrix: () => getDOMMatrix,
  getFormControlItems: () => getFormControlItems,
  getFormControlNamedItem: () => getFormControlNamedItem,
  getItemList: () => getItemList,
  getLength: () => getLength,
  getNamedItemKey: () => getNamedItemKey,
  getNamespaceItemKey: () => getNamespaceItemKey,
  getTokenList: () => getTokenList,
  globalObject: () => globalObject,
  gradientTransform: () => gradientTransform,
  gradientUnits: () => gradientUnits,
  headers: () => headers,
  height: () => height,
  history: () => history,
  host: () => host,
  href: () => href,
  id: () => id,
  illegalConstructor: () => illegalConstructor,
  immediatePropagationStopped: () => immediatePropagationStopped,
  implementation: () => implementation,
  in1: () => in1,
  in2: () => in2,
  indeterminate: () => indeterminate,
  insertBefore: () => insertBefore,
  intercept: () => intercept,
  internalId: () => internalId,
  invertSelf: () => invertSelf,
  isConnected: () => isConnected,
  isFirstWrite: () => isFirstWrite,
  isFirstWriteAfterOpen: () => isFirstWriteAfterOpen,
  isInPassiveEventListener: () => isInPassiveEventListener,
  isValue: () => isValue,
  items: () => items,
  itemsByName: () => itemsByName,
  itemsByNamespaceURI: () => itemsByNamespaceURI,
  kernelMatrix: () => kernelMatrix,
  kernelUnitLengthX: () => kernelUnitLengthX,
  kernelUnitLengthY: () => kernelUnitLengthY,
  kind: () => kind,
  label: () => label,
  language: () => language,
  length: () => length,
  lengthAdjust: () => lengthAdjust,
  limitingConeAngle: () => limitingConeAngle,
  listenerOptions: () => listenerOptions,
  listeners: () => listeners,
  loading: () => loading,
  localName: () => localName,
  localStorage: () => localStorage,
  location: () => location,
  m11: () => m11,
  m12: () => m12,
  m13: () => m13,
  m14: () => m14,
  m21: () => m21,
  m22: () => m22,
  m23: () => m23,
  m24: () => m24,
  m31: () => m31,
  m32: () => m32,
  m33: () => m33,
  m34: () => m34,
  m41: () => m41,
  m42: () => m42,
  m43: () => m43,
  m44: () => m44,
  markerHeight: () => markerHeight,
  markerUnits: () => markerUnits,
  markerWidth: () => markerWidth,
  maskContentUnits: () => maskContentUnits,
  maskUnits: () => maskUnits,
  matrix: () => matrix,
  mediaKeys: () => mediaKeys,
  method: () => method,
  mode: () => mode,
  moduleImportMap: () => moduleImportMap,
  modules: () => modules,
  multiplySelf: () => multiplySelf,
  mutationListeners: () => mutationListeners,
  mutationObservers: () => mutationObservers,
  muted: () => muted,
  name: () => name,
  namespaceURI: () => namespaceURI,
  naturalHeight: () => naturalHeight,
  naturalWidth: () => naturalWidth,
  navigator: () => navigator,
  networkState: () => networkState,
  nextActiveElement: () => nextActiveElement,
  nodeArray: () => nodeArray,
  nodeStream: () => nodeStream,
  nodeType: () => nodeType,
  numOctaves: () => numOctaves,
  observeMutations: () => observeMutations,
  offset: () => offset,
  offsetHeight: () => offsetHeight,
  offsetLeft: () => offsetLeft,
  offsetTop: () => offsetTop,
  offsetWidth: () => offsetWidth,
  onRemoveAttribute: () => onRemoveAttribute,
  onSetAttribute: () => onSetAttribute,
  openerFrame: () => openerFrame,
  openerWindow: () => openerWindow,
  operator: () => operator,
  options: () => options,
  orderX: () => orderX,
  orderY: () => orderY,
  orientAngle: () => orientAngle,
  orientType: () => orientType,
  ownerDocument: () => ownerDocument,
  ownerElement: () => ownerElement,
  parent: () => parent,
  parentNode: () => parentNode,
  pathLength: () => pathLength,
  patternContentUnits: () => patternContentUnits,
  patternTransform: () => patternTransform,
  patternUnits: () => patternUnits,
  paused: () => paused,
  playbackRate: () => playbackRate,
  played: () => played,
  points: () => points,
  pointsAtX: () => pointsAtX,
  pointsAtY: () => pointsAtY,
  pointsAtZ: () => pointsAtZ,
  popoverTargetElement: () => popoverTargetElement,
  popup: () => popup,
  prefix: () => prefix,
  preloads: () => preloads,
  preserveAlpha: () => preserveAlpha,
  preserveAspectRatio: () => preserveAspectRatio,
  preservesPitch: () => preservesPitch,
  primitiveUnits: () => primitiveUnits,
  propagationStopped: () => propagationStopped,
  propertyEventListeners: () => propertyEventListeners,
  proxy: () => proxy,
  publicId: () => publicId,
  query: () => query,
  r: () => r,
  radiusX: () => radiusX,
  radiusY: () => radiusY,
  readOnly: () => readOnly,
  readyState: () => readyState,
  readyStateManager: () => readyStateManager,
  reason: () => reason,
  redirect: () => redirect,
  refX: () => refX,
  refY: () => refY,
  referrer: () => referrer,
  referrerPolicy: () => referrerPolicy,
  registry: () => registry,
  relList: () => relList,
  remote: () => remote,
  removeChild: () => removeChild,
  removeNamedItem: () => removeNamedItem,
  replaceChild: () => replaceChild,
  reportMutation: () => reportMutation,
  requiredExtensions: () => requiredExtensions,
  resetSelection: () => resetSelection,
  result: () => result,
  returnValue: () => returnValue,
  root: () => root,
  rootNode: () => rootNode,
  rotate: () => rotate,
  rotateAxisAngleSelf: () => rotateAxisAngleSelf,
  rotateFromVectorSelf: () => rotateFromVectorSelf,
  rotateSelf: () => rotateSelf,
  rows: () => rows,
  rx: () => rx,
  ry: () => ry,
  sandbox: () => sandbox,
  scale: () => scale,
  scale3dSelf: () => scale3dSelf,
  scaleNonUniformSelf: () => scaleNonUniformSelf,
  scaleSelf: () => scaleSelf,
  screen: () => screen,
  scrollHeight: () => scrollHeight,
  scrollLeft: () => scrollLeft,
  scrollTop: () => scrollTop,
  scrollWidth: () => scrollWidth,
  seed: () => seed,
  seekable: () => seekable,
  seeking: () => seeking,
  selectNode: () => selectNode,
  selectedIndex: () => selectedIndex,
  selectedOptions: () => selectedOptions,
  selectedness: () => selectedness,
  selection: () => selection,
  self: () => self,
  serializable: () => serializable,
  sessionStorage: () => sessionStorage,
  setAttribute: () => setAttribute,
  setDOMMatrix: () => setDOMMatrix,
  setMatrixValue: () => setMatrixValue,
  setNamedItem: () => setNamedItem,
  setURL: () => setURL,
  settings: () => settings,
  setupVMContext: () => setupVMContext,
  shadowRoot: () => shadowRoot,
  sheet: () => sheet,
  signal: () => signal,
  sinkId: () => sinkId,
  skewXSelf: () => skewXSelf,
  skewYSelf: () => skewYSelf,
  slope: () => slope,
  slotAssignment: () => slotAssignment,
  spacing: () => spacing,
  specified: () => specified,
  specularConstant: () => specularConstant,
  specularExponent: () => specularExponent,
  spreadMethod: () => spreadMethod,
  srcObject: () => srcObject,
  start: () => start,
  startOffset: () => startOffset,
  state: () => state,
  stdDeviationX: () => stdDeviationX,
  stdDeviationY: () => stdDeviationY,
  stitchTiles: () => stitchTiles,
  style: () => style,
  styleNode: () => styleNode,
  supports: () => supports,
  surfaceScale: () => surfaceScale,
  systemId: () => systemId,
  systemLanguage: () => systemLanguage,
  tBodies: () => tBodies,
  tableValues: () => tableValues,
  tagName: () => tagName,
  target: () => target,
  targetX: () => targetX,
  targetY: () => targetY,
  textAreaNode: () => textAreaNode,
  textLength: () => textLength,
  textTracks: () => textTracks,
  timeStamp: () => timeStamp,
  toArray: () => toArray,
  top: () => top,
  track: () => track,
  tracks: () => tracks,
  transform: () => transform,
  translateSelf: () => translateSelf,
  type: () => type,
  unitType: () => unitType,
  unobserveMutations: () => unobserveMutations,
  updateSelectedness: () => updateSelectedness,
  updateSheet: () => updateSheet,
  url: () => url,
  validationMessage: () => validationMessage,
  validity: () => validity,
  value: () => value,
  values: () => values,
  viewBox: () => viewBox,
  volume: () => volume,
  w: () => w,
  width: () => width,
  window: () => window,
  windowInternalId: () => windowInternalId,
  windowResizeListener: () => windowResizeListener,
  x: () => x,
  x1: () => x1,
  x2: () => x2,
  xChannelSelector: () => xChannelSelector,
  xmlProcessingInstruction: () => xmlProcessingInstruction,
  y: () => y,
  y1: () => y1,
  y2: () => y2,
  yChannelSelector: () => yChannelSelector,
  z: () => z
});
var abort = Symbol("abort");
var activeElement = Symbol("activeElement");
var asyncTaskManager = Symbol("asyncTaskManager");
var bodyBuffer = Symbol("bodyBuffer");
var buffer = Symbol("buffer");
var cachedResponse = Symbol("cachedResponse");
var callbacks = Symbol("callbacks");
var checked = Symbol("checked");
var childNodes = Symbol("childNodes");
var children = Symbol("children");
var classList = Symbol("classList");
var connectedToNode = Symbol("connectedToNode");
var disconnectedFromNode = Symbol("disconnectedFromNode");
var connectedToDocument = Symbol("connectedToDocument");
var disconnectedFromDocument = Symbol("disconnectedFromDocument");
var contentLength = Symbol("contentLength");
var contentType = Symbol("contentType");
var cssText = Symbol("cssText");
var currentScript = Symbol("currentScript");
var currentTarget = Symbol("currentTarget");
var data = Symbol("data");
var defaultView = Symbol("defaultView");
var destroy = Symbol("destroy");
var dirtyness = Symbol("dirtyness");
var end = Symbol("end");
var entries = Symbol("entries");
var evaluateCSS = Symbol("evaluateCSS");
var evaluateScript = Symbol("evaluateScript");
var exceptionObserver = Symbol("exceptionObserver");
var formNode = Symbol("formNode");
var internalId = Symbol("internalId");
var height = Symbol("height");
var immediatePropagationStopped = Symbol("immediatePropagationStopped");
var indeterminate = Symbol("indeterminate");
var isFirstWrite = Symbol("isFirstWrite");
var isFirstWriteAfterOpen = Symbol("isFirstWriteAfterOpen");
var isInPassiveEventListener = Symbol("isInPassiveEventListener");
var isValue = Symbol("isValue");
var listenerOptions = Symbol("listenerOptions");
var listeners = Symbol("listeners");
var itemsByName = Symbol("itemsByName");
var nextActiveElement = Symbol("nextActiveElement");
var observeMutations = Symbol("observeMutations");
var mutationListeners = Symbol("mutationListeners");
var ownerDocument = Symbol("ownerDocument");
var ownerElement = Symbol("ownerElement");
var propagationStopped = Symbol("propagationStopped");
var readyStateManager = Symbol("readyStateManager");
var referrer = Symbol("referrer");
var registry = Symbol("registry");
var relList = Symbol("relList");
var resetSelection = Symbol("resetSelection");
var rootNode = Symbol("rootNode");
var selectNode = Symbol("selectNode");
var selectedness = Symbol("selectedness");
var selection = Symbol("selection");
var setupVMContext = Symbol("setupVMContext");
var shadowRoot = Symbol("shadowRoot");
var start = Symbol("start");
var style = Symbol("style");
var target = Symbol("target");
var textAreaNode = Symbol("textAreaNode");
var unobserveMutations = Symbol("unobserveMutations");
var reportMutation = Symbol("reportMutation");
var updateSelectedness = Symbol("updateSelectedness");
var url = Symbol("url");
var value = Symbol("value");
var width = Symbol("width");
var window = Symbol("window");
var windowResizeListener = Symbol("windowResizeListener");
var mutationObservers = Symbol("mutationObservers");
var openerFrame = Symbol("openerFrame");
var openerWindow = Symbol("openerWindow");
var popup = Symbol("popup");
var isConnected = Symbol("isConnected");
var parentNode = Symbol("parentNode");
var nodeType = Symbol("nodeType");
var tagName = Symbol("tagName");
var prefix = Symbol("prefix");
var scrollHeight = Symbol("scrollHeight");
var scrollWidth = Symbol("scrollWidth");
var scrollTop = Symbol("scrollTop");
var scrollLeft = Symbol("scrollLeft");
var attributes = Symbol("attributes");
var attributesProxy = Symbol("attributesProxy");
var namespaceURI = Symbol("namespaceURI");
var accessKey = Symbol("accessKey");
var accessKeyLabel = Symbol("accessKeyLabel");
var offsetHeight = Symbol("offsetHeight");
var offsetWidth = Symbol("offsetWidth");
var offsetLeft = Symbol("offsetLeft");
var offsetTop = Symbol("offsetTop");
var clientHeight = Symbol("clientHeight");
var clientWidth = Symbol("clientWidth");
var clientLeft = Symbol("clientLeft");
var clientTop = Symbol("clientTop");
var name = Symbol("name");
var specified = Symbol("specified");
var adoptedStyleSheets = Symbol("adoptedStyleSheets");
var implementation = Symbol("implementation");
var readyState = Symbol("readyState");
var publicId = Symbol("publicId");
var systemId = Symbol("systemId");
var validationMessage = Symbol("validationMessage");
var validity = Symbol("validity");
var returnValue = Symbol("returnValue");
var elements = Symbol("elements");
var length = Symbol("length");
var complete = Symbol("complete");
var naturalHeight = Symbol("naturalHeight");
var naturalWidth = Symbol("naturalWidth");
var loading = Symbol("loading");
var x = Symbol("x");
var y = Symbol("y");
var defaultChecked = Symbol("defaultChecked");
var files = Symbol("files");
var sheet = Symbol("sheet");
var volume = Symbol("volume");
var paused = Symbol("paused");
var currentTime = Symbol("currentTime");
var playbackRate = Symbol("playbackRate");
var defaultPlaybackRate = Symbol("defaultPlaybackRate");
var muted = Symbol("muted");
var defaultMuted = Symbol("defaultMuted");
var preservesPitch = Symbol("preservesPitch");
var buffered = Symbol("buffered");
var duration = Symbol("duration");
var error = Symbol("error");
var ended = Symbol("ended");
var networkState = Symbol("networkState");
var textTracks = Symbol("textTracks");
var seeking = Symbol("seeking");
var seekable = Symbol("seekable");
var played = Symbol("played");
var options = Symbol("options");
var content = Symbol("content");
var mode = Symbol("mode");
var host = Symbol("host");
var setURL = Symbol("setURL");
var localName = Symbol("localName");
var classRegistry = Symbol("classRegistry");
var nodeStream = Symbol("nodeStream");
var location = Symbol("location");
var history = Symbol("history");
var navigator = Symbol("navigator");
var screen = Symbol("screen");
var sessionStorage = Symbol("sessionStorage");
var localStorage = Symbol("localStorage");
var sandbox = Symbol("sandbox");
var cloneNode = Symbol("cloneNode");
var appendChild = Symbol("appendChild");
var removeChild = Symbol("removeChild");
var insertBefore = Symbol("insertBefore");
var replaceChild = Symbol("replaceChild");
var tracks = Symbol("tracks");
var constraints = Symbol("constraints");
var capabilities = Symbol("capabilities");
var settings = Symbol("settings");
var clone = Symbol("clone");
var removeNamedItem = Symbol("removeNamedItem");
var items = Symbol("items");
var selectedOptions = Symbol("selectedOptions");
var styleNode = Symbol("styleNode");
var updateSheet = Symbol("updateSheet");
var clearCache = Symbol("clearCache");
var onSetAttribute = Symbol("onSetAttribute");
var onRemoveAttribute = Symbol("onRemoveAttribute");
var nodeArray = Symbol("nodeArray");
var elementArray = Symbol("elementArray");
var cache = Symbol("cache");
var affectsCache = Symbol("affectsCache");
var forms = Symbol("forms");
var affectsComputedStyleCache = Symbol("affectsComputedStyleCache");
var query = Symbol("query");
var computedStyle = Symbol("computedStyle");
var getFormControlItems = Symbol("getFormControlItems");
var getFormControlNamedItem = Symbol("getFormControlNamedItem");
var dataset = Symbol("dataset");
var getNamespaceItemKey = Symbol("getNamespaceItemKey");
var getNamedItemKey = Symbol("getNamedItemKey");
var itemsByNamespaceURI = Symbol("itemsByNamespaceURI");
var proxy = Symbol("proxy");
var setNamedItem = Symbol("setNamedItem");
var getTokenList = Symbol("getTokenList");
var attributeName = Symbol("attributeName");
var selectedIndex = Symbol("selectedIndex");
var self = Symbol("self");
var parent = Symbol("parent");
var top = Symbol("top");
var areas = Symbol("areas");
var defaultValue = Symbol("defaultValue");
var elementIdMap = Symbol("elementIdMap");
var clonable = Symbol("clonable");
var delegatesFocus = Symbol("delegatesFocus");
var serializable = Symbol("serializable");
var slotAssignment = Symbol("slotAssignment");
var assignedNodes = Symbol("assignedNodes");
var assignedToSlot = Symbol("assignedToSlot");
var cells = Symbol("cells");
var rows = Symbol("rows");
var headers = Symbol("headers");
var tBodies = Symbol("tBodies");
var track = Symbol("track");
var controlsList = Symbol("controlsList");
var mediaKeys = Symbol("mediaKeys");
var remote = Symbol("remote");
var sinkId = Symbol("sinkId");
var srcObject = Symbol("srcObject");
var cues = Symbol("cues");
var activeCues = Symbol("activeCues");
var kind = Symbol("kind");
var label = Symbol("label");
var language = Symbol("language");
var id = Symbol("id");
var illegalConstructor = Symbol("illegalConstructor");
var state = Symbol("state");
var canvas = Symbol("canvas");
var popoverTargetElement = Symbol("popoverTargetElement");
var composed = Symbol("composed");
var bubbles = Symbol("bubbles");
var cancelable = Symbol("cancelable");
var defaultPrevented = Symbol("defaultPrevented");
var eventPhase = Symbol("eventPhase");
var timeStamp = Symbol("timeStamp");
var type = Symbol("type");
var detail = Symbol("detail");
var globalObject = Symbol("globalObject");
var destroyed = Symbol("destroyed");
var aborted = Symbol("aborted");
var browserFrames = Symbol("browserFrames");
var windowInternalId = Symbol("windowInternalId");
var getItemList = Symbol("getItemList");
var requiredExtensions = Symbol("requiredExtensions");
var systemLanguage = Symbol("systemLanguage");
var transform = Symbol("transform");
var baseVal = Symbol("baseVal");
var animVal = Symbol("animVal");
var pathLength = Symbol("pathLength");
var unitType = Symbol("unitType");
var viewBox = Symbol("viewBox");
var markerUnits = Symbol("markerUnits");
var markerWidth = Symbol("markerWidth");
var markerHeight = Symbol("markerHeight");
var values = Symbol("values");
var orientType = Symbol("orientType");
var orientAngle = Symbol("orientAngle");
var refX = Symbol("refX");
var refY = Symbol("refY");
var readOnly = Symbol("readOnly");
var preserveAspectRatio = Symbol("preserveAspectRatio");
var animatedPoints = Symbol("animatedPoints");
var points = Symbol("points");
var rx = Symbol("rx");
var ry = Symbol("ry");
var cx = Symbol("cx");
var cy = Symbol("cy");
var r = Symbol("r");
var clipPathUnits = Symbol("clipPathUnits");
var maskUnits = Symbol("maskUnits");
var maskContentUnits = Symbol("maskContentUnits");
var filterUnits = Symbol("filterUnits");
var primitiveUnits = Symbol("primitiveUnits");
var href = Symbol("href");
var x1 = Symbol("x1");
var y1 = Symbol("y1");
var x2 = Symbol("x2");
var y2 = Symbol("y2");
var gradientUnits = Symbol("gradientUnits");
var gradientTransform = Symbol("gradientTransform");
var spreadMethod = Symbol("spreadMethod");
var patternUnits = Symbol("patternUnits");
var patternContentUnits = Symbol("patternContentUnits");
var patternTransform = Symbol("patternTransform");
var fx = Symbol("fx");
var fy = Symbol("fy");
var offset = Symbol("offset");
var disabled = Symbol("disabled");
var textLength = Symbol("textLength");
var lengthAdjust = Symbol("lengthAdjust");
var getAttribute = Symbol("getAttribute");
var setAttribute = Symbol("setAttribute");
var z = Symbol("z");
var w = Symbol("w");
var toArray = Symbol("toArray");
var fromString = Symbol("fromString");
var fromArray = Symbol("fromArray");
var angle = Symbol("angle");
var m11 = Symbol("m11");
var m12 = Symbol("m12");
var m13 = Symbol("m13");
var m14 = Symbol("m14");
var m21 = Symbol("m21");
var m22 = Symbol("m22");
var m23 = Symbol("m23");
var m24 = Symbol("m24");
var m31 = Symbol("m31");
var m32 = Symbol("m32");
var m33 = Symbol("m33");
var m34 = Symbol("m34");
var m41 = Symbol("m41");
var m42 = Symbol("m42");
var m43 = Symbol("m43");
var m44 = Symbol("m44");
var setMatrixValue = Symbol("setMatrixValue");
var translateSelf = Symbol("translateSelf");
var rotateSelf = Symbol("rotateSelf");
var rotateAxisAngleSelf = Symbol("rotateAxisAngleSelf");
var scaleSelf = Symbol("scaleSelf");
var scale3dSelf = Symbol("scale3dSelf");
var scaleNonUniformSelf = Symbol("scaleNonUniformSelf");
var skewXSelf = Symbol("skewXSelf");
var skewYSelf = Symbol("skewYSelf");
var multiplySelf = Symbol("multiplySelf");
var matrix = Symbol("matrix");
var domMatrix = Symbol("domMatrix");
var getDOMMatrix = Symbol("getDOMMatrix");
var setDOMMatrix = Symbol("setDOMMatrix");
var attributeValue = Symbol("attributeValue");
var startOffset = Symbol("startOffset");
var method = Symbol("method");
var spacing = Symbol("spacing");
var in1 = Symbol("in1");
var in2 = Symbol("in2");
var result = Symbol("result");
var bias = Symbol("bias");
var divisor = Symbol("divisor");
var edgeMode = Symbol("edgeMode");
var kernelMatrix = Symbol("kernelMatrix");
var kernelUnitLengthX = Symbol("kernelUnitLengthX");
var kernelUnitLengthY = Symbol("kernelUnitLengthY");
var orderX = Symbol("orderX");
var orderY = Symbol("orderY");
var preserveAlpha = Symbol("preserveAlpha");
var targetX = Symbol("targetX");
var targetY = Symbol("targetY");
var diffuseConstant = Symbol("diffuseConstant");
var surfaceScale = Symbol("surfaceScale");
var scale = Symbol("scale");
var xChannelSelector = Symbol("xChannelSelector");
var yChannelSelector = Symbol("yChannelSelector");
var azimuth = Symbol("azimuth");
var elevation = Symbol("elevation");
var dx = Symbol("dx");
var dy = Symbol("dy");
var stdDeviationX = Symbol("stdDeviationX");
var stdDeviationY = Symbol("stdDeviationY");
var tableValues = Symbol("tableValues");
var slope = Symbol("slope");
var intercept = Symbol("intercept");
var amplitude = Symbol("amplitude");
var exponent = Symbol("exponent");
var crossOrigin = Symbol("crossOrigin");
var operator = Symbol("operator");
var radiusX = Symbol("radiusX");
var radiusY = Symbol("radiusY");
var specularConstant = Symbol("specularConstant");
var specularExponent = Symbol("specularExponent");
var pointsAtX = Symbol("pointsAtX");
var pointsAtY = Symbol("pointsAtY");
var pointsAtZ = Symbol("pointsAtZ");
var limitingConeAngle = Symbol("limitingConeAngle");
var baseFrequencyX = Symbol("baseFrequencyX");
var baseFrequencyY = Symbol("baseFrequencyY");
var numOctaves = Symbol("numOctaves");
var seed = Symbol("seed");
var stitchTiles = Symbol("stitchTiles");
var rotateFromVectorSelf = Symbol("rotateFromVectorSelf");
var flipXSelf = Symbol("flipXSelf");
var flipYSelf = Symbol("flipYSelf");
var invertSelf = Symbol("invertSelf");
var getLength = Symbol("getLength");
var currentScale = Symbol("currentScale");
var rotate = Symbol("rotate");
var bindMethods = Symbol("bindMethods");
var xmlProcessingInstruction = Symbol("xmlProcessingInstruction");
var root = Symbol("root");
var filterNode = Symbol("filterNode");
var customElementReactionStack = Symbol("customElementReactionStack");
var dispatching = Symbol("dispatching");
var modules = Symbol("modules");
var preloads = Symbol("preloads");
var body = Symbol("body");
var redirect = Symbol("redirect");
var referrerPolicy = Symbol("referrerPolicy");
var signal = Symbol("signal");
var bodyUsed = Symbol("bodyUsed");
var credentials = Symbol("credentials");
var blocking = Symbol("blocking");
var moduleImportMap = Symbol("moduleImportMap");
var dispatchError = Symbol("dispatchError");
var supports = Symbol("supports");
var reason = Symbol("reason");
var propertyEventListeners = Symbol("propertyEventListeners");

// node_modules/happy-dom/lib/cookie/enums/CookieSameSiteEnum.js
var CookieSameSiteEnum;
(function(CookieSameSiteEnum2) {
  CookieSameSiteEnum2["strict"] = "Strict";
  CookieSameSiteEnum2["lax"] = "Lax";
  CookieSameSiteEnum2["none"] = "None";
})(CookieSameSiteEnum || (CookieSameSiteEnum = {}));
var CookieSameSiteEnum_default = CookieSameSiteEnum;

// node_modules/happy-dom/lib/cookie/DefaultCookie.js
var DefaultCookie_default = {
  // Required
  key: null,
  originURL: null,
  // Optional
  value: null,
  domain: "",
  path: "",
  expires: null,
  httpOnly: false,
  secure: false,
  sameSite: CookieSameSiteEnum_default.lax
};

// node_modules/happy-dom/lib/cookie/urilities/CookieExpireUtility.js
var CookieExpireUtility = class {
  /**
   * Returns "true" if cookie has expired.
   *
   * @param cookie Cookie.
   * @returns "true" if cookie has expired.
   */
  static hasExpired(cookie) {
    return cookie.expires && cookie.expires.getTime() < Date.now();
  }
};

// node_modules/happy-dom/lib/cookie/urilities/CookieURLUtility.js
var CookieURLUtility = class {
  /**
   * Returns "true" if cookie matches URL.
   *
   * @param cookie Cookie.
   * @param url URL.
   * @returns "true" if cookie matches URL.
   */
  static cookieMatchesURL(cookie, url2) {
    const isLocalhost = url2.hostname === "localhost" || url2.hostname.endsWith(".localhost");
    return (!cookie.secure || url2.protocol === "https:" || isLocalhost) && (!cookie.domain || url2.hostname.endsWith(cookie.domain)) && (!cookie.path || url2.pathname.startsWith(cookie.path)) && // @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value
    (cookie.sameSite === CookieSameSiteEnum_default.none && cookie.secure || cookie.originURL.hostname === url2.hostname);
  }
};

// node_modules/happy-dom/lib/cookie/CookieContainer.js
var CookieContainer = class {
  #cookies = [];
  /**
   * Adds cookies.
   *
   * @param cookies Cookies.
   */
  addCookies(cookies) {
    const indexMap = {};
    const getKey = (cookie) => `${cookie.key}-${cookie.originURL.hostname}-${cookie.path}-${typeof cookie.value}`;
    for (let i = 0, max = this.#cookies.length; i < max; i++) {
      indexMap[getKey(this.#cookies[i])] = i;
    }
    for (const cookie of cookies) {
      const newCookie = Object.assign({}, DefaultCookie_default, cookie);
      if (newCookie && newCookie.key && newCookie.originURL) {
        const index = indexMap[getKey(newCookie)];
        if (index !== void 0) {
          this.#cookies.splice(index, 1);
        }
        if (!CookieExpireUtility.hasExpired(newCookie)) {
          indexMap[getKey(newCookie)] = this.#cookies.length;
          this.#cookies.push(newCookie);
        }
      }
    }
  }
  /**
   * Returns cookies.
   *
   * @param [url] URL.
   * @param [httpOnly] "true" if only http cookies should be returned.
   * @returns Cookies.
   */
  getCookies(url2 = null, httpOnly = false) {
    const cookies = [];
    for (const cookie of this.#cookies) {
      if (!CookieExpireUtility.hasExpired(cookie) && (!httpOnly || !cookie.httpOnly) && (!url2 || CookieURLUtility.cookieMatchesURL(cookie, url2 || cookie.originURL))) {
        cookies.push(cookie);
      }
    }
    return cookies;
  }
};

// node_modules/happy-dom/lib/fetch/cache/response/CachedResponseStateEnum.js
var CachedResponseStateEnum;
(function(CachedResponseStateEnum2) {
  CachedResponseStateEnum2["fresh"] = "fresh";
  CachedResponseStateEnum2["stale"] = "stale";
})(CachedResponseStateEnum || (CachedResponseStateEnum = {}));
var CachedResponseStateEnum_default = CachedResponseStateEnum;

// node_modules/happy-dom/lib/exception/DOMExceptionNameEnum.js
var DOMExceptionNameEnum;
(function(DOMExceptionNameEnum2) {
  DOMExceptionNameEnum2["invalidStateError"] = "InvalidStateError";
  DOMExceptionNameEnum2["indexSizeError"] = "IndexSizeError";
  DOMExceptionNameEnum2["syntaxError"] = "SyntaxError";
  DOMExceptionNameEnum2["hierarchyRequestError"] = "HierarchyRequestError";
  DOMExceptionNameEnum2["notSupportedError"] = "NotSupportedError";
  DOMExceptionNameEnum2["wrongDocumentError"] = "WrongDocumentError";
  DOMExceptionNameEnum2["invalidNodeTypeError"] = "InvalidNodeTypeError";
  DOMExceptionNameEnum2["invalidCharacterError"] = "InvalidCharacterError";
  DOMExceptionNameEnum2["notFoundError"] = "NotFoundError";
  DOMExceptionNameEnum2["securityError"] = "SecurityError";
  DOMExceptionNameEnum2["networkError"] = "NetworkError";
  DOMExceptionNameEnum2["domException"] = "DOMException";
  DOMExceptionNameEnum2["invalidAccessError"] = "InvalidAccessError";
  DOMExceptionNameEnum2["unknownError"] = "UnknownError";
  DOMExceptionNameEnum2["abortError"] = "AbortError";
  DOMExceptionNameEnum2["timeoutError"] = "TimeoutError";
  DOMExceptionNameEnum2["encodingError"] = "EncodingError";
  DOMExceptionNameEnum2["uriMismatchError"] = "URIMismatchError";
  DOMExceptionNameEnum2["inUseAttributeError"] = "InUseAttributeError";
  DOMExceptionNameEnum2["namespaceError"] = "NamespaceError";
})(DOMExceptionNameEnum || (DOMExceptionNameEnum = {}));
var DOMExceptionNameEnum_default = DOMExceptionNameEnum;

// node_modules/happy-dom/lib/exception/DOMException.js
var DOMException = class extends Error {
  /**
   * Constructor.
   *
   * @param message Message.
   * @param name Name.
   */
  constructor(message, name2 = null) {
    super(message);
    this.name = name2 || DOMExceptionNameEnum_default.domException;
  }
};

// node_modules/happy-dom/lib/fetch/Headers.js
var Headers = class _Headers {
  [entries] = {};
  /**
   * Constructor.
   *
   * @param init Headers init.
   */
  constructor(init) {
    if (init) {
      if (init instanceof _Headers) {
        this[entries] = JSON.parse(JSON.stringify(init[entries]));
      } else if (Array.isArray(init)) {
        for (const entry of init) {
          if (entry.length !== 2) {
            throw new DOMException('Failed to construct "Headers": The provided init is not a valid array.', DOMExceptionNameEnum_default.invalidStateError);
          }
          this.append(entry[0], entry[1]);
        }
      } else {
        for (const name2 of Object.keys(init)) {
          this.set(name2, init[name2]);
        }
      }
    }
  }
  /**
   * Appends a new value onto an existing header inside a Headers object, or adds the header if it does not already exist.
   *
   * @param name Name.
   * @param value Value.
   */
  append(name2, value2) {
    const lowerName = name2.toLowerCase();
    if (this[entries][lowerName]) {
      this[entries][lowerName].value.push(value2);
    } else {
      this[entries][lowerName] = {
        name: name2,
        value: [value2]
      };
    }
  }
  /**
   * Removes an header.
   *
   * @param name Name.
   */
  delete(name2) {
    delete this[entries][name2.toLowerCase()];
  }
  /**
   * Returns header value.
   *
   * @param name Name.
   * @returns Value.
   */
  get(name2) {
    return this[entries][name2.toLowerCase()]?.value.join(", ") ?? null;
  }
  /**
   * Sets a new value for an existing header inside a Headers object, or adds the header if it does not already exist.
   *
   * @param name Name.
   * @param value Value.
   */
  set(name2, value2) {
    this[entries][name2.toLowerCase()] = {
      name: name2,
      value: [value2]
    };
  }
  /**
   * Returns an array containing the values of all Set-Cookie headers associated with a response.
   *
   * @returns An array of strings representing the values of all the different Set-Cookie headers.
   */
  getSetCookie() {
    const entry = this[entries]["set-cookie"];
    if (!entry) {
      return [];
    }
    return entry.value;
  }
  /**
   * Returns whether an Headers object contains a certain key.
   *
   * @param name Name.
   * @returns "true" if the Headers object contains the key.
   */
  has(name2) {
    return !!this[entries][name2.toLowerCase()];
  }
  /**
   * Executes a callback function once per each key/value pair in the Headers object.
   *
   * @param callback Callback.
   */
  forEach(callback) {
    for (const header of Object.values(this[entries])) {
      callback(header.value.join(", "), header.name, this);
    }
  }
  /**
   * Returns an iterator, allowing you to go through all keys of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *keys() {
    for (const header of Object.values(this[entries])) {
      yield header.name;
    }
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *values() {
    for (const header of Object.values(this[entries])) {
      yield header.value.join(", ");
    }
  }
  /**
   * Returns an iterator, allowing you to go through all key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *entries() {
    for (const header of Object.values(this[entries])) {
      yield [header.name, header.value.join(", ")];
    }
  }
  /**
   * Iterator.
   *
   * @returns Iterator.
   */
  *[Symbol.iterator]() {
    for (const header of Object.values(this[entries])) {
      yield [header.name, header.value.join(", ")];
    }
  }
};

// node_modules/happy-dom/lib/fetch/cache/response/ResponseCache.js
var UPDATE_RESPONSE_HEADERS = ["Cache-Control", "Last-Modified", "Vary", "ETag"];
var ResponseCache = class {
  #entries = {};
  /**
   * Returns cached response.
   *
   * @param request Request.
   * @returns Cached response.
   */
  get(request) {
    if (request.headers.get("Cache-Control")?.includes("no-cache")) {
      return null;
    }
    const url2 = request.url;
    if (this.#entries[url2]) {
      for (let i = 0, max = this.#entries[url2].length; i < max; i++) {
        const entry = this.#entries[url2][i];
        let isMatch = entry.request.method === request.method;
        if (isMatch) {
          for (const header of Object.keys(entry.vary)) {
            const requestHeader = request.headers.get(header);
            if (requestHeader !== null && entry.vary[header] !== requestHeader) {
              isMatch = false;
              break;
            }
          }
        }
        if (isMatch) {
          if (entry.expires && entry.expires < Date.now()) {
            if (entry.lastModified) {
              entry.state = CachedResponseStateEnum_default.stale;
            } else if (!entry.etag) {
              this.#entries[url2].splice(i, 1);
              return null;
            }
          }
          return entry;
        }
      }
    }
    return null;
  }
  /**
   * Adds a cache entity.
   *
   * @param request Request.
   * @param response Response.
   * @returns Cached response.
   */
  add(request, response) {
    if (request.method !== "GET" && request.method !== "HEAD" || request.headers.get("Cache-Control")?.includes("no-cache")) {
      return null;
    }
    const url2 = request.url;
    let cachedResponse2 = this.get(request);
    if (response.status === 304) {
      if (!cachedResponse2) {
        throw new Error("ResponseCache: Cached response not found.");
      }
      for (const name2 of UPDATE_RESPONSE_HEADERS) {
        if (response.headers.has(name2)) {
          cachedResponse2.response.headers.set(name2, response.headers.get(name2));
        }
      }
      cachedResponse2.cacheUpdateTime = Date.now();
      cachedResponse2.state = CachedResponseStateEnum_default.fresh;
    } else {
      if (cachedResponse2) {
        const index = this.#entries[url2].indexOf(cachedResponse2);
        if (index !== -1) {
          this.#entries[url2].splice(index, 1);
        }
      }
      cachedResponse2 = {
        response: {
          status: response.status,
          statusText: response.statusText,
          url: response.url,
          headers: new Headers(response.headers),
          // We need to wait for the body to be consumed and then populated if set to true (e.g. by using Response.text()).
          waitingForBody: response.waitingForBody,
          body: response.body ?? null
        },
        request: {
          headers: request.headers,
          method: request.method
        },
        vary: {},
        expires: null,
        etag: null,
        cacheUpdateTime: Date.now(),
        lastModified: null,
        mustRevalidate: false,
        staleWhileRevalidate: false,
        state: CachedResponseStateEnum_default.fresh
      };
      this.#entries[url2] = this.#entries[url2] || [];
      this.#entries[url2].push(cachedResponse2);
    }
    if (response.headers.has("Cache-Control")) {
      const age = response.headers.get("Age");
      for (const part of response.headers.get("Cache-Control").split(",")) {
        const [key, value2] = part.trim().split("=");
        switch (key) {
          case "max-age":
            cachedResponse2.expires = Date.now() + parseInt(value2) * 1e3 - (age ? parseInt(age) * 1e3 : 0);
            break;
          case "no-cache":
          case "no-store":
            const index = this.#entries[url2].indexOf(cachedResponse2);
            if (index !== -1) {
              this.#entries[url2].splice(index, 1);
            }
            return null;
          case "must-revalidate":
            cachedResponse2.mustRevalidate = true;
            break;
          case "stale-while-revalidate":
            cachedResponse2.staleWhileRevalidate = true;
            break;
        }
      }
    }
    if (response.headers.has("Last-Modified")) {
      cachedResponse2.lastModified = Date.parse(response.headers.get("Last-Modified"));
    }
    if (response.headers.has("Vary")) {
      for (const header of response.headers.get("Vary").split(",")) {
        const name2 = header.trim();
        const value2 = request.headers.get(name2);
        if (value2) {
          cachedResponse2.vary[name2] = value2;
        }
      }
    }
    if (response.headers.has("ETag")) {
      cachedResponse2.etag = response.headers.get("ETag");
    }
    if (!cachedResponse2.expires) {
      const expires = response.headers.get("Expires");
      if (expires) {
        cachedResponse2.expires = Date.parse(expires);
      }
    }
    if (!cachedResponse2.etag && (!cachedResponse2.expires || cachedResponse2.expires < Date.now())) {
      const index = this.#entries[url2].indexOf(cachedResponse2);
      if (index !== -1) {
        this.#entries[url2].splice(index, 1);
      }
      return null;
    }
    return cachedResponse2;
  }
  /**
   * Clears the cache.
   *
   * @param [options] Options.
   * @param [options.url] URL.
   * @param [options.toTime] Removes all entries that are older than this time. Time in MS.
   */
  clear(options2) {
    if (options2) {
      if (options2.toTime) {
        for (const key of options2.url ? [options2.url] : Object.keys(this.#entries)) {
          if (this.#entries[key]) {
            for (let i = 0, max = this.#entries[key].length; i < max; i++) {
              if (this.#entries[key][i].cacheUpdateTime < options2.toTime) {
                this.#entries[key].splice(i, 1);
                i--;
                max--;
              }
            }
          }
        }
      } else if (options2.url) {
        delete this.#entries[options2.url];
      }
    } else {
      this.#entries = {};
    }
  }
};

// node_modules/happy-dom/lib/console/enums/VirtualConsoleLogLevelEnum.js
var VirtualConsoleLogLevelEnum;
(function(VirtualConsoleLogLevelEnum2) {
  VirtualConsoleLogLevelEnum2[VirtualConsoleLogLevelEnum2["log"] = 0] = "log";
  VirtualConsoleLogLevelEnum2[VirtualConsoleLogLevelEnum2["info"] = 1] = "info";
  VirtualConsoleLogLevelEnum2[VirtualConsoleLogLevelEnum2["warn"] = 2] = "warn";
  VirtualConsoleLogLevelEnum2[VirtualConsoleLogLevelEnum2["error"] = 3] = "error";
})(VirtualConsoleLogLevelEnum || (VirtualConsoleLogLevelEnum = {}));
var VirtualConsoleLogLevelEnum_default = VirtualConsoleLogLevelEnum;

// node_modules/happy-dom/lib/nodes/node/NodeTypeEnum.js
var NodeTypeEnum;
(function(NodeTypeEnum2) {
  NodeTypeEnum2[NodeTypeEnum2["elementNode"] = 1] = "elementNode";
  NodeTypeEnum2[NodeTypeEnum2["attributeNode"] = 2] = "attributeNode";
  NodeTypeEnum2[NodeTypeEnum2["textNode"] = 3] = "textNode";
  NodeTypeEnum2[NodeTypeEnum2["cdataSectionNode"] = 4] = "cdataSectionNode";
  NodeTypeEnum2[NodeTypeEnum2["commentNode"] = 8] = "commentNode";
  NodeTypeEnum2[NodeTypeEnum2["documentNode"] = 9] = "documentNode";
  NodeTypeEnum2[NodeTypeEnum2["documentTypeNode"] = 10] = "documentTypeNode";
  NodeTypeEnum2[NodeTypeEnum2["documentFragmentNode"] = 11] = "documentFragmentNode";
  NodeTypeEnum2[NodeTypeEnum2["processingInstructionNode"] = 7] = "processingInstructionNode";
})(NodeTypeEnum || (NodeTypeEnum = {}));
var NodeTypeEnum_default = NodeTypeEnum;

// node_modules/happy-dom/lib/event/EventPhaseEnum.js
var EventPhaseEnum;
(function(EventPhaseEnum2) {
  EventPhaseEnum2[EventPhaseEnum2["none"] = 0] = "none";
  EventPhaseEnum2[EventPhaseEnum2["capturing"] = 1] = "capturing";
  EventPhaseEnum2[EventPhaseEnum2["atTarget"] = 2] = "atTarget";
  EventPhaseEnum2[EventPhaseEnum2["bubbling"] = 3] = "bubbling";
})(EventPhaseEnum || (EventPhaseEnum = {}));
var EventPhaseEnum_default = EventPhaseEnum;

// node_modules/happy-dom/lib/event/Event.js
var Event = class _Event {
  static NONE = EventPhaseEnum_default.none;
  static CAPTURING_PHASE = EventPhaseEnum_default.capturing;
  static AT_TARGET = EventPhaseEnum_default.atTarget;
  static BUBBLING_PHASE = EventPhaseEnum_default.bubbling;
  NONE = _Event.NONE;
  CAPTURING_PHASE = _Event.CAPTURING_PHASE;
  AT_TARGET = _Event.AT_TARGET;
  BUBBLING_PHASE = _Event.BUBBLING_PHASE;
  [composed] = false;
  [bubbles] = false;
  [cancelable] = false;
  [defaultPrevented] = false;
  [eventPhase] = EventPhaseEnum_default.none;
  [timeStamp] = performance.now();
  [type];
  [dispatching] = false;
  [immediatePropagationStopped] = false;
  [propagationStopped] = false;
  [target] = null;
  [currentTarget] = null;
  [isInPassiveEventListener] = false;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    this[type] = type2;
    this[bubbles] = eventInit?.bubbles ?? false;
    this[cancelable] = eventInit?.cancelable ?? false;
    this[composed] = eventInit?.composed ?? false;
  }
  /**
   * Returns composed.
   *
   * @returns Composed.
   */
  get composed() {
    return this[composed];
  }
  /**
   * Returns bubbles.
   *
   * @returns Bubbles.
   */
  get bubbles() {
    return this[bubbles];
  }
  /**
   * Returns cancelable.
   *
   * @returns Cancelable.
   */
  get cancelable() {
    return this[cancelable];
  }
  /**
   * Returns defaultPrevented.
   *
   * @returns Default prevented.
   */
  get defaultPrevented() {
    return this[defaultPrevented];
  }
  /**
   * Returns eventPhase.
   *
   * @returns Event phase.
   */
  get eventPhase() {
    return this[eventPhase];
  }
  /**
   * Returns timeStamp.
   *
   * @returns Time stamp.
   */
  get timeStamp() {
    return this[timeStamp];
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this[type];
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get target() {
    return this[target];
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get currentTarget() {
    return this[currentTarget];
  }
  /**
   * Returns "true" if propagation has been stopped.
   *
   * @returns "true" if propagation has been stopped.
   */
  get cancelBubble() {
    return this[propagationStopped];
  }
  /**
   * Returns composed path.
   *
   * @returns Composed path.
   */
  composedPath() {
    if (!this[target]) {
      return [];
    }
    const composedPath = [];
    let eventTarget = this[target];
    while (eventTarget) {
      composedPath.push(eventTarget);
      if (eventTarget.parentNode) {
        eventTarget = eventTarget.parentNode;
      } else if (this[composed] && eventTarget[nodeType] === NodeTypeEnum_default.documentFragmentNode && eventTarget.host) {
        eventTarget = eventTarget.host;
      } else if (eventTarget[nodeType] === NodeTypeEnum_default.documentNode && // The "load" event is a special case. It should not bubble up to the window.
      this[type] !== "load") {
        eventTarget = eventTarget[window];
      } else {
        break;
      }
    }
    return composedPath;
  }
  /**
   * Init event.
   *
   * @deprecated
   * @param type Type.
   * @param [bubbles=false] "true" if it bubbles.
   * @param [cancelable=false] "true" if it cancelable.
   */
  initEvent(type2, bubbles2 = false, cancelable2 = false) {
    this[type] = type2;
    this[bubbles] = bubbles2;
    this[cancelable] = cancelable2;
  }
  /**
   * Prevents default.
   */
  preventDefault() {
    if (!this[isInPassiveEventListener] && this.cancelable) {
      this[defaultPrevented] = true;
    }
  }
  /**
   * Stops immediate propagation.
   */
  stopImmediatePropagation() {
    this[immediatePropagationStopped] = true;
  }
  /**
   * Stops propagation.
   */
  stopPropagation() {
    this[propagationStopped] = true;
  }
};

// node_modules/happy-dom/lib/console/enums/VirtualConsoleLogTypeEnum.js
var VirtualConsoleLogTypeEnum;
(function(VirtualConsoleLogTypeEnum2) {
  VirtualConsoleLogTypeEnum2["log"] = "log";
  VirtualConsoleLogTypeEnum2["table"] = "table";
  VirtualConsoleLogTypeEnum2["trace"] = "trace";
  VirtualConsoleLogTypeEnum2["dir"] = "dir";
  VirtualConsoleLogTypeEnum2["dirxml"] = "dirxml";
  VirtualConsoleLogTypeEnum2["group"] = "group";
  VirtualConsoleLogTypeEnum2["groupCollapsed"] = "groupCollapsed";
  VirtualConsoleLogTypeEnum2["debug"] = "debug";
  VirtualConsoleLogTypeEnum2["timeLog"] = "timeLog";
  VirtualConsoleLogTypeEnum2["info"] = "info";
  VirtualConsoleLogTypeEnum2["count"] = "count";
  VirtualConsoleLogTypeEnum2["timeEnd"] = "timeEnd";
  VirtualConsoleLogTypeEnum2["warn"] = "warn";
  VirtualConsoleLogTypeEnum2["countReset"] = "countReset";
  VirtualConsoleLogTypeEnum2["error"] = "error";
  VirtualConsoleLogTypeEnum2["assert"] = "assert";
})(VirtualConsoleLogTypeEnum || (VirtualConsoleLogTypeEnum = {}));
var VirtualConsoleLogTypeEnum_default = VirtualConsoleLogTypeEnum;

// node_modules/happy-dom/lib/console/utilities/VirtualConsoleLogEntryStringifier.js
var VirtualConsoleLogEntryStringifier = class {
  /**
   * Stringifies a log entry.
   *
   * @param logEntry Log entry.
   * @returns Stringified message.
   */
  static toString(logEntry) {
    if (this.isLogEntryCollapsed(logEntry)) {
      return "";
    }
    const tabbing = this.getLogEntryGroupTabbing(logEntry);
    let output = tabbing;
    for (const part of logEntry.message) {
      output += output !== "" && output !== tabbing ? " " : "";
      if (typeof part === "object" && (part === null || part.constructor.name === "Object" || Array.isArray(part))) {
        try {
          output += JSON.stringify(part);
        } catch (error2) {
          output += new Error("Failed to JSON stringify object in log entry.").stack.replace(/\n    at/gm, "\n    " + tabbing + "at");
        }
      } else if (typeof part === "object" && part["message"] && part["stack"]) {
        output += part["stack"].replace(/\n    at/gm, "\n    " + tabbing + "at");
      } else {
        output += this.getLogEntryIcon(logEntry) + String(part);
      }
    }
    return output + "\n";
  }
  /**
   * Gets the log entry icon.
   *
   * @param logEntry Log entry.
   * @returns Icon.
   */
  static getLogEntryIcon(logEntry) {
    switch (logEntry.type) {
      case VirtualConsoleLogTypeEnum_default.group:
        return "\u25BC ";
      case VirtualConsoleLogTypeEnum_default.groupCollapsed:
        return "\u25B6 ";
    }
    return "";
  }
  /**
   * Gets the log entry group tabbing.
   *
   * @param logEntry Log entry.
   * @returns Tabbing.
   */
  static getLogEntryGroupTabbing(logEntry) {
    let tabs = "";
    let group = logEntry.type === VirtualConsoleLogTypeEnum_default.group || logEntry.type === VirtualConsoleLogTypeEnum_default.groupCollapsed ? logEntry.group?.parent : logEntry.group;
    while (group) {
      tabs += "  ";
      group = group.parent;
    }
    return tabs;
  }
  /**
   * Checks if the log entry content is collapsed.
   *
   * @param logEntry Log entry.
   * @returns True if collapsed.
   */
  static isLogEntryCollapsed(logEntry) {
    let group = logEntry.type === VirtualConsoleLogTypeEnum_default.group || logEntry.type === VirtualConsoleLogTypeEnum_default.groupCollapsed ? logEntry.group?.parent : logEntry.group;
    while (group) {
      if (group.collapsed) {
        return true;
      }
      group = group.parent;
    }
    return false;
  }
};

// node_modules/happy-dom/lib/console/VirtualConsolePrinter.js
var VirtualConsolePrinter = class {
  #logEntries = [];
  #listeners = { print: [], clear: [] };
  /**
   * Writes to the output.
   *
   * @param logEntry Log entry.
   */
  print(logEntry) {
    this.#logEntries.push(logEntry);
    this.dispatchEvent(new Event("print"));
  }
  /**
   * Clears the output.
   */
  clear() {
    this.#logEntries = [];
    this.dispatchEvent(new Event("clear"));
  }
  /**
   * Adds an event listener.
   *
   * @param eventType Event type ("print" or "clear").
   * @param listener Listener.
   */
  addEventListener(eventType, listener) {
    if (!this.#listeners[eventType]) {
      throw new Error(`Event type "${eventType}" is not supported.`);
    }
    this.#listeners[eventType].push(listener);
  }
  /**
   * Removes an event listener.
   *
   * @param eventType Event type ("print" or "clear").
   * @param listener Listener.
   */
  removeEventListener(eventType, listener) {
    if (!this.#listeners[eventType]) {
      throw new Error(`Event type "${eventType}" is not supported.`);
    }
    const index = this.#listeners[eventType].indexOf(listener);
    if (index !== -1) {
      this.#listeners[eventType].splice(index, 1);
    }
  }
  /**
   * Dispatches an event.
   *
   * @param event Event.
   */
  dispatchEvent(event) {
    if (!this.#listeners[event.type]) {
      throw new Error(`Event type "${event.type}" is not supported.`);
    }
    for (const listener of this.#listeners[event.type]) {
      listener(event);
    }
  }
  /**
   * Reads the buffer.
   *
   * @returns Console log entries.
   */
  read() {
    const logEntries = this.#logEntries;
    this.#logEntries = [];
    return logEntries;
  }
  /**
   * Returns the buffer as a string.
   *
   * @param [logLevel] Log level.
   * @returns Buffer as a string of concatenated log entries.
   */
  readAsString(logLevel = VirtualConsoleLogLevelEnum_default.log) {
    const logEntries = this.read();
    let output = "";
    for (const logEntry of logEntries) {
      if (logEntry.level >= logLevel) {
        output += VirtualConsoleLogEntryStringifier.toString(logEntry);
      }
    }
    return output;
  }
};

// node_modules/happy-dom/lib/async-task-manager/AsyncTaskManager.js
var TIMER = {
  setTimeout: globalThis.setTimeout.bind(globalThis),
  clearTimeout: globalThis.clearTimeout.bind(globalThis),
  clearImmediate: globalThis.clearImmediate.bind(globalThis)
};
var AsyncTaskManager = class {
  static taskID = 0;
  runningTasks = {};
  runningTaskCount = 0;
  runningTimers = [];
  runningImmediates = [];
  debugTrace = /* @__PURE__ */ new Map();
  waitUntilCompleteTimer = null;
  waitUntilCompleteResolvers = [];
  aborted = false;
  destroyed = false;
  #browserFrame;
  #debugTimeout;
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   */
  constructor(browserFrame) {
    this.#browserFrame = browserFrame;
  }
  /**
   * Returns a promise that is resolved when async tasks are complete.
   *
   * @returns Promise.
   */
  waitUntilComplete() {
    return new Promise((resolve, reject) => {
      this.waitUntilCompleteResolvers.push({ resolve, reject });
      this.resolveWhenComplete();
    });
  }
  /**
   * Aborts all tasks.
   */
  abort() {
    if (this.aborted) {
      return new Promise((resolve, reject) => {
        this.waitUntilCompleteResolvers.push({ resolve, reject });
        this.resolveWhenComplete();
      });
    }
    return this.abortAll(false);
  }
  /**
   * Destroys the manager.
   */
  destroy() {
    if (this.aborted) {
      return new Promise((resolve, reject) => {
        this.waitUntilCompleteResolvers.push({ resolve, reject });
        this.resolveWhenComplete();
      });
    }
    return this.abortAll(true);
  }
  /**
   * Starts a timer.
   *
   * @param timerID Timer ID.
   */
  startTimer(timerID) {
    if (this.aborted) {
      TIMER.clearTimeout(timerID);
      return;
    }
    if (this.waitUntilCompleteTimer) {
      TIMER.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    this.runningTimers.push(timerID);
    if (this.#browserFrame.page?.context?.browser?.settings?.debug?.traceWaitUntilComplete > 0) {
      this.debugTrace.set(timerID, new Error().stack);
    }
  }
  /**
   * Ends a timer.
   *
   * @param timerID Timer ID.
   */
  endTimer(timerID) {
    if (this.aborted) {
      TIMER.clearTimeout(timerID);
      return;
    }
    const index = this.runningTimers.indexOf(timerID);
    if (index !== -1) {
      this.runningTimers.splice(index, 1);
      this.resolveWhenComplete();
    }
    if (this.#browserFrame.page?.context?.browser?.settings?.debug?.traceWaitUntilComplete > 0) {
      this.debugTrace.delete(timerID);
    }
  }
  /**
   * Starts an immediate.
   *
   * @param immediateID Immediate ID.
   */
  startImmediate(immediateID) {
    if (this.aborted) {
      TIMER.clearImmediate(immediateID);
      return;
    }
    if (this.waitUntilCompleteTimer) {
      TIMER.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    this.runningImmediates.push(immediateID);
    if (this.#browserFrame.page?.context?.browser?.settings?.debug?.traceWaitUntilComplete > 0) {
      this.debugTrace.set(immediateID, new Error().stack);
    }
  }
  /**
   * Ends an immediate.
   *
   * @param immediateID Immediate ID.
   */
  endImmediate(immediateID) {
    if (this.aborted) {
      TIMER.clearImmediate(immediateID);
      return;
    }
    const index = this.runningImmediates.indexOf(immediateID);
    if (index !== -1) {
      this.runningImmediates.splice(index, 1);
      this.resolveWhenComplete();
    }
    if (this.#browserFrame.page?.context?.browser?.settings?.debug?.traceWaitUntilComplete > 0) {
      this.debugTrace.delete(immediateID);
    }
  }
  /**
   * Starts an async task.
   *
   * @param abortHandler Abort handler.
   * @returns Task ID.
   */
  startTask(abortHandler) {
    if (this.aborted) {
      if (abortHandler) {
        abortHandler(this.destroyed);
      }
      throw new this.#browserFrame.window.Error(`Failed to execute 'startTask()' on 'AsyncTaskManager': The asynchrounous task manager has been aborted.`);
    }
    if (this.waitUntilCompleteTimer) {
      TIMER.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    const taskID = this.newTaskID();
    this.runningTasks[taskID] = abortHandler ? abortHandler : () => {
    };
    this.runningTaskCount++;
    if (this.#browserFrame.page?.context?.browser?.settings?.debug?.traceWaitUntilComplete > 0) {
      this.debugTrace.set(taskID, new Error().stack);
    }
    return taskID;
  }
  /**
   * Ends an async task.
   *
   * @param taskID Task ID.
   */
  endTask(taskID) {
    if (this.aborted) {
      return;
    }
    if (this.runningTasks[taskID]) {
      delete this.runningTasks[taskID];
      this.runningTaskCount--;
      this.resolveWhenComplete();
    }
    if (this.#browserFrame.page?.context?.browser?.settings?.debug?.traceWaitUntilComplete > 0) {
      this.debugTrace.delete(taskID);
    }
  }
  /**
   * Returns the amount of running tasks.
   *
   * @returns Count.
   */
  getTaskCount() {
    return this.runningTaskCount;
  }
  /**
   * Returns a new task ID.
   *
   * @returns Task ID.
   */
  newTaskID() {
    this.constructor.taskID++;
    return this.constructor.taskID;
  }
  /**
   * Resolves when complete.
   */
  resolveWhenComplete() {
    this.applyDebugging();
    if (this.runningTaskCount || this.runningTimers.length || this.runningImmediates.length) {
      return;
    }
    if (this.waitUntilCompleteTimer) {
      TIMER.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    this.waitUntilCompleteTimer = TIMER.setTimeout(() => {
      this.waitUntilCompleteTimer = null;
      if (!this.runningTaskCount && !this.runningTimers.length && !this.runningImmediates.length) {
        if (this.#debugTimeout) {
          TIMER.clearTimeout(this.#debugTimeout);
        }
        const resolvers = this.waitUntilCompleteResolvers;
        this.waitUntilCompleteResolvers = [];
        for (const resolver of resolvers) {
          resolver.resolve();
        }
        this.aborted = false;
      } else {
        this.applyDebugging();
      }
    }, 1);
  }
  /**
   * Applies debugging.
   */
  applyDebugging() {
    const debug = this.#browserFrame.page?.context?.browser?.settings?.debug;
    if (!debug?.traceWaitUntilComplete || debug.traceWaitUntilComplete < 1) {
      return;
    }
    if (this.#debugTimeout) {
      return;
    }
    this.#debugTimeout = TIMER.setTimeout(() => {
      this.#debugTimeout = null;
      let errorMessage = `The maximum time was reached for "waitUntilComplete()".

${this.debugTrace.size} task${this.debugTrace.size === 1 ? "" : "s"} did not end in time.

The following traces were recorded:

`;
      for (const [key, value2] of this.debugTrace.entries()) {
        const type2 = typeof key === "number" ? "Task" : "Timer";
        errorMessage += `${type2} #${key}
\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E\u203E${value2.replace(/Error:/, "").replace(/\s+at /gm, "\n> ")}

`;
      }
      const error2 = new Error(errorMessage);
      for (const resolver of this.waitUntilCompleteResolvers) {
        resolver.reject(error2);
      }
      this.abortAll(true);
    }, debug.traceWaitUntilComplete);
  }
  /**
   * Aborts all tasks.
   *
   * @param destroy Destroy.
   */
  abortAll(destroy2) {
    const runningTimers = this.runningTimers;
    const runningImmediates = this.runningImmediates;
    const runningTasks = this.runningTasks;
    this.aborted = true;
    this.destroyed = destroy2;
    this.runningTasks = {};
    this.runningTaskCount = 0;
    this.runningImmediates = [];
    this.runningTimers = [];
    this.debugTrace = /* @__PURE__ */ new Map();
    if (this.waitUntilCompleteTimer) {
      TIMER.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    for (const immediate of runningImmediates) {
      TIMER.clearImmediate(immediate);
    }
    for (const timer of runningTimers) {
      TIMER.clearTimeout(timer);
    }
    for (const key of Object.keys(runningTasks)) {
      runningTasks[key](destroy2);
    }
    return new Promise((resolve, reject) => {
      this.waitUntilCompleteResolvers.push({ resolve, reject });
      this.resolveWhenComplete();
    });
  }
};

// node_modules/happy-dom/lib/window/BrowserWindow.js
import { Buffer as Buffer8 } from "buffer";
import { webcrypto } from "crypto";
import { TextEncoder, TextDecoder as TextDecoder2 } from "util";
import Stream3 from "stream";
import { ReadableStream as ReadableStream4 } from "stream/web";
import { URLSearchParams as URLSearchParams4 } from "url";
import VM from "vm";

// node_modules/happy-dom/lib/base64/Base64.js
var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var Base64 = class {
  /**
   * Creates a Base64-encoded ASCII string from a binary string (i.e., a string in which each character in the string is treated as a byte of binary data).
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/btoa
   * @param data Binay data.
   * @returns Base64-encoded string.
   */
  static btoa(data2) {
    const str = data2.toString();
    if (/[^\u0000-\u00ff]/.test(str)) {
      throw new DOMException("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.", DOMExceptionNameEnum_default.invalidCharacterError);
    }
    let t = "";
    let p = -6;
    let a = 0;
    let i = 0;
    let v = 0;
    let c;
    while (i < str.length || p > -6) {
      if (p < 0) {
        if (i < str.length) {
          c = str.charCodeAt(i++);
          v += 8;
        } else {
          c = 0;
        }
        a = (a & 255) << 8 | c & 255;
        p += 8;
      }
      t += BASE64_CHARS.charAt(v > 0 ? a >> p & 63 : 64);
      p -= 6;
      v -= 6;
    }
    return t;
  }
  /**
   * Decodes a string of data which has been encoded using Base64 encoding.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/atob
   * @see https://infra.spec.whatwg.org/#forgiving-base64-encode.
   * @see Https://html.spec.whatwg.org/multipage/webappapis.html#btoa.
   * @param data Binay string.
   * @returns An ASCII string containing decoded data from encodedData.
   */
  static atob(data2) {
    const str = data2.toString();
    if (/[^\u0000-\u00ff]/.test(str)) {
      throw new DOMException("Failed to execute 'atob' on 'Window': The string to be decoded contains characters outside of the Latin1 range.", DOMExceptionNameEnum_default.invalidCharacterError);
    }
    if (/[^A-Za-z\d+/=]/.test(str) || str.length % 4 == 1) {
      throw new DOMException("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.", DOMExceptionNameEnum_default.invalidCharacterError);
    }
    let t = "";
    let p = -8;
    let a = 0;
    let c;
    let d;
    for (let i = 0; i < str.length; i++) {
      if ((c = BASE64_CHARS.indexOf(str.charAt(i))) < 0) {
        continue;
      }
      a = a << 6 | c & 63;
      if ((p += 6) >= 0) {
        d = a >> p & 255;
        if (c !== 64) {
          t += String.fromCharCode(d);
        }
        a &= 63;
        p -= 8;
      }
    }
    return t;
  }
};

// node_modules/happy-dom/lib/browser/enums/BrowserErrorCaptureEnum.js
var BrowserErrorCaptureEnum;
(function(BrowserErrorCaptureEnum2) {
  BrowserErrorCaptureEnum2["tryAndCatch"] = "tryAndCatch";
  BrowserErrorCaptureEnum2["processLevel"] = "processLevel";
  BrowserErrorCaptureEnum2["disabled"] = "disabled";
})(BrowserErrorCaptureEnum || (BrowserErrorCaptureEnum = {}));
var BrowserErrorCaptureEnum_default = BrowserErrorCaptureEnum;

// node_modules/happy-dom/lib/file/Blob.js
import { Buffer as Buffer2 } from "buffer";
import { ReadableStream } from "stream/web";
var Blob = class _Blob {
  type = "";
  [buffer] = null;
  /**
   * Constructor.
   *
   * @param [bits] Bits.
   * @param [options] Options.
   * @param [options.type] MIME type.
   */
  constructor(bits, options2) {
    const buffers = [];
    if (bits) {
      for (const bit of bits) {
        let buffer2;
        if (bit instanceof ArrayBuffer) {
          buffer2 = Buffer2.from(new Uint8Array(bit));
        } else if (bit instanceof _Blob) {
          buffer2 = bit[buffer];
        } else if (bit instanceof Buffer2) {
          buffer2 = bit;
        } else if (ArrayBuffer.isView(bit)) {
          buffer2 = Buffer2.from(new Uint8Array(bit.buffer, bit.byteOffset, bit.byteLength));
        } else {
          buffer2 = Buffer2.from(typeof bit === "string" ? bit : String(bit));
        }
        buffers.push(buffer2);
      }
    }
    this[buffer] = Buffer2.concat(buffers);
    if (options2 && options2.type && options2.type.match(/^[\u0020-\u007E]*$/)) {
      this.type = String(options2.type).toLowerCase();
    }
  }
  /**
   * Returns size.
   *
   * @returns Size.
   */
  get size() {
    return this[buffer].length;
  }
  /**
   * Slices the blob.
   *
   * @param start Start.
   * @param end End.
   * @param contentType Content type.
   * @returns New Blob.
   */
  slice(start2 = 0, end2 = null, contentType2 = "") {
    const size = this.size;
    let relativeStart;
    let relativeEnd;
    let relativeContentType;
    if (start2 === void 0) {
      relativeStart = 0;
    } else if (start2 < 0) {
      relativeStart = Math.max(size + start2, 0);
    } else {
      relativeStart = Math.min(start2, size);
    }
    if (end2 === null) {
      relativeEnd = size;
    } else if (end2 < 0) {
      relativeEnd = Math.max(size + end2, 0);
    } else {
      relativeEnd = Math.min(end2, size);
    }
    if (contentType2 === void 0) {
      relativeContentType = "";
    } else {
      relativeContentType = contentType2;
    }
    const span = Math.max(relativeEnd - relativeStart, 0);
    const buffer2 = this[buffer];
    const slicedBuffer = buffer2.slice(relativeStart, relativeStart + span);
    const blob = new _Blob([], { type: relativeContentType });
    blob[buffer] = slicedBuffer;
    return blob;
  }
  /**
   * Returns a Promise that resolves to a ArrayBuffer.
   *
   * @returns ArrayBuffer.
   */
  // Reference:
  // https://github.com/web-std/io/blob/c88170bf24f064adfbb3586a21fb76650ca5a9ab/packages/blob/src/blob.js#L139-L148
  // https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer
  /**
   *
   */
  async arrayBuffer() {
    return new Uint8Array(this[buffer]).buffer;
  }
  /**
   * Returns a Promise that resolves to a text.
   *
   * @returns Text.
   */
  async text() {
    return this[buffer].toString();
  }
  /**
   * Returns returns a ReadableStream which upon reading returns the data contained within the Blob.
   *
   * @returns ReadableStream
   */
  stream() {
    const buffer2 = this[buffer];
    return new ReadableStream({
      start(controller) {
        controller.enqueue(buffer2);
        controller.close();
      }
    });
  }
  /**
   * Returns the object converted to string.
   *
   * @returns String.
   */
  toString() {
    return "[object Blob]";
  }
};

// node_modules/happy-dom/lib/clipboard/Clipboard.js
var Clipboard = class {
  #window;
  #data = [];
  /**
   * Constructor.
   *
   * @param window Owner window.
   */
  constructor(window2) {
    if (!window2) {
      throw new TypeError("Illegal constructor");
    }
    this.#window = window2;
  }
  /**
   * Returns data.
   *
   * @returns Data.
   */
  async read() {
    const permissionStatus = await this.#window.navigator.permissions.query({
      name: "clipboard-read"
    });
    if (permissionStatus.state === "denied") {
      throw new this.#window.DOMException(`Failed to execute 'read' on 'Clipboard': The request is not allowed`);
    }
    return this.#data;
  }
  /**
   * Returns text.
   *
   * @returns Text.
   */
  async readText() {
    const permissionStatus = await this.#window.navigator.permissions.query({
      name: "clipboard-read"
    });
    if (permissionStatus.state === "denied") {
      throw new this.#window.DOMException(`Failed to execute 'readText' on 'Clipboard': The request is not allowed`);
    }
    let text = "";
    for (const item of this.#data) {
      if (item.types.includes("text/plain")) {
        const data2 = await item.getType("text/plain");
        if (typeof data2 === "string") {
          text += data2;
        } else {
          text += await data2.text();
        }
      }
    }
    return text;
  }
  /**
   * Writes data.
   *
   * @param data Data.
   */
  async write(data2) {
    const permissionStatus = await this.#window.navigator.permissions.query({
      name: "clipboard-write"
    });
    if (permissionStatus.state === "denied") {
      throw new this.#window.DOMException(`Failed to execute 'write' on 'Clipboard': The request is not allowed`);
    }
    this.#data = data2;
  }
  /**
   * Writes text.
   *
   * @param text Text.
   */
  async writeText(text) {
    const permissionStatus = await this.#window.navigator.permissions.query({
      name: "clipboard-write"
    });
    if (permissionStatus.state === "denied") {
      throw new this.#window.DOMException(`Failed to execute 'writeText' on 'Clipboard': The request is not allowed`);
    }
    this.#data = [
      new this.#window.ClipboardItem({ "text/plain": new Blob([text], { type: "text/plain" }) })
    ];
  }
};

// node_modules/happy-dom/lib/css/utilities/CSSEscaper.js
var CSSEscaper = class {
  /**
   * Escapes CSS.
   *
   * Based on:
   * https://github.com/mathiasbynens/CSS.escape
   *
   * @param cssText CSS.
   * @returns Escaped CSS.
   */
  static escape(cssText2) {
    if (arguments.length == 0) {
      throw new TypeError("`CSS.escape` requires an argument.");
    }
    const returnValue2 = String(cssText2);
    const length2 = returnValue2.length;
    let index = -1;
    let codeUnit;
    let result2 = "";
    const firstCodeUnit = returnValue2.charCodeAt(0);
    if (
      // If the character is the first character and is a `-` (U+002D), and
      // There is no second character, []
      length2 == 1 && firstCodeUnit == 45
    ) {
      return "\\" + returnValue2;
    }
    while (++index < length2) {
      codeUnit = returnValue2.charCodeAt(index);
      if (codeUnit == 0) {
        result2 += "\uFFFD";
        continue;
      }
      if (
        // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
        // U+007F, []
        codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
        // (U+0030 to U+0039), []
        index == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
        // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
        index == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
      ) {
        result2 += "\\" + codeUnit.toString(16) + " ";
        continue;
      }
      if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
        result2 += returnValue2.charAt(index);
        continue;
      }
      result2 += "\\" + returnValue2.charAt(index);
    }
    return result2;
  }
};

// node_modules/happy-dom/lib/css/CSSUnits.js
var CSSUnits_default = [
  "Hz",
  "Q",
  "ch",
  "cm",
  "deg",
  "dpcm",
  "dpi",
  "dppx",
  "em",
  "ex",
  "fr",
  "grad",
  "in",
  "kHz",
  "mm",
  "ms",
  "number",
  "pc",
  "percent",
  "pt",
  "px",
  "rad",
  "rem",
  "s",
  "turn",
  "vh",
  "vmax",
  "vmin",
  "vw"
];

// node_modules/happy-dom/lib/css/CSSUnitValue.js
var CSSUnitValue = class {
  unit = null;
  value = null;
  /**
   * Constructor.
   *
   * @param value Value.
   * @param unit Unit.
   */
  constructor(value2, unit) {
    if (typeof value2 !== "number") {
      throw new TypeError("The provided double value is non-finite");
    }
    if (!CSSUnits_default.includes(unit)) {
      throw new TypeError("Invalid unit: " + unit);
    }
    this.value = value2;
    this.unit = unit;
  }
};

// node_modules/happy-dom/lib/css/CSS.js
var CSS = class {
  /**
   * Constructor.
   */
  constructor() {
    for (const unit of CSSUnits_default) {
      this[unit] = (value2) => new CSSUnitValue(value2, unit);
    }
  }
  /**
   * Returns a Boolean indicating if the pair property-value, or the condition, given in parameter is supported.
   *
   * TODO: Always returns "true" for now, but it should probably be improved in the future.
   *
   * @param _condition Property name or condition.
   * @param [_value] Value when using property name.
   * @returns "true" if supported.
   */
  supports(_condition, _value) {
    return true;
  }
  /**
   * Escapes a value.
   *
   * @param value Value to escape.
   * @returns Escaped string.
   */
  escape(value2) {
    return CSSEscaper.escape(value2);
  }
};

// node_modules/happy-dom/lib/css/CSSRuleTypeEnum.js
var CSSRuleTypeEnum;
(function(CSSRuleTypeEnum2) {
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["containerRule"] = 0] = "containerRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["styleRule"] = 1] = "styleRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["importRule"] = 3] = "importRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["mediaRule"] = 4] = "mediaRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["fontFaceRule"] = 5] = "fontFaceRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["pageRule"] = 6] = "pageRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["keyframesRule"] = 7] = "keyframesRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["keyframeRule"] = 8] = "keyframeRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["namespaceRule"] = 10] = "namespaceRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["counterStyleRule"] = 11] = "counterStyleRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["supportsRule"] = 12] = "supportsRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["documentRule"] = 13] = "documentRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["fontFeatureValuesRule"] = 14] = "fontFeatureValuesRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["regionStyleRule"] = 16] = "regionStyleRule";
})(CSSRuleTypeEnum || (CSSRuleTypeEnum = {}));
var CSSRuleTypeEnum_default = CSSRuleTypeEnum;

// node_modules/happy-dom/lib/css/CSSRule.js
var CSSRule = class {
  // Static properties
  static CONTAINER_RULE = CSSRuleTypeEnum_default.containerRule;
  static STYLE_RULE = CSSRuleTypeEnum_default.styleRule;
  static IMPORT_RULE = CSSRuleTypeEnum_default.importRule;
  static MEDIA_RULE = CSSRuleTypeEnum_default.mediaRule;
  static FONT_FACE_RULE = CSSRuleTypeEnum_default.fontFaceRule;
  static PAGE_RULE = CSSRuleTypeEnum_default.pageRule;
  static KEYFRAMES_RULE = CSSRuleTypeEnum_default.keyframesRule;
  static KEYFRAME_RULE = CSSRuleTypeEnum_default.keyframeRule;
  static NAMESPACE_RULE = CSSRuleTypeEnum_default.namespaceRule;
  static COUNTER_STYLE_RULE = CSSRuleTypeEnum_default.counterStyleRule;
  static SUPPORTS_RULE = CSSRuleTypeEnum_default.supportsRule;
  static DOCUMENT_RULE = CSSRuleTypeEnum_default.documentRule;
  static FONT_FEATURE_VALUES_RULE = CSSRuleTypeEnum_default.fontFeatureValuesRule;
  static REGION_STYLE_RULE = CSSRuleTypeEnum_default.regionStyleRule;
  // Internal properties
  [window];
  // Public properties
  parentRule = null;
  parentStyleSheet = null;
  type = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   */
  constructor(illegalConstructorSymbol, window2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
  }
  /**
   * Returns selector text.
   *
   * @returns Selector text.
   */
  get cssText() {
    return "";
  }
};

// node_modules/happy-dom/lib/css/declaration/property-manager/CSSStyleDeclarationValueParser.js
var COLOR_REGEXP = /^#([0-9a-fA-F]{3,4}){1,2}$|^rgb\(([^)]*)\)$|^rgba\(([^)]*)\)$|^hsla?\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*(,\s*(-?\d+|-?\d*.\d+)\s*)?\)/;
var LENGTH_REGEXP = /^(0|[-+]?[0-9]*\.?[0-9]+)(in|cm|em|mm|pt|pc|px|ex|rem|vh|vw|ch|vw|vh|vmin|vmax|Q)$/;
var PERCENTAGE_REGEXP = /^[-+]?[0-9]*\.?[0-9]+%$/;
var DEGREE_REGEXP = /^[0-9]+deg$/;
var URL_REGEXP = /^url\(\s*([^)]*)\s*\)$/;
var INTEGER_REGEXP = /^[0-9]+$/;
var FLOAT_REGEXP = /^[0-9.]+$/;
var CALC_REGEXP = /^calc\([^^)]+\)$/;
var CSS_VARIABLE_REGEXP = /^var\(\s*(--[^)\s]+)\)$/;
var FIT_CONTENT_REGEXP = /^fit-content\([^^)]+\)$/;
var GRADIENT_REGEXP = /^((repeating-linear|linear|radial|repeating-radial|conic|repeating-conic)-gradient)\(([^)]+)\)$/;
var GLOBALS = ["inherit", "initial", "unset", "revert"];
var COLORS = [
  "none",
  "currentcolor",
  "transparent",
  "silver",
  "gray",
  "white",
  "maroon",
  "red",
  "purple",
  "fuchsia",
  "green",
  "lime",
  "olive",
  "yellow",
  "navy",
  "blue",
  "teal",
  "aliceblue",
  "aqua",
  "antiquewhite",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkgrey",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "greenyellow",
  "grey",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightgrey",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "limegreen",
  "linen",
  "magenta",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "oldlace",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "rebeccapurple",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "whitesmoke",
  "yellowgreen"
];
var CSSStyleDeclarationValueParser = class {
  /**
   * Returns length.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getLength(value2) {
    if (value2 === "0") {
      return "0px";
    }
    const match = value2.match(LENGTH_REGEXP);
    if (match) {
      const number = parseFloat(match[1]);
      if (isNaN(number)) {
        return null;
      }
      const unit = match[2];
      return `${Math.round(number * 1e6) / 1e6}${unit}`;
    }
    return null;
  }
  /**
   * Returns percentance.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getPercentage(value2) {
    if (value2 === "0") {
      return "0%";
    }
    if (PERCENTAGE_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns degree.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getDegree(value2) {
    if (value2 === "0") {
      return "0deg";
    }
    if (DEGREE_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns calc.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getCalc(value2) {
    if (CALC_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns fit content.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getFitContent(value2) {
    const lowerValue = value2.toLowerCase();
    if (lowerValue === "auto" || lowerValue === "max-content" || lowerValue === "min-content" || lowerValue === "fit-content") {
      return lowerValue;
    }
    if (FIT_CONTENT_REGEXP.test(lowerValue)) {
      return lowerValue;
    }
    return null;
  }
  /**
   * Returns measurement.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getMeasurement(value2) {
    return this.getLength(value2) || this.getPercentage(value2) || this.getCalc(value2);
  }
  /**
   * Returns measurement or auto, min-content, max-content or fit-content.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getContentMeasurement(value2) {
    return this.getFitContent(value2) || this.getMeasurement(value2);
  }
  /**
   * Returns measurement or auto, min-content, max-content or fit-content.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getAutoMeasurement(value2) {
    if (value2.toLocaleLowerCase() === "auto") {
      return "auto";
    }
    return this.getMeasurement(value2);
  }
  /**
   * Returns integer.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getInteger(value2) {
    if (INTEGER_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns float.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getFloat(value2) {
    if (FLOAT_REGEXP.test(value2)) {
      const number = parseFloat(value2);
      if (isNaN(number)) {
        return null;
      }
      return String(Math.round(number * 1e6) / 1e6);
    }
    return null;
  }
  /**
   * Returns gradient.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getGradient(value2) {
    const match = value2.match(GRADIENT_REGEXP);
    if (match) {
      return `${match[1]}(${match[3].trim().split(/\s*,\s*/).join(", ")})`;
    }
    return null;
  }
  /**
   * Returns color.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getColor(value2) {
    const lowerValue = value2.toLowerCase();
    if (COLORS.includes(lowerValue)) {
      return lowerValue;
    }
    if (COLOR_REGEXP.test(value2)) {
      return value2.replace(/,([^ ])/g, ", $1");
    }
    return null;
  }
  /**
   * Returns URL.
   *
   * Based on:
   * https://github.com/jsdom/cssstyle/blob/master/lib/parsers.js#L222
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getURL(value2) {
    if (!value2) {
      return null;
    }
    if (value2.toLowerCase() === "none") {
      return "none";
    }
    const result2 = URL_REGEXP.exec(value2);
    if (!result2) {
      return null;
    }
    let url2 = result2[1].trim();
    if ((url2[0] === '"' || url2[0] === "'") && url2[0] !== url2[url2.length - 1]) {
      return null;
    }
    if (url2[0] === '"' || url2[0] === "'") {
      url2 = url2.substring(1, url2.length - 1);
    }
    for (let i = 0; i < url2.length; i++) {
      switch (url2[i]) {
        case "(":
        case ")":
        case " ":
        case "	":
        case "\n":
        case "'":
        case '"':
          return null;
        case "\\":
          i++;
          break;
      }
    }
    return `url("${url2}")`;
  }
  /**
   * Returns global initial value.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getInitial(value2) {
    return value2.toLowerCase() === "initial" ? "initial" : null;
  }
  /**
   * Returns CSS variable.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getVariable(value2) {
    const cssVariableMatch = value2.match(CSS_VARIABLE_REGEXP);
    if (cssVariableMatch) {
      return `var(${cssVariableMatch[1]})`;
    }
    return null;
  }
  /**
   * Returns global.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getGlobal(value2) {
    const lowerValue = value2.toLowerCase();
    return GLOBALS.includes(lowerValue) ? lowerValue : null;
  }
  /**
   * Returns global, unless it is not set to 'initial' as it is sometimes treated different.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getGlobalExceptInitial(value2) {
    const lowerValue = value2.toLowerCase();
    return lowerValue !== "initial" && GLOBALS.includes(lowerValue) ? lowerValue : null;
  }
};

// node_modules/happy-dom/lib/css/declaration/property-manager/CSSStyleDeclarationPropertySetParser.js
var RECT_REGEXP = /^rect\((.*)\)$/i;
var SPLIT_COMMA_SEPARATED_WITH_PARANTHESES_REGEXP = /,(?=(?:(?:(?!\))[\s\S])*\()|[^\(\)]*$)/;
var SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP = /\s+(?=(?:(?:(?!\))[\s\S])*\()|[^\(\)]*$)/;
var WHITE_SPACE_GLOBAL_REGEXP = /\s+/gm;
var BORDER_STYLE = [
  "none",
  "hidden",
  "dotted",
  "dashed",
  "solid",
  "double",
  "groove",
  "ridge",
  "inset",
  "outset"
];
var BORDER_WIDTH = ["thin", "medium", "thick"];
var BORDER_COLLAPSE = ["separate", "collapse"];
var BACKGROUND_REPEAT = ["repeat", "repeat-x", "repeat-y", "no-repeat"];
var BACKGROUND_ORIGIN = ["border-box", "padding-box", "content-box"];
var BACKGROUND_CLIP = ["border-box", "padding-box", "content-box"];
var BACKGROUND_ATTACHMENT = ["scroll", "fixed"];
var FLEX_BASIS = ["auto", "fill", "content"];
var CLEAR = ["none", "left", "right", "both"];
var FLOAT = ["none", "left", "right", "inline-start", "inline-end"];
var SYSTEM_FONT = ["caption", "icon", "menu", "message-box", "small-caption", "status-bar"];
var FONT_WEIGHT = ["normal", "bold", "bolder", "lighter"];
var FONT_STYLE = ["normal", "italic", "oblique"];
var FONT_SIZE = [
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  "smaller",
  "larger"
];
var FONT_STRETCH = [
  "ultra-condensed",
  "extra-condensed",
  "condensed",
  "semi-condensed",
  "normal",
  "semi-expanded",
  "expanded",
  "extra-expanded",
  "ultra-expanded"
];
var DISPLAY = [
  /* Legacy values */
  "block",
  "inline",
  "inline-block",
  "flex",
  "inline-flex",
  "grid",
  "inline-grid",
  "flow-root",
  /* Box generation */
  "none",
  "contents",
  /* Two-value syntax */
  "block flow",
  "inline flow",
  "inline flow-root",
  "block flex",
  "inline flex",
  "block grid",
  "inline grid",
  "block flow-root",
  /* Other values */
  "table",
  "table-row",
  "list-item"
];
var BORDER_IMAGE_REPEAT = ["stretch", "repeat", "round", "space"];
var TEXT_TRANSFORM = [
  "capitalize",
  "uppercase",
  "lowercase",
  "none",
  "full-width",
  "full-size-kana"
];
var VISIBILITY = ["visible", "hidden", "collapse"];
var CSSStyleDeclarationPropertySetParser = class {
  /**
   * Returns border collapse.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderCollapse(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-collapse": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_COLLAPSE.includes(lowerValue)) {
      return { "border-collapse": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns display.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getDisplay(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { display: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || DISPLAY.includes(lowerValue)) {
      return { display: { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns direction.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getDirection(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { direction: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "ltr" || lowerValue === "rtl") {
      return { direction: { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns letter spacing.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getLetterSpacing(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { "letter-spacing": { value: parsedValue, important } } : null;
  }
  /**
   * Returns word spacing.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getWordSpacing(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { "word-spacing": { value: parsedValue, important } } : null;
  }
  /**
   * Returns text indent.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getTextIndent(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { "text-indent": { value: parsedValue, important } } : null;
  }
  /**
   * Returns width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getWidth(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { width: { value: parsedValue, important } } : null;
  }
  /**
   * Returns height.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getHeight(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { height: { value: parsedValue, important } } : null;
  }
  /**
   * Returns top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getTop(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { top: { value: parsedValue, important } } : null;
  }
  /**
   * Returns top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getRight(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { right: { value: parsedValue, important } } : null;
  }
  /**
   * Returns top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBottom(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { bottom: { value: parsedValue, important } } : null;
  }
  /**
   * Returns top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getLeft(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { left: { value: parsedValue, important } } : null;
  }
  /**
   * Returns clear.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getClear(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { clear: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || CLEAR.includes(lowerValue)) {
      return { clear: { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns clip
   *
   * Based on:
   * https://github.com/jsdom/cssstyle/blob/master/lib/properties/clip.js
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getClip(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { clip: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "auto") {
      return { clip: { value: lowerValue, important } };
    }
    const matches = lowerValue.match(RECT_REGEXP);
    if (!matches) {
      return null;
    }
    const parts = matches[1].split(/\s*,\s*/);
    if (parts.length !== 4) {
      return null;
    }
    for (const part of parts) {
      if (!CSSStyleDeclarationValueParser.getMeasurement(part)) {
        return null;
      }
    }
    return { clip: { value: value2, important } };
  }
  /**
   * Returns float.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFloat(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { float: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FLOAT.includes(lowerValue)) {
      return { float: { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns float.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getCSSFloat(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "css-float": { value: variable, important } };
    }
    const float = this.getFloat(value2, important);
    return float ? { "css-float": float["float"] } : null;
  }
  /**
   * Returns outline.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getOutline(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { outline: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getOutlineColor(globalValue, important),
        ...this.getOutlineStyle(globalValue, important),
        ...this.getOutlineWidth(globalValue, important)
      };
    }
    const properties = {
      ...this.getOutlineColor("initial", important),
      ...this.getOutlineStyle("initial", important),
      ...this.getOutlineWidth("initial", important)
    };
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    for (const part of parts) {
      const width2 = this.getOutlineWidth(part, important);
      const style2 = this.getOutlineStyle(part, important);
      const color = this.getOutlineColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns outline color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getOutlineColor(value2, important) {
    const color = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "outline-color": { value: color, important }
    } : null;
  }
  /**
   * Returns outline offset.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getOutlineOffset(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getLength(value2);
    return parsedValue ? { "outline-offset": { value: parsedValue, important } } : null;
  }
  /**
   * Returns outline style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getOutlineStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "outline-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "outline-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns outline width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getOutlineWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "outline-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "outline-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorder(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { border: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderWidth(globalValue, important),
        ...this.getBorderStyle(globalValue, important),
        ...this.getBorderColor(globalValue, important),
        ...this.getBorderImage(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderWidth("initial", important),
      ...this.getBorderStyle("initial", important),
      ...this.getBorderColor("initial", important),
      ...this.getBorderImage("initial", important)
    };
    const parts = value2.replace(/\s*,\s*/g, ",").split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    for (const part of parts) {
      const width2 = this.getBorderWidth(part, important);
      const style2 = this.getBorderStyle(part, important);
      const color = this.getBorderColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-width": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopWidth(globalValue, important),
        ...this.getBorderRightWidth(globalValue, important),
        ...this.getBorderBottomWidth(globalValue, important),
        ...this.getBorderLeftWidth(globalValue, important)
      };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    const top2 = this.getBorderTopWidth(parts[0], important);
    const right = this.getBorderRightWidth(parts[1] || parts[0], important);
    const bottom = this.getBorderBottomWidth(parts[2] || parts[0], important);
    const left = this.getBorderLeftWidth(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right || !bottom || !left) {
      return null;
    }
    return {
      ...top2,
      ...right,
      ...bottom,
      ...left
    };
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-style": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopStyle(globalValue, important),
        ...this.getBorderRightStyle(globalValue, important),
        ...this.getBorderBottomStyle(globalValue, important),
        ...this.getBorderLeftStyle(globalValue, important)
      };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    const top2 = this.getBorderTopStyle(parts[0], important);
    const right = this.getBorderRightStyle(parts[1] || parts[0], important);
    const bottom = this.getBorderBottomStyle(parts[2] || parts[0], important);
    const left = this.getBorderLeftStyle(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right || !bottom || !left) {
      return null;
    }
    return {
      ...top2,
      ...right,
      ...bottom,
      ...left
    };
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-color": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopColor(globalValue, important),
        ...this.getBorderRightColor(globalValue, important),
        ...this.getBorderBottomColor(globalValue, important),
        ...this.getBorderLeftColor(globalValue, important)
      };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    const top2 = this.getBorderTopColor(parts[0], important);
    const right = this.getBorderRightColor(parts[1] || parts[0], important);
    const bottom = this.getBorderBottomColor(parts[2] || parts[0], important);
    const left = this.getBorderLeftColor(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right || !bottom || !left) {
      return null;
    }
    return {
      ...top2,
      ...right,
      ...bottom,
      ...left
    };
  }
  /**
   * Returns border image.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImage(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderImageSource(globalValue, important),
        ...this.getBorderImageSlice(globalValue, important),
        ...this.getBorderImageWidth(globalValue, important),
        ...this.getBorderImageOutset(globalValue, important),
        ...this.getBorderImageRepeat(globalValue, important)
      };
    }
    let parsedValue = value2.replace(/\s\/\s/g, "/");
    const sourceMatch = parsedValue.match(/\s*([a-zA-Z-]+\([^)]*\))\s*/);
    if (sourceMatch) {
      parsedValue = parsedValue.replace(sourceMatch[0], "");
    }
    const parts = parsedValue.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    if (sourceMatch) {
      parts.push(sourceMatch[1]);
    }
    const properties = {
      ...this.getBorderImageSource("none", important),
      ...this.getBorderImageSlice("100%", important),
      ...this.getBorderImageWidth("1", important),
      ...this.getBorderImageOutset("0", important),
      ...this.getBorderImageRepeat("stretch", important)
    };
    for (let i = 0, max = parts.length; i < max; i++) {
      const part = parts[i];
      const previousPart = i > 0 ? parts[i - 1] : "";
      if (!part.startsWith("url") && part.includes("/")) {
        const [slice, width2, outset] = part.split("/");
        const borderImageSlice = this.getBorderImageSlice(`${previousPart} ${slice}`, important) || this.getBorderImageSlice(slice, important);
        const borderImageWidth = this.getBorderImageWidth(width2, important);
        const borderImageOutset = outset && this.getBorderImageOutset(outset, important);
        if (!borderImageSlice || !borderImageWidth || borderImageOutset === null) {
          return null;
        }
        Object.assign(properties, borderImageSlice, borderImageWidth, borderImageOutset);
      } else {
        const slice = this.getBorderImageSlice(`${previousPart} ${part}`, important) || this.getBorderImageSlice(part, important);
        const source = this.getBorderImageSource(part, important);
        const repeat = this.getBorderImageRepeat(part, important);
        if (!slice && !source && !repeat) {
          return null;
        }
        Object.assign(properties, slice, source, repeat);
      }
    }
    return properties;
  }
  /**
   * Returns border source.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageSource(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-source": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "none") {
      return {
        "border-image-source": {
          important,
          value: lowerValue
        }
      };
    }
    const parsedValue = CSSStyleDeclarationValueParser.getURL(value2) || CSSStyleDeclarationValueParser.getGradient(value2);
    if (!parsedValue) {
      return null;
    }
    return {
      "border-image-source": {
        important,
        value: parsedValue
      }
    };
  }
  /**
   * Returns border slice.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageSlice(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-slice": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        "border-image-slice": {
          important,
          value: lowerValue
        }
      };
    }
    if (lowerValue !== lowerValue.trim()) {
      return null;
    }
    const regexp = /(fill)|(calc\([^^)]+\))|([0-9]+%)|([0-9]+)/g;
    const values2 = [];
    let match;
    while (match = regexp.exec(lowerValue)) {
      const previousCharacter = lowerValue[match.index - 1];
      const nextCharacter = lowerValue[match.index + match[0].length];
      if (previousCharacter && previousCharacter !== " " || nextCharacter && nextCharacter !== " ") {
        return null;
      }
      const fill = match[1] && "fill";
      const calc = match[2] && CSSStyleDeclarationValueParser.getCalc(match[2]);
      const percentage = match[3] && CSSStyleDeclarationValueParser.getPercentage(match[3]);
      const integer = match[4] && CSSStyleDeclarationValueParser.getInteger(match[4]);
      if (!fill && !calc && !percentage && !integer) {
        return null;
      }
      values2.push(fill || calc || percentage || integer);
    }
    if (!values2.length || values2.length > 4) {
      return null;
    }
    return {
      "border-image-slice": {
        important,
        value: values2.join(" ")
      }
    };
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        "border-image-width": {
          important,
          value: lowerValue
        }
      };
    }
    const parts = lowerValue.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    if (parts.length > 4) {
      return null;
    }
    for (const part of parts) {
      if (!CSSStyleDeclarationValueParser.getInteger(part) && !CSSStyleDeclarationValueParser.getAutoMeasurement(part)) {
        return null;
      }
    }
    return {
      "border-image-width": {
        important,
        value: value2
      }
    };
  }
  /**
   * Returns border outset.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageOutset(value2, important) {
    if (value2 === "0") {
      return {
        "border-image-outset": {
          important,
          value: value2
        }
      };
    }
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-outset": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        "border-image-outset": {
          important,
          value: lowerValue
        }
      };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    if (parts.length > 4) {
      return null;
    }
    const newParts = [];
    for (const part of parts) {
      const parsedValue = CSSStyleDeclarationValueParser.getLength(part) || CSSStyleDeclarationValueParser.getFloat(part);
      if (!parsedValue) {
        return null;
      }
      newParts.push(parsedValue === "0px" ? "0" : parsedValue);
    }
    return {
      "border-image-outset": {
        important,
        value: newParts.join(" ")
      }
    };
  }
  /**
   * Returns border repeat.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageRepeat(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-repeat": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        "border-image-repeat": {
          important,
          value: lowerValue
        }
      };
    }
    const parts = lowerValue.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    if (parts.length > 2) {
      return null;
    }
    for (const part of parts) {
      if (!BORDER_IMAGE_REPEAT.includes(part)) {
        return null;
      }
    }
    return {
      "border-image-repeat": {
        important,
        value: value2
      }
    };
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderTopWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "border-top-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderRightWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-right-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "border-right-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderBottomWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "border-bottom-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderLeftWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-left-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "border-left-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderTopStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "border-top-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderRightStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-right-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "border-right-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderBottomStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "border-bottom-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderLeftStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-left-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "border-left-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderTopColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "border-top-color": { value: color, important }
    } : null;
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderRightColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-right-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "border-right-color": { value: color, important }
    } : null;
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderBottomColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "border-bottom-color": { value: color, important }
    } : null;
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderLeftColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-left-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "border-left-color": { value: color, important }
    } : null;
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-radius": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopLeftRadius(globalValue, important),
        ...this.getBorderTopRightRadius(globalValue, important),
        ...this.getBorderBottomRightRadius(globalValue, important),
        ...this.getBorderBottomLeftRadius(globalValue, important)
      };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    const topLeft = this.getBorderTopLeftRadius(parts[0], important);
    const topRight = this.getBorderTopRightRadius(parts[1] || parts[0], important);
    const bottomRight = this.getBorderBottomRightRadius(parts[2] || parts[0], important);
    const bottomLeft = this.getBorderBottomLeftRadius(parts[3] || parts[1] || parts[0], important);
    if (!topLeft || !topRight || !bottomRight || !bottomLeft) {
      return null;
    }
    return {
      ...topLeft,
      ...topRight,
      ...bottomRight,
      ...bottomLeft
    };
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderTopLeftRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-left-radius": { value: variable, important } };
    }
    const radius = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return radius ? { "border-top-left-radius": { important, value: radius } } : null;
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderTopRightRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-right-radius": { value: variable, important } };
    }
    const radius = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return radius ? { "border-top-right-radius": { important, value: radius } } : null;
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderBottomRightRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-right-radius": { value: variable, important } };
    }
    const radius = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return radius ? { "border-bottom-right-radius": { important, value: radius } } : null;
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderBottomLeftRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-left-radius": { value: variable, important } };
    }
    const radius = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return radius ? { "border-bottom-left-radius": { important, value: radius } } : null;
  }
  /**
   * Returns border top, right, bottom or left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderTop(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopWidth(globalValue, important),
        ...this.getBorderTopStyle(globalValue, important),
        ...this.getBorderTopColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderTopWidth("initial", important),
      ...this.getBorderTopStyle("initial", important),
      ...this.getBorderTopColor("initial", important)
    };
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    for (const part of parts) {
      const width2 = this.getBorderTopWidth(part, important);
      const style2 = this.getBorderTopStyle(part, important);
      const color = this.getBorderTopColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns border top, right, bottom or left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderRight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-right": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderRightWidth(globalValue, important),
        ...this.getBorderRightStyle(globalValue, important),
        ...this.getBorderRightColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderRightWidth("initial", important),
      ...this.getBorderRightStyle("initial", important),
      ...this.getBorderRightColor("initial", important)
    };
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    for (const part of parts) {
      const width2 = this.getBorderRightWidth(part, important);
      const style2 = this.getBorderRightStyle(part, important);
      const color = this.getBorderRightColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns border top, right, bottom or left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderBottom(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderBottomWidth(globalValue, important),
        ...this.getBorderBottomStyle(globalValue, important),
        ...this.getBorderBottomColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderBottomWidth("initial", important),
      ...this.getBorderBottomStyle("initial", important),
      ...this.getBorderBottomColor("initial", important)
    };
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    for (const part of parts) {
      const width2 = this.getBorderBottomWidth(part, important);
      const style2 = this.getBorderBottomStyle(part, important);
      const color = this.getBorderBottomColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns border top, right, bottom or left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderLeft(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-left": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderLeftWidth(globalValue, important),
        ...this.getBorderLeftStyle(globalValue, important),
        ...this.getBorderLeftColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderLeftWidth("initial", important),
      ...this.getBorderLeftStyle("initial", important),
      ...this.getBorderLeftColor("initial", important)
    };
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    for (const part of parts) {
      const width2 = this.getBorderLeftWidth(part, important);
      const style2 = this.getBorderLeftStyle(part, important);
      const color = this.getBorderLeftColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns padding.
   *
   * @param value Value.
   * @param important Important.
   */
  static getPadding(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { padding: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getPaddingTop(globalValue, important),
        ...this.getPaddingRight(globalValue, important),
        ...this.getPaddingBottom(globalValue, important),
        ...this.getPaddingLeft(globalValue, important)
      };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    const top2 = this.getPaddingTop(parts[0], important);
    const right = this.getPaddingRight(parts[1] || parts[0], important);
    const bottom = this.getPaddingBottom(parts[2] || parts[0], important);
    const left = this.getPaddingLeft(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right || !bottom || !left) {
      return null;
    }
    return {
      ...top2,
      ...right,
      ...bottom,
      ...left
    };
  }
  /**
   * Returns padding top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getPaddingTop(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "padding-top": { value: variable, important } };
    }
    const padding = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return padding ? { "padding-top": { value: padding, important } } : null;
  }
  /**
   * Returns padding right.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getPaddingRight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "padding-right": { value: variable, important } };
    }
    const padding = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return padding ? { "padding-right": { value: padding, important } } : null;
  }
  /**
   * Returns padding bottom.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getPaddingBottom(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "padding-bottom": { value: variable, important } };
    }
    const padding = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return padding ? { "padding-bottom": { value: padding, important } } : null;
  }
  /**
   * Returns padding left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getPaddingLeft(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "padding-left": { value: variable, important } };
    }
    const padding = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return padding ? { "padding-left": { value: padding, important } } : null;
  }
  /**
   * Returns margin.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMargin(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { margin: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getMarginTop(globalValue, important),
        ...this.getMarginRight(globalValue, important),
        ...this.getMarginBottom(globalValue, important),
        ...this.getMarginLeft(globalValue, important)
      };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    const top2 = this.getMarginTop(parts[0], important);
    const right = this.getMarginRight(parts[1] || parts[0], important);
    const bottom = this.getMarginBottom(parts[2] || parts[0], important);
    const left = this.getMarginLeft(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right || !bottom || !left) {
      return null;
    }
    return {
      ...top2,
      ...right,
      ...bottom,
      ...left
    };
  }
  /**
   * Returns margin top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMarginTop(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "margin-top": { value: variable, important } };
    }
    const margin = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getAutoMeasurement(value2);
    return margin ? { "margin-top": { value: margin, important } } : null;
  }
  /**
   * Returns margin right.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMarginRight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "margin-right": { value: variable, important } };
    }
    const margin = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getAutoMeasurement(value2);
    return margin ? { "margin-right": { value: margin, important } } : null;
  }
  /**
   * Returns margin right.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMarginBottom(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "margin-bottom": { value: variable, important } };
    }
    const margin = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getAutoMeasurement(value2);
    return margin ? { "margin-bottom": { value: margin, important } } : null;
  }
  /**
   * Returns margin left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMarginLeft(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "margin-left": { value: variable, important } };
    }
    const margin = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getAutoMeasurement(value2);
    return margin ? { "margin-left": { value: margin, important } } : null;
  }
  /**
   * Returns flex.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getFlex(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { flex: { value: variable, important } };
    }
    const lowerValue = value2.trim().toLowerCase();
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getFlexGrow(globalValue, important),
        ...this.getFlexShrink(globalValue, important),
        ...this.getFlexBasis(globalValue, important)
      };
    }
    switch (lowerValue) {
      case "none":
        return {
          ...this.getFlexGrow("0", important),
          ...this.getFlexShrink("0", important),
          ...this.getFlexBasis("auto", important)
        };
      case "auto":
        return {
          ...this.getFlexGrow("1", important),
          ...this.getFlexShrink("1", important),
          ...this.getFlexBasis("auto", important)
        };
    }
    const measurement = CSSStyleDeclarationValueParser.getContentMeasurement(lowerValue);
    if (measurement) {
      return {
        ...this.getFlexGrow("1", important),
        ...this.getFlexShrink("1", important),
        ...this.getFlexBasis(measurement, important)
      };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    const flexGrow = this.getFlexGrow(parts[0], important);
    const flexShrink = this.getFlexShrink(parts[1] || "1", important);
    const flexBasis = this.getFlexBasis(parts[2] || "0%", important);
    if (!flexGrow || !flexShrink || !flexBasis) {
      return null;
    }
    return {
      ...flexGrow,
      ...flexShrink,
      ...flexBasis
    };
  }
  /**
   * Returns flex basis.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFlexBasis(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "flex-basis": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FLEX_BASIS.includes(lowerValue)) {
      return { "flex-basis": { value: lowerValue, important } };
    }
    const measurement = CSSStyleDeclarationValueParser.getContentMeasurement(lowerValue);
    return measurement ? { "flex-basis": { value: measurement, important } } : null;
  }
  /**
   * Returns flex shrink.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFlexShrink(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "flex-shrink": { value: variable, important } };
    }
    const parsedValue = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getFloat(value2);
    return parsedValue ? { "flex-shrink": { value: parsedValue, important } } : null;
  }
  /**
   * Returns flex grow.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFlexGrow(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "flex-grow": { value: variable, important } };
    }
    const parsedValue = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getFloat(value2);
    return parsedValue ? { "flex-grow": { value: parsedValue, important } } : null;
  }
  /**
   * Returns background.
   *
   * @param name Name.
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBackground(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { background: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBackgroundImage(globalValue, important),
        ...this.getBackgroundPosition(globalValue, important),
        ...this.getBackgroundSize(globalValue, important),
        ...this.getBackgroundRepeat(globalValue, important),
        ...this.getBackgroundAttachment(globalValue, important),
        ...this.getBackgroundOrigin(globalValue, important),
        ...this.getBackgroundClip(globalValue, important),
        ...this.getBackgroundColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBackgroundImage("initial", important),
      ...this.getBackgroundPosition("initial", important),
      ...this.getBackgroundSize("initial", important),
      ...this.getBackgroundRepeat("initial", important),
      ...this.getBackgroundAttachment("initial", important),
      ...this.getBackgroundOrigin("initial", important),
      ...this.getBackgroundClip("initial", important),
      ...this.getBackgroundColor("initial", important)
    };
    const parts = value2.replace(/\s,\s/g, ",").replace(/\s\/\s/g, "/").split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    const backgroundPositions = [];
    for (const part of parts) {
      if (!part.startsWith("url") && part.includes("/")) {
        const [position, size] = part.split("/");
        const backgroundPositionX = this.getBackgroundPositionX(position, important);
        const backgroundPositionY = this.getBackgroundPositionY(position, important);
        const backgroundSize = this.getBackgroundSize(size, important);
        if (!backgroundPositionX && !backgroundPositionY || !backgroundSize) {
          return null;
        }
        if (backgroundPositionY) {
          backgroundPositions.push(backgroundPositionY["background-position-y"].value);
        } else if (backgroundPositionX) {
          backgroundPositions.push(backgroundPositionX["background-position-x"].value);
        }
        Object.assign(properties, backgroundSize);
      } else {
        const backgroundImage = this.getBackgroundImage(part, important);
        const backgroundRepeat = this.getBackgroundRepeat(part, important);
        const backgroundAttachment = this.getBackgroundAttachment(part, important);
        const backgroundPositionX = this.getBackgroundPositionX(part, important);
        const backgroundPositionY = this.getBackgroundPositionY(part, important);
        const backgroundColor = this.getBackgroundColor(part, important);
        const backgroundOrigin = this.getBackgroundOrigin(part, important);
        const backgroundClip = this.getBackgroundClip(part, important);
        if (!backgroundImage && !backgroundRepeat && !backgroundAttachment && !backgroundPositionX && !backgroundPositionY && !backgroundColor && !backgroundOrigin && !backgroundClip) {
          return null;
        }
        if (backgroundPositionX) {
          backgroundPositions.push(backgroundPositionX["background-position-x"].value);
        } else if (backgroundPositionY) {
          backgroundPositions.push(backgroundPositionY["background-position-y"].value);
        }
        Object.assign(properties, backgroundImage, backgroundRepeat, backgroundAttachment, backgroundColor, backgroundOrigin, backgroundClip);
      }
    }
    if (backgroundPositions.length) {
      Object.assign(properties, this.getBackgroundPosition(backgroundPositions.join(" "), important));
    }
    return properties;
  }
  /**
   * Returns background size.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundSize(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-size": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return { "background-size": { value: lowerValue, important } };
    }
    const imageParts = lowerValue.split(SPLIT_COMMA_SEPARATED_WITH_PARANTHESES_REGEXP);
    const parsed = [];
    for (const imagePart of imageParts) {
      const parts = imagePart.trim().split(" ");
      if (parts.length !== 1 && parts.length !== 2) {
        return null;
      }
      if (parts.length === 1) {
        if (parts[0] !== "cover" && parts[0] !== "contain" && !CSSStyleDeclarationValueParser.getAutoMeasurement(parts[0])) {
          return null;
        }
        parsed.push(parts[0]);
      } else {
        if (!CSSStyleDeclarationValueParser.getAutoMeasurement(parts[0]) || !CSSStyleDeclarationValueParser.getAutoMeasurement(parts[1])) {
          return null;
        }
        parsed.push(`${parts[0]} ${parts[1]}`);
      }
    }
    if (parsed.length === 1) {
      return { "background-size": { value: parsed.join(", "), important } };
    }
    return null;
  }
  /**
   * Returns background origin.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundOrigin(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-origin": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BACKGROUND_ORIGIN.includes(lowerValue)) {
      return { "background-origin": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns background clip.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundClip(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-clip": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BACKGROUND_CLIP.includes(lowerValue)) {
      return { "background-clip": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns background repeat.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundRepeat(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-repeat": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BACKGROUND_REPEAT.includes(lowerValue)) {
      return { "background-repeat": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns background attachment.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundAttachment(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-attachment": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BACKGROUND_ATTACHMENT.includes(lowerValue)) {
      return { "background-attachment": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns background position.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundPosition(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-position": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBackgroundPositionX(globalValue, important),
        ...this.getBackgroundPositionY(globalValue, important)
      };
    }
    const imageParts = value2.split(SPLIT_COMMA_SEPARATED_WITH_PARANTHESES_REGEXP);
    let x3 = "";
    let y3 = "";
    for (const imagePart of imageParts) {
      const parts = imagePart.trim().split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
      if (x3) {
        x3 += ",";
        y3 += ",";
      }
      switch (parts.length) {
        case 1:
          if (parts[0] === "top" || parts[0] === "bottom") {
            x3 += "center";
            y3 += parts[0];
          } else if (parts[0] === "left" || parts[0] === "right") {
            x3 += parts[0];
            y3 += "center";
          } else if (parts[0] === "center") {
            x3 += "center";
            y3 += "center";
          }
          break;
        case 2:
          x3 += parts[0] === "top" || parts[0] === "bottom" ? parts[1] : parts[0];
          y3 += parts[0] === "top" || parts[0] === "bottom" ? parts[0] : parts[1];
          break;
        case 3:
          if (parts[0] === "top" || parts[0] === "bottom" || parts[1] === "left" || parts[1] === "right" || parts[2] === "left" || parts[2] === "right") {
            if (CSSStyleDeclarationValueParser.getMeasurement(parts[1])) {
              x3 += parts[2];
              y3 += `${parts[0]} ${parts[1]}`;
            } else {
              x3 += `${parts[1]} ${parts[2]}`;
              y3 += parts[0];
            }
          } else {
            if (CSSStyleDeclarationValueParser.getMeasurement(parts[1])) {
              x3 += `${parts[0]} ${parts[1]}`;
              y3 += parts[2];
            } else {
              x3 += parts[0];
              y3 += `${parts[1]} ${parts[2]}`;
            }
          }
          break;
        case 4:
          x3 += parts[0] === "top" || parts[0] === "bottom" || parts[1] === "top" || parts[1] === "bottom" ? `${parts[2]} ${parts[3]}` : `${parts[0]} ${parts[1]}`;
          y3 += parts[0] === "top" || parts[0] === "bottom" || parts[1] === "top" || parts[1] === "bottom" ? `${parts[0]} ${parts[1]}` : `${parts[2]} ${parts[3]}`;
          break;
        default:
          return null;
      }
    }
    const xValue = this.getBackgroundPositionX(x3, important);
    const yValue = this.getBackgroundPositionY(y3, important);
    if (xValue && yValue) {
      return {
        ...xValue,
        ...yValue
      };
    }
    return null;
  }
  /**
   * Returns background position.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundPositionX(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-position-x": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return { "background-position-x": { value: lowerValue, important } };
    }
    const imageParts = lowerValue.split(SPLIT_COMMA_SEPARATED_WITH_PARANTHESES_REGEXP);
    let parsedValue = "";
    for (const imagePart of imageParts) {
      const parts = imagePart.trim().split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
      if (parsedValue) {
        parsedValue += ",";
      }
      for (const part of parts) {
        const measurement = CSSStyleDeclarationValueParser.getMeasurement(part);
        if (!measurement && part !== "left" && part !== "right" && part !== "center") {
          return null;
        }
        if (parsedValue) {
          parsedValue += " ";
        }
        parsedValue += measurement || part;
      }
    }
    return { "background-position-x": { value: parsedValue, important } };
  }
  /**
   * Returns background position.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundPositionY(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-position-y": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return { "background-position-y": { value: lowerValue, important } };
    }
    const imageParts = lowerValue.split(SPLIT_COMMA_SEPARATED_WITH_PARANTHESES_REGEXP);
    let parsedValue = "";
    for (const imagePart of imageParts) {
      const parts = imagePart.trim().split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
      if (parsedValue) {
        parsedValue += ",";
      }
      for (const part of parts) {
        const measurement = CSSStyleDeclarationValueParser.getMeasurement(part);
        if (!measurement && part !== "top" && part !== "bottom" && part !== "center") {
          return null;
        }
        if (parsedValue) {
          parsedValue += " ";
        }
        parsedValue += measurement || part;
      }
    }
    return { "background-position-y": { value: parsedValue, important } };
  }
  /**
   * Returns background color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property value.
   */
  static getBackgroundColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      ["background-color"]: { important, value: color }
    } : null;
  }
  /**
   * Returns background image.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property value.
   */
  static getBackgroundImage(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-image": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "none") {
      return { "background-image": { value: lowerValue, important } };
    }
    const parts = value2.split(SPLIT_COMMA_SEPARATED_WITH_PARANTHESES_REGEXP);
    const parsed = [];
    for (const part of parts) {
      const parsedValue = CSSStyleDeclarationValueParser.getURL(part.trim()) || CSSStyleDeclarationValueParser.getGradient(part.trim());
      if (!parsedValue) {
        return null;
      }
      parsed.push(parsedValue);
    }
    if (parsed.length) {
      return { "background-image": { value: parsed.join(", "), important } };
    }
    return null;
  }
  /**
   * Returns color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property value.
   */
  static getColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { color: { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? { color: { important, value: color } } : null;
  }
  /**
   * Returns color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property value.
   */
  static getFloodColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "flood-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? { "flood-color": { important, value: color } } : null;
  }
  /**
   * Returns font.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFont(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { font: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        ...this.getFontStyle(lowerValue, important),
        ...this.getFontVariant(lowerValue, important),
        ...this.getFontWeight(lowerValue, important),
        ...this.getFontStretch(lowerValue, important),
        ...this.getFontSize(lowerValue, important),
        ...this.getLineHeight(lowerValue, important),
        ...this.getFontFamily(lowerValue, important)
      };
    }
    if (SYSTEM_FONT.includes(lowerValue)) {
      return { font: { value: lowerValue, important } };
    }
    const properties = {
      ...this.getFontStyle("normal", important),
      ...this.getFontVariant("normal", important),
      ...this.getFontWeight("normal", important),
      ...this.getFontStretch("normal", important),
      ...this.getLineHeight("normal", important)
    };
    const parts = value2.replace(/\s*\/\s*/g, "/").split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    for (let i = 0, max = parts.length; i < max; i++) {
      const part = parts[i];
      if (part.includes("/")) {
        const [size, height2] = part.split("/");
        const fontSize = this.getFontSize(size, important);
        const lineHeight = this.getLineHeight(height2, important);
        if (!fontSize || !lineHeight) {
          return null;
        }
        Object.assign(properties, fontSize, lineHeight);
      } else {
        const fontStyle = this.getFontStyle(part, important);
        const fontVariant = this.getFontVariant(part, important);
        const fontWeight = this.getFontWeight(part, important);
        const fontSize = this.getFontSize(part, important);
        const fontStretch = this.getFontStretch(part, important);
        if (fontStyle) {
          Object.assign(properties, fontStyle);
        } else if (fontVariant) {
          Object.assign(properties, fontVariant);
        } else if (fontWeight) {
          Object.assign(properties, fontWeight);
        } else if (fontSize) {
          Object.assign(properties, fontSize);
        } else if (fontStretch) {
          Object.assign(properties, fontStretch);
        } else {
          const fontFamilyValue = parts.slice(i).join(" ");
          const fontFamily = this.getFontFamily(fontFamilyValue, important);
          if (!fontFamily) {
            return null;
          }
          Object.assign(properties, fontFamily);
          break;
        }
      }
    }
    return properties;
  }
  /**
   * Returns font style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FONT_STYLE.includes(lowerValue)) {
      return { "font-style": { value: lowerValue, important } };
    }
    const parts = value2.split(SPLIT_SPACE_SEPARATED_WITH_PARANTHESES_REGEXP);
    if (parts.length === 2 && parts[0] === "oblique") {
      const degree = CSSStyleDeclarationValueParser.getDegree(parts[1]);
      return degree ? { "font-style": { value: lowerValue, important } } : null;
    }
    return null;
  }
  /**
   * Returns font variant.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontVariant(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-variant": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    return CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "normal" || lowerValue === "small-caps" ? { "font-variant": { value: lowerValue, important } } : null;
  }
  /**
   * Returns font strech.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontStretch(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-stretch": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FONT_STRETCH.includes(lowerValue)) {
      return { "font-stretch": { value: lowerValue, important } };
    }
    const percentage = CSSStyleDeclarationValueParser.getPercentage(value2);
    return percentage ? { "font-stretch": { value: percentage, important } } : null;
  }
  /**
   * Returns font weight.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontWeight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-weight": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FONT_WEIGHT.includes(lowerValue)) {
      return { "font-weight": { value: lowerValue, important } };
    }
    const integer = CSSStyleDeclarationValueParser.getInteger(value2);
    return integer ? { "font-weight": { value: integer, important } } : null;
  }
  /**
   * Returns font size.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontSize(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-size": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FONT_SIZE.includes(lowerValue)) {
      return { "font-size": { value: lowerValue, important } };
    }
    const measurement = CSSStyleDeclarationValueParser.getMeasurement(value2);
    return measurement ? { "font-size": { value: measurement, important } } : null;
  }
  /**
   * Returns line height.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getLineHeight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "line-height": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "normal") {
      return { "line-height": { value: lowerValue, important } };
    }
    const lineHeight = CSSStyleDeclarationValueParser.getFloat(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return lineHeight ? { "line-height": { value: lineHeight, important } } : null;
  }
  /**
   * Returns font family.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontFamily(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-family": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return { "font-family": { value: globalValue, important } };
    }
    const parts = value2.split(",");
    let parsedValue = "";
    let endWithApostroph = false;
    for (let i = 0, max = parts.length; i < max; i++) {
      let trimmedPart = parts[i].trim().replace(/'/g, '"');
      if (!trimmedPart) {
        return null;
      }
      if (trimmedPart.includes(" ")) {
        const apostrophCount = (trimmedPart.match(/"/g) || []).length;
        if ((trimmedPart[0] !== '"' || i !== 0) && apostrophCount !== 2 && apostrophCount !== 0) {
          return null;
        }
        if (trimmedPart[0] === '"' && trimmedPart[trimmedPart.length - 1] !== '"') {
          endWithApostroph = true;
        } else if (trimmedPart[0] !== '"' && trimmedPart[trimmedPart.length - 1] !== '"') {
          trimmedPart = `"${trimmedPart}"`;
        }
      } else {
        trimmedPart = trimmedPart.replace(/"/g, "");
      }
      if (i > 0) {
        parsedValue += ", ";
      }
      parsedValue += trimmedPart;
    }
    if (endWithApostroph) {
      parsedValue += '"';
    }
    if (!parsedValue) {
      return null;
    }
    return {
      "font-family": {
        important,
        value: parsedValue
      }
    };
  }
  /**
   * Returns font family.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getTextTransform(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "text-transform": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = CSSStyleDeclarationValueParser.getGlobal(lowerValue) || TEXT_TRANSFORM.includes(lowerValue) && lowerValue;
    if (parsedValue) {
      return {
        "text-transform": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns visibility.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property
   */
  static getVisibility(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { visibility: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = CSSStyleDeclarationValueParser.getGlobal(lowerValue) || VISIBILITY.includes(lowerValue) && lowerValue;
    if (parsedValue) {
      return {
        visibility: { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns aspect ratio.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property
   */
  static getAspectRatio(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "aspect-ratio": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return { "aspect-ratio": { value: lowerValue, important } };
    }
    let parsedValue = value2;
    const hasAuto = parsedValue.includes("auto");
    if (hasAuto) {
      parsedValue = parsedValue.replace("auto", "");
    }
    parsedValue = parsedValue.replace(WHITE_SPACE_GLOBAL_REGEXP, "");
    if (!parsedValue) {
      return { "aspect-ratio": { value: "auto", important } };
    }
    const aspectRatio = parsedValue.split("/");
    if (aspectRatio.length > 3) {
      return null;
    }
    const width2 = Number(aspectRatio[0]);
    const height2 = aspectRatio[1] ? Number(aspectRatio[1]) : 1;
    if (isNaN(width2) || isNaN(height2)) {
      return null;
    }
    if (hasAuto) {
      return { "aspect-ratio": { value: `auto ${width2} / ${height2}`, important } };
    }
    return { "aspect-ratio": { value: `${width2} / ${height2}`, important } };
  }
};

// node_modules/happy-dom/lib/css/declaration/property-manager/CSSStyleDeclarationPropertyGetParser.js
var CSSStyleDeclarationPropertyGetParser = class {
  /**
   * Returns margin.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getMargin(properties) {
    return this.getPaddingLikeProperty(["margin-top", "margin-right", "margin-bottom", "margin-left"], properties);
  }
  /**
   * Returns padding.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getPadding(properties) {
    return this.getPaddingLikeProperty(["padding-top", "padding-right", "padding-bottom", "padding-left"], properties);
  }
  /**
   * Returns outline.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getOutline(properties) {
    if (!properties["outline-color"]?.value || !properties["outline-style"]?.value || !properties["outline-width"]?.value) {
      return null;
    }
    const important = properties["outline-color"].important && properties["outline-style"].important && properties["outline-width"].important;
    if (CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["outline-width"].value) && properties["outline-width"].value === properties["outline-style"].value && properties["outline-width"].value === properties["outline-color"].value) {
      return {
        important,
        value: properties["outline-width"].value
      };
    }
    const values2 = [];
    if (!CSSStyleDeclarationValueParser.getInitial(properties["outline-color"]?.value)) {
      values2.push(properties["outline-color"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["outline-style"]?.value)) {
      values2.push(properties["outline-style"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["outline-width"].value)) {
      values2.push(properties["outline-width"].value);
    }
    return {
      important,
      value: values2.join(" ")
    };
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorder(properties) {
    if (!properties["border-top-width"]?.value || properties["border-top-width"]?.value !== properties["border-right-width"]?.value || properties["border-top-width"]?.value !== properties["border-bottom-width"]?.value || properties["border-top-width"]?.value !== properties["border-left-width"]?.value || !properties["border-top-style"]?.value || properties["border-top-style"]?.value !== properties["border-right-style"]?.value || properties["border-top-style"]?.value !== properties["border-bottom-style"]?.value || properties["border-top-style"]?.value !== properties["border-left-style"]?.value || !properties["border-top-color"]?.value || properties["border-top-color"]?.value !== properties["border-right-color"]?.value || properties["border-top-color"]?.value !== properties["border-bottom-color"]?.value || properties["border-top-color"]?.value !== properties["border-left-color"]?.value || !properties["border-image-source"]?.value || !properties["border-image-slice"]?.value || !properties["border-image-width"]?.value || !properties["border-image-outset"]?.value || !properties["border-image-repeat"]?.value) {
      return null;
    }
    const important = properties["border-top-width"].important && properties["border-right-width"].important && properties["border-bottom-width"].important && properties["border-left-width"].important && properties["border-top-style"].important && properties["border-right-style"].important && properties["border-bottom-style"].important && properties["border-left-style"].important && properties["border-top-color"].important && properties["border-right-color"].important && properties["border-bottom-color"].important && properties["border-left-color"].important && properties["border-image-source"].important && properties["border-image-slice"].important && properties["border-image-width"].important && properties["border-image-outset"].important && properties["border-image-repeat"].important;
    if (CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-top-width"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-top-style"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-top-color"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-source"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-slice"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-width"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-outset"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-repeat"].value)) {
      if (properties["border-top-width"].value !== properties["border-top-style"].value || properties["border-top-width"].value !== properties["border-top-color"].value || properties["border-top-width"].value !== properties["border-image-source"].value || properties["border-top-width"].value !== properties["border-image-slice"].value || properties["border-top-width"].value !== properties["border-image-width"].value || properties["border-top-width"].value !== properties["border-image-outset"].value || properties["border-top-width"].value !== properties["border-image-repeat"].value) {
        return null;
      }
      return {
        important,
        value: properties["border-top-width"].value
      };
    }
    const values2 = [];
    if (!CSSStyleDeclarationValueParser.getInitial(properties["border-top-width"].value)) {
      values2.push(properties["border-top-width"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["border-top-style"].value)) {
      values2.push(properties["border-top-style"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["border-top-color"].value)) {
      values2.push(properties["border-top-color"].value);
    }
    return {
      important,
      value: values2.join(" ")
    };
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderTop(properties) {
    return this.getBorderTopRightBottomLeft("top", properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderRight(properties) {
    return this.getBorderTopRightBottomLeft("right", properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderBottom(properties) {
    return this.getBorderTopRightBottomLeft("bottom", properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderLeft(properties) {
    return this.getBorderTopRightBottomLeft("left", properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderColor(properties) {
    return this.getPaddingLikeProperty(["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"], properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderWidth(properties) {
    return this.getPaddingLikeProperty(["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"], properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderStyle(properties) {
    return this.getPaddingLikeProperty(["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"], properties);
  }
  /**
   * Returns border radius.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderRadius(properties) {
    return this.getPaddingLikeProperty([
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius"
    ], properties);
  }
  /**
   * Returns border image.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderImage(properties) {
    if (!properties["border-image-source"]?.value || !properties["border-image-slice"]?.value || !properties["border-image-width"]?.value || !properties["border-image-outset"]?.value || !properties["border-image-repeat"]?.value) {
      return null;
    }
    const important = properties["border-image-source"].important && properties["border-image-slice"].important && properties["border-image-width"].important && properties["border-image-outset"].important && properties["border-image-repeat"].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties["border-image-source"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["border-image-slice"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["border-image-width"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["border-image-outset"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["border-image-repeat"].value)) {
      if (properties["border-image-source"].value !== properties["border-image-slice"].value || properties["border-image-source"].value !== properties["border-image-width"].value || properties["border-image-source"].value !== properties["border-image-outset"].value || properties["border-image-source"].value !== properties["border-image-repeat"].value) {
        return null;
      }
      return {
        important,
        value: properties["border-image-source"].value
      };
    }
    return {
      important,
      value: `${properties["border-image-source"].value} ${properties["border-image-slice"].value} / ${properties["border-image-width"].value} / ${properties["border-image-outset"].value} ${properties["border-image-repeat"].value}`
    };
  }
  /**
   * Returns background.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBackground(properties) {
    if (!properties["background-image"]?.value || !properties["background-repeat"]?.value || !properties["background-attachment"]?.value || !properties["background-position-x"]?.value || !properties["background-position-y"]?.value || !properties["background-color"]?.value || !properties["background-size"]?.value || !properties["background-origin"]?.value || !properties["background-clip"]?.value) {
      return null;
    }
    const important = properties["background-image"].important && properties["background-repeat"].important && properties["background-attachment"].important && properties["background-position-x"].important && properties["background-position-y"].important && properties["background-color"].important && properties["background-size"].important && properties["background-origin"].important && properties["background-clip"].important;
    if (CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-image"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-repeat"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-attachment"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-position-x"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-position-y"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-color"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-size"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-origin"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-clip"].value)) {
      if (properties["background-image"].value !== properties["background-repeat"].value || properties["background-image"].value !== properties["background-attachment"].value || properties["background-image"].value !== properties["background-position-x"].value || properties["background-image"].value !== properties["background-position-y"].value || properties["background-image"].value !== properties["background-color"].value || properties["background-image"].value !== properties["background-size"].value || properties["background-image"].value !== properties["background-origin"].value || properties["background-image"].value !== properties["background-clip"].value) {
        return null;
      }
      return {
        important,
        value: properties["background-image"].value
      };
    }
    const values2 = [];
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-image"].value)) {
      values2.push(properties["background-image"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-position-x"].value) && !CSSStyleDeclarationValueParser.getInitial(properties["background-position-y"].value) && !CSSStyleDeclarationValueParser.getInitial(properties["background-size"].value)) {
      values2.push(`${properties["background-position-x"].value} ${properties["background-position-y"].value} / ${properties["background-size"].value}`);
    } else if (!CSSStyleDeclarationValueParser.getInitial(properties["background-position-x"].value) && !CSSStyleDeclarationValueParser.getInitial(properties["background-position-y"].value)) {
      values2.push(`${properties["background-position-x"].value} ${properties["background-position-y"].value}`);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-repeat"].value)) {
      values2.push(properties["background-repeat"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-attachment"].value)) {
      values2.push(properties["background-attachment"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-origin"].value)) {
      values2.push(properties["background-origin"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-clip"].value)) {
      values2.push(properties["background-clip"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-color"].value)) {
      values2.push(properties["background-color"].value);
    }
    return {
      important,
      value: values2.join(" ")
    };
  }
  /**
   * Returns background position.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBackgroundPosition(properties) {
    if (!properties["background-position-x"]?.value || !properties["background-position-y"]?.value) {
      return null;
    }
    const important = properties["background-position-x"].important && properties["background-position-y"].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties["background-position-x"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["background-position-y"].value)) {
      if (properties["background-position-x"].value !== properties["background-position-y"].value) {
        return null;
      }
      return {
        important,
        value: properties["background-position-x"].value
      };
    }
    const positionX = properties["background-position-x"].value.replace(/ *, */g, ",").split(",");
    const positionY = properties["background-position-y"].value.replace(/ *, */g, ",").split(",");
    const parts = [];
    for (let i = 0; i < positionX.length; i++) {
      parts.push(`${positionX[i]} ${positionY[i]}`);
    }
    return {
      important,
      value: parts.join(", ")
    };
  }
  /**
   * Returns flex.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getFlex(properties) {
    if (!properties["flex-grow"]?.value || !properties["flex-shrink"]?.value || !properties["flex-basis"]?.value) {
      return null;
    }
    const important = properties["flex-grow"].important && properties["flex-shrink"].important && properties["flex-basis"].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties["flex-grow"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["flex-shrink"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["flex-basis"].value)) {
      if (properties["flex-grow"].value !== properties["flex-shrink"].value || properties["flex-grow"].value !== properties["flex-basis"].value) {
        return null;
      }
      return {
        important,
        value: properties["flex-grow"].value
      };
    }
    return {
      important,
      value: `${properties["flex-grow"].value} ${properties["flex-shrink"].value} ${properties["flex-basis"].value}`
    };
  }
  /**
   * Returns flex.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getFont(properties) {
    if (!properties["font-size"]?.value || !properties["font-family"]?.value || !properties["font-weight"]?.value || !properties["font-style"]?.value || !properties["font-variant"]?.value || !properties["font-stretch"]?.value || !properties["line-height"]?.value) {
      return null;
    }
    const important = properties["font-size"].important && properties["font-family"].important && properties["font-weight"].important && properties["font-style"].important && properties["font-variant"].important && properties["font-stretch"].important && properties["line-height"].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties["font-size"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-family"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-weight"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-style"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-variant"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-stretch"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["line-height"].value)) {
      if (properties["font-size"].value !== properties["font-family"].value || properties["font-size"].value !== properties["font-weight"].value || properties["font-size"].value !== properties["font-style"].value || properties["font-size"].value !== properties["font-variant"].value || properties["font-size"].value !== properties["font-stretch"].value || properties["font-size"].value !== properties["line-height"].value) {
        return null;
      }
      return {
        important,
        value: properties["font-size"].value
      };
    }
    const values2 = [];
    if (properties["font-style"].value !== "normal") {
      values2.push(properties["font-style"].value);
    }
    if (properties["font-variant"].value !== "normal") {
      values2.push(properties["font-variant"].value);
    }
    if (properties["font-weight"].value !== "normal") {
      values2.push(properties["font-weight"].value);
    }
    if (properties["font-stretch"].value !== "normal") {
      values2.push(properties["font-stretch"].value);
    }
    if (properties["line-height"].value !== "normal") {
      values2.push(`${properties["font-size"].value} / ${properties["line-height"].value}`);
    } else {
      values2.push(properties["font-size"].value);
    }
    values2.push(properties["font-family"].value);
    return {
      important,
      value: values2.join(" ")
    };
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @param position
   * @returns Property value
   */
  static getBorderTopRightBottomLeft(position, properties) {
    if (!properties[`border-${position}-width`]?.value || !properties[`border-${position}-style`]?.value || !properties[`border-${position}-color`]?.value) {
      return null;
    }
    const important = properties[`border-${position}-width`].important && properties[`border-${position}-style`].important && properties[`border-${position}-color`].important;
    if (CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties[`border-${position}-width`].value) && properties[`border-${position}-width`].value === properties[`border-${position}-style`].value && properties[`border-${position}-width`].value === properties[`border-${position}-color`].value) {
      return {
        important,
        value: properties[`border-${position}-width`].value
      };
    }
    const values2 = [];
    if (!CSSStyleDeclarationValueParser.getInitial(properties[`border-${position}-width`].value)) {
      values2.push(properties[`border-${position}-width`].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties[`border-${position}-style`]?.value)) {
      values2.push(properties[`border-${position}-style`].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties[`border-${position}-color`]?.value)) {
      values2.push(properties[`border-${position}-color`].value);
    }
    return {
      important,
      value: values2.join(" ")
    };
  }
  /**
   * Returns a padding like property.
   *
   * @param properties Properties.
   * @param position
   * @param propertyNames
   * @returns Property value
   */
  static getPaddingLikeProperty(propertyNames, properties) {
    if (!properties[propertyNames[0]]?.value || !properties[propertyNames[1]]?.value || !properties[propertyNames[2]]?.value || !properties[propertyNames[3]]?.value) {
      return null;
    }
    const important = properties[propertyNames[0]].important && properties[propertyNames[1]].important && properties[propertyNames[2]].important && properties[propertyNames[3]].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties[propertyNames[0]].value) || CSSStyleDeclarationValueParser.getGlobal(properties[propertyNames[1]].value) || CSSStyleDeclarationValueParser.getGlobal(properties[propertyNames[2]].value) || CSSStyleDeclarationValueParser.getGlobal(properties[propertyNames[3]].value)) {
      if (properties[propertyNames[0]].value !== properties[propertyNames[1]].value || properties[propertyNames[0]].value !== properties[propertyNames[2]].value || properties[propertyNames[0]].value !== properties[propertyNames[3]].value) {
        return null;
      }
      return {
        important,
        value: properties[propertyNames[0]].value
      };
    }
    const values2 = [properties[propertyNames[0]].value];
    if (properties[propertyNames[1]].value !== properties[propertyNames[0]].value || properties[propertyNames[2]].value !== properties[propertyNames[0]].value || properties[propertyNames[3]].value !== properties[propertyNames[1]].value) {
      values2.push(properties[propertyNames[1]].value);
    }
    if (properties[propertyNames[2]].value !== properties[propertyNames[0]].value || properties[propertyNames[3]].value !== properties[propertyNames[1]].value) {
      values2.push(properties[propertyNames[2]].value);
    }
    if (properties[propertyNames[3]].value !== properties[propertyNames[1]].value) {
      values2.push(properties[propertyNames[3]].value);
    }
    return {
      important,
      value: values2.join(" ")
    };
  }
};

// node_modules/happy-dom/lib/css/declaration/css-parser/CSSStyleDeclarationCSSParser.js
var SPLIT_RULES_REGEXP = /\s*([^:;]+?)\s*:\s*((?:[^(;]*?(?:\([^)]*\))?)*?)\s*(!important)?\s*(?:$|;)/g;
var CSSStyleDeclarationCSSParser = class {
  /**
   * Class construtor.
   *
   * @param cssText CSS string.
   * @param callback Callback.
   */
  static parse(cssText2) {
    const properties = {};
    const rules = [];
    const regexp = new RegExp(SPLIT_RULES_REGEXP);
    let match;
    while (match = regexp.exec(cssText2)) {
      const name2 = (match[1] ?? "").trim();
      const value2 = (match[2] ?? "").trim();
      const important = match[3] ? true : false;
      if (name2 && value2) {
        if (name2.startsWith("--")) {
          properties[name2] = value2;
        }
        rules.push({ name: name2, value: value2, important });
      }
    }
    return { rules, properties };
  }
};

// node_modules/happy-dom/lib/css/declaration/property-manager/CSSStyleDeclarationPropertyManager.js
var TO_STRING_SHORTHAND_PROPERTIES = [
  ["margin"],
  ["padding"],
  ["border", ["border-width", "border-style", "border-color", "border-image"]],
  ["border-radius"],
  ["background", "background-position"],
  ["font"]
];
var CSSStyleDeclarationPropertyManager = class {
  properties = {};
  definedPropertyNames = {};
  /**
   * Class construtor.
   *
   * @param [options] Options.
   * @param [options.cssText] CSS string.
   */
  constructor(options2) {
    if (options2?.cssText) {
      const { rules } = CSSStyleDeclarationCSSParser.parse(options2.cssText);
      for (const rule of rules) {
        if (rule.important || !this.get(rule.name)?.important) {
          this.set(rule.name, rule.value, rule.important);
        }
      }
    }
  }
  /**
   * Returns property value.
   *
   * @param name Property name.
   * @returns Property value.
   */
  get(name2) {
    if (this.properties[name2]) {
      return this.properties[name2];
    }
    switch (name2) {
      case "margin":
        return CSSStyleDeclarationPropertyGetParser.getMargin(this.properties);
      case "padding":
        return CSSStyleDeclarationPropertyGetParser.getPadding(this.properties);
      case "border":
        return CSSStyleDeclarationPropertyGetParser.getBorder(this.properties);
      case "border-top":
        return CSSStyleDeclarationPropertyGetParser.getBorderTop(this.properties);
      case "border-right":
        return CSSStyleDeclarationPropertyGetParser.getBorderRight(this.properties);
      case "border-bottom":
        return CSSStyleDeclarationPropertyGetParser.getBorderBottom(this.properties);
      case "border-left":
        return CSSStyleDeclarationPropertyGetParser.getBorderLeft(this.properties);
      case "border-color":
        return CSSStyleDeclarationPropertyGetParser.getBorderColor(this.properties);
      case "border-style":
        return CSSStyleDeclarationPropertyGetParser.getBorderStyle(this.properties);
      case "border-width":
        return CSSStyleDeclarationPropertyGetParser.getBorderWidth(this.properties);
      case "border-radius":
        return CSSStyleDeclarationPropertyGetParser.getBorderRadius(this.properties);
      case "border-image":
        return CSSStyleDeclarationPropertyGetParser.getBorderImage(this.properties);
      case "outline":
        return CSSStyleDeclarationPropertyGetParser.getOutline(this.properties);
      case "background":
        return CSSStyleDeclarationPropertyGetParser.getBackground(this.properties);
      case "background-position":
        return CSSStyleDeclarationPropertyGetParser.getBackgroundPosition(this.properties);
      case "flex":
        return CSSStyleDeclarationPropertyGetParser.getFlex(this.properties);
      case "font":
        return CSSStyleDeclarationPropertyGetParser.getFont(this.properties);
    }
    return this.properties[name2] || null;
  }
  /**
   * Removes a property.
   *
   * @param name Property name.
   */
  remove(name2) {
    delete this.properties[name2];
    delete this.definedPropertyNames[name2];
    switch (name2) {
      case "border":
        delete this.properties["border-top-width"];
        delete this.properties["border-right-width"];
        delete this.properties["border-bottom-width"];
        delete this.properties["border-left-width"];
        delete this.properties["border-top-style"];
        delete this.properties["border-right-style"];
        delete this.properties["border-bottom-style"];
        delete this.properties["border-left-style"];
        delete this.properties["border-top-color"];
        delete this.properties["border-right-color"];
        delete this.properties["border-bottom-color"];
        delete this.properties["border-left-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-top":
        delete this.properties["border-top-width"];
        delete this.properties["border-top-style"];
        delete this.properties["border-top-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-right":
        delete this.properties["border-right-width"];
        delete this.properties["border-right-style"];
        delete this.properties["border-right-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-bottom":
        delete this.properties["border-bottom-width"];
        delete this.properties["border-bottom-style"];
        delete this.properties["border-bottom-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-left":
        delete this.properties["border-left-width"];
        delete this.properties["border-left-style"];
        delete this.properties["border-left-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-width":
        delete this.properties["border-top-width"];
        delete this.properties["border-right-width"];
        delete this.properties["border-bottom-width"];
        delete this.properties["border-left-width"];
        break;
      case "border-style":
        delete this.properties["border-top-style"];
        delete this.properties["border-right-style"];
        delete this.properties["border-bottom-style"];
        delete this.properties["border-left-style"];
        break;
      case "border-color":
        delete this.properties["border-top-color"];
        delete this.properties["border-right-color"];
        delete this.properties["border-bottom-color"];
        delete this.properties["border-left-color"];
        break;
      case "border-image":
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-radius":
        delete this.properties["border-top-left-radius"];
        delete this.properties["border-top-right-radius"];
        delete this.properties["border-bottom-right-radius"];
        delete this.properties["border-bottom-left-radius"];
        break;
      case "outline":
        delete this.properties["outline-color"];
        delete this.properties["outline-style"];
        delete this.properties["outline-width"];
        break;
      case "background":
        delete this.properties["background-color"];
        delete this.properties["background-image"];
        delete this.properties["background-repeat"];
        delete this.properties["background-attachment"];
        delete this.properties["background-position-x"];
        delete this.properties["background-position-y"];
        delete this.properties["background-size"];
        delete this.properties["background-origin"];
        delete this.properties["background-clip"];
        break;
      case "background-position":
        delete this.properties["background-position-x"];
        delete this.properties["background-position-y"];
        break;
      case "flex":
        delete this.properties["flex-grow"];
        delete this.properties["flex-shrink"];
        delete this.properties["flex-basis"];
        break;
      case "font":
        delete this.properties["font-style"];
        delete this.properties["font-variant"];
        delete this.properties["font-weight"];
        delete this.properties["font-stretch"];
        delete this.properties["font-size"];
        delete this.properties["line-height"];
        delete this.properties["font-family"];
        break;
      case "padding":
        delete this.properties["padding-top"];
        delete this.properties["padding-right"];
        delete this.properties["padding-bottom"];
        delete this.properties["padding-left"];
        break;
      case "margin":
        delete this.properties["margin-top"];
        delete this.properties["margin-right"];
        delete this.properties["margin-bottom"];
        delete this.properties["margin-left"];
        break;
    }
  }
  /**
   * Sets a property
   *
   * @param name Name.
   * @param value Value.
   * @param important Important.
   */
  set(name2, value2, important) {
    if (value2 === null) {
      this.remove(name2);
      return;
    }
    let properties = null;
    switch (name2) {
      case "border":
        properties = CSSStyleDeclarationPropertySetParser.getBorder(value2, important);
        break;
      case "border-top":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTop(value2, important);
        break;
      case "border-right":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRight(value2, important);
        break;
      case "border-bottom":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottom(value2, important);
        break;
      case "border-left":
        properties = CSSStyleDeclarationPropertySetParser.getBorderLeft(value2, important);
        break;
      case "border-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderWidth(value2, important);
        break;
      case "border-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderStyle(value2, important);
        break;
      case "border-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderColor(value2, important);
        break;
      case "border-image":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImage(value2, important);
        break;
      case "border-image-source":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageSource(value2, important);
        break;
      case "border-image-slice":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageSlice(value2, important);
        break;
      case "border-image-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageWidth(value2, important);
        break;
      case "border-image-outset":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageOutset(value2, important);
        break;
      case "border-image-repeat":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageRepeat(value2, important);
        break;
      case "border-top-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopWidth(value2, important);
        break;
      case "border-right-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRightWidth(value2, important);
        break;
      case "border-bottom-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomWidth(value2, important);
        break;
      case "border-left-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderLeftWidth(value2, important);
        break;
      case "border-top-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopColor(value2, important);
        break;
      case "border-right-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRightColor(value2, important);
        break;
      case "border-bottom-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomColor(value2, important);
        break;
      case "border-left-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderLeftColor(value2, important);
        break;
      case "border-top-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopStyle(value2, important);
        break;
      case "border-right-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRightStyle(value2, important);
        break;
      case "border-bottom-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomStyle(value2, important);
        break;
      case "border-left-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderLeftStyle(value2, important);
        break;
      case "border-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRadius(value2, important);
        break;
      case "border-top-left-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopLeftRadius(value2, important);
        break;
      case "border-top-right-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopRightRadius(value2, important);
        break;
      case "border-bottom-right-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomRightRadius(value2, important);
        break;
      case "border-bottom-left-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomLeftRadius(value2, important);
        break;
      case "border-collapse":
        properties = CSSStyleDeclarationPropertySetParser.getBorderCollapse(value2, important);
        break;
      case "outline":
        properties = CSSStyleDeclarationPropertySetParser.getOutline(value2, important);
        break;
      case "outline-width":
        properties = CSSStyleDeclarationPropertySetParser.getOutlineWidth(value2, important);
        break;
      case "outline-style":
        properties = CSSStyleDeclarationPropertySetParser.getOutlineStyle(value2, important);
        break;
      case "outline-color":
        properties = CSSStyleDeclarationPropertySetParser.getOutlineColor(value2, important);
        break;
      case "letter-spacing":
        properties = CSSStyleDeclarationPropertySetParser.getLetterSpacing(value2, important);
        break;
      case "word-spacing":
        properties = CSSStyleDeclarationPropertySetParser.getWordSpacing(value2, important);
        break;
      case "clear":
        properties = CSSStyleDeclarationPropertySetParser.getClear(value2, important);
        break;
      case "clip":
        properties = CSSStyleDeclarationPropertySetParser.getClip(value2, important);
        break;
      case "css-float":
        properties = CSSStyleDeclarationPropertySetParser.getCSSFloat(value2, important);
        break;
      case "float":
        properties = CSSStyleDeclarationPropertySetParser.getFloat(value2, important);
        break;
      case "display":
        properties = CSSStyleDeclarationPropertySetParser.getDisplay(value2, important);
        break;
      case "direction":
        properties = CSSStyleDeclarationPropertySetParser.getDirection(value2, important);
        break;
      case "flex":
        properties = CSSStyleDeclarationPropertySetParser.getFlex(value2, important);
        break;
      case "flex-shrink":
        properties = CSSStyleDeclarationPropertySetParser.getFlexShrink(value2, important);
        break;
      case "flex-grow":
        properties = CSSStyleDeclarationPropertySetParser.getFlexGrow(value2, important);
        break;
      case "flex-basis":
        properties = CSSStyleDeclarationPropertySetParser.getFlexBasis(value2, important);
        break;
      case "padding":
        properties = CSSStyleDeclarationPropertySetParser.getPadding(value2, important);
        break;
      case "padding-top":
        properties = CSSStyleDeclarationPropertySetParser.getPaddingTop(value2, important);
        break;
      case "padding-right":
        properties = CSSStyleDeclarationPropertySetParser.getPaddingRight(value2, important);
        break;
      case "padding-bottom":
        properties = CSSStyleDeclarationPropertySetParser.getPaddingBottom(value2, important);
        break;
      case "padding-left":
        properties = CSSStyleDeclarationPropertySetParser.getPaddingLeft(value2, important);
        break;
      case "margin":
        properties = CSSStyleDeclarationPropertySetParser.getMargin(value2, important);
        break;
      case "margin-top":
        properties = CSSStyleDeclarationPropertySetParser.getMarginTop(value2, important);
        break;
      case "margin-right":
        properties = CSSStyleDeclarationPropertySetParser.getMarginRight(value2, important);
        break;
      case "margin-bottom":
        properties = CSSStyleDeclarationPropertySetParser.getMarginBottom(value2, important);
        break;
      case "margin-left":
        properties = CSSStyleDeclarationPropertySetParser.getMarginLeft(value2, important);
        break;
      case "background":
        properties = CSSStyleDeclarationPropertySetParser.getBackground(value2, important);
        break;
      case "background-image":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundImage(value2, important);
        break;
      case "background-color":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundColor(value2, important);
        break;
      case "background-repeat":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundRepeat(value2, important);
        break;
      case "background-attachment":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundAttachment(value2, important);
        break;
      case "background-position":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundPosition(value2, important);
        break;
      case "width":
        properties = CSSStyleDeclarationPropertySetParser.getWidth(value2, important);
        break;
      case "height":
        properties = CSSStyleDeclarationPropertySetParser.getHeight(value2, important);
        break;
      case "top":
        properties = CSSStyleDeclarationPropertySetParser.getTop(value2, important);
        break;
      case "right":
        properties = CSSStyleDeclarationPropertySetParser.getRight(value2, important);
        break;
      case "bottom":
        properties = CSSStyleDeclarationPropertySetParser.getBottom(value2, important);
        break;
      case "left":
        properties = CSSStyleDeclarationPropertySetParser.getLeft(value2, important);
        break;
      case "font":
        properties = CSSStyleDeclarationPropertySetParser.getFont(value2, important);
        break;
      case "font-style":
        properties = CSSStyleDeclarationPropertySetParser.getFontStyle(value2, important);
        break;
      case "font-variant":
        properties = CSSStyleDeclarationPropertySetParser.getFontVariant(value2, important);
        break;
      case "font-weight":
        properties = CSSStyleDeclarationPropertySetParser.getFontWeight(value2, important);
        break;
      case "font-stretch":
        properties = CSSStyleDeclarationPropertySetParser.getFontStretch(value2, important);
        break;
      case "font-size":
        properties = CSSStyleDeclarationPropertySetParser.getFontSize(value2, important);
        break;
      case "line-height":
        properties = CSSStyleDeclarationPropertySetParser.getLineHeight(value2, important);
        break;
      case "text-indent":
        properties = CSSStyleDeclarationPropertySetParser.getTextIndent(value2, important);
        break;
      case "font-family":
        properties = CSSStyleDeclarationPropertySetParser.getFontFamily(value2, important);
        break;
      case "color":
        properties = CSSStyleDeclarationPropertySetParser.getColor(value2, important);
        break;
      case "flood-color":
        properties = CSSStyleDeclarationPropertySetParser.getFloodColor(value2, important);
        break;
      case "text-transform":
        properties = CSSStyleDeclarationPropertySetParser.getTextTransform(value2, important);
        break;
      case "visibility":
        properties = CSSStyleDeclarationPropertySetParser.getVisibility(value2, important);
        break;
      case "aspect-ratio":
        properties = CSSStyleDeclarationPropertySetParser.getAspectRatio(value2, important);
        break;
      default:
        const trimmedValue = value2.trim();
        if (trimmedValue) {
          const globalValue = CSSStyleDeclarationValueParser.getGlobal(trimmedValue);
          properties = {
            [name2]: { value: globalValue || trimmedValue, important }
          };
        }
        break;
    }
    if (properties !== null && Object.keys(properties).length > 0) {
      this.definedPropertyNames[name2] = true;
      Object.assign(this.properties, properties);
    }
  }
  /**
   * Returns a clone.
   *
   * @returns Clone.
   */
  clone() {
    const _class = this.constructor;
    const clone2 = new _class();
    clone2.properties = JSON.parse(JSON.stringify(this.properties));
    clone2.definedPropertyNames = Object.assign({}, this.definedPropertyNames);
    return clone2;
  }
  /**
   * Returns size.
   *
   * @returns Size.
   */
  size() {
    return Object.keys(this.properties).length;
  }
  /**
   * Returns property name.
   *
   * @param index Index.
   * @returns Property name.
   */
  item(index) {
    return Object.keys(this.properties)[index] || "";
  }
  /**
   * Converts properties to string.
   *
   * @returns String.
   */
  toString() {
    const result2 = [];
    const clone2 = this.clone();
    const properties = {};
    for (const shorthandPropertyGroup of TO_STRING_SHORTHAND_PROPERTIES) {
      for (const shorthandProperty of shorthandPropertyGroup) {
        if (Array.isArray(shorthandProperty)) {
          let isMatch = false;
          for (const childShorthandProperty of shorthandProperty) {
            const property = clone2.get(childShorthandProperty);
            if (property) {
              properties[childShorthandProperty] = property;
              clone2.remove(childShorthandProperty);
              isMatch = true;
            }
          }
          if (isMatch) {
            break;
          }
        } else {
          const property = clone2.get(shorthandProperty);
          if (property) {
            properties[shorthandProperty] = property;
            clone2.remove(shorthandProperty);
            break;
          }
        }
      }
    }
    for (const name2 of Object.keys(clone2.properties)) {
      properties[name2] = clone2.get(name2);
    }
    for (const definedPropertyName of Object.keys(this.definedPropertyNames)) {
      const property = properties[definedPropertyName];
      if (property) {
        result2.push(`${definedPropertyName}: ${property.value}${property.important ? " !important" : ""};`);
        delete properties[definedPropertyName];
      }
    }
    for (const propertyName of Object.keys(properties)) {
      const property = properties[propertyName];
      if (property) {
        result2.push(`${propertyName}: ${property.value}${property.important ? " !important" : ""};`);
      }
    }
    return result2.join(" ");
  }
};

// node_modules/happy-dom/lib/css/declaration/computed-style/config/CSSStyleDeclarationElementDefaultCSS.js
var CSSStyleDeclarationElementDefaultCSS_default = {
  default: "display: inline;",
  A: "",
  ABBR: "",
  ADDRESS: "display: block;",
  AREA: "",
  ARTICLE: "display: block;",
  ASIDE: "display: block;",
  AUDIO: "display: none;",
  B: "",
  BASE: "display: none;",
  BDI: "",
  BDO: "",
  BLOCKQUAOTE: "",
  BODY: "display: block;",
  TEMPLATE: "display: none;",
  FORM: "display: block;",
  INPUT: "display: inline-block;",
  TEXTAREA: "display: inline-block;",
  SCRIPT: "display: none;",
  IMG: "",
  LINK: "display: none;",
  STYLE: "display: none;",
  LABEL: "",
  SLOT: "display: contents;",
  SVG: "",
  CIRCLE: "",
  ELLIPSE: "",
  LINE: "",
  PATH: "",
  POLYGON: "",
  POLYLINE: "",
  RECT: "",
  STOP: "",
  USE: "",
  META: "display: none;",
  BLOCKQUOTE: "display: block;",
  BR: "",
  BUTTON: "display: inline-block;",
  CANVAS: "",
  CAPTION: "display: table-caption;",
  CITE: "",
  CODE: "",
  COL: "display: table-column;",
  COLGROUP: "display: table-column-group;",
  DATA: "",
  DATALIST: "display: none;",
  DD: "display: block;",
  DEL: "",
  DETAILS: "display: block;",
  DFN: "",
  DIALOG: {
    default: "display: none;",
    open: "display: block;"
  },
  DIV: "display: block;",
  DL: "display: block;",
  DT: "display: block;",
  EM: "",
  EMBED: "",
  FIELDSET: "display: block;",
  FIGCAPTION: "display: block;",
  FIGURE: "display: block;",
  FOOTER: "display: block;",
  H1: "display: block;",
  H2: "display: block;",
  H3: "display: block;",
  H4: "display: block;",
  H5: "display: block;",
  H6: "display: block;",
  HEAD: "display: none;",
  HEADER: "display: block;",
  HGROUP: "display: block;",
  HR: "display: block;",
  HTML: 'display: block;direction: ltr;font: 16px "Times New Roman";',
  I: "",
  IFRAME: "",
  INS: "",
  KBD: "",
  LEGEND: "display: block;",
  LI: "display: list-item;",
  MAIN: "display: block;",
  MAP: "",
  MARK: "",
  MATH: "",
  MENU: "display: block;",
  MENUITEM: "",
  METER: "display: inline-block;",
  NAV: "display: block;",
  NOSCRIPT: "",
  OBJECT: "",
  OL: "display: block;",
  OPTGROUP: "display: block;",
  OPTION: "display: block;",
  OUTPUT: "unicode-bidi: isolate;",
  P: "display: block;",
  PARAM: "display: none;",
  PICTURE: "",
  PRE: "display: block;",
  PROGRESS: "display: inline-block;",
  Q: "",
  RB: "",
  RP: "display: none;",
  RT: "",
  RTC: "",
  RUBY: "",
  S: "",
  SAMP: "",
  SECTION: "display: block;",
  SELECT: "display: inline-block;",
  SMALL: "",
  SOURCE: "",
  SPAN: "",
  STRONG: "",
  SUB: "",
  SUMMARY: "display: block;",
  SUP: "",
  TABLE: "display: table;",
  TBODY: "display: table-row-group;",
  TD: "display: table-cell;",
  TFOOT: "display: table-footer-group;",
  TH: "display: table-cell;",
  THEAD: "display: table-header-group;",
  TIME: "",
  TITLE: "display: none;",
  TR: "display: table-row;",
  TRACK: "",
  U: "",
  UL: "display: block;",
  VAR: "",
  VIDEO: "",
  WBR: ""
};

// node_modules/happy-dom/lib/css/declaration/computed-style/config/CSSStyleDeclarationElementInheritedProperties.js
var CSSStyleDeclarationElementInheritedProperties_default = {
  "border-collapse": true,
  "border-spacing": true,
  "caption-side": true,
  color: true,
  cursor: true,
  direction: true,
  "empty-cells": true,
  "font-family": true,
  "font-size": true,
  "font-style": true,
  "font-variant": true,
  "font-weight": true,
  "font-size-adjust": true,
  "font-stretch": true,
  font: true,
  "letter-spacing": true,
  "line-height": true,
  "list-style-image": true,
  "list-style-position": true,
  "list-style-type": true,
  "list-style": true,
  orphans: true,
  quotes: true,
  "tab-size": true,
  "text-align": true,
  "text-align-last": true,
  "text-decoration-color": true,
  "text-indent": true,
  "text-justify": true,
  "text-shadow": true,
  "text-transform": true,
  visibility: true,
  "white-space": true,
  widows: true,
  "word-break": true,
  "word-spacing": true,
  "word-wrap": true
};

// node_modules/happy-dom/lib/css/declaration/computed-style/config/CSSStyleDeclarationElementMeasurementProperties.js
var CSSStyleDeclarationElementMeasurementProperties_default = [
  "background-position-x",
  "background-position-y",
  "background-size",
  "border-image-outset",
  "border-top-width",
  "border-right-width",
  "border-bottom-width",
  "border-left-width",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-bottom-right-radius",
  "border-bottom-left-radius",
  "border-image-width",
  "clip",
  "font-size",
  "padding-top",
  "padding-right",
  "padding-bottom",
  "padding-left",
  "margin-top",
  "margin-right",
  "margin-bottom",
  "margin-left",
  "width",
  "height",
  "min-width",
  "min-height",
  "max-width",
  "max-height",
  "top",
  "right",
  "bottom",
  "left",
  "outline-width",
  "outline-offset",
  "letter-spacing",
  "word-spacing",
  "text-indent",
  "line-height"
];

// node_modules/happy-dom/lib/utilities/ClassMethodBinder.js
var ClassMethodBinder = class {
  target;
  classes;
  cache = /* @__PURE__ */ new Map();
  /**
   * Constructor.
   *
   * @param target Target.
   * @param classes Classes.
   */
  constructor(target2, classes) {
    this.target = target2;
    this.classes = classes;
  }
  /**
   * Binds method, getters and setters to a target.
   *
   * @param name Method name.
   */
  bind(name2) {
    if (this.cache.has(name2) || name2 === Symbol.iterator || name2 === "constructor") {
      return;
    }
    this.cache.set(name2, true);
    const target2 = this.target;
    if (!(name2 in target2)) {
      return;
    }
    for (const _class of this.classes) {
      const descriptor = Object.getOwnPropertyDescriptor(_class.prototype, name2);
      if (descriptor) {
        if (typeof descriptor.value === "function") {
          if (descriptor.value.toString().startsWith("class ")) {
            return;
          }
          Object.defineProperty(target2, name2, {
            ...descriptor,
            value: descriptor.value.bind(target2)
          });
        } else if (descriptor.get !== void 0) {
          Object.defineProperty(target2, name2, {
            ...descriptor,
            get: descriptor.get?.bind(target2),
            set: descriptor.set?.bind(target2)
          });
        }
        return;
      }
    }
  }
  /**
   * Prevents a method, getter or setter from being bound.
   *
   * @param name Method name.
   */
  preventBinding(name2) {
    this.cache.set(name2, true);
  }
};

// node_modules/happy-dom/lib/nodes/node/NodeList.js
var NodeList = class _NodeList {
  [items];
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param items Items.
   */
  constructor(illegalConstructorSymbol, items2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[items] = items2;
    const methodBinder = new ClassMethodBinder(this, this.constructor !== _NodeList ? [this.constructor, _NodeList] : [_NodeList]);
    const proxy2 = new Proxy(this, {
      get: (target2, property) => {
        if (property === "length") {
          return items2.length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        if (property === "") {
          return void 0;
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return items2[index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys() {
        return Object.keys(items2);
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        return !isNaN(index) && index >= 0 && index < items2.length;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        if (!isNaN(index) && items2[index]) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
    return proxy2;
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[items].length;
  }
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [Symbol.toStringTag]() {
    return "NodeList";
  }
  /**
   * Returns `[object NodeList]`.
   *
   * @returns `[object NodeList]`.
   */
  toLocaleString() {
    return "[object NodeList]";
  }
  /**
   * Returns `[object NodeList]`.
   *
   * @returns `[object NodeList]`.
   */
  toString() {
    return "[object NodeList]";
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    const nodes = this[items];
    return index >= 0 && nodes[index] ? nodes[index] : null;
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  [Symbol.iterator]() {
    const items2 = this[items];
    return items2[Symbol.iterator]();
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  values() {
    return this[items].values();
  }
  /**
   * Returns an iterator, allowing you to go through all key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  entries() {
    return this[items].entries();
  }
  /**
   * Executes a provided callback function once for each DOMTokenList element.
   *
   * @param callback Function.
   * @param thisArg thisArg.
   */
  forEach(callback, thisArg) {
    return this[items].forEach(callback, thisArg);
  }
  /**
   * Returns an iterator, allowing you to go through all keys of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  keys() {
    return this[items].keys();
  }
};
var NodeList_default = NodeList;

// node_modules/happy-dom/lib/query-selector/SelectorCombinatorEnum.js
var SelectorCombinatorEnum;
(function(SelectorCombinatorEnum2) {
  SelectorCombinatorEnum2["descendant"] = "descendant";
  SelectorCombinatorEnum2["child"] = "child";
  SelectorCombinatorEnum2["adjacentSibling"] = "adjacentSibling";
  SelectorCombinatorEnum2["subsequentSibling"] = "subsequentSibling";
})(SelectorCombinatorEnum || (SelectorCombinatorEnum = {}));
var SelectorCombinatorEnum_default = SelectorCombinatorEnum;

// node_modules/happy-dom/lib/query-selector/SelectorItem.js
var SPACE_REGEXP = /\s+/;
var SelectorItem = class {
  tagName;
  id;
  classNames;
  attributes;
  pseudos;
  isPseudoElement;
  combinator;
  ignoreErrors;
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.combinator] Combinator.
   * @param [options.tagName] Tag name.
   * @param [options.id] ID.
   * @param [options.classNames] Class names.
   * @param [options.attributes] Attributes.
   * @param [options.pseudos] Pseudos.
   * @param [options.isPseudoElement] Is pseudo element.
   * @param [options.ignoreErrors] Ignore errors.
   */
  constructor(options2) {
    this.tagName = options2?.tagName || null;
    this.id = options2?.id || null;
    this.classNames = options2?.classNames || null;
    this.attributes = options2?.attributes || null;
    this.pseudos = options2?.pseudos || null;
    this.isPseudoElement = options2?.isPseudoElement || false;
    this.combinator = options2?.combinator || SelectorCombinatorEnum_default.descendant;
    this.ignoreErrors = options2?.ignoreErrors || false;
  }
  /**
   * Matches a selector against an element.
   *
   * @param element HTML element.
   * @returns Result.
   */
  match(element) {
    let priorityWeight = 0;
    if (this.isPseudoElement) {
      return null;
    }
    if (this.tagName) {
      if (this.tagName !== "*" && this.tagName !== element[tagName].toUpperCase()) {
        return null;
      }
      priorityWeight += 1;
    }
    if (this.id) {
      if (this.id !== element.id) {
        return null;
      }
      priorityWeight += 100;
    }
    if (this.classNames) {
      const result2 = this.matchClass(element);
      if (!result2) {
        return null;
      }
      priorityWeight += result2.priorityWeight;
    }
    if (this.attributes) {
      const result2 = this.matchAttributes(element);
      if (!result2) {
        return null;
      }
      priorityWeight += result2.priorityWeight;
    }
    if (this.pseudos) {
      const result2 = this.matchPseudo(element);
      if (!result2) {
        return null;
      }
      priorityWeight += result2.priorityWeight;
    }
    return { priorityWeight };
  }
  /**
   * Matches a pseudo selector.
   *
   * @param element Element.
   * @returns Result.
   */
  matchPseudo(element) {
    const parent2 = element[parentNode];
    const parentChildren = element[parentNode] ? element[parentNode][elementArray] : [];
    if (!this.pseudos) {
      return { priorityWeight: 0 };
    }
    let priorityWeight = 0;
    for (const pseudo of this.pseudos) {
      switch (pseudo.name) {
        case "not":
        case "nth-child":
        case "nth-of-type":
        case "nth-last-child":
        case "nth-last-of-type":
        case "is":
        case "where":
          if (!pseudo.arguments) {
            if (this.ignoreErrors) {
              return null;
            }
            throw new DOMException(`Failed to execute 'matches' on '${element.constructor.name}': '${this.getSelectorString()}' is not a valid selector.`);
          }
          break;
      }
      if (!parent2) {
        switch (pseudo.name) {
          case "first-child":
          case "last-child":
          case "only-child":
          case "first-of-type":
          case "last-of-type":
          case "only-of-type":
          case "nth-child":
          case "nth-of-type":
          case "nth-last-child":
          case "nth-last-of-type":
            return null;
        }
      }
      const selectorMatch = this.matchPseudoItem(element, parentChildren, pseudo);
      if (!selectorMatch) {
        return null;
      }
      priorityWeight += selectorMatch.priorityWeight;
    }
    return { priorityWeight };
  }
  /**
   * Matches a pseudo selector.
   *
   * @param element Element.
   * @param parentChildren Parent children.
   * @param pseudo Pseudo.
   */
  matchPseudoItem(element, parentChildren, pseudo) {
    switch (pseudo.name) {
      case "first-child":
        return parentChildren[0] === element ? { priorityWeight: 10 } : null;
      case "last-child":
        return parentChildren.length && parentChildren[parentChildren.length - 1] === element ? { priorityWeight: 10 } : null;
      case "only-child":
        return parentChildren.length === 1 && parentChildren[0] === element ? { priorityWeight: 10 } : null;
      case "first-of-type":
        for (const child of parentChildren) {
          if (child[tagName] === element[tagName]) {
            return child === element ? { priorityWeight: 10 } : null;
          }
        }
        return null;
      case "last-of-type":
        for (let i = parentChildren.length - 1; i >= 0; i--) {
          const child = parentChildren[i];
          if (child[tagName] === element[tagName]) {
            return child === element ? { priorityWeight: 10 } : null;
          }
        }
        return null;
      case "only-of-type":
        let isFound = false;
        for (const child of parentChildren) {
          if (child[tagName] === element[tagName]) {
            if (isFound || child !== element) {
              return null;
            }
            isFound = true;
          }
        }
        return isFound ? { priorityWeight: 10 } : null;
      case "checked":
        return element[tagName] === "INPUT" && element.checked ? { priorityWeight: 10 } : null;
      case "disabled":
        return "disabled" in element && element.hasAttribute("disabled") ? { priorityWeight: 10 } : null;
      case "empty":
        return !element[elementArray].length ? { priorityWeight: 10 } : null;
      case "root":
        return element[tagName] === "HTML" ? { priorityWeight: 10 } : null;
      case "not":
        for (const selectorItem of pseudo.selectorItems) {
          if (selectorItem.match(element)) {
            return null;
          }
        }
        return { priorityWeight: 10 };
      case "nth-child":
        let nthChildIndex = -1;
        if (pseudo.selectorItems[0] && !pseudo.selectorItems[0].match(element)) {
          return null;
        }
        for (let i = 0, max = parentChildren.length; i < max; i++) {
          if (!pseudo.selectorItems[0] || pseudo.selectorItems[0].match(parentChildren[i])) {
            nthChildIndex++;
          }
          if (parentChildren[i] === element) {
            return nthChildIndex !== -1 && pseudo.nthFunction(nthChildIndex + 1) ? { priorityWeight: 10 } : null;
          }
        }
        return null;
      case "nth-of-type":
        let nthOfTypeIndex = -1;
        for (let i = 0, max = parentChildren.length; i < max; i++) {
          if (parentChildren[i][tagName] === element[tagName]) {
            nthOfTypeIndex++;
          }
          if (parentChildren[i] === element) {
            return nthOfTypeIndex !== -1 && pseudo.nthFunction(nthOfTypeIndex + 1) ? { priorityWeight: 10 } : null;
          }
        }
        return null;
      case "nth-last-child":
        let nthLastChildIndex = -1;
        if (pseudo.selectorItems[0] && !pseudo.selectorItems[0].match(element)) {
          return null;
        }
        for (let i = parentChildren.length - 1; i >= 0; i--) {
          if (!pseudo.selectorItems[0] || pseudo.selectorItems[0].match(parentChildren[i])) {
            nthLastChildIndex++;
          }
          if (parentChildren[i] === element) {
            return nthLastChildIndex !== -1 && pseudo.nthFunction(nthLastChildIndex + 1) ? { priorityWeight: 10 } : null;
          }
        }
        return null;
      case "nth-last-of-type":
        let nthLastOfTypeIndex = -1;
        for (let i = parentChildren.length - 1; i >= 0; i--) {
          if (parentChildren[i][tagName] === element[tagName]) {
            nthLastOfTypeIndex++;
          }
          if (parentChildren[i] === element) {
            return nthLastOfTypeIndex !== -1 && pseudo.nthFunction(nthLastOfTypeIndex + 1) ? { priorityWeight: 10 } : null;
          }
        }
        return null;
      case "target":
        const hash = element[ownerDocument].location.hash;
        if (!hash) {
          return null;
        }
        return element.isConnected && element.id === hash.slice(1) ? { priorityWeight: 10 } : null;
      case "is":
        let priorityWeightForIs = 0;
        for (const selectorItem of pseudo.selectorItems) {
          const match = selectorItem.match(element);
          if (match && priorityWeightForIs < match.priorityWeight) {
            priorityWeightForIs = match.priorityWeight;
          }
        }
        return priorityWeightForIs ? { priorityWeight: priorityWeightForIs } : null;
      case "where":
        for (const selectorItem of pseudo.selectorItems) {
          if (selectorItem.match(element)) {
            return { priorityWeight: 0 };
          }
        }
        return null;
      case "has":
        let priorityWeightForHas = 0;
        if (pseudo.arguments[0] === "+") {
          const nextSibling = element.nextElementSibling;
          if (!nextSibling) {
            return null;
          }
          for (const selectorItem of pseudo.selectorItems) {
            const match = selectorItem.match(nextSibling);
            if (match && priorityWeightForHas < match.priorityWeight) {
              priorityWeightForHas = match.priorityWeight;
            }
          }
        } else if (pseudo.arguments[0] === ">") {
          for (const selectorItem of pseudo.selectorItems) {
            for (const child of element[elementArray]) {
              const match = selectorItem.match(child);
              if (match && priorityWeightForHas < match.priorityWeight) {
                priorityWeightForHas = match.priorityWeight;
                break;
              }
            }
          }
        } else {
          for (const selectorItem of pseudo.selectorItems) {
            const match = this.matchChildOfElement(selectorItem, element);
            if (match && priorityWeightForHas < match.priorityWeight) {
              priorityWeightForHas = match.priorityWeight;
            }
          }
        }
        return priorityWeightForHas ? { priorityWeight: priorityWeightForHas } : null;
      case "focus":
      case "focus-visible":
        return element[ownerDocument].activeElement === element ? { priorityWeight: 10 } : null;
      default:
        return null;
    }
  }
  /**
   * Matches attribute.
   *
   * @param element Element.
   * @returns Result.
   */
  matchAttributes(element) {
    if (!this.attributes) {
      return null;
    }
    let priorityWeight = 0;
    for (const attribute of this.attributes) {
      const elementAttribute = element[attributes].getNamedItem(attribute.name);
      if (!elementAttribute) {
        return null;
      }
      priorityWeight += 10;
      if (attribute.value !== null && (elementAttribute[value] === null || attribute.regExp && !attribute.regExp.test(elementAttribute[value]) || !attribute.regExp && attribute.value !== elementAttribute[value])) {
        return null;
      }
    }
    return { priorityWeight };
  }
  /**
   * Matches class.
   *
   * @param element Element.
   * @returns Result.
   */
  matchClass(element) {
    if (!this.classNames) {
      return null;
    }
    const classList2 = element.className.split(SPACE_REGEXP);
    let priorityWeight = 0;
    for (const className of this.classNames) {
      if (!classList2.includes(className)) {
        return null;
      }
      priorityWeight += 10;
    }
    return { priorityWeight };
  }
  /**
   * Matches a selector item against children of an element.
   *
   * @param selectorItem Selector item.
   * @param element Element.
   * @returns Result.
   */
  matchChildOfElement(selectorItem, element) {
    for (const child of element[elementArray]) {
      const match = selectorItem.match(child);
      if (match) {
        return match;
      }
      const childMatch = this.matchChildOfElement(selectorItem, child);
      if (childMatch) {
        return childMatch;
      }
    }
  }
  /**
   * Returns the selector string.
   *
   * @returns Selector string.
   */
  getSelectorString() {
    return `${this.tagName ? this.tagName.toLowerCase() : ""}${this.id ? `#${this.id}` : ""}${this.classNames ? `.${this.classNames.join(".")}` : ""}${this.attributes ? this.attributes.map((attribute) => `[${attribute.name}${attribute.value ? `${attribute.operator || ""}="${attribute.value}"` : ""}]`).join("") : ""}${this.pseudos ? this.pseudos.map((pseudo) => `:${pseudo.name}${pseudo.arguments ? `(${pseudo.arguments})` : ""}`).join("") : ""}`;
  }
};

// node_modules/happy-dom/lib/query-selector/SelectorParser.js
var SELECTOR_REGEXP = /(\*)|([a-zA-Z0-9-]+)|#((?:[a-zA-Z0-9-_]|\\.)+)|\.((?:[a-zA-Z0-9-_]|\\.)+)|\[([a-zA-Z0-9-_\\:]+)\]|\[([a-zA-Z0-9-_\\:]+)\s*([~|^$*]{0,1})\s*=\s*["']{1}([^"']*)["']{1}\s*(s|i){0,1}\]|\[([a-zA-Z0-9-_]+)\s*([~|^$*]{0,1})\s*=\s*([^\]]*)\]|:([a-zA-Z-]+)\s*\(((?:[^()]|\[[^\]]*\]|\([^()]*\))*)\){0,1}|:([a-zA-Z-]+)|::([a-zA-Z-]+)|([\s,+>~]*)/gm;
var ESCAPED_CHARACTER_REGEXP = /\\/g;
var ATTRIBUTE_ESCAPE_REGEXP = /[.*+?^${}()|[\]\\]/g;
var NTH_FUNCTION = {
  odd: (n) => (n + 1) % 2 === 0,
  even: (n) => (n + 1) % 2 !== 0,
  alwaysFalse: () => false
};
var SPACE_REGEXP2 = / /g;
var SIMPLE_SELECTOR_REGEXP = /(^[a-zA-Z0-9-]+$)|(^\.[a-zA-Z0-9-_.]+$)|(^#[a-zA-Z0-9-_]+$)/;
var SelectorParser = class {
  /**
   * Parses a selector string and returns an instance of SelectorItem.
   *
   * @param selector Selector.
   * @param [options] Options.
   * @param [options.ignoreErrors] Ignores errors.
   * @returns Selector item.
   */
  static getSelectorItem(selector, options2) {
    return this.getSelectorGroups(selector, options2)[0][0];
  }
  /**
   * Parses a selector string and returns groups with SelectorItem instances.
   *
   * @param selector Selector.
   * @param [options] Options.
   * @param [options.ignoreErrors] Ignores errors.
   * @returns Selector groups.
   */
  static getSelectorGroups(selector, options2) {
    selector = selector.trim();
    const ignoreErrors = options2?.ignoreErrors;
    if (selector === "*") {
      return [[new SelectorItem({ tagName: "*", ignoreErrors })]];
    }
    const simpleMatch = selector.match(SIMPLE_SELECTOR_REGEXP);
    if (simpleMatch) {
      if (simpleMatch[1]) {
        return [[new SelectorItem({ tagName: selector.toUpperCase(), ignoreErrors })]];
      } else if (simpleMatch[2]) {
        return [
          [new SelectorItem({ classNames: selector.replace(".", "").split("."), ignoreErrors })]
        ];
      } else if (simpleMatch[3]) {
        return [[new SelectorItem({ id: selector.replace("#", ""), ignoreErrors })]];
      }
    }
    const regexp = new RegExp(SELECTOR_REGEXP);
    let currentSelectorItem = new SelectorItem({
      combinator: SelectorCombinatorEnum_default.descendant,
      ignoreErrors
    });
    let currentGroup = [currentSelectorItem];
    const groups = [currentGroup];
    let isValid = false;
    let match;
    while (match = regexp.exec(selector)) {
      if (match[0]) {
        isValid = true;
        if (match[1]) {
          currentSelectorItem.tagName = "*";
        } else if (match[2]) {
          currentSelectorItem.tagName = match[2].toUpperCase();
        } else if (match[3]) {
          currentSelectorItem.id = match[3].replace(ESCAPED_CHARACTER_REGEXP, "");
        } else if (match[4]) {
          currentSelectorItem.classNames = currentSelectorItem.classNames || [];
          currentSelectorItem.classNames.push(match[4].replace(ESCAPED_CHARACTER_REGEXP, ""));
        } else if (match[5]) {
          currentSelectorItem.attributes = currentSelectorItem.attributes || [];
          currentSelectorItem.attributes.push({
            name: match[5].toLowerCase(),
            operator: null,
            value: null,
            modifier: null,
            regExp: null
          });
        } else if (match[6] && match[8] !== void 0) {
          currentSelectorItem.attributes = currentSelectorItem.attributes || [];
          currentSelectorItem.attributes.push({
            name: match[6].toLowerCase(),
            operator: match[7] || null,
            value: match[8].replace(ESCAPED_CHARACTER_REGEXP, ""),
            modifier: match[9] || null,
            regExp: this.getAttributeRegExp({
              operator: match[7],
              value: match[8],
              modifier: match[9]
            })
          });
        } else if (match[10] && match[12] !== void 0) {
          currentSelectorItem.attributes = currentSelectorItem.attributes || [];
          currentSelectorItem.attributes.push({
            name: match[10].toLowerCase(),
            operator: match[11] || null,
            value: match[12].replace(ESCAPED_CHARACTER_REGEXP, ""),
            modifier: null,
            regExp: this.getAttributeRegExp({ operator: match[11], value: match[12] })
          });
        } else if (match[13] && match[14]) {
          currentSelectorItem.pseudos = currentSelectorItem.pseudos || [];
          currentSelectorItem.pseudos.push(this.getPseudo(match[13], match[14], options2));
        } else if (match[15]) {
          currentSelectorItem.pseudos = currentSelectorItem.pseudos || [];
          currentSelectorItem.pseudos.push(this.getPseudo(match[15], null, options2));
        } else if (match[16]) {
          currentSelectorItem.isPseudoElement = true;
        } else if (match[17]) {
          switch (match[17].trim()) {
            case ",":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum_default.descendant,
                ignoreErrors
              });
              currentGroup = [currentSelectorItem];
              groups.push(currentGroup);
              break;
            case ">":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum_default.child,
                ignoreErrors
              });
              currentGroup.push(currentSelectorItem);
              break;
            case "+":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum_default.adjacentSibling,
                ignoreErrors
              });
              currentGroup.push(currentSelectorItem);
              break;
            case "~":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum_default.subsequentSibling,
                ignoreErrors
              });
              currentGroup.push(currentSelectorItem);
              break;
            case "":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum_default.descendant,
                ignoreErrors
              });
              currentGroup.push(currentSelectorItem);
              break;
          }
        }
      } else {
        break;
      }
    }
    if (!isValid) {
      if (options2?.ignoreErrors) {
        return [];
      }
      throw new DOMException(`Invalid selector: "${selector}"`);
    }
    return groups;
  }
  /**
   * Returns attribute RegExp.
   *
   * @param attribute Attribute.
   * @param attribute.value Attribute value.
   * @param attribute.operator Attribute operator.
   * @param attribute.modifier Attribute modifier.
   * @returns Attribute RegExp.
   */
  static getAttributeRegExp(attribute) {
    const modifier = attribute.modifier === "i" ? "i" : "";
    if (!attribute.operator || !attribute.value) {
      return null;
    }
    const escapedValue = attribute.value.replace(ATTRIBUTE_ESCAPE_REGEXP, "\\$&");
    switch (attribute.operator) {
      // [attribute~="value"] - Contains a specified word.
      case "~":
        return new RegExp(`[- ]${escapedValue}|${escapedValue}[- ]|^${escapedValue}$`, modifier);
      // [attribute|="value"] - Starts with the specified word.
      case "|":
        return new RegExp(`^${escapedValue}[- ]|^${escapedValue}$`, modifier);
      // [attribute^="value"] - Begins with a specified value.
      case "^":
        return new RegExp(`^${escapedValue}`, modifier);
      // [attribute$="value"] - Ends with a specified value.
      case "$":
        return new RegExp(`${escapedValue}$`, modifier);
      // [attribute*="value"] - Contains a specified value.
      case "*":
        return new RegExp(`${escapedValue}`, modifier);
      default:
        return null;
    }
  }
  /**
   * Returns pseudo.
   *
   * @param name Pseudo name.
   * @param args Pseudo arguments.
   * @param [options] Options.
   * @param [options.ignoreErrors] Ignores errors.
   * @returns Pseudo.
   */
  static getPseudo(name2, args, options2) {
    const lowerName = name2.toLowerCase();
    if (args) {
      args = args.trim();
    }
    if (!args) {
      return { name: lowerName, arguments: null, selectorItems: null, nthFunction: null };
    }
    switch (lowerName) {
      case "nth-last-child":
      case "nth-child":
        const nthOfIndex = args.indexOf(" of ");
        const nthFunction = nthOfIndex !== -1 ? args.substring(0, nthOfIndex) : args;
        const selectorItem = nthOfIndex !== -1 ? this.getSelectorItem(args.substring(nthOfIndex + 4).trim(), options2) : null;
        return {
          name: lowerName,
          arguments: args,
          selectorItems: [selectorItem],
          nthFunction: this.getPseudoNthFunction(nthFunction)
        };
      case "nth-of-type":
      case "nth-last-of-type":
        return {
          name: lowerName,
          arguments: args,
          selectorItems: null,
          nthFunction: this.getPseudoNthFunction(args)
        };
      case "not":
        const notSelectorItems = [];
        for (const group of this.getSelectorGroups(args, options2)) {
          notSelectorItems.push(group[0]);
        }
        return {
          name: lowerName,
          arguments: args,
          selectorItems: notSelectorItems,
          nthFunction: null
        };
      case "is":
      case "where":
        const selectorItems = [];
        for (const group of this.getSelectorGroups(args, options2)) {
          selectorItems.push(group[0]);
        }
        return {
          name: lowerName,
          arguments: args,
          selectorItems,
          nthFunction: null
        };
      case "has":
        const hasSelectorItems = [];
        if (!args.includes(":has(")) {
          let newArgs = args;
          if (args[0] === "+") {
            newArgs = args.replace("+", "");
          } else if (args[0] === ">") {
            newArgs = args.replace(">", "");
          }
          for (const group of this.getSelectorGroups(newArgs, options2)) {
            hasSelectorItems.push(group[0]);
          }
        }
        return {
          name: lowerName,
          arguments: args,
          selectorItems: hasSelectorItems,
          nthFunction: null
        };
      default:
        return { name: lowerName, arguments: args, selectorItems: null, nthFunction: null };
    }
  }
  /**
   * Returns pseudo nth function.
   *
   * Based on:
   * https://github.com/dperini/nwsapi/blob/master/src/nwsapi.js
   *
   * @param args Pseudo arguments.
   * @returns Pseudo nth function.
   */
  static getPseudoNthFunction(args) {
    if (args === "odd") {
      return NTH_FUNCTION.odd;
    } else if (args === "even") {
      return NTH_FUNCTION.even;
    }
    const parts = args.replace(SPACE_REGEXP2, "").split("n");
    let partA = parseInt(parts[0], 10) || 0;
    if (parts[0] == "-") {
      partA = -1;
    }
    if (parts.length === 1) {
      return (n) => n == partA;
    }
    let partB = parseInt(parts[1], 10) || 0;
    if (parts[0] == "+") {
      partB = 1;
    }
    if (partA >= 1 || partA <= -1) {
      if (partA >= 1) {
        if (Math.abs(partA) === 1) {
          return (n) => n > partB - 1;
        }
        return (n) => n > partB - 1 && (n + -1 * partB) % partA === 0;
      }
      if (Math.abs(partA) === 1) {
        return (n) => n < partB + 1;
      }
      return (n) => n < partB + 1 && (n + -1 * partB) % partA === 0;
    }
    if (parts[0]) {
      return (n) => n === partB;
    }
    return (n) => n > partB - 1;
  }
};

// node_modules/happy-dom/lib/query-selector/QuerySelector.js
var INVALID_SELECTOR_REGEXP = /^[.#\[]?\d|[.#]$/;
var QuerySelector = class {
  /**
   * Finds elements based on a query selector.
   *
   * @param node Node to search in.
   * @param selector Selector.
   * @returns HTML elements.
   */
  static querySelectorAll(node, selector) {
    const window2 = node[window];
    if (selector === "") {
      throw new window2.DOMException(`Failed to execute 'querySelectorAll' on '${node.constructor.name}': The provided selector is empty.`);
    }
    if (typeof selector === "function") {
      throw new window2.DOMException(`Failed to execute 'querySelectorAll' on '${node.constructor.name}': '${selector}' is not a valid selector.`);
    }
    if (typeof selector === "symbol") {
      throw new window2.TypeError(`Failed to execute 'querySelectorAll' on '${node.constructor.name}': Cannot convert a Symbol value to a string`);
    }
    selector = String(selector);
    if (INVALID_SELECTOR_REGEXP.test(selector)) {
      throw new window2.DOMException(`Failed to execute 'querySelectorAll' on '${node.constructor.name}': '${selector}' is not a valid selector.`);
    }
    const cache2 = node[cache].querySelectorAll;
    const cachedResult = cache2.get(selector);
    if (cachedResult?.result) {
      const result2 = cachedResult.result.deref();
      if (result2) {
        return result2;
      }
    }
    const groups = SelectorParser.getSelectorGroups(selector);
    const items2 = [];
    const nodeList = new NodeList_default(illegalConstructor, items2);
    const matchesMap = /* @__PURE__ */ new Map();
    const matchedPositions = [];
    const cachedItem = {
      result: new WeakRef(nodeList)
    };
    node[cache].querySelectorAll.set(selector, cachedItem);
    if (node[isConnected]) {
      (node[ownerDocument] || node)[affectsCache].push(cachedItem);
    }
    for (const items3 of groups) {
      const matches = node[nodeType] === NodeTypeEnum_default.elementNode ? this.findAll(node, [node], items3, cachedItem) : this.findAll(null, node[elementArray], items3, cachedItem);
      for (const match of matches) {
        if (!matchesMap.has(match.documentPosition)) {
          matchesMap.set(match.documentPosition, match.element);
          matchedPositions.push(match.documentPosition);
        }
      }
    }
    const keys = matchedPositions.sort();
    for (let i = 0, max = keys.length; i < max; i++) {
      items2.push(matchesMap.get(keys[i]));
    }
    return nodeList;
  }
  /**
   * Finds an element based on a query selector.
   *
   * @param node Node to search in.
   * @param selector Selector.
   * @returns HTML element.
   */
  static querySelector(node, selector) {
    const window2 = node[window];
    if (selector === "") {
      throw new window2.DOMException(`Failed to execute 'querySelector' on '${node.constructor.name}': The provided selector is empty.`);
    }
    if (typeof selector === "function") {
      throw new window2.DOMException(`Failed to execute 'querySelector' on '${node.constructor.name}': '${selector}' is not a valid selector.`);
    }
    if (typeof selector === "symbol") {
      throw new window2.TypeError(`Failed to execute 'querySelector' on '${node.constructor.name}': Cannot convert a Symbol value to a string`);
    }
    selector = String(selector);
    if (INVALID_SELECTOR_REGEXP.test(selector)) {
      throw new window2.DOMException(`Failed to execute 'querySelector' on '${node.constructor.name}': '${selector}' is not a valid selector.`);
    }
    const cachedResult = node[cache].querySelector.get(selector);
    if (cachedResult?.result) {
      const result2 = cachedResult.result.deref();
      if (result2) {
        return result2;
      }
    }
    const cachedItem = {
      result: {
        deref: () => null
      }
    };
    node[cache].querySelector.set(selector, cachedItem);
    if (node[isConnected]) {
      (node[ownerDocument] || node)[affectsCache].push(cachedItem);
    }
    const matchesMap = /* @__PURE__ */ new Map();
    const matchedPositions = [];
    for (const items2 of SelectorParser.getSelectorGroups(selector)) {
      const match = node[nodeType] === NodeTypeEnum_default.elementNode ? this.findFirst(node, [node], items2, cachedItem) : this.findFirst(null, node[elementArray], items2, cachedItem);
      if (match && !matchesMap.has(match.documentPosition)) {
        matchesMap.set(match.documentPosition, match.element);
        matchedPositions.push(match.documentPosition);
      }
    }
    if (matchedPositions.length > 0) {
      const keys = matchedPositions.sort();
      return matchesMap.get(keys[0]);
    }
    return null;
  }
  /**
   * Checks if an element matches a selector and returns priority weight.
   *
   * @param element Element to match.
   * @param selector Selector to match with.
   * @param [options] Options.
   * @param [options.ignoreErrors] Ignores errors.
   * @returns Result.
   */
  static matches(element, selector, options2) {
    const ignoreErrors = options2?.ignoreErrors;
    const window2 = element[window];
    if (selector === "*") {
      return {
        priorityWeight: 1
      };
    }
    if (selector === "") {
      if (ignoreErrors) {
        return null;
      }
      throw new window2.DOMException(`Failed to execute 'matches' on '${element.constructor.name}': The provided selector is empty.`);
    }
    if (typeof selector === "function") {
      if (ignoreErrors) {
        return null;
      }
      throw new window2.DOMException(`Failed to execute 'matches' on '${element.constructor.name}': '${selector}' is not a valid selector.`);
    }
    if (typeof selector === "symbol") {
      if (ignoreErrors) {
        return null;
      }
      throw new window2.TypeError(`Cannot convert a Symbol value to a string`);
    }
    selector = String(selector);
    if (INVALID_SELECTOR_REGEXP.test(selector)) {
      if (ignoreErrors) {
        return null;
      }
      throw new window2.DOMException(`Failed to execute 'matches' on '${element.constructor.name}': '${selector}' is not a valid selector.`);
    }
    const cachedResult = element[cache].matches.get(selector);
    if (cachedResult?.result) {
      return cachedResult.result.match;
    }
    const cachedItem = {
      result: { match: null }
    };
    element[cache].matches.set(selector, cachedItem);
    if (element[isConnected]) {
      (element[ownerDocument] || element)[affectsCache].push(cachedItem);
    }
    for (const items2 of SelectorParser.getSelectorGroups(selector, options2)) {
      const result2 = this.matchSelector(element, items2.reverse(), cachedItem);
      if (result2) {
        cachedItem.result.match = result2;
        return result2;
      }
    }
    return null;
  }
  /**
   * Checks if a node matches a selector.
   *
   * @param element Target element.
   * @param currentElement
   * @param selectorItems Selector items.
   * @param cachedItem Cached item.
   * @param [previousSelectorItem] Previous selector item.
   * @param [priorityWeight] Priority weight.
   * @returns Result.
   */
  static matchSelector(element, selectorItems, cachedItem, previousSelectorItem = null, priorityWeight = 0) {
    const selectorItem = selectorItems[0];
    const result2 = selectorItem.match(element);
    if (result2) {
      if (selectorItems.length === 1) {
        return {
          priorityWeight: priorityWeight + result2.priorityWeight
        };
      }
      switch (selectorItem.combinator) {
        case SelectorCombinatorEnum_default.adjacentSibling:
          const previousElementSibling = element.previousElementSibling;
          if (previousElementSibling) {
            previousElementSibling[affectsCache].push(cachedItem);
            const match = this.matchSelector(previousElementSibling, selectorItems.slice(1), cachedItem, selectorItem, priorityWeight + result2.priorityWeight);
            if (match) {
              return match;
            }
          }
          break;
        case SelectorCombinatorEnum_default.child:
        case SelectorCombinatorEnum_default.descendant:
          const parentElement = element.parentElement;
          if (parentElement) {
            parentElement[affectsCache].push(cachedItem);
            const match = this.matchSelector(parentElement, selectorItems.slice(1), cachedItem, selectorItem, priorityWeight + result2.priorityWeight);
            if (match) {
              return match;
            }
          }
          break;
        case SelectorCombinatorEnum_default.subsequentSibling:
          const siblingParentElement = element.parentElement;
          if (siblingParentElement) {
            const siblings = siblingParentElement[elementArray];
            const index = siblings.indexOf(element);
            siblingParentElement[affectsCache].push(cachedItem);
            for (let i = index - 1; i >= 0; i--) {
              const sibling = siblings[i];
              sibling[affectsCache].push(cachedItem);
              const match = this.matchSelector(sibling, selectorItems.slice(1), cachedItem, selectorItem, priorityWeight + result2.priorityWeight);
              if (match) {
                return match;
              }
            }
          }
          break;
      }
    }
    if (previousSelectorItem?.combinator === SelectorCombinatorEnum_default.descendant) {
      const parentElement = element.parentElement;
      if (parentElement) {
        return this.matchSelector(parentElement, selectorItems, cachedItem, previousSelectorItem, priorityWeight);
      }
    }
    return null;
  }
  /**
   * Finds elements based on a query selector for a part of a list of selectors separated with comma.
   *
   * @param rootElement Root element.
   * @param children Child elements.
   * @param selectorItems Selector items.
   * @param cachedItem Cached item.
   * @param [documentPosition] Document position of the element.
   * @returns Document position and element map.
   */
  static findAll(rootElement, children2, selectorItems, cachedItem, documentPosition) {
    const selectorItem = selectorItems[0];
    const nextSelectorItem = selectorItems[1];
    let matched = [];
    for (let i = 0, max = children2.length; i < max; i++) {
      const child = children2[i];
      const childrenOfChild = child[elementArray];
      const position = (documentPosition ? documentPosition + ">" : "") + String.fromCharCode(i);
      child[affectsCache].push(cachedItem);
      if (selectorItem.match(child)) {
        if (!nextSelectorItem) {
          if (rootElement !== child) {
            matched.push({
              documentPosition: position,
              element: child
            });
          }
        } else {
          switch (nextSelectorItem.combinator) {
            case SelectorCombinatorEnum_default.adjacentSibling:
              const nextElementSibling = child.nextElementSibling;
              if (nextElementSibling) {
                matched = matched.concat(this.findAll(rootElement, [nextElementSibling], selectorItems.slice(1), cachedItem, position));
              }
              break;
            case SelectorCombinatorEnum_default.descendant:
            case SelectorCombinatorEnum_default.child:
              matched = matched.concat(this.findAll(rootElement, childrenOfChild, selectorItems.slice(1), cachedItem, position));
              break;
            case SelectorCombinatorEnum_default.subsequentSibling:
              const index = children2.indexOf(child);
              for (let j = index + 1; j < children2.length; j++) {
                const sibling = children2[j];
                matched = matched.concat(this.findAll(rootElement, [sibling], selectorItems.slice(1), cachedItem, position));
              }
              break;
          }
        }
      }
      if (selectorItem.combinator === SelectorCombinatorEnum_default.descendant && childrenOfChild.length) {
        matched = matched.concat(this.findAll(rootElement, childrenOfChild, selectorItems, cachedItem, position));
      }
    }
    return matched;
  }
  /**
   * Finds an element based on a query selector for a part of a list of selectors separated with comma.
   *
   * @param rootElement Root element.
   * @param children Child elements.
   * @param selectorItems Selector items.
   * @param cachedItem Cached item.
   * @param [documentPosition] Document position of the element.
   * @returns Document position and element map.
   */
  static findFirst(rootElement, children2, selectorItems, cachedItem, documentPosition) {
    const selectorItem = selectorItems[0];
    const nextSelectorItem = selectorItems[1];
    for (let i = 0, max = children2.length; i < max; i++) {
      const child = children2[i];
      const childrenOfChild = child[elementArray];
      const position = (documentPosition ? documentPosition + ">" : "") + String.fromCharCode(i);
      child[affectsCache].push(cachedItem);
      if (selectorItem.match(child)) {
        if (!nextSelectorItem) {
          if (rootElement !== child) {
            return { documentPosition: position, element: child };
          }
        } else {
          switch (nextSelectorItem.combinator) {
            case SelectorCombinatorEnum_default.adjacentSibling:
              const nextElementSibling = child.nextElementSibling;
              if (nextElementSibling) {
                const match2 = this.findFirst(rootElement, [nextElementSibling], selectorItems.slice(1), cachedItem, position);
                if (match2) {
                  return match2;
                }
              }
              break;
            case SelectorCombinatorEnum_default.descendant:
            case SelectorCombinatorEnum_default.child:
              const match = this.findFirst(rootElement, childrenOfChild, selectorItems.slice(1), cachedItem, position);
              if (match) {
                return match;
              }
              break;
            case SelectorCombinatorEnum_default.subsequentSibling:
              const index = children2.indexOf(child);
              for (let i2 = index + 1; i2 < children2.length; i2++) {
                const sibling = children2[i2];
                const match2 = this.findFirst(rootElement, [sibling], selectorItems.slice(1), cachedItem, position);
                if (match2) {
                  return match2;
                }
              }
              break;
          }
        }
      }
      if (selectorItem.combinator === SelectorCombinatorEnum_default.descendant && childrenOfChild.length) {
        const match = this.findFirst(rootElement, childrenOfChild, selectorItems, cachedItem, position);
        if (match) {
          return match;
        }
      }
    }
    return null;
  }
};

// node_modules/happy-dom/lib/css/declaration/measurement-converter/CSSMeasurementConverter.js
var CSSMeasurementConverter = class {
  /**
   * Returns measurement in pixels.
   *
   * @param options Options.
   * @param options.window Owner window.
   * @param options.value Measurement (e.g. "10px", "10rem" or "10em").
   * @param options.rootFontSize Root font size in pixels.
   * @param options.parentFontSize Parent font size in pixels.
   * @param [options.parentSize] Parent size in pixels.
   * @returns Measurement in pixels.
   */
  static toPixels(options2) {
    const value2 = parseFloat(options2.value);
    const unit = options2.value.replace(value2.toString(), "");
    if (isNaN(value2)) {
      return null;
    }
    switch (unit) {
      case "px":
        return value2;
      case "rem":
        return this.round(value2 * parseFloat(options2.rootFontSize));
      case "em":
        return this.round(value2 * parseFloat(options2.parentFontSize));
      case "vw":
        return this.round(value2 * options2.window.innerWidth / 100);
      case "vh":
        return this.round(value2 * options2.window.innerHeight / 100);
      case "%":
        return options2.parentSize !== void 0 && options2.parentSize !== null ? this.round(value2 * parseFloat(options2.parentSize) / 100) : null;
      case "vmin":
        return this.round(value2 * Math.min(options2.window.innerWidth, options2.window.innerHeight) / 100);
      case "vmax":
        return value2 * Math.max(options2.window.innerWidth, options2.window.innerHeight) / 100;
      case "cm":
        return this.round(value2 * 37.7812);
      case "mm":
        return this.round(value2 * 3.7781);
      case "in":
        return this.round(value2 * 96);
      case "pt":
        return this.round(value2 * 1.3281);
      case "pc":
        return this.round(value2 * 16);
      case "Q":
        return this.round(value2 * 0.945);
      default:
        return null;
    }
  }
  /**
   * Rounds the number with 4 decimals.
   *
   * @param value Value.
   * @returns Rounded value.
   */
  static round(value2) {
    return Math.round(value2 * 1e4) / 1e4;
  }
};

// node_modules/happy-dom/lib/window/WindowBrowserContext.js
var WindowBrowserContext = class {
  static [browserFrames] = /* @__PURE__ */ new Map();
  static [windowInternalId] = 0;
  #window;
  /**
   * Browser window.
   *
   * @param window Window.
   */
  constructor(window2) {
    this.#window = window2;
  }
  /**
   * Returns the browser settings of the window.
   *
   * @returns Browser settings.
   */
  getSettings() {
    return this.getBrowserFrame()?.page?.context?.browser?.settings || null;
  }
  /**
   * Returns the browser.
   *
   * @returns Browser.
   */
  getBrowser() {
    return this.getBrowserFrame()?.page?.context?.browser || null;
  }
  /**
   * Returns the browser page.
   *
   * @returns Browser page.
   */
  getBrowserPage() {
    return this.getBrowserFrame()?.page || null;
  }
  /**
   * Returns the browser context.
   *
   * @returns Browser context.
   */
  getBrowserContext() {
    return this.getBrowserFrame()?.page?.context || null;
  }
  /**
   * Returns the browser frame of the window.
   *
   * @returns Browser frame.
   */
  getBrowserFrame() {
    if (!this.#window) {
      return null;
    }
    return this.constructor[browserFrames].get(this.#window[internalId]) || null;
  }
  /**
   * Returns the async task manager of the window.
   *
   * @returns Async task manager.
   */
  getAsyncTaskManager() {
    return this.getBrowserFrame()?.[asyncTaskManager] || null;
  }
  /**
   * Assigns the window to a browser frame.
   *
   * @param window Window.
   * @param browserFrame Browser frame.
   */
  static setWindowBrowserFrameRelation(window2, browserFrame) {
    const browserFrames2 = this[browserFrames];
    if (window2[internalId] === -1) {
      window2[internalId] = this[windowInternalId];
      this[windowInternalId]++;
    }
    browserFrames2.set(window2[internalId], browserFrame);
  }
  /**
   * Assigns the window to a browser frame.
   *
   * @param window Window.
   * @param browserFrame Browser frame.
   */
  static removeWindowBrowserFrameRelation(window2) {
    this[browserFrames].delete(window2[internalId]);
  }
};

// node_modules/happy-dom/lib/event/EventTarget.js
var EventTarget = class {
  [listeners] = {
    capturing: /* @__PURE__ */ new Map(),
    bubbling: /* @__PURE__ */ new Map()
  };
  [listenerOptions] = {
    capturing: /* @__PURE__ */ new Map(),
    bubbling: /* @__PURE__ */ new Map()
  };
  /**
   * Return a default description for the EventTarget class.
   */
  get [Symbol.toStringTag]() {
    return "EventTarget";
  }
  /**
   * Adds an event listener.
   *
   * @param type Event type.
   * @param listener Listener.
   * @param options An object that specifies characteristics about the event listener.(currently only once)
   * @param options.once
   * @param options.signal An AbortSignal. The listener will be removed when the given AbortSignal object's abort() method is called.
   */
  addEventListener(type2, listener, options2) {
    options2 = typeof options2 === "boolean" ? { capture: options2 } : options2 || {};
    const eventPhase2 = options2.capture ? "capturing" : "bubbling";
    let listeners2 = this[listeners][eventPhase2].get(type2);
    let listenerOptions2 = this[listenerOptions][eventPhase2].get(type2);
    if (!listeners2) {
      listeners2 = [];
      listenerOptions2 = [];
      this[listeners][eventPhase2].set(type2, listeners2);
      this[listenerOptions][eventPhase2].set(type2, listenerOptions2);
    }
    if (listeners2.includes(listener)) {
      return;
    }
    listeners2.push(listener);
    listenerOptions2.push(options2);
    if (options2.signal && !options2.signal.aborted) {
      options2.signal.addEventListener("abort", () => {
        this.removeEventListener(type2, listener);
      });
    }
  }
  /**
   * Adds an event listener.
   *
   * @param type Event type.
   * @param listener Listener.
   */
  removeEventListener(type2, listener) {
    const bubblingListeners = this[listeners].bubbling.get(type2);
    if (bubblingListeners) {
      const index = bubblingListeners.indexOf(listener);
      if (index !== -1) {
        bubblingListeners.splice(index, 1);
        this[listenerOptions].bubbling.get(type2).splice(index, 1);
        return;
      }
    }
    const capturingListeners = this[listeners].capturing.get(type2);
    if (capturingListeners) {
      const index = capturingListeners.indexOf(listener);
      if (index !== -1) {
        capturingListeners.splice(index, 1);
        this[listenerOptions].capturing.get(type2).splice(index, 1);
      }
    }
  }
  /**
   * Dispatches an event.
   *
   * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-flow
   * @see https://www.quirksmode.org/js/events_order.html#link4
   * @param event Event.
   * @returns The return value is false if event is cancelable and at least one of the event handlers which handled this event called Event.preventDefault().
   */
  dispatchEvent(event) {
    if (!event[dispatching] && (event[type] !== "load" || !event[target])) {
      event[dispatching] = true;
      event[target] = this[proxy] || this;
      this.#goThroughDispatchEventPhases(event);
      event[dispatching] = false;
      return !(event[cancelable] && event[defaultPrevented]);
    }
    this.#callDispatchEventListeners(event);
    return !(event[cancelable] && event[defaultPrevented]);
  }
  /**
   * Adds an event listener.
   *
   * TODO:
   * Was used by with IE8- and Opera. React believed Happy DOM was a legacy browser and used them, but that is no longer the case, so we should remove this method after that this is verified.
   *
   * @deprecated
   * @param type Event type.
   * @param listener Listener.
   */
  attachEvent(type2, listener) {
    this.addEventListener(type2.replace("on", ""), listener);
  }
  /**
   * Removes an event listener.
   *
   * TODO:
   * Was used by IE8- and Opera. React believed Happy DOM was a legacy browser and used them, but that is no longer the case, so we should remove this method after that this is verified.
   *
   * @deprecated
   * @param type Event type.
   * @param listener Listener.
   */
  detachEvent(type2, listener) {
    this.removeEventListener(type2.replace("on", ""), listener);
  }
  /**
   * Goes through dispatch event phases.
   *
   * @param event Event.
   */
  #goThroughDispatchEventPhases(event) {
    const composedPath = event.composedPath();
    event[eventPhase] = EventPhaseEnum_default.capturing;
    for (let i = composedPath.length - 1; i >= 0; i--) {
      event[currentTarget] = composedPath[i];
      composedPath[i].dispatchEvent(event);
      if (event[propagationStopped] || event[immediatePropagationStopped]) {
        event[eventPhase] = EventPhaseEnum_default.none;
        event[currentTarget] = null;
        return;
      }
    }
    event[eventPhase] = EventPhaseEnum_default.atTarget;
    event[currentTarget] = this[proxy] || this;
    event[target].dispatchEvent(event);
    event[eventPhase] = EventPhaseEnum_default.bubbling;
    if (event[bubbles] && !event[propagationStopped] && !event[immediatePropagationStopped]) {
      for (let i = 1, max = composedPath.length; i < max; i++) {
        event[currentTarget] = composedPath[i];
        composedPath[i].dispatchEvent(event);
        if (event[propagationStopped] || event[immediatePropagationStopped]) {
          event[eventPhase] = EventPhaseEnum_default.none;
          event[currentTarget] = null;
          return;
        }
      }
    }
    event[eventPhase] = EventPhaseEnum_default.none;
    event[currentTarget] = null;
  }
  /**
   * Handles dispatch event listeners.
   *
   * @param event Event.
   */
  #callDispatchEventListeners(event) {
    const window2 = this[window];
    const browserSettings = window2 ? new WindowBrowserContext(window2).getSettings() : null;
    const eventPhase2 = event.eventPhase === EventPhaseEnum_default.capturing ? "capturing" : "bubbling";
    const listeners2 = this[listeners][eventPhase2].get(event.type)?.slice();
    if (listeners2 && listeners2.length) {
      const listenerOptions2 = this[listenerOptions][eventPhase2].get(event.type)?.slice();
      for (let i = 0, max = listeners2.length; i < max; i++) {
        const listener = listeners2[i];
        const options2 = listenerOptions2[i];
        if (options2?.passive) {
          event[isInPassiveEventListener] = true;
        }
        if (window2 && (this !== window2 || event.type !== "error") && !browserSettings?.disableErrorCapturing && browserSettings?.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch) {
          if (listener.handleEvent) {
            let result2;
            try {
              result2 = listener.handleEvent.call(listener, event);
            } catch (error2) {
              window2[dispatchError](error2);
            }
            if (result2 instanceof Promise) {
              result2.catch((error2) => window2[dispatchError](error2));
            }
          } else {
            let result2;
            try {
              result2 = listener.call(this, event);
            } catch (error2) {
              window2[dispatchError](error2);
            }
            if (result2 instanceof Promise) {
              result2.catch((error2) => window2[dispatchError](error2));
            }
          }
        } else {
          if (listener.handleEvent) {
            listener.handleEvent.call(listener, event);
          } else {
            listener.call(this, event);
          }
        }
        event[isInPassiveEventListener] = false;
        if (options2?.once) {
          listeners2.splice(i, 1);
          listenerOptions2.splice(i, 1);
          this.removeEventListener(event.type, listener);
          i--;
          max--;
        }
        if (event[immediatePropagationStopped]) {
          return;
        }
      }
    }
    if (event.eventPhase !== EventPhaseEnum_default.capturing) {
      const onEventName = "on" + event.type.toLowerCase();
      const eventListener = this[onEventName];
      if (typeof eventListener === "function") {
        if (window2 && (this !== window2 || event.type !== "error") && !browserSettings?.disableErrorCapturing && browserSettings?.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch) {
          let result2;
          try {
            result2 = eventListener(event);
          } catch (error2) {
            window2[dispatchError](error2);
          }
          if (result2 instanceof Promise) {
            result2.catch((error2) => window2[dispatchError](error2));
          }
        } else {
          eventListener(event);
        }
      }
    }
  }
};

// node_modules/happy-dom/lib/event/events/MediaQueryListEvent.js
var MediaQueryListEvent = class extends Event {
  matches;
  media;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.matches = eventInit?.matches ?? false;
    this.media = eventInit?.media ?? "";
  }
};

// node_modules/happy-dom/lib/match-media/MediaQueryTypeEnum.js
var MediaQueryTypeEnum;
(function(MediaQueryTypeEnum2) {
  MediaQueryTypeEnum2["all"] = "all";
  MediaQueryTypeEnum2["print"] = "print";
  MediaQueryTypeEnum2["screen"] = "screen";
})(MediaQueryTypeEnum || (MediaQueryTypeEnum = {}));
var MediaQueryTypeEnum_default = MediaQueryTypeEnum;

// node_modules/happy-dom/lib/match-media/MediaQueryItem.js
var MediaQueryItem = class {
  mediaTypes;
  not;
  rules;
  ranges;
  rootFontSize = null;
  window;
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.window Owner window.
   * @param [options.rootFontSize] Root font size.
   * @param [options.mediaTypes] Media types.
   * @param [options.not] Not.
   * @param [options.rules] Rules.
   * @param [options.ranges] Ranges.
   */
  constructor(options2) {
    this.window = options2.window;
    this.rootFontSize = options2.rootFontSize || null;
    this.mediaTypes = options2.mediaTypes || [];
    this.not = options2.not || false;
    this.rules = options2.rules || [];
    this.ranges = options2.ranges || [];
  }
  /**
   * Returns media string.
   */
  toString() {
    return `${this.not ? "not " : ""}${this.mediaTypes.join(", ")}${(this.not || this.mediaTypes.length > 0) && !!this.ranges.length ? " and " : ""}${this.ranges.map((range) => `(${range.before ? `${range.before.value} ${range.before.operator} ` : ""}${range.type}${range.after ? ` ${range.after.operator} ${range.after.value}` : ""})`).join(" and ")}${(this.not || this.mediaTypes.length > 0) && !!this.rules.length ? " and " : ""}${this.rules.map((rule) => rule.value ? `(${rule.name}: ${rule.value})` : `(${rule.name})`).join(" and ")}`;
  }
  /**
   * Returns "true" if the item matches.
   */
  matches() {
    return this.not ? !this.matchesAll() : this.matchesAll();
  }
  /**
   * Returns "true" if all matches.
   *
   * @returns "true" if all matches.
   */
  matchesAll() {
    if (!!this.mediaTypes.length) {
      let isMediaTypeMatch = false;
      for (const mediaType of this.mediaTypes) {
        if (this.matchesMediaType(mediaType)) {
          isMediaTypeMatch = true;
          break;
        }
      }
      if (!isMediaTypeMatch) {
        return false;
      }
    }
    for (const rule of this.rules) {
      if (!this.matchesRule(rule)) {
        return false;
      }
    }
    for (const range of this.ranges) {
      if (!this.matchesRange(range)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns "true" if the mediaType matches.
   *
   * @param mediaType Media type.
   * @returns "true" if the mediaType matches.
   */
  matchesMediaType(mediaType) {
    if (mediaType === MediaQueryTypeEnum_default.all) {
      return true;
    }
    return mediaType === new WindowBrowserContext(this.window).getSettings()?.device.mediaType;
  }
  /**
   * Returns "true" if the range matches.
   *
   * @param range Range.
   * @returns "true" if the range matches.
   */
  matchesRange(range) {
    const windowSize = range.type === "width" ? this.window.innerWidth : this.window.innerHeight;
    if (range.before) {
      const beforeValue = this.toPixels(range.before.value);
      if (beforeValue === null) {
        return false;
      }
      switch (range.before.operator) {
        case "<":
          if (beforeValue >= windowSize) {
            return false;
          }
          break;
        case "<=":
          if (beforeValue > windowSize) {
            return false;
          }
          break;
        case ">":
          if (beforeValue <= windowSize) {
            return false;
          }
          break;
        case ">=":
          if (beforeValue < windowSize) {
            return false;
          }
          break;
      }
    }
    if (range.after) {
      const afterValue = this.toPixels(range.after.value);
      if (afterValue === null) {
        return false;
      }
      switch (range.after.operator) {
        case "<":
          if (windowSize >= afterValue) {
            return false;
          }
          break;
        case "<=":
          if (windowSize > afterValue) {
            return false;
          }
          break;
        case ">":
          if (windowSize <= afterValue) {
            return false;
          }
          break;
        case ">=":
          if (windowSize < afterValue) {
            return false;
          }
          break;
      }
    }
    return true;
  }
  /**
   * Returns "true" if the rule matches.
   *
   * @param rule Rule.
   * @returns "true" if the rule matches.
   */
  matchesRule(rule) {
    const settings2 = new WindowBrowserContext(this.window).getSettings();
    if (!settings2) {
      return false;
    }
    if (!rule.value) {
      switch (rule.name) {
        case "min-width":
        case "max-width":
        case "min-height":
        case "max-height":
        case "width":
        case "height":
        case "orientation":
        case "prefers-color-scheme":
        case "hover":
        case "any-hover":
        case "any-pointer":
        case "pointer":
        case "display-mode":
        case "min-aspect-ratio":
        case "max-aspect-ratio":
        case "aspect-ratio":
          return true;
        case "prefers-reduced-motion":
          return settings2.device.prefersReducedMotion === "reduce";
        case "forced-colors":
          return settings2.device.forcedColors === "active";
      }
      return false;
    }
    switch (rule.name) {
      case "min-width":
        const minWidth = this.toPixels(rule.value);
        return minWidth !== null && this.window.innerWidth >= minWidth;
      case "max-width":
        const maxWidth = this.toPixels(rule.value);
        return maxWidth !== null && this.window.innerWidth <= maxWidth;
      case "min-height":
        const minHeight = this.toPixels(rule.value);
        return minHeight !== null && this.window.innerHeight >= minHeight;
      case "max-height":
        const maxHeight = this.toPixels(rule.value);
        return maxHeight !== null && this.window.innerHeight <= maxHeight;
      case "width":
        const width2 = this.toPixels(rule.value);
        return width2 !== null && this.window.innerWidth === width2;
      case "height":
        const height2 = this.toPixels(rule.value);
        return height2 !== null && this.window.innerHeight === height2;
      case "orientation":
        return rule.value === "landscape" ? this.window.innerWidth > this.window.innerHeight : this.window.innerWidth < this.window.innerHeight;
      case "prefers-color-scheme":
        return rule.value === settings2.device.prefersColorScheme;
      case "prefers-reduced-motion":
        return rule.value === settings2.device.prefersReducedMotion;
      case "forced-colors":
        return (rule.value === "none" || rule.value === "active") && rule.value === settings2.device.forcedColors;
      case "any-hover":
      case "hover":
        if (rule.value === "none") {
          return this.window.navigator.maxTouchPoints > 0;
        }
        if (rule.value === "hover") {
          return this.window.navigator.maxTouchPoints === 0;
        }
        return false;
      case "any-pointer":
      case "pointer":
        if (rule.value === "none") {
          return false;
        }
        if (rule.value === "coarse") {
          return this.window.navigator.maxTouchPoints > 0;
        }
        if (rule.value === "fine") {
          return this.window.navigator.maxTouchPoints === 0;
        }
        return false;
      case "display-mode":
        return rule.value === "browser";
      case "min-aspect-ratio":
      case "max-aspect-ratio":
      case "aspect-ratio":
        const aspectRatio = rule.value.split("/");
        const aspectRatioWidth = parseInt(aspectRatio[0], 10);
        const aspectRatioHeight = parseInt(aspectRatio[1], 10);
        if (isNaN(aspectRatioWidth) || isNaN(aspectRatioHeight)) {
          return false;
        }
        switch (rule.name) {
          case "min-aspect-ratio":
            return aspectRatioWidth / aspectRatioHeight <= this.window.innerWidth / this.window.innerHeight;
          case "max-aspect-ratio":
            return aspectRatioWidth / aspectRatioHeight >= this.window.innerWidth / this.window.innerHeight;
          case "aspect-ratio":
            return aspectRatioWidth / aspectRatioHeight === this.window.innerWidth / this.window.innerHeight;
        }
    }
    return false;
  }
  /**
   * Convert to pixels.
   *
   * @param value Value.
   * @returns Value in pixels.
   */
  toPixels(value2) {
    if (!new WindowBrowserContext(this.window).getSettings()?.disableComputedStyleRendering && value2.endsWith("em")) {
      this.rootFontSize = this.rootFontSize || parseFloat(this.window.getComputedStyle(this.window.document.documentElement).fontSize);
      return CSSMeasurementConverter.toPixels({
        window: this.window,
        value: value2,
        rootFontSize: this.rootFontSize,
        parentFontSize: this.rootFontSize
      });
    }
    return CSSMeasurementConverter.toPixels({
      window: this.window,
      value: value2,
      rootFontSize: 16,
      parentFontSize: 16
    });
  }
};

// node_modules/happy-dom/lib/match-media/MediaQueryParser.js
var MEDIA_QUERY_REGEXP = /(not|only|all|screen|print)|\(([^\)]+)(\)){0,1}|(,)| +(or|and) +/g;
var IS_RESOLUTION_REGEXP = /[<>]/;
var RESOLUTION_REGEXP = /(?:([0-9]+[a-z]+) *(<|<=|>|=>)){0,1} *(width|height) *(?:(<|<=|>|=>) *([0-9]+[a-z]+)){0,1}/;
var MediaQueryParser = class {
  /**
   * Parses a media query string.
   *
   * @param options Options.
   * @param options.window Owner window.
   * @param options.mediaQuery Media query string.
   * @param [options.rootFontSize] Root font size.
   * @returns Media query items.
   */
  static parse(options2) {
    let currentMediaQueryItem = new MediaQueryItem({
      window: options2.window,
      rootFontSize: options2.rootFontSize
    });
    const mediaQueryItems = [currentMediaQueryItem];
    const regexp = new RegExp(MEDIA_QUERY_REGEXP);
    let match = null;
    while (match = regexp.exec(options2.mediaQuery.toLowerCase())) {
      if (match[4] === "," || match[5] === "or") {
        currentMediaQueryItem = new MediaQueryItem({
          window: options2.window,
          rootFontSize: options2.rootFontSize
        });
        mediaQueryItems.push(currentMediaQueryItem);
      } else if (match[1] === "all" || match[1] === "screen" || match[1] === "print") {
        currentMediaQueryItem.mediaTypes.push(match[1]);
      } else if (match[1] === "not") {
        currentMediaQueryItem.not = true;
      } else if (match[2]) {
        const resolutionMatch = IS_RESOLUTION_REGEXP.test(match[2]) ? match[2].match(RESOLUTION_REGEXP) : null;
        if (resolutionMatch && (resolutionMatch[1] || resolutionMatch[5])) {
          currentMediaQueryItem.ranges.push({
            before: resolutionMatch[1] ? {
              value: resolutionMatch[1],
              operator: resolutionMatch[2]
            } : null,
            type: resolutionMatch[3],
            after: resolutionMatch[5] ? {
              value: resolutionMatch[5],
              operator: resolutionMatch[4]
            } : null
          });
        } else {
          const [name2, value2] = match[2].split(":");
          const trimmedValue = value2 ? value2.trim() : null;
          if (!trimmedValue && !match[3]) {
            return [
              new MediaQueryItem({
                window: options2.window,
                rootFontSize: options2.rootFontSize,
                not: true,
                mediaTypes: [MediaQueryTypeEnum_default.all]
              })
            ];
          }
          currentMediaQueryItem.rules.push({
            name: name2.trim(),
            value: trimmedValue
          });
        }
      }
    }
    return mediaQueryItems;
  }
};

// node_modules/happy-dom/lib/match-media/MediaQueryList.js
var MediaQueryList = class extends EventTarget {
  onchange = null;
  #window;
  #items = null;
  #media;
  #rootFontSize = null;
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.window Owner window.
   * @param options.media Media.
   * @param [options.rootFontSize] Root font size.
   */
  constructor(options2) {
    super();
    this.#window = options2.window;
    this.#media = options2.media;
    this.#rootFontSize = options2.rootFontSize || null;
  }
  /**
   * Returns media.
   *
   * @returns Media.
   */
  get media() {
    this.#items = this.#items || MediaQueryParser.parse({
      window: this.#window,
      mediaQuery: this.#media,
      rootFontSize: this.#rootFontSize
    });
    return this.#items.map((item) => item.toString()).join(", ");
  }
  /**
   * Returns "true" if the document matches.
   *
   * @returns Matches.
   */
  get matches() {
    this.#items = this.#items || MediaQueryParser.parse({
      window: this.#window,
      mediaQuery: this.#media,
      rootFontSize: this.#rootFontSize
    });
    for (const item of this.#items) {
      if (!item.matches()) {
        return false;
      }
    }
    return true;
  }
  /**
   * Adds a listener.
   *
   * @deprecated
   * @param callback Callback.
   */
  addListener(callback) {
    this.addEventListener("change", callback);
  }
  /**
   * Removes listener.
   *
   * @deprecated
   * @param callback Callback.
   */
  removeListener(callback) {
    this.removeEventListener("change", callback);
  }
  /**
   * @override
   */
  addEventListener(type2, listener) {
    super.addEventListener(type2, listener);
    if (type2 === "change") {
      let matchesState = false;
      const resizeListener = () => {
        const matches = this.matches;
        if (matches !== matchesState) {
          matchesState = matches;
          this.dispatchEvent(new MediaQueryListEvent("change", { matches, media: this.media }));
        }
      };
      listener[windowResizeListener] = resizeListener;
      this.#window.addEventListener("resize", resizeListener);
    }
  }
  /**
   * @override
   */
  removeEventListener(type2, listener) {
    super.removeEventListener(type2, listener);
    if (type2 === "change" && listener[windowResizeListener]) {
      this.#window.removeEventListener("resize", listener[windowResizeListener]);
    }
  }
};

// node_modules/happy-dom/lib/css/declaration/computed-style/CSSStyleDeclarationComputedStyle.js
var CSS_MEASUREMENT_REGEXP = /[0-9.]+(px|rem|em|vw|vh|%|vmin|vmax|cm|mm|in|pt|pc|Q)/g;
var CSS_VARIABLE_REGEXP2 = /var\( *(--[^), ]+)\)|var\( *(--[^), ]+), *(.+)\)/;
var CSSStyleDeclarationComputedStyle = class {
  element;
  /**
   * Constructor.
   *
   * @param element Element.
   * @param [computed] Computed.
   */
  constructor(element) {
    this.element = element;
  }
  /**
   * Returns style sheets.
   *
   * @param element Element.
   * @returns Style sheets.
   */
  getComputedStyle() {
    const documentElements = [];
    const parentElements = [];
    let styleAndElement = {
      element: this.element,
      cssTexts: []
    };
    let shadowRootElements = [];
    if (!this.element[isConnected]) {
      return new CSSStyleDeclarationPropertyManager();
    }
    const cacheResult = this.element[cache].computedStyle;
    if (cacheResult?.result) {
      const result2 = cacheResult.result.deref();
      if (result2) {
        return result2;
      }
    }
    while (styleAndElement.element) {
      if (styleAndElement.element[nodeType] === NodeTypeEnum_default.elementNode) {
        const rootNode2 = styleAndElement.element.getRootNode();
        if (rootNode2[nodeType] === NodeTypeEnum_default.documentNode) {
          documentElements.unshift(styleAndElement);
        } else {
          shadowRootElements.unshift(styleAndElement);
        }
        parentElements.unshift(styleAndElement);
      }
      if (styleAndElement.element === this.element[ownerDocument]) {
        const styleSheets = this.element[ownerDocument].querySelectorAll('style,link[rel="stylesheet"]');
        for (const styleSheet of styleSheets) {
          const sheet2 = styleSheet.sheet;
          if (sheet2) {
            this.parseCSSRules({
              elements: documentElements,
              rootElement: documentElements[0].element[tagName] === "HTML" ? documentElements[0] : null,
              cssRules: sheet2.cssRules
            });
          }
        }
        for (const sheet2 of this.element[ownerDocument].adoptedStyleSheets) {
          this.parseCSSRules({
            elements: documentElements,
            rootElement: documentElements[0].element[tagName] === "HTML" ? documentElements[0] : null,
            cssRules: sheet2.cssRules
          });
        }
        styleAndElement = { element: null, cssTexts: [] };
      } else if (styleAndElement.element[nodeType] === NodeTypeEnum_default.documentFragmentNode && styleAndElement.element.host) {
        const shadowRoot2 = styleAndElement.element;
        const styleSheets = shadowRoot2.querySelectorAll('style,link[rel="stylesheet"]');
        styleAndElement = {
          element: shadowRoot2.host,
          cssTexts: []
        };
        for (const styleSheet of styleSheets) {
          const sheet2 = styleSheet.sheet;
          if (sheet2) {
            this.parseCSSRules({
              elements: shadowRootElements,
              cssRules: sheet2.cssRules,
              hostElement: styleAndElement
            });
          }
        }
        for (const sheet2 of shadowRoot2.adoptedStyleSheets) {
          this.parseCSSRules({
            elements: shadowRootElements,
            cssRules: sheet2.cssRules,
            hostElement: styleAndElement
          });
        }
        shadowRootElements = [];
      } else {
        styleAndElement = {
          element: styleAndElement.element[parentNode],
          cssTexts: []
        };
      }
    }
    const targetElement = parentElements[parentElements.length - 1];
    const propertyManager = new CSSStyleDeclarationPropertyManager();
    const cssProperties = {};
    let rootFontSize = 16;
    let parentFontSize = 16;
    for (const parentElement of parentElements) {
      parentElement.cssTexts.sort((a, b) => a.priorityWeight - b.priorityWeight);
      let elementCSSText = "";
      if (CSSStyleDeclarationElementDefaultCSS_default[parentElement.element[tagName]]) {
        if (typeof CSSStyleDeclarationElementDefaultCSS_default[parentElement.element[tagName]] === "string") {
          elementCSSText += CSSStyleDeclarationElementDefaultCSS_default[parentElement.element[tagName]];
        } else {
          for (const key of Object.keys(CSSStyleDeclarationElementDefaultCSS_default[parentElement.element[tagName]])) {
            if (key === "default" || !!parentElement.element[key]) {
              elementCSSText += CSSStyleDeclarationElementDefaultCSS_default[parentElement.element[tagName]][key];
            }
          }
        }
        elementCSSText += CSSStyleDeclarationElementDefaultCSS_default[parentElement.element[tagName]];
      }
      for (const cssText2 of parentElement.cssTexts) {
        elementCSSText += cssText2.cssText;
      }
      const elementStyleAttribute = parentElement.element.getAttribute("style");
      if (elementStyleAttribute) {
        elementCSSText += elementStyleAttribute;
      }
      const rulesAndProperties = CSSStyleDeclarationCSSParser.parse(elementCSSText);
      const rules = rulesAndProperties.rules;
      Object.assign(cssProperties, rulesAndProperties.properties);
      for (const { name: name2, value: value2, important } of rules) {
        if (CSSStyleDeclarationElementInheritedProperties_default[name2] || parentElement === targetElement) {
          const parsedValue = this.parseCSSVariablesInValue(value2.trim(), cssProperties);
          if (parsedValue && (!propertyManager.get(name2)?.important || important)) {
            propertyManager.set(name2, parsedValue, important);
            if (name2 === "font" || name2 === "font-size") {
              const fontSize = propertyManager.properties["font-size"];
              if (fontSize !== null) {
                const parsedValue2 = this.parseMeasurementsInValue({
                  value: fontSize.value,
                  rootFontSize,
                  parentFontSize,
                  parentSize: parentFontSize
                });
                if (parentElement.element[tagName] === "HTML") {
                  rootFontSize = parsedValue2;
                } else if (parentElement !== targetElement) {
                  parentFontSize = parsedValue2;
                }
              }
            }
          }
        }
      }
    }
    for (const name2 of CSSStyleDeclarationElementMeasurementProperties_default) {
      const property = propertyManager.properties[name2];
      if (property) {
        property.value = this.parseMeasurementsInValue({
          value: property.value,
          rootFontSize,
          parentFontSize,
          // TODO: Only "font-size" is supported when using percentage values. Add support for other properties.
          parentSize: name2 === "font-size" ? parentFontSize : null
        });
      }
    }
    const cachedResult = {
      result: new WeakRef(propertyManager)
    };
    this.element[cache].computedStyle = cachedResult;
    this.element[ownerDocument][affectsComputedStyleCache].push(cachedResult);
    return propertyManager;
  }
  /**
   * Applies CSS text to elements.
   *
   * @param options Options.
   * @param options.elements Elements.
   * @param options.cssRules CSS rules.
   * @param options.rootElement Root element.
   * @param [options.hostElement] Host element.
   */
  parseCSSRules(options2) {
    if (!options2.elements.length) {
      return;
    }
    const window2 = this.element[window];
    for (const rule of options2.cssRules) {
      if (rule.type === CSSRuleTypeEnum_default.styleRule) {
        const selectorText = rule.selectorText;
        if (selectorText) {
          if (selectorText.startsWith(":host")) {
            if (options2.hostElement) {
              options2.hostElement.cssTexts.push({
                cssText: rule[cssText],
                priorityWeight: 0
              });
            }
          } else if (selectorText.startsWith(":root")) {
            if (options2.rootElement) {
              options2.rootElement.cssTexts.push({
                cssText: rule[cssText],
                priorityWeight: 0
              });
            }
          } else {
            for (const element of options2.elements) {
              const match = QuerySelector.matches(element.element, selectorText, {
                ignoreErrors: true
              });
              if (match) {
                element.cssTexts.push({
                  cssText: rule[cssText],
                  priorityWeight: match.priorityWeight
                });
              }
            }
          }
        }
      } else if (rule.type === CSSRuleTypeEnum_default.mediaRule && // TODO: We need to send in a predfined root font size as it will otherwise be calculated using Window.getComputedStyle(), which will cause a never ending loop. Is there another solution?
      new MediaQueryList({
        window: window2,
        media: rule.conditionText,
        rootFontSize: this.element[tagName] === "HTML" ? 16 : null
      }).matches) {
        this.parseCSSRules({
          elements: options2.elements,
          cssRules: rule.cssRules,
          hostElement: options2.hostElement
        });
      }
    }
  }
  /**
   * Parses CSS variables in a value.
   *
   * @param value Value.
   * @param cssVariables CSS variables.
   * @returns CSS value.
   */
  parseCSSVariablesInValue(value2, cssVariables) {
    let newValue = value2;
    let match;
    while ((match = newValue.match(CSS_VARIABLE_REGEXP2)) !== null) {
      if (match[2] !== void 0) {
        newValue = newValue.replace(match[0], cssVariables[match[2]] || match[3]);
      } else {
        newValue = newValue.replace(match[0], cssVariables[match[1]] || "");
      }
    }
    return newValue;
  }
  /**
   * Parses measurements in a value.
   *
   * @param options Options.
   * @param options.value Value.
   * @param options.rootFontSize Root font size.
   * @param options.parentFontSize Parent font size.
   * @param [options.parentSize] Parent width.
   * @returns CSS value.
   */
  parseMeasurementsInValue(options2) {
    if (new WindowBrowserContext(this.element[window]).getSettings()?.disableComputedStyleRendering) {
      return options2.value;
    }
    const regexp = new RegExp(CSS_MEASUREMENT_REGEXP);
    let newValue = options2.value;
    let match;
    while ((match = regexp.exec(options2.value)) !== null) {
      if (match[1] !== "px") {
        const valueInPixels = CSSMeasurementConverter.toPixels({
          window: this.element[window],
          value: match[0],
          rootFontSize: options2.rootFontSize,
          parentFontSize: options2.parentFontSize,
          parentSize: options2.parentSize
        });
        if (valueInPixels !== null) {
          newValue = newValue.replace(match[0], valueInPixels + "px");
        }
      }
    }
    return newValue;
  }
};

// node_modules/happy-dom/lib/css/declaration/CSSStyleDeclaration.js
var CSSStyleDeclaration = class {
  // Public properties
  parentRule = null;
  // Internal properties
  [window];
  // Private properties
  #element;
  #computed;
  #cache = {
    attributeValue: null,
    propertyManager: null
  };
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.element] Element.
   * @param [options.computed] Computed.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this.#element = options2?.element;
    this.#computed = options2?.element ? !!options2?.computed : false;
  }
  /**
   * Index properties
   */
  /* eslint-disable jsdoc/require-jsdoc */
  get 0() {
    return this.item(0) || void 0;
  }
  get 1() {
    return this.item(1) || void 0;
  }
  get 2() {
    return this.item(2) || void 0;
  }
  get 3() {
    return this.item(3) || void 0;
  }
  get 4() {
    return this.item(4) || void 0;
  }
  get 5() {
    return this.item(5) || void 0;
  }
  get 6() {
    return this.item(6) || void 0;
  }
  get 7() {
    return this.item(7) || void 0;
  }
  get 8() {
    return this.item(8) || void 0;
  }
  get 9() {
    return this.item(9) || void 0;
  }
  get 10() {
    return this.item(10) || void 0;
  }
  get 11() {
    return this.item(11) || void 0;
  }
  get 12() {
    return this.item(12) || void 0;
  }
  get 13() {
    return this.item(13) || void 0;
  }
  get 14() {
    return this.item(14) || void 0;
  }
  get 15() {
    return this.item(15) || void 0;
  }
  get 16() {
    return this.item(16) || void 0;
  }
  get 17() {
    return this.item(17) || void 0;
  }
  get 18() {
    return this.item(18) || void 0;
  }
  get 19() {
    return this.item(19) || void 0;
  }
  get 20() {
    return this.item(20) || void 0;
  }
  get 21() {
    return this.item(21) || void 0;
  }
  get 22() {
    return this.item(22) || void 0;
  }
  get 23() {
    return this.item(23) || void 0;
  }
  get 24() {
    return this.item(24) || void 0;
  }
  get 25() {
    return this.item(25) || void 0;
  }
  get 26() {
    return this.item(26) || void 0;
  }
  get 27() {
    return this.item(27) || void 0;
  }
  get 28() {
    return this.item(28) || void 0;
  }
  get 29() {
    return this.item(29) || void 0;
  }
  get 30() {
    return this.item(30) || void 0;
  }
  get 31() {
    return this.item(31) || void 0;
  }
  get 32() {
    return this.item(32) || void 0;
  }
  get 33() {
    return this.item(33) || void 0;
  }
  get 34() {
    return this.item(34) || void 0;
  }
  get 35() {
    return this.item(35) || void 0;
  }
  get 36() {
    return this.item(36) || void 0;
  }
  get 37() {
    return this.item(37) || void 0;
  }
  get 38() {
    return this.item(38) || void 0;
  }
  get 39() {
    return this.item(39) || void 0;
  }
  get 40() {
    return this.item(40) || void 0;
  }
  get 41() {
    return this.item(41) || void 0;
  }
  get 42() {
    return this.item(42) || void 0;
  }
  get 43() {
    return this.item(43) || void 0;
  }
  get 44() {
    return this.item(44) || void 0;
  }
  get 45() {
    return this.item(45) || void 0;
  }
  get 46() {
    return this.item(46) || void 0;
  }
  get 47() {
    return this.item(47) || void 0;
  }
  get 48() {
    return this.item(48) || void 0;
  }
  get 49() {
    return this.item(49) || void 0;
  }
  get 50() {
    return this.item(50) || void 0;
  }
  get 51() {
    return this.item(51) || void 0;
  }
  get 52() {
    return this.item(52) || void 0;
  }
  get 53() {
    return this.item(53) || void 0;
  }
  get 54() {
    return this.item(54) || void 0;
  }
  get 55() {
    return this.item(55) || void 0;
  }
  get 56() {
    return this.item(56) || void 0;
  }
  get 57() {
    return this.item(57) || void 0;
  }
  get 58() {
    return this.item(58) || void 0;
  }
  get 59() {
    return this.item(59) || void 0;
  }
  get 60() {
    return this.item(60) || void 0;
  }
  get 61() {
    return this.item(61) || void 0;
  }
  get 62() {
    return this.item(62) || void 0;
  }
  get 63() {
    return this.item(63) || void 0;
  }
  get 64() {
    return this.item(64) || void 0;
  }
  get 65() {
    return this.item(65) || void 0;
  }
  get 66() {
    return this.item(66) || void 0;
  }
  get 67() {
    return this.item(67) || void 0;
  }
  get 68() {
    return this.item(68) || void 0;
  }
  get 69() {
    return this.item(69) || void 0;
  }
  get 70() {
    return this.item(70) || void 0;
  }
  get 71() {
    return this.item(71) || void 0;
  }
  get 72() {
    return this.item(72) || void 0;
  }
  get 73() {
    return this.item(73) || void 0;
  }
  get 74() {
    return this.item(74) || void 0;
  }
  get 75() {
    return this.item(75) || void 0;
  }
  get 76() {
    return this.item(76) || void 0;
  }
  get 77() {
    return this.item(77) || void 0;
  }
  get 78() {
    return this.item(78) || void 0;
  }
  get 79() {
    return this.item(79) || void 0;
  }
  get 80() {
    return this.item(80) || void 0;
  }
  get 81() {
    return this.item(81) || void 0;
  }
  get 82() {
    return this.item(82) || void 0;
  }
  get 83() {
    return this.item(83) || void 0;
  }
  get 84() {
    return this.item(84) || void 0;
  }
  get 85() {
    return this.item(85) || void 0;
  }
  get 86() {
    return this.item(86) || void 0;
  }
  get 87() {
    return this.item(87) || void 0;
  }
  get 88() {
    return this.item(88) || void 0;
  }
  get 89() {
    return this.item(89) || void 0;
  }
  get 90() {
    return this.item(90) || void 0;
  }
  get 91() {
    return this.item(91) || void 0;
  }
  get 92() {
    return this.item(92) || void 0;
  }
  get 93() {
    return this.item(93) || void 0;
  }
  get 94() {
    return this.item(94) || void 0;
  }
  get 95() {
    return this.item(95) || void 0;
  }
  get 96() {
    return this.item(96) || void 0;
  }
  get 97() {
    return this.item(97) || void 0;
  }
  get 98() {
    return this.item(98) || void 0;
  }
  get 99() {
    return this.item(99) || void 0;
  }
  get 100() {
    return this.item(100) || void 0;
  }
  get 101() {
    return this.item(101) || void 0;
  }
  get 102() {
    return this.item(102) || void 0;
  }
  get 103() {
    return this.item(103) || void 0;
  }
  get 104() {
    return this.item(104) || void 0;
  }
  get 105() {
    return this.item(105) || void 0;
  }
  get 106() {
    return this.item(106) || void 0;
  }
  get 107() {
    return this.item(107) || void 0;
  }
  get 108() {
    return this.item(108) || void 0;
  }
  get 109() {
    return this.item(109) || void 0;
  }
  get 110() {
    return this.item(110) || void 0;
  }
  get 111() {
    return this.item(111) || void 0;
  }
  get 112() {
    return this.item(112) || void 0;
  }
  get 113() {
    return this.item(113) || void 0;
  }
  get 114() {
    return this.item(114) || void 0;
  }
  get 115() {
    return this.item(115) || void 0;
  }
  get 116() {
    return this.item(116) || void 0;
  }
  get 117() {
    return this.item(117) || void 0;
  }
  get 118() {
    return this.item(118) || void 0;
  }
  get 119() {
    return this.item(119) || void 0;
  }
  get 120() {
    return this.item(120) || void 0;
  }
  get 121() {
    return this.item(121) || void 0;
  }
  get 122() {
    return this.item(122) || void 0;
  }
  get 123() {
    return this.item(123) || void 0;
  }
  get 124() {
    return this.item(124) || void 0;
  }
  get 125() {
    return this.item(125) || void 0;
  }
  get 126() {
    return this.item(126) || void 0;
  }
  get 127() {
    return this.item(127) || void 0;
  }
  get 128() {
    return this.item(128) || void 0;
  }
  get 129() {
    return this.item(129) || void 0;
  }
  get 130() {
    return this.item(130) || void 0;
  }
  get 131() {
    return this.item(131) || void 0;
  }
  get 132() {
    return this.item(132) || void 0;
  }
  get 133() {
    return this.item(133) || void 0;
  }
  get 134() {
    return this.item(134) || void 0;
  }
  get 135() {
    return this.item(135) || void 0;
  }
  get 136() {
    return this.item(136) || void 0;
  }
  get 137() {
    return this.item(137) || void 0;
  }
  get 138() {
    return this.item(138) || void 0;
  }
  get 139() {
    return this.item(139) || void 0;
  }
  get 140() {
    return this.item(140) || void 0;
  }
  get 141() {
    return this.item(141) || void 0;
  }
  get 142() {
    return this.item(142) || void 0;
  }
  get 143() {
    return this.item(143) || void 0;
  }
  get 144() {
    return this.item(144) || void 0;
  }
  get 145() {
    return this.item(145) || void 0;
  }
  get 146() {
    return this.item(146) || void 0;
  }
  get 147() {
    return this.item(147) || void 0;
  }
  get 148() {
    return this.item(148) || void 0;
  }
  get 149() {
    return this.item(149) || void 0;
  }
  get 150() {
    return this.item(150) || void 0;
  }
  get 151() {
    return this.item(151) || void 0;
  }
  get 152() {
    return this.item(152) || void 0;
  }
  get 153() {
    return this.item(153) || void 0;
  }
  get 154() {
    return this.item(154) || void 0;
  }
  get 155() {
    return this.item(155) || void 0;
  }
  get 156() {
    return this.item(156) || void 0;
  }
  get 157() {
    return this.item(157) || void 0;
  }
  get 158() {
    return this.item(158) || void 0;
  }
  get 159() {
    return this.item(159) || void 0;
  }
  get 160() {
    return this.item(160) || void 0;
  }
  get 161() {
    return this.item(161) || void 0;
  }
  get 162() {
    return this.item(162) || void 0;
  }
  get 163() {
    return this.item(163) || void 0;
  }
  get 164() {
    return this.item(164) || void 0;
  }
  get 165() {
    return this.item(165) || void 0;
  }
  get 166() {
    return this.item(166) || void 0;
  }
  get 167() {
    return this.item(167) || void 0;
  }
  get 168() {
    return this.item(168) || void 0;
  }
  get 169() {
    return this.item(169) || void 0;
  }
  get 170() {
    return this.item(170) || void 0;
  }
  get 171() {
    return this.item(171) || void 0;
  }
  get 172() {
    return this.item(172) || void 0;
  }
  get 173() {
    return this.item(173) || void 0;
  }
  get 174() {
    return this.item(174) || void 0;
  }
  get 175() {
    return this.item(175) || void 0;
  }
  get 176() {
    return this.item(176) || void 0;
  }
  get 177() {
    return this.item(177) || void 0;
  }
  get 178() {
    return this.item(178) || void 0;
  }
  get 179() {
    return this.item(179) || void 0;
  }
  get 180() {
    return this.item(180) || void 0;
  }
  get 181() {
    return this.item(181) || void 0;
  }
  get 182() {
    return this.item(182) || void 0;
  }
  get 183() {
    return this.item(183) || void 0;
  }
  get 184() {
    return this.item(184) || void 0;
  }
  get 185() {
    return this.item(185) || void 0;
  }
  get 186() {
    return this.item(186) || void 0;
  }
  get 187() {
    return this.item(187) || void 0;
  }
  get 188() {
    return this.item(188) || void 0;
  }
  get 189() {
    return this.item(189) || void 0;
  }
  get 190() {
    return this.item(190) || void 0;
  }
  get 191() {
    return this.item(191) || void 0;
  }
  get 192() {
    return this.item(192) || void 0;
  }
  get 193() {
    return this.item(193) || void 0;
  }
  get 194() {
    return this.item(194) || void 0;
  }
  get 195() {
    return this.item(195) || void 0;
  }
  get 196() {
    return this.item(196) || void 0;
  }
  get 197() {
    return this.item(197) || void 0;
  }
  get 198() {
    return this.item(198) || void 0;
  }
  get 199() {
    return this.item(199) || void 0;
  }
  get 200() {
    return this.item(200) || void 0;
  }
  get 201() {
    return this.item(201) || void 0;
  }
  get 202() {
    return this.item(202) || void 0;
  }
  get 203() {
    return this.item(203) || void 0;
  }
  get 204() {
    return this.item(204) || void 0;
  }
  get 205() {
    return this.item(205) || void 0;
  }
  get 206() {
    return this.item(206) || void 0;
  }
  get 207() {
    return this.item(207) || void 0;
  }
  get 208() {
    return this.item(208) || void 0;
  }
  get 209() {
    return this.item(209) || void 0;
  }
  get 210() {
    return this.item(210) || void 0;
  }
  get 211() {
    return this.item(211) || void 0;
  }
  get 212() {
    return this.item(212) || void 0;
  }
  get 213() {
    return this.item(213) || void 0;
  }
  get 214() {
    return this.item(214) || void 0;
  }
  get 215() {
    return this.item(215) || void 0;
  }
  get 216() {
    return this.item(216) || void 0;
  }
  get 217() {
    return this.item(217) || void 0;
  }
  get 218() {
    return this.item(218) || void 0;
  }
  get 219() {
    return this.item(219) || void 0;
  }
  get 220() {
    return this.item(220) || void 0;
  }
  get 221() {
    return this.item(221) || void 0;
  }
  get 222() {
    return this.item(222) || void 0;
  }
  get 223() {
    return this.item(223) || void 0;
  }
  get 224() {
    return this.item(224) || void 0;
  }
  get 225() {
    return this.item(225) || void 0;
  }
  get 226() {
    return this.item(226) || void 0;
  }
  get 227() {
    return this.item(227) || void 0;
  }
  get 228() {
    return this.item(228) || void 0;
  }
  get 229() {
    return this.item(229) || void 0;
  }
  get 230() {
    return this.item(230) || void 0;
  }
  get 231() {
    return this.item(231) || void 0;
  }
  get 232() {
    return this.item(232) || void 0;
  }
  get 233() {
    return this.item(233) || void 0;
  }
  get 234() {
    return this.item(234) || void 0;
  }
  get 235() {
    return this.item(235) || void 0;
  }
  get 236() {
    return this.item(236) || void 0;
  }
  get 237() {
    return this.item(237) || void 0;
  }
  get 238() {
    return this.item(238) || void 0;
  }
  get 239() {
    return this.item(239) || void 0;
  }
  get 240() {
    return this.item(240) || void 0;
  }
  get 241() {
    return this.item(241) || void 0;
  }
  get 242() {
    return this.item(242) || void 0;
  }
  get 243() {
    return this.item(243) || void 0;
  }
  get 244() {
    return this.item(244) || void 0;
  }
  get 245() {
    return this.item(245) || void 0;
  }
  get 246() {
    return this.item(246) || void 0;
  }
  get 247() {
    return this.item(247) || void 0;
  }
  get 248() {
    return this.item(248) || void 0;
  }
  get 249() {
    return this.item(249) || void 0;
  }
  get 250() {
    return this.item(250) || void 0;
  }
  get 251() {
    return this.item(251) || void 0;
  }
  get 252() {
    return this.item(252) || void 0;
  }
  get 253() {
    return this.item(253) || void 0;
  }
  get 254() {
    return this.item(254) || void 0;
  }
  get 255() {
    return this.item(255) || void 0;
  }
  get 256() {
    return this.item(256) || void 0;
  }
  get 257() {
    return this.item(257) || void 0;
  }
  get 258() {
    return this.item(258) || void 0;
  }
  get 259() {
    return this.item(259) || void 0;
  }
  get 260() {
    return this.item(260) || void 0;
  }
  get 261() {
    return this.item(261) || void 0;
  }
  get 262() {
    return this.item(262) || void 0;
  }
  get 263() {
    return this.item(263) || void 0;
  }
  get 264() {
    return this.item(264) || void 0;
  }
  get 265() {
    return this.item(265) || void 0;
  }
  get 266() {
    return this.item(266) || void 0;
  }
  get 267() {
    return this.item(267) || void 0;
  }
  get 268() {
    return this.item(268) || void 0;
  }
  get 269() {
    return this.item(269) || void 0;
  }
  get 270() {
    return this.item(270) || void 0;
  }
  get 271() {
    return this.item(271) || void 0;
  }
  get 272() {
    return this.item(272) || void 0;
  }
  get 273() {
    return this.item(273) || void 0;
  }
  get 274() {
    return this.item(274) || void 0;
  }
  get 275() {
    return this.item(275) || void 0;
  }
  get 276() {
    return this.item(276) || void 0;
  }
  get 277() {
    return this.item(277) || void 0;
  }
  get 278() {
    return this.item(278) || void 0;
  }
  get 279() {
    return this.item(279) || void 0;
  }
  get 280() {
    return this.item(280) || void 0;
  }
  get 281() {
    return this.item(281) || void 0;
  }
  get 282() {
    return this.item(282) || void 0;
  }
  get 283() {
    return this.item(283) || void 0;
  }
  get 284() {
    return this.item(284) || void 0;
  }
  get 285() {
    return this.item(285) || void 0;
  }
  get 286() {
    return this.item(286) || void 0;
  }
  get 287() {
    return this.item(287) || void 0;
  }
  get 288() {
    return this.item(288) || void 0;
  }
  get 289() {
    return this.item(289) || void 0;
  }
  get 290() {
    return this.item(290) || void 0;
  }
  get 291() {
    return this.item(291) || void 0;
  }
  get 292() {
    return this.item(292) || void 0;
  }
  get 293() {
    return this.item(293) || void 0;
  }
  get 294() {
    return this.item(294) || void 0;
  }
  get 295() {
    return this.item(295) || void 0;
  }
  get 296() {
    return this.item(296) || void 0;
  }
  get 297() {
    return this.item(297) || void 0;
  }
  get 298() {
    return this.item(298) || void 0;
  }
  get 299() {
    return this.item(299) || void 0;
  }
  get 300() {
    return this.item(300) || void 0;
  }
  get 301() {
    return this.item(301) || void 0;
  }
  get 302() {
    return this.item(302) || void 0;
  }
  get 303() {
    return this.item(303) || void 0;
  }
  get 304() {
    return this.item(304) || void 0;
  }
  get 305() {
    return this.item(305) || void 0;
  }
  get 306() {
    return this.item(306) || void 0;
  }
  get 307() {
    return this.item(307) || void 0;
  }
  get 308() {
    return this.item(308) || void 0;
  }
  get 309() {
    return this.item(309) || void 0;
  }
  get 310() {
    return this.item(310) || void 0;
  }
  get 311() {
    return this.item(311) || void 0;
  }
  get 312() {
    return this.item(312) || void 0;
  }
  get 313() {
    return this.item(313) || void 0;
  }
  get 314() {
    return this.item(314) || void 0;
  }
  get 315() {
    return this.item(315) || void 0;
  }
  get 316() {
    return this.item(316) || void 0;
  }
  get 317() {
    return this.item(317) || void 0;
  }
  get 318() {
    return this.item(318) || void 0;
  }
  get 319() {
    return this.item(319) || void 0;
  }
  get 320() {
    return this.item(320) || void 0;
  }
  get 321() {
    return this.item(321) || void 0;
  }
  get 322() {
    return this.item(322) || void 0;
  }
  get 323() {
    return this.item(323) || void 0;
  }
  get 324() {
    return this.item(324) || void 0;
  }
  get 325() {
    return this.item(325) || void 0;
  }
  get 326() {
    return this.item(326) || void 0;
  }
  get 327() {
    return this.item(327) || void 0;
  }
  get 328() {
    return this.item(328) || void 0;
  }
  get 329() {
    return this.item(329) || void 0;
  }
  get 330() {
    return this.item(330) || void 0;
  }
  get 331() {
    return this.item(331) || void 0;
  }
  get 332() {
    return this.item(332) || void 0;
  }
  get 333() {
    return this.item(333) || void 0;
  }
  get 334() {
    return this.item(334) || void 0;
  }
  get 335() {
    return this.item(335) || void 0;
  }
  get 336() {
    return this.item(336) || void 0;
  }
  get 337() {
    return this.item(337) || void 0;
  }
  get 338() {
    return this.item(338) || void 0;
  }
  get 339() {
    return this.item(339) || void 0;
  }
  get 340() {
    return this.item(340) || void 0;
  }
  get 341() {
    return this.item(341) || void 0;
  }
  get 342() {
    return this.item(342) || void 0;
  }
  get 343() {
    return this.item(343) || void 0;
  }
  get 344() {
    return this.item(344) || void 0;
  }
  get 345() {
    return this.item(345) || void 0;
  }
  get 346() {
    return this.item(346) || void 0;
  }
  get 347() {
    return this.item(347) || void 0;
  }
  get 348() {
    return this.item(348) || void 0;
  }
  get 349() {
    return this.item(349) || void 0;
  }
  get 350() {
    return this.item(350) || void 0;
  }
  get 351() {
    return this.item(351) || void 0;
  }
  get 352() {
    return this.item(352) || void 0;
  }
  get 353() {
    return this.item(353) || void 0;
  }
  get 354() {
    return this.item(354) || void 0;
  }
  get 355() {
    return this.item(355) || void 0;
  }
  get 356() {
    return this.item(356) || void 0;
  }
  get 357() {
    return this.item(357) || void 0;
  }
  get 358() {
    return this.item(358) || void 0;
  }
  get 359() {
    return this.item(359) || void 0;
  }
  get 360() {
    return this.item(360) || void 0;
  }
  get 361() {
    return this.item(361) || void 0;
  }
  get 362() {
    return this.item(362) || void 0;
  }
  get 363() {
    return this.item(363) || void 0;
  }
  get 364() {
    return this.item(364) || void 0;
  }
  get 365() {
    return this.item(365) || void 0;
  }
  get 366() {
    return this.item(366) || void 0;
  }
  get 367() {
    return this.item(367) || void 0;
  }
  get 368() {
    return this.item(368) || void 0;
  }
  get 369() {
    return this.item(369) || void 0;
  }
  get 370() {
    return this.item(370) || void 0;
  }
  get 371() {
    return this.item(371) || void 0;
  }
  get 372() {
    return this.item(372) || void 0;
  }
  get 373() {
    return this.item(373) || void 0;
  }
  get 374() {
    return this.item(374) || void 0;
  }
  get 375() {
    return this.item(375) || void 0;
  }
  get 376() {
    return this.item(376) || void 0;
  }
  get 377() {
    return this.item(377) || void 0;
  }
  get 378() {
    return this.item(378) || void 0;
  }
  get 379() {
    return this.item(379) || void 0;
  }
  get 380() {
    return this.item(380) || void 0;
  }
  get 381() {
    return this.item(381) || void 0;
  }
  get 382() {
    return this.item(382) || void 0;
  }
  get 383() {
    return this.item(383) || void 0;
  }
  get 384() {
    return this.item(384) || void 0;
  }
  get 385() {
    return this.item(385) || void 0;
  }
  get 386() {
    return this.item(386) || void 0;
  }
  get 387() {
    return this.item(387) || void 0;
  }
  get 388() {
    return this.item(388) || void 0;
  }
  get 389() {
    return this.item(389) || void 0;
  }
  get 390() {
    return this.item(390) || void 0;
  }
  get 391() {
    return this.item(391) || void 0;
  }
  get 392() {
    return this.item(392) || void 0;
  }
  get 393() {
    return this.item(393) || void 0;
  }
  /**
   * CSS properties
   */
  get accentColor() {
    return this.getPropertyValue("accent-color");
  }
  set accentColor(value2) {
    this.setProperty("accent-color", value2);
  }
  get appRegion() {
    return this.getPropertyValue("app-region");
  }
  set appRegion(value2) {
    this.setProperty("app-region", value2);
  }
  get alignContent() {
    return this.getPropertyValue("align-content");
  }
  set alignContent(value2) {
    this.setProperty("align-content", value2);
  }
  get alignItems() {
    return this.getPropertyValue("align-items");
  }
  set alignItems(value2) {
    this.setProperty("align-items", value2);
  }
  get alignSelf() {
    return this.getPropertyValue("align-self");
  }
  set alignSelf(value2) {
    this.setProperty("align-self", value2);
  }
  get alignmentBaseline() {
    return this.getPropertyValue("alignment-baseline");
  }
  set alignmentBaseline(value2) {
    this.setProperty("alignment-baseline", value2);
  }
  get all() {
    return this.getPropertyValue("all");
  }
  set all(value2) {
    this.setProperty("all", value2);
  }
  get animation() {
    return this.getPropertyValue("animation");
  }
  set animation(value2) {
    this.setProperty("animation", value2);
  }
  get animationDelay() {
    return this.getPropertyValue("animation-delay");
  }
  set animationDelay(value2) {
    this.setProperty("animation-delay", value2);
  }
  get animationDirection() {
    return this.getPropertyValue("animation-direction");
  }
  set animationDirection(value2) {
    this.setProperty("animation-direction", value2);
  }
  get animationDuration() {
    return this.getPropertyValue("animation-duration");
  }
  set animationDuration(value2) {
    this.setProperty("animation-duration", value2);
  }
  get animationFillMode() {
    return this.getPropertyValue("animation-fill-mode");
  }
  set animationFillMode(value2) {
    this.setProperty("animation-fill-mode", value2);
  }
  get animationIterationCount() {
    return this.getPropertyValue("animation-iteration-count");
  }
  set animationIterationCount(value2) {
    this.setProperty("animation-iteration-count", value2);
  }
  get animationName() {
    return this.getPropertyValue("animation-name");
  }
  set animationName(value2) {
    this.setProperty("animation-name", value2);
  }
  get animationPlayState() {
    return this.getPropertyValue("animation-play-state");
  }
  set animationPlayState(value2) {
    this.setProperty("animation-play-state", value2);
  }
  get animationTimingFunction() {
    return this.getPropertyValue("animation-timing-function");
  }
  set animationTimingFunction(value2) {
    this.setProperty("animation-timing-function", value2);
  }
  get appearance() {
    return this.getPropertyValue("appearance");
  }
  set appearance(value2) {
    this.setProperty("appearance", value2);
  }
  get backdropFilter() {
    return this.getPropertyValue("backdrop-filter");
  }
  set backdropFilter(value2) {
    this.setProperty("backdrop-filter", value2);
  }
  get backfaceVisibility() {
    return this.getPropertyValue("backface-visibility");
  }
  set backfaceVisibility(value2) {
    this.setProperty("backface-visibility", value2);
  }
  get background() {
    return this.getPropertyValue("background");
  }
  set background(value2) {
    this.setProperty("background", value2);
  }
  get backgroundAttachment() {
    return this.getPropertyValue("background-attachment");
  }
  set backgroundAttachment(value2) {
    this.setProperty("background-attachment", value2);
  }
  get backgroundBlendMode() {
    return this.getPropertyValue("background-blend-mode");
  }
  set backgroundBlendMode(value2) {
    this.setProperty("background-blend-mode", value2);
  }
  get backgroundClip() {
    return this.getPropertyValue("background-clip");
  }
  set backgroundClip(value2) {
    this.setProperty("background-clip", value2);
  }
  get backgroundColor() {
    return this.getPropertyValue("background-color");
  }
  set backgroundColor(value2) {
    this.setProperty("background-color", value2);
  }
  get backgroundImage() {
    return this.getPropertyValue("background-image");
  }
  set backgroundImage(value2) {
    this.setProperty("background-image", value2);
  }
  get backgroundOrigin() {
    return this.getPropertyValue("background-origin");
  }
  set backgroundOrigin(value2) {
    this.setProperty("background-origin", value2);
  }
  get backgroundPosition() {
    return this.getPropertyValue("background-position");
  }
  set backgroundPosition(value2) {
    this.setProperty("background-position", value2);
  }
  get backgroundPositionX() {
    return this.getPropertyValue("background-position-x");
  }
  set backgroundPositionX(value2) {
    this.setProperty("background-position-x", value2);
  }
  get backgroundPositionY() {
    return this.getPropertyValue("background-position-y");
  }
  set backgroundPositionY(value2) {
    this.setProperty("background-position-y", value2);
  }
  get backgroundRepeat() {
    return this.getPropertyValue("background-repeat");
  }
  set backgroundRepeat(value2) {
    this.setProperty("background-repeat", value2);
  }
  get backgroundRepeatX() {
    return this.getPropertyValue("background-repeat-x");
  }
  set backgroundRepeatX(value2) {
    this.setProperty("background-repeat-x", value2);
  }
  get backgroundRepeatY() {
    return this.getPropertyValue("background-repeat-y");
  }
  set backgroundRepeatY(value2) {
    this.setProperty("background-repeat-y", value2);
  }
  get backgroundSize() {
    return this.getPropertyValue("background-size");
  }
  set backgroundSize(value2) {
    this.setProperty("background-size", value2);
  }
  get baselineShift() {
    return this.getPropertyValue("baseline-shift");
  }
  set baselineShift(value2) {
    this.setProperty("baseline-shift", value2);
  }
  get blockSize() {
    return this.getPropertyValue("block-size");
  }
  set blockSize(value2) {
    this.setProperty("block-size", value2);
  }
  get border() {
    return this.getPropertyValue("border");
  }
  set border(value2) {
    this.setProperty("border", value2);
  }
  get borderBlockEnd() {
    return this.getPropertyValue("border-block-end");
  }
  set borderBlockEnd(value2) {
    this.setProperty("border-block-end", value2);
  }
  get borderBlockEndColor() {
    return this.getPropertyValue("border-block-end-color");
  }
  set borderBlockEndColor(value2) {
    this.setProperty("border-block-end-color", value2);
  }
  get borderBlockEndStyle() {
    return this.getPropertyValue("border-block-end-style");
  }
  set borderBlockEndStyle(value2) {
    this.setProperty("border-block-end-style", value2);
  }
  get borderBlockEndWidth() {
    return this.getPropertyValue("border-block-end-width");
  }
  set borderBlockEndWidth(value2) {
    this.setProperty("border-block-end-width", value2);
  }
  get borderBlockStart() {
    return this.getPropertyValue("border-block-start");
  }
  set borderBlockStart(value2) {
    this.setProperty("border-block-start", value2);
  }
  get borderBlockStartColor() {
    return this.getPropertyValue("border-block-start-color");
  }
  set borderBlockStartColor(value2) {
    this.setProperty("border-block-start-color", value2);
  }
  get borderBlockStartStyle() {
    return this.getPropertyValue("border-block-start-style");
  }
  set borderBlockStartStyle(value2) {
    this.setProperty("border-block-start-style", value2);
  }
  get borderBlockStartWidth() {
    return this.getPropertyValue("border-block-start-width");
  }
  set borderBlockStartWidth(value2) {
    this.setProperty("border-block-start-width", value2);
  }
  get borderBottom() {
    return this.getPropertyValue("border-bottom");
  }
  set borderBottom(value2) {
    this.setProperty("border-bottom", value2);
  }
  get borderBottomColor() {
    return this.getPropertyValue("border-bottom-color");
  }
  set borderBottomColor(value2) {
    this.setProperty("border-bottom-color", value2);
  }
  get borderBottomLeftRadius() {
    return this.getPropertyValue("border-bottom-left-radius");
  }
  set borderBottomLeftRadius(value2) {
    this.setProperty("border-bottom-left-radius", value2);
  }
  get borderBottomRightRadius() {
    return this.getPropertyValue("border-bottom-right-radius");
  }
  set borderBottomRightRadius(value2) {
    this.setProperty("border-bottom-right-radius", value2);
  }
  get borderBottomStyle() {
    return this.getPropertyValue("border-bottom-style");
  }
  set borderBottomStyle(value2) {
    this.setProperty("border-bottom-style", value2);
  }
  get borderBottomWidth() {
    return this.getPropertyValue("border-bottom-width");
  }
  set borderBottomWidth(value2) {
    this.setProperty("border-bottom-width", value2);
  }
  get borderCollapse() {
    return this.getPropertyValue("border-collapse");
  }
  set borderCollapse(value2) {
    this.setProperty("border-collapse", value2);
  }
  get borderColor() {
    return this.getPropertyValue("border-color");
  }
  set borderColor(value2) {
    this.setProperty("border-color", value2);
  }
  get borderImage() {
    return this.getPropertyValue("border-image");
  }
  set borderImage(value2) {
    this.setProperty("border-image", value2);
  }
  get borderImageOutset() {
    return this.getPropertyValue("border-image-outset");
  }
  set borderImageOutset(value2) {
    this.setProperty("border-image-outset", value2);
  }
  get borderImageRepeat() {
    return this.getPropertyValue("border-image-repeat");
  }
  set borderImageRepeat(value2) {
    this.setProperty("border-image-repeat", value2);
  }
  get borderImageSlice() {
    return this.getPropertyValue("border-image-slice");
  }
  set borderImageSlice(value2) {
    this.setProperty("border-image-slice", value2);
  }
  get borderImageSource() {
    return this.getPropertyValue("border-image-source");
  }
  set borderImageSource(value2) {
    this.setProperty("border-image-source", value2);
  }
  get borderImageWidth() {
    return this.getPropertyValue("border-image-width");
  }
  set borderImageWidth(value2) {
    this.setProperty("border-image-width", value2);
  }
  get borderInlineEnd() {
    return this.getPropertyValue("border-inline-end");
  }
  set borderInlineEnd(value2) {
    this.setProperty("border-inline-end", value2);
  }
  get borderInlineEndColor() {
    return this.getPropertyValue("border-inline-end-color");
  }
  set borderInlineEndColor(value2) {
    this.setProperty("border-inline-end-color", value2);
  }
  get borderInlineEndStyle() {
    return this.getPropertyValue("border-inline-end-style");
  }
  set borderInlineEndStyle(value2) {
    this.setProperty("border-inline-end-style", value2);
  }
  get borderInlineEndWidth() {
    return this.getPropertyValue("border-inline-end-width");
  }
  set borderInlineEndWidth(value2) {
    this.setProperty("border-inline-end-width", value2);
  }
  get borderInlineStart() {
    return this.getPropertyValue("border-inline-start");
  }
  set borderInlineStart(value2) {
    this.setProperty("border-inline-start", value2);
  }
  get borderInlineStartColor() {
    return this.getPropertyValue("border-inline-start-color");
  }
  set borderInlineStartColor(value2) {
    this.setProperty("border-inline-start-color", value2);
  }
  get borderInlineStartStyle() {
    return this.getPropertyValue("border-inline-start-style");
  }
  set borderInlineStartStyle(value2) {
    this.setProperty("border-inline-start-style", value2);
  }
  get borderInlineStartWidth() {
    return this.getPropertyValue("border-inline-start-width");
  }
  set borderInlineStartWidth(value2) {
    this.setProperty("border-inline-start-width", value2);
  }
  get borderLeft() {
    return this.getPropertyValue("border-left");
  }
  set borderLeft(value2) {
    this.setProperty("border-left", value2);
  }
  get borderLeftColor() {
    return this.getPropertyValue("border-left-color");
  }
  set borderLeftColor(value2) {
    this.setProperty("border-left-color", value2);
  }
  get borderLeftStyle() {
    return this.getPropertyValue("border-left-style");
  }
  set borderLeftStyle(value2) {
    this.setProperty("border-left-style", value2);
  }
  get borderLeftWidth() {
    return this.getPropertyValue("border-left-width");
  }
  set borderLeftWidth(value2) {
    this.setProperty("border-left-width", value2);
  }
  get borderRadius() {
    return this.getPropertyValue("border-radius");
  }
  set borderRadius(value2) {
    this.setProperty("border-radius", value2);
  }
  get borderRight() {
    return this.getPropertyValue("border-right");
  }
  set borderRight(value2) {
    this.setProperty("border-right", value2);
  }
  get borderRightColor() {
    return this.getPropertyValue("border-right-color");
  }
  set borderRightColor(value2) {
    this.setProperty("border-right-color", value2);
  }
  get borderRightStyle() {
    return this.getPropertyValue("border-right-style");
  }
  set borderRightStyle(value2) {
    this.setProperty("border-right-style", value2);
  }
  get borderRightWidth() {
    return this.getPropertyValue("border-right-width");
  }
  set borderRightWidth(value2) {
    this.setProperty("border-right-width", value2);
  }
  get borderSpacing() {
    return this.getPropertyValue("border-spacing");
  }
  set borderSpacing(value2) {
    this.setProperty("border-spacing", value2);
  }
  get borderStyle() {
    return this.getPropertyValue("border-style");
  }
  set borderStyle(value2) {
    this.setProperty("border-style", value2);
  }
  get borderTop() {
    return this.getPropertyValue("border-top");
  }
  set borderTop(value2) {
    this.setProperty("border-top", value2);
  }
  get borderTopColor() {
    return this.getPropertyValue("border-top-color");
  }
  set borderTopColor(value2) {
    this.setProperty("border-top-color", value2);
  }
  get borderTopLeftRadius() {
    return this.getPropertyValue("border-top-left-radius");
  }
  set borderTopLeftRadius(value2) {
    this.setProperty("border-top-left-radius", value2);
  }
  get borderTopRightRadius() {
    return this.getPropertyValue("border-top-right-radius");
  }
  set borderTopRightRadius(value2) {
    this.setProperty("border-top-right-radius", value2);
  }
  get borderTopStyle() {
    return this.getPropertyValue("border-top-style");
  }
  set borderTopStyle(value2) {
    this.setProperty("border-top-style", value2);
  }
  get borderTopWidth() {
    return this.getPropertyValue("border-top-width");
  }
  set borderTopWidth(value2) {
    this.setProperty("border-top-width", value2);
  }
  get borderWidth() {
    return this.getPropertyValue("border-width");
  }
  set borderWidth(value2) {
    this.setProperty("border-width", value2);
  }
  get borderEndEndRadius() {
    return this.getPropertyValue("border-end-end-radius");
  }
  set borderEndEndRadius(value2) {
    this.setProperty("border-end-end-radius", value2);
  }
  get borderEndStartRadius() {
    return this.getPropertyValue("border-end-start-radius");
  }
  set borderEndStartRadius(value2) {
    this.setProperty("border-end-start-radius", value2);
  }
  get borderStartEndRadius() {
    return this.getPropertyValue("border-start-end-radius");
  }
  set borderStartEndRadius(value2) {
    this.setProperty("border-start-end-radius", value2);
  }
  get borderStartStartRadius() {
    return this.getPropertyValue("border-start-start-radius");
  }
  set borderStartStartRadius(value2) {
    this.setProperty("border-start-start-radius", value2);
  }
  get bottom() {
    return this.getPropertyValue("bottom");
  }
  set bottom(value2) {
    this.setProperty("bottom", value2);
  }
  get boxShadow() {
    return this.getPropertyValue("box-shadow");
  }
  set boxShadow(value2) {
    this.setProperty("box-shadow", value2);
  }
  get boxSizing() {
    return this.getPropertyValue("box-sizing");
  }
  set boxSizing(value2) {
    this.setProperty("box-sizing", value2);
  }
  get breakAfter() {
    return this.getPropertyValue("break-after");
  }
  set breakAfter(value2) {
    this.setProperty("break-after", value2);
  }
  get breakBefore() {
    return this.getPropertyValue("break-before");
  }
  set breakBefore(value2) {
    this.setProperty("break-before", value2);
  }
  get breakInside() {
    return this.getPropertyValue("break-inside");
  }
  set breakInside(value2) {
    this.setProperty("break-inside", value2);
  }
  get bufferedRendering() {
    return this.getPropertyValue("buffered-rendering");
  }
  set bufferedRendering(value2) {
    this.setProperty("buffered-rendering", value2);
  }
  get captionSide() {
    return this.getPropertyValue("caption-side");
  }
  set captionSide(value2) {
    this.setProperty("caption-side", value2);
  }
  get caretColor() {
    return this.getPropertyValue("caret-color");
  }
  set caretColor(value2) {
    this.setProperty("caret-color", value2);
  }
  get clear() {
    return this.getPropertyValue("clear");
  }
  set clear(value2) {
    this.setProperty("clear", value2);
  }
  get clip() {
    return this.getPropertyValue("clip");
  }
  set clip(value2) {
    this.setProperty("clip", value2);
  }
  get clipPath() {
    return this.getPropertyValue("clip-path");
  }
  set clipPath(value2) {
    this.setProperty("clip-path", value2);
  }
  get clipRule() {
    return this.getPropertyValue("clip-rule");
  }
  set clipRule(value2) {
    this.setProperty("clip-rule", value2);
  }
  get color() {
    return this.getPropertyValue("color");
  }
  set color(value2) {
    this.setProperty("color", value2);
  }
  get colorInterpolation() {
    return this.getPropertyValue("color-interpolation");
  }
  set colorInterpolation(value2) {
    this.setProperty("color-interpolation", value2);
  }
  get colorInterpolationFilters() {
    return this.getPropertyValue("color-interpolation-filters");
  }
  set colorInterpolationFilters(value2) {
    this.setProperty("color-interpolation-filters", value2);
  }
  get colorRendering() {
    return this.getPropertyValue("color-rendering");
  }
  set colorRendering(value2) {
    this.setProperty("color-rendering", value2);
  }
  get colorScheme() {
    return this.getPropertyValue("color-scheme");
  }
  set colorScheme(value2) {
    this.setProperty("color-scheme", value2);
  }
  get columnCount() {
    return this.getPropertyValue("column-count");
  }
  set columnCount(value2) {
    this.setProperty("column-count", value2);
  }
  get columnFill() {
    return this.getPropertyValue("column-fill");
  }
  set columnFill(value2) {
    this.setProperty("column-fill", value2);
  }
  get columnGap() {
    return this.getPropertyValue("column-gap");
  }
  set columnGap(value2) {
    this.setProperty("column-gap", value2);
  }
  get columnRule() {
    return this.getPropertyValue("column-rule");
  }
  set columnRule(value2) {
    this.setProperty("column-rule", value2);
  }
  get columnRuleColor() {
    return this.getPropertyValue("column-rule-color");
  }
  set columnRuleColor(value2) {
    this.setProperty("column-rule-color", value2);
  }
  get columnRuleStyle() {
    return this.getPropertyValue("column-rule-style");
  }
  set columnRuleStyle(value2) {
    this.setProperty("column-rule-style", value2);
  }
  get columnRuleWidth() {
    return this.getPropertyValue("column-rule-width");
  }
  set columnRuleWidth(value2) {
    this.setProperty("column-rule-width", value2);
  }
  get columnSpan() {
    return this.getPropertyValue("column-span");
  }
  set columnSpan(value2) {
    this.setProperty("column-span", value2);
  }
  get columnWidth() {
    return this.getPropertyValue("column-width");
  }
  set columnWidth(value2) {
    this.setProperty("column-width", value2);
  }
  get columns() {
    return this.getPropertyValue("columns");
  }
  set columns(value2) {
    this.setProperty("columns", value2);
  }
  get contain() {
    return this.getPropertyValue("contain");
  }
  set contain(value2) {
    this.setProperty("contain", value2);
  }
  get containIntrinsicSize() {
    return this.getPropertyValue("contain-intrinsic-size");
  }
  set containIntrinsicSize(value2) {
    this.setProperty("contain-intrinsic-size", value2);
  }
  get content() {
    return this.getPropertyValue("content");
  }
  set content(value2) {
    this.setProperty("content", value2);
  }
  get contentVisibility() {
    return this.getPropertyValue("content-visibility");
  }
  set contentVisibility(value2) {
    this.setProperty("content-visibility", value2);
  }
  get counterIncrement() {
    return this.getPropertyValue("counter-increment");
  }
  set counterIncrement(value2) {
    this.setProperty("counter-increment", value2);
  }
  get counterReset() {
    return this.getPropertyValue("counter-reset");
  }
  set counterReset(value2) {
    this.setProperty("counter-reset", value2);
  }
  get counterSet() {
    return this.getPropertyValue("counter-set");
  }
  set counterSet(value2) {
    this.setProperty("counter-set", value2);
  }
  get containIntrinsicBlockSize() {
    return this.getPropertyValue("contain-intrinsic-block-size");
  }
  set containIntrinsicBlockSize(value2) {
    this.setProperty("contain-intrinsic-block-size", value2);
  }
  get containIntrinsicHeight() {
    return this.getPropertyValue("contain-intrinsic-height");
  }
  set containIntrinsicHeight(value2) {
    this.setProperty("contain-intrinsic-height", value2);
  }
  get containIntrinsicInlineSize() {
    return this.getPropertyValue("contain-intrinsic-inline-size");
  }
  set containIntrinsicInlineSize(value2) {
    this.setProperty("contain-intrinsic-inline-size", value2);
  }
  get containIntrinsicWidth() {
    return this.getPropertyValue("contain-intrinsic-width");
  }
  set containIntrinsicWidth(value2) {
    this.setProperty("contain-intrinsic-width", value2);
  }
  get cssFloat() {
    return this.getPropertyValue("css-float");
  }
  set cssFloat(value2) {
    this.setProperty("css-float", value2);
  }
  get cursor() {
    return this.getPropertyValue("cursor");
  }
  set cursor(value2) {
    this.setProperty("cursor", value2);
  }
  get cx() {
    return this.getPropertyValue("cx");
  }
  set cx(value2) {
    this.setProperty("cx", value2);
  }
  get cy() {
    return this.getPropertyValue("cy");
  }
  set cy(value2) {
    this.setProperty("cy", value2);
  }
  get d() {
    return this.getPropertyValue("d");
  }
  set d(value2) {
    this.setProperty("d", value2);
  }
  get direction() {
    return this.getPropertyValue("direction");
  }
  set direction(value2) {
    this.setProperty("direction", value2);
  }
  get display() {
    return this.getPropertyValue("display");
  }
  set display(value2) {
    this.setProperty("display", value2);
  }
  get dominantBaseline() {
    return this.getPropertyValue("dominant-baseline");
  }
  set dominantBaseline(value2) {
    this.setProperty("dominant-baseline", value2);
  }
  get emptyCells() {
    return this.getPropertyValue("empty-cells");
  }
  set emptyCells(value2) {
    this.setProperty("empty-cells", value2);
  }
  get fill() {
    return this.getPropertyValue("fill");
  }
  set fill(value2) {
    this.setProperty("fill", value2);
  }
  get fillOpacity() {
    return this.getPropertyValue("fill-opacity");
  }
  set fillOpacity(value2) {
    this.setProperty("fill-opacity", value2);
  }
  get fillRule() {
    return this.getPropertyValue("fill-rule");
  }
  set fillRule(value2) {
    this.setProperty("fill-rule", value2);
  }
  get filter() {
    return this.getPropertyValue("filter");
  }
  set filter(value2) {
    this.setProperty("filter", value2);
  }
  get flex() {
    return this.getPropertyValue("flex");
  }
  set flex(value2) {
    this.setProperty("flex", value2);
  }
  get flexBasis() {
    return this.getPropertyValue("flex-basis");
  }
  set flexBasis(value2) {
    this.setProperty("flex-basis", value2);
  }
  get flexDirection() {
    return this.getPropertyValue("flex-direction");
  }
  set flexDirection(value2) {
    this.setProperty("flex-direction", value2);
  }
  get flexFlow() {
    return this.getPropertyValue("flex-flow");
  }
  set flexFlow(value2) {
    this.setProperty("flex-flow", value2);
  }
  get flexGrow() {
    return this.getPropertyValue("flex-grow");
  }
  set flexGrow(value2) {
    this.setProperty("flex-grow", value2);
  }
  get flexShrink() {
    return this.getPropertyValue("flex-shrink");
  }
  set flexShrink(value2) {
    this.setProperty("flex-shrink", value2);
  }
  get flexWrap() {
    return this.getPropertyValue("flex-wrap");
  }
  set flexWrap(value2) {
    this.setProperty("flex-wrap", value2);
  }
  get float() {
    return this.getPropertyValue("float");
  }
  set float(value2) {
    this.setProperty("float", value2);
  }
  get floodColor() {
    return this.getPropertyValue("flood-color");
  }
  set floodColor(value2) {
    this.setProperty("flood-color", value2);
  }
  get floodOpacity() {
    return this.getPropertyValue("flood-opacity");
  }
  set floodOpacity(value2) {
    this.setProperty("flood-opacity", value2);
  }
  get font() {
    return this.getPropertyValue("font");
  }
  set font(value2) {
    this.setProperty("font", value2);
  }
  get fontDisplay() {
    return this.getPropertyValue("font-display");
  }
  set fontDisplay(value2) {
    this.setProperty("font-display", value2);
  }
  get fontFamily() {
    return this.getPropertyValue("font-family");
  }
  set fontFamily(value2) {
    this.setProperty("font-family", value2);
  }
  get fontFeatureSettings() {
    return this.getPropertyValue("font-feature-settings");
  }
  set fontFeatureSettings(value2) {
    this.setProperty("font-feature-settings", value2);
  }
  get fontKerning() {
    return this.getPropertyValue("font-kerning");
  }
  set fontKerning(value2) {
    this.setProperty("font-kerning", value2);
  }
  get fontOpticalSizing() {
    return this.getPropertyValue("font-optical-sizing");
  }
  set fontOpticalSizing(value2) {
    this.setProperty("font-optical-sizing", value2);
  }
  get fontSize() {
    return this.getPropertyValue("font-size");
  }
  set fontSize(value2) {
    this.setProperty("font-size", value2);
  }
  get fontStretch() {
    return this.getPropertyValue("font-stretch");
  }
  set fontStretch(value2) {
    this.setProperty("font-stretch", value2);
  }
  get fontStyle() {
    return this.getPropertyValue("font-style");
  }
  set fontStyle(value2) {
    this.setProperty("font-style", value2);
  }
  get fontVariant() {
    return this.getPropertyValue("font-variant");
  }
  set fontVariant(value2) {
    this.setProperty("font-variant", value2);
  }
  get fontVariantCaps() {
    return this.getPropertyValue("font-variant-caps");
  }
  set fontVariantCaps(value2) {
    this.setProperty("font-variant-caps", value2);
  }
  get fontVariantEastAsian() {
    return this.getPropertyValue("font-variant-east-asian");
  }
  set fontVariantEastAsian(value2) {
    this.setProperty("font-variant-east-asian", value2);
  }
  get fontVariantLigatures() {
    return this.getPropertyValue("font-variant-ligatures");
  }
  set fontVariantLigatures(value2) {
    this.setProperty("font-variant-ligatures", value2);
  }
  get fontVariantNumeric() {
    return this.getPropertyValue("font-variant-numeric");
  }
  set fontVariantNumeric(value2) {
    this.setProperty("font-variant-numeric", value2);
  }
  get fontVariationSettings() {
    return this.getPropertyValue("font-variation-settings");
  }
  set fontVariationSettings(value2) {
    this.setProperty("font-variation-settings", value2);
  }
  get fontPalette() {
    return this.getPropertyValue("font-palette");
  }
  set fontPalette(value2) {
    this.setProperty("font-palette", value2);
  }
  get fontSynthesisSmallCaps() {
    return this.getPropertyValue("font-synthesis-small-caps");
  }
  set fontSynthesisSmallCaps(value2) {
    this.setProperty("font-synthesis-small-caps", value2);
  }
  get fontSynthesisStyle() {
    return this.getPropertyValue("font-synthesis-style");
  }
  set fontSynthesisStyle(value2) {
    this.setProperty("font-synthesis-style", value2);
  }
  get fontSynthesisWeight() {
    return this.getPropertyValue("font-synthesis-weight");
  }
  set fontSynthesisWeight(value2) {
    this.setProperty("font-synthesis-weight", value2);
  }
  get fontWeight() {
    return this.getPropertyValue("font-weight");
  }
  set fontWeight(value2) {
    this.setProperty("font-weight", value2);
  }
  get gap() {
    return this.getPropertyValue("gap");
  }
  set gap(value2) {
    this.setProperty("gap", value2);
  }
  get grid() {
    return this.getPropertyValue("grid");
  }
  set grid(value2) {
    this.setProperty("grid", value2);
  }
  get gridArea() {
    return this.getPropertyValue("grid-area");
  }
  set gridArea(value2) {
    this.setProperty("grid-area", value2);
  }
  get gridAutoColumns() {
    return this.getPropertyValue("grid-auto-columns");
  }
  set gridAutoColumns(value2) {
    this.setProperty("grid-auto-columns", value2);
  }
  get gridAutoFlow() {
    return this.getPropertyValue("grid-auto-flow");
  }
  set gridAutoFlow(value2) {
    this.setProperty("grid-auto-flow", value2);
  }
  get gridAutoRows() {
    return this.getPropertyValue("grid-auto-rows");
  }
  set gridAutoRows(value2) {
    this.setProperty("grid-auto-rows", value2);
  }
  get gridColumn() {
    return this.getPropertyValue("grid-column");
  }
  set gridColumn(value2) {
    this.setProperty("grid-column", value2);
  }
  get gridColumnEnd() {
    return this.getPropertyValue("grid-column-end");
  }
  set gridColumnEnd(value2) {
    this.setProperty("grid-column-end", value2);
  }
  get gridColumnGap() {
    return this.getPropertyValue("grid-column-gap");
  }
  set gridColumnGap(value2) {
    this.setProperty("grid-column-gap", value2);
  }
  get gridColumnStart() {
    return this.getPropertyValue("grid-column-start");
  }
  set gridColumnStart(value2) {
    this.setProperty("grid-column-start", value2);
  }
  get gridGap() {
    return this.getPropertyValue("grid-gap");
  }
  set gridGap(value2) {
    this.setProperty("grid-gap", value2);
  }
  get gridRow() {
    return this.getPropertyValue("grid-row");
  }
  set gridRow(value2) {
    this.setProperty("grid-row", value2);
  }
  get gridRowEnd() {
    return this.getPropertyValue("grid-row-end");
  }
  set gridRowEnd(value2) {
    this.setProperty("grid-row-end", value2);
  }
  get gridRowGap() {
    return this.getPropertyValue("grid-row-gap");
  }
  set gridRowGap(value2) {
    this.setProperty("grid-row-gap", value2);
  }
  get gridRowStart() {
    return this.getPropertyValue("grid-row-start");
  }
  set gridRowStart(value2) {
    this.setProperty("grid-row-start", value2);
  }
  get gridTemplate() {
    return this.getPropertyValue("grid-template");
  }
  set gridTemplate(value2) {
    this.setProperty("grid-template", value2);
  }
  get gridTemplateAreas() {
    return this.getPropertyValue("grid-template-areas");
  }
  set gridTemplateAreas(value2) {
    this.setProperty("grid-template-areas", value2);
  }
  get gridTemplateColumns() {
    return this.getPropertyValue("grid-template-columns");
  }
  set gridTemplateColumns(value2) {
    this.setProperty("grid-template-columns", value2);
  }
  get gridTemplateRows() {
    return this.getPropertyValue("grid-template-rows");
  }
  set gridTemplateRows(value2) {
    this.setProperty("grid-template-rows", value2);
  }
  get height() {
    return this.getPropertyValue("height");
  }
  set height(value2) {
    this.setProperty("height", value2);
  }
  get hyphens() {
    return this.getPropertyValue("hyphens");
  }
  set hyphens(value2) {
    this.setProperty("hyphens", value2);
  }
  get imageOrientation() {
    return this.getPropertyValue("image-orientation");
  }
  set imageOrientation(value2) {
    this.setProperty("image-orientation", value2);
  }
  get imageRendering() {
    return this.getPropertyValue("image-rendering");
  }
  set imageRendering(value2) {
    this.setProperty("image-rendering", value2);
  }
  get inherits() {
    return this.getPropertyValue("inherits");
  }
  set inherits(value2) {
    this.setProperty("inherits", value2);
  }
  get initialValue() {
    return this.getPropertyValue("initial-value");
  }
  set initialValue(value2) {
    this.setProperty("initial-value", value2);
  }
  get inlineSize() {
    return this.getPropertyValue("inline-size");
  }
  set inlineSize(value2) {
    this.setProperty("inline-size", value2);
  }
  get isolation() {
    return this.getPropertyValue("isolation");
  }
  set isolation(value2) {
    this.setProperty("isolation", value2);
  }
  get insetBlockEnd() {
    return this.getPropertyValue("inset-block-end");
  }
  set insetBlockEnd(value2) {
    this.setProperty("inset-block-end", value2);
  }
  get insetBlockStart() {
    return this.getPropertyValue("inset-block-start");
  }
  set insetBlockStart(value2) {
    this.setProperty("inset-block-start", value2);
  }
  get insetInlineEnd() {
    return this.getPropertyValue("inset-inline-end");
  }
  set insetInlineEnd(value2) {
    this.setProperty("inset-inline-end", value2);
  }
  get insetInlineStart() {
    return this.getPropertyValue("inset-inline-start");
  }
  set insetInlineStart(value2) {
    this.setProperty("inset-inline-start", value2);
  }
  get justifyContent() {
    return this.getPropertyValue("justify-content");
  }
  set justifyContent(value2) {
    this.setProperty("justify-content", value2);
  }
  get justifyItems() {
    return this.getPropertyValue("justify-items");
  }
  set justifyItems(value2) {
    this.setProperty("justify-items", value2);
  }
  get justifySelf() {
    return this.getPropertyValue("justify-self");
  }
  set justifySelf(value2) {
    this.setProperty("justify-self", value2);
  }
  get left() {
    return this.getPropertyValue("left");
  }
  set left(value2) {
    this.setProperty("left", value2);
  }
  get letterSpacing() {
    return this.getPropertyValue("letter-spacing");
  }
  set letterSpacing(value2) {
    this.setProperty("letter-spacing", value2);
  }
  get lightingColor() {
    return this.getPropertyValue("lighting-color");
  }
  set lightingColor(value2) {
    this.setProperty("lighting-color", value2);
  }
  get lineBreak() {
    return this.getPropertyValue("line-break");
  }
  set lineBreak(value2) {
    this.setProperty("line-break", value2);
  }
  get lineHeight() {
    return this.getPropertyValue("line-height");
  }
  set lineHeight(value2) {
    this.setProperty("line-height", value2);
  }
  get listStyle() {
    return this.getPropertyValue("list-style");
  }
  set listStyle(value2) {
    this.setProperty("list-style", value2);
  }
  get listStyleImage() {
    return this.getPropertyValue("list-style-image");
  }
  set listStyleImage(value2) {
    this.setProperty("list-style-image", value2);
  }
  get listStylePosition() {
    return this.getPropertyValue("list-style-position");
  }
  set listStylePosition(value2) {
    this.setProperty("list-style-position", value2);
  }
  get listStyleType() {
    return this.getPropertyValue("list-style-type");
  }
  set listStyleType(value2) {
    this.setProperty("list-style-type", value2);
  }
  get margin() {
    return this.getPropertyValue("margin");
  }
  set margin(value2) {
    this.setProperty("margin", value2);
  }
  get marginBlockEnd() {
    return this.getPropertyValue("margin-block-end");
  }
  set marginBlockEnd(value2) {
    this.setProperty("margin-block-end", value2);
  }
  get marginBlockStart() {
    return this.getPropertyValue("margin-block-start");
  }
  set marginBlockStart(value2) {
    this.setProperty("margin-block-start", value2);
  }
  get marginBottom() {
    return this.getPropertyValue("margin-bottom");
  }
  set marginBottom(value2) {
    this.setProperty("margin-bottom", value2);
  }
  get marginInlineEnd() {
    return this.getPropertyValue("margin-inline-end");
  }
  set marginInlineEnd(value2) {
    this.setProperty("margin-inline-end", value2);
  }
  get marginInlineStart() {
    return this.getPropertyValue("margin-inline-start");
  }
  set marginInlineStart(value2) {
    this.setProperty("margin-inline-start", value2);
  }
  get marginLeft() {
    return this.getPropertyValue("margin-left");
  }
  set marginLeft(value2) {
    this.setProperty("margin-left", value2);
  }
  get marginRight() {
    return this.getPropertyValue("margin-right");
  }
  set marginRight(value2) {
    this.setProperty("margin-right", value2);
  }
  get marginTop() {
    return this.getPropertyValue("margin-top");
  }
  set marginTop(value2) {
    this.setProperty("margin-top", value2);
  }
  get marker() {
    return this.getPropertyValue("marker");
  }
  set marker(value2) {
    this.setProperty("marker", value2);
  }
  get markerEnd() {
    return this.getPropertyValue("marker-end");
  }
  set markerEnd(value2) {
    this.setProperty("marker-end", value2);
  }
  get markerMid() {
    return this.getPropertyValue("marker-mid");
  }
  set markerMid(value2) {
    this.setProperty("marker-mid", value2);
  }
  get markerStart() {
    return this.getPropertyValue("marker-start");
  }
  set markerStart(value2) {
    this.setProperty("marker-start", value2);
  }
  get mask() {
    return this.getPropertyValue("mask");
  }
  set mask(value2) {
    this.setProperty("mask", value2);
  }
  get maskType() {
    return this.getPropertyValue("mask-type");
  }
  set maskType(value2) {
    this.setProperty("mask-type", value2);
  }
  get maxBlockSize() {
    return this.getPropertyValue("max-block-size");
  }
  set maxBlockSize(value2) {
    this.setProperty("max-block-size", value2);
  }
  get maxHeight() {
    return this.getPropertyValue("max-height");
  }
  set maxHeight(value2) {
    this.setProperty("max-height", value2);
  }
  get maxInlineSize() {
    return this.getPropertyValue("max-inline-size");
  }
  set maxInlineSize(value2) {
    this.setProperty("max-inline-size", value2);
  }
  get maxWidth() {
    return this.getPropertyValue("max-width");
  }
  set maxWidth(value2) {
    this.setProperty("max-width", value2);
  }
  get maxZoom() {
    return this.getPropertyValue("max-zoom");
  }
  set maxZoom(value2) {
    this.setProperty("max-zoom", value2);
  }
  get minBlockSize() {
    return this.getPropertyValue("min-block-size");
  }
  set minBlockSize(value2) {
    this.setProperty("min-block-size", value2);
  }
  get minHeight() {
    return this.getPropertyValue("min-height");
  }
  set minHeight(value2) {
    this.setProperty("min-height", value2);
  }
  get minInlineSize() {
    return this.getPropertyValue("min-inline-size");
  }
  set minInlineSize(value2) {
    this.setProperty("min-inline-size", value2);
  }
  get minWidth() {
    return this.getPropertyValue("min-width");
  }
  set minWidth(value2) {
    this.setProperty("min-width", value2);
  }
  get minZoom() {
    return this.getPropertyValue("min-zoom");
  }
  set minZoom(value2) {
    this.setProperty("min-zoom", value2);
  }
  get mixBlendMode() {
    return this.getPropertyValue("mix-blend-mode");
  }
  set mixBlendMode(value2) {
    this.setProperty("mix-blend-mode", value2);
  }
  get objectFit() {
    return this.getPropertyValue("object-fit");
  }
  set objectFit(value2) {
    this.setProperty("object-fit", value2);
  }
  get objectPosition() {
    return this.getPropertyValue("object-position");
  }
  set objectPosition(value2) {
    this.setProperty("object-position", value2);
  }
  get offset() {
    return this.getPropertyValue("offset");
  }
  set offset(value2) {
    this.setProperty("offset", value2);
  }
  get offsetDistance() {
    return this.getPropertyValue("offset-distance");
  }
  set offsetDistance(value2) {
    this.setProperty("offset-distance", value2);
  }
  get offsetPath() {
    return this.getPropertyValue("offset-path");
  }
  set offsetPath(value2) {
    this.setProperty("offset-path", value2);
  }
  get offsetRotate() {
    return this.getPropertyValue("offset-rotate");
  }
  set offsetRotate(value2) {
    this.setProperty("offset-rotate", value2);
  }
  get opacity() {
    return this.getPropertyValue("opacity");
  }
  set opacity(value2) {
    this.setProperty("opacity", value2);
  }
  get order() {
    return this.getPropertyValue("order");
  }
  set order(value2) {
    this.setProperty("order", value2);
  }
  get orientation() {
    return this.getPropertyValue("orientation");
  }
  set orientation(value2) {
    this.setProperty("orientation", value2);
  }
  get orphans() {
    return this.getPropertyValue("orphans");
  }
  set orphans(value2) {
    this.setProperty("orphans", value2);
  }
  get outline() {
    return this.getPropertyValue("outline");
  }
  set outline(value2) {
    this.setProperty("outline", value2);
  }
  get outlineColor() {
    return this.getPropertyValue("outline-color");
  }
  set outlineColor(value2) {
    this.setProperty("outline-color", value2);
  }
  get outlineOffset() {
    return this.getPropertyValue("outline-offset");
  }
  set outlineOffset(value2) {
    this.setProperty("outline-offset", value2);
  }
  get outlineStyle() {
    return this.getPropertyValue("outline-style");
  }
  set outlineStyle(value2) {
    this.setProperty("outline-style", value2);
  }
  get outlineWidth() {
    return this.getPropertyValue("outline-width");
  }
  set outlineWidth(value2) {
    this.setProperty("outline-width", value2);
  }
  get overflow() {
    return this.getPropertyValue("overflow");
  }
  set overflow(value2) {
    this.setProperty("overflow", value2);
  }
  get overflowAnchor() {
    return this.getPropertyValue("overflow-anchor");
  }
  set overflowAnchor(value2) {
    this.setProperty("overflow-anchor", value2);
  }
  get overflowWrap() {
    return this.getPropertyValue("overflow-wrap");
  }
  set overflowWrap(value2) {
    this.setProperty("overflow-wrap", value2);
  }
  get overflowX() {
    return this.getPropertyValue("overflow-x");
  }
  set overflowX(value2) {
    this.setProperty("overflow-x", value2);
  }
  get overflowY() {
    return this.getPropertyValue("overflow-y");
  }
  set overflowY(value2) {
    this.setProperty("overflow-y", value2);
  }
  get overscrollBehavior() {
    return this.getPropertyValue("overscroll-behavior");
  }
  set overscrollBehavior(value2) {
    this.setProperty("overscroll-behavior", value2);
  }
  get overscrollBehaviorBlock() {
    return this.getPropertyValue("overscroll-behavior-block");
  }
  set overscrollBehaviorBlock(value2) {
    this.setProperty("overscroll-behavior-block", value2);
  }
  get overscrollBehaviorInline() {
    return this.getPropertyValue("overscroll-behavior-inline");
  }
  set overscrollBehaviorInline(value2) {
    this.setProperty("overscroll-behavior-inline", value2);
  }
  get overscrollBehaviorX() {
    return this.getPropertyValue("overscroll-behavior-x");
  }
  set overscrollBehaviorX(value2) {
    this.setProperty("overscroll-behavior-x", value2);
  }
  get overscrollBehaviorY() {
    return this.getPropertyValue("overscroll-behavior-y");
  }
  set overscrollBehaviorY(value2) {
    this.setProperty("overscroll-behavior-y", value2);
  }
  get overflowClipMargin() {
    return this.getPropertyValue("overflow-clip-margin");
  }
  set overflowClipMargin(value2) {
    this.setProperty("overflow-clip-margin", value2);
  }
  get padding() {
    return this.getPropertyValue("padding");
  }
  set padding(value2) {
    this.setProperty("padding", value2);
  }
  get paddingBlockEnd() {
    return this.getPropertyValue("padding-block-end");
  }
  set paddingBlockEnd(value2) {
    this.setProperty("padding-block-end", value2);
  }
  get paddingBlockStart() {
    return this.getPropertyValue("padding-block-start");
  }
  set paddingBlockStart(value2) {
    this.setProperty("padding-block-start", value2);
  }
  get paddingBottom() {
    return this.getPropertyValue("padding-bottom");
  }
  set paddingBottom(value2) {
    this.setProperty("padding-bottom", value2);
  }
  get paddingInlineEnd() {
    return this.getPropertyValue("padding-inline-end");
  }
  set paddingInlineEnd(value2) {
    this.setProperty("padding-inline-end", value2);
  }
  get paddingInlineStart() {
    return this.getPropertyValue("padding-inline-start");
  }
  set paddingInlineStart(value2) {
    this.setProperty("padding-inline-start", value2);
  }
  get paddingLeft() {
    return this.getPropertyValue("padding-left");
  }
  set paddingLeft(value2) {
    this.setProperty("padding-left", value2);
  }
  get paddingRight() {
    return this.getPropertyValue("padding-right");
  }
  set paddingRight(value2) {
    this.setProperty("padding-right", value2);
  }
  get paddingTop() {
    return this.getPropertyValue("padding-top");
  }
  set paddingTop(value2) {
    this.setProperty("padding-top", value2);
  }
  get page() {
    return this.getPropertyValue("page");
  }
  set page(value2) {
    this.setProperty("page", value2);
  }
  get pageBreakAfter() {
    return this.getPropertyValue("page-break-after");
  }
  set pageBreakAfter(value2) {
    this.setProperty("page-break-after", value2);
  }
  get pageBreakBefore() {
    return this.getPropertyValue("page-break-before");
  }
  set pageBreakBefore(value2) {
    this.setProperty("page-break-before", value2);
  }
  get pageBreakInside() {
    return this.getPropertyValue("page-break-inside");
  }
  set pageBreakInside(value2) {
    this.setProperty("page-break-inside", value2);
  }
  get pageOrientation() {
    return this.getPropertyValue("page-orientation");
  }
  set pageOrientation(value2) {
    this.setProperty("page-orientation", value2);
  }
  get paintOrder() {
    return this.getPropertyValue("paint-order");
  }
  set paintOrder(value2) {
    this.setProperty("paint-order", value2);
  }
  get perspective() {
    return this.getPropertyValue("perspective");
  }
  set perspective(value2) {
    this.setProperty("perspective", value2);
  }
  get perspectiveOrigin() {
    return this.getPropertyValue("perspective-origin");
  }
  set perspectiveOrigin(value2) {
    this.setProperty("perspective-origin", value2);
  }
  get placeContent() {
    return this.getPropertyValue("place-content");
  }
  set placeContent(value2) {
    this.setProperty("place-content", value2);
  }
  get placeItems() {
    return this.getPropertyValue("place-items");
  }
  set placeItems(value2) {
    this.setProperty("place-items", value2);
  }
  get placeSelf() {
    return this.getPropertyValue("place-self");
  }
  set placeSelf(value2) {
    this.setProperty("place-self", value2);
  }
  get pointerEvents() {
    return this.getPropertyValue("pointer-events");
  }
  set pointerEvents(value2) {
    this.setProperty("pointer-events", value2);
  }
  get position() {
    return this.getPropertyValue("position");
  }
  set position(value2) {
    this.setProperty("position", value2);
  }
  get quotes() {
    return this.getPropertyValue("quotes");
  }
  set quotes(value2) {
    this.setProperty("quotes", value2);
  }
  get r() {
    return this.getPropertyValue("r");
  }
  set r(value2) {
    this.setProperty("r", value2);
  }
  get resize() {
    return this.getPropertyValue("resize");
  }
  set resize(value2) {
    this.setProperty("resize", value2);
  }
  get right() {
    return this.getPropertyValue("right");
  }
  set right(value2) {
    this.setProperty("right", value2);
  }
  get rowGap() {
    return this.getPropertyValue("row-gap");
  }
  set rowGap(value2) {
    this.setProperty("row-gap", value2);
  }
  get rubyPosition() {
    return this.getPropertyValue("ruby-position");
  }
  set rubyPosition(value2) {
    this.setProperty("ruby-position", value2);
  }
  get rx() {
    return this.getPropertyValue("rx");
  }
  set rx(value2) {
    this.setProperty("rx", value2);
  }
  get ry() {
    return this.getPropertyValue("ry");
  }
  set ry(value2) {
    this.setProperty("ry", value2);
  }
  get scrollBehavior() {
    return this.getPropertyValue("scroll-behavior");
  }
  set scrollBehavior(value2) {
    this.setProperty("scroll-behavior", value2);
  }
  get scrollMargin() {
    return this.getPropertyValue("scroll-margin");
  }
  set scrollMargin(value2) {
    this.setProperty("scroll-margin", value2);
  }
  get scrollMarginBlock() {
    return this.getPropertyValue("scroll-margin-block");
  }
  set scrollMarginBlock(value2) {
    this.setProperty("scroll-margin-block", value2);
  }
  get scrollMarginBlockEnd() {
    return this.getPropertyValue("scroll-margin-block-end");
  }
  set scrollMarginBlockEnd(value2) {
    this.setProperty("scroll-margin-block-end", value2);
  }
  get scrollMarginBlockStart() {
    return this.getPropertyValue("scroll-margin-block-start");
  }
  set scrollMarginBlockStart(value2) {
    this.setProperty("scroll-margin-block-start", value2);
  }
  get scrollMarginBottom() {
    return this.getPropertyValue("scroll-margin-bottom");
  }
  set scrollMarginBottom(value2) {
    this.setProperty("scroll-margin-bottom", value2);
  }
  get scrollMarginInline() {
    return this.getPropertyValue("scroll-margin-inline");
  }
  set scrollMarginInline(value2) {
    this.setProperty("scroll-margin-inline", value2);
  }
  get scrollMarginInlineEnd() {
    return this.getPropertyValue("scroll-margin-inline-end");
  }
  set scrollMarginInlineEnd(value2) {
    this.setProperty("scroll-margin-inline-end", value2);
  }
  get scrollMarginInlineStart() {
    return this.getPropertyValue("scroll-margin-inline-start");
  }
  set scrollMarginInlineStart(value2) {
    this.setProperty("scroll-margin-inline-start", value2);
  }
  get scrollMarginLeft() {
    return this.getPropertyValue("scroll-margin-left");
  }
  set scrollMarginLeft(value2) {
    this.setProperty("scroll-margin-left", value2);
  }
  get scrollMarginRight() {
    return this.getPropertyValue("scroll-margin-right");
  }
  set scrollMarginRight(value2) {
    this.setProperty("scroll-margin-right", value2);
  }
  get scrollMarginTop() {
    return this.getPropertyValue("scroll-margin-top");
  }
  set scrollMarginTop(value2) {
    this.setProperty("scroll-margin-top", value2);
  }
  get scrollPadding() {
    return this.getPropertyValue("scroll-padding");
  }
  set scrollPadding(value2) {
    this.setProperty("scroll-padding", value2);
  }
  get scrollPaddingBlock() {
    return this.getPropertyValue("scroll-padding-block");
  }
  set scrollPaddingBlock(value2) {
    this.setProperty("scroll-padding-block", value2);
  }
  get scrollPaddingBlockEnd() {
    return this.getPropertyValue("scroll-padding-block-end");
  }
  set scrollPaddingBlockEnd(value2) {
    this.setProperty("scroll-padding-block-end", value2);
  }
  get scrollPaddingBlockStart() {
    return this.getPropertyValue("scroll-padding-block-start");
  }
  set scrollPaddingBlockStart(value2) {
    this.setProperty("scroll-padding-block-start", value2);
  }
  get scrollPaddingBottom() {
    return this.getPropertyValue("scroll-padding-bottom");
  }
  set scrollPaddingBottom(value2) {
    this.setProperty("scroll-padding-bottom", value2);
  }
  get scrollPaddingInline() {
    return this.getPropertyValue("scroll-padding-inline");
  }
  set scrollPaddingInline(value2) {
    this.setProperty("scroll-padding-inline", value2);
  }
  get scrollPaddingInlineEnd() {
    return this.getPropertyValue("scroll-padding-inline-end");
  }
  set scrollPaddingInlineEnd(value2) {
    this.setProperty("scroll-padding-inline-end", value2);
  }
  get scrollPaddingInlineStart() {
    return this.getPropertyValue("scroll-padding-inline-start");
  }
  set scrollPaddingInlineStart(value2) {
    this.setProperty("scroll-padding-inline-start", value2);
  }
  get scrollPaddingLeft() {
    return this.getPropertyValue("scroll-padding-left");
  }
  set scrollPaddingLeft(value2) {
    this.setProperty("scroll-padding-left", value2);
  }
  get scrollPaddingRight() {
    return this.getPropertyValue("scroll-padding-right");
  }
  set scrollPaddingRight(value2) {
    this.setProperty("scroll-padding-right", value2);
  }
  get scrollPaddingTop() {
    return this.getPropertyValue("scroll-padding-top");
  }
  set scrollPaddingTop(value2) {
    this.setProperty("scroll-padding-top", value2);
  }
  get scrollSnapAlign() {
    return this.getPropertyValue("scroll-snap-align");
  }
  set scrollSnapAlign(value2) {
    this.setProperty("scroll-snap-align", value2);
  }
  get scrollSnapStop() {
    return this.getPropertyValue("scroll-snap-stop");
  }
  set scrollSnapStop(value2) {
    this.setProperty("scroll-snap-stop", value2);
  }
  get scrollSnapType() {
    return this.getPropertyValue("scroll-snap-type");
  }
  set scrollSnapType(value2) {
    this.setProperty("scroll-snap-type", value2);
  }
  get shapeImageThreshold() {
    return this.getPropertyValue("shape-image-threshold");
  }
  set shapeImageThreshold(value2) {
    this.setProperty("shape-image-threshold", value2);
  }
  get shapeMargin() {
    return this.getPropertyValue("shape-margin");
  }
  set shapeMargin(value2) {
    this.setProperty("shape-margin", value2);
  }
  get shapeOutside() {
    return this.getPropertyValue("shape-outside");
  }
  set shapeOutside(value2) {
    this.setProperty("shape-outside", value2);
  }
  get shapeRendering() {
    return this.getPropertyValue("shape-rendering");
  }
  set shapeRendering(value2) {
    this.setProperty("shape-rendering", value2);
  }
  get size() {
    return this.getPropertyValue("size");
  }
  set size(value2) {
    this.setProperty("size", value2);
  }
  get speak() {
    return this.getPropertyValue("speak");
  }
  set speak(value2) {
    this.setProperty("speak", value2);
  }
  get src() {
    return this.getPropertyValue("src");
  }
  set src(value2) {
    this.setProperty("src", value2);
  }
  get stopColor() {
    return this.getPropertyValue("stop-color");
  }
  set stopColor(value2) {
    this.setProperty("stop-color", value2);
  }
  get stopOpacity() {
    return this.getPropertyValue("stop-opacity");
  }
  set stopOpacity(value2) {
    this.setProperty("stop-opacity", value2);
  }
  get stroke() {
    return this.getPropertyValue("stroke");
  }
  set stroke(value2) {
    this.setProperty("stroke", value2);
  }
  get strokeDasharray() {
    return this.getPropertyValue("stroke-dasharray");
  }
  set strokeDasharray(value2) {
    this.setProperty("stroke-dasharray", value2);
  }
  get strokeDashoffset() {
    return this.getPropertyValue("stroke-dashoffset");
  }
  set strokeDashoffset(value2) {
    this.setProperty("stroke-dashoffset", value2);
  }
  get strokeLinecap() {
    return this.getPropertyValue("stroke-linecap");
  }
  set strokeLinecap(value2) {
    this.setProperty("stroke-linecap", value2);
  }
  get strokeLinejoin() {
    return this.getPropertyValue("stroke-linejoin");
  }
  set strokeLinejoin(value2) {
    this.setProperty("stroke-linejoin", value2);
  }
  get strokeMiterlimit() {
    return this.getPropertyValue("stroke-miterlimit");
  }
  set strokeMiterlimit(value2) {
    this.setProperty("stroke-miterlimit", value2);
  }
  get strokeOpacity() {
    return this.getPropertyValue("stroke-opacity");
  }
  set strokeOpacity(value2) {
    this.setProperty("stroke-opacity", value2);
  }
  get strokeWidth() {
    return this.getPropertyValue("stroke-width");
  }
  set strokeWidth(value2) {
    this.setProperty("stroke-width", value2);
  }
  get syntax() {
    return this.getPropertyValue("syntax");
  }
  set syntax(value2) {
    this.setProperty("syntax", value2);
  }
  get scrollbarGutter() {
    return this.getPropertyValue("scrollbar-gutter");
  }
  set scrollbarGutter(value2) {
    this.setProperty("scrollbar-gutter", value2);
  }
  get tabSize() {
    return this.getPropertyValue("tab-size");
  }
  set tabSize(value2) {
    this.setProperty("tab-size", value2);
  }
  get tableLayout() {
    return this.getPropertyValue("table-layout");
  }
  set tableLayout(value2) {
    this.setProperty("table-layout", value2);
  }
  get textAlign() {
    return this.getPropertyValue("text-align");
  }
  set textAlign(value2) {
    this.setProperty("text-align", value2);
  }
  get textAlignLast() {
    return this.getPropertyValue("text-align-last");
  }
  set textAlignLast(value2) {
    this.setProperty("text-align-last", value2);
  }
  get textAnchor() {
    return this.getPropertyValue("text-anchor");
  }
  set textAnchor(value2) {
    this.setProperty("text-anchor", value2);
  }
  get textCombineUpright() {
    return this.getPropertyValue("text-combine-upright");
  }
  set textCombineUpright(value2) {
    this.setProperty("text-combine-upright", value2);
  }
  get textDecoration() {
    return this.getPropertyValue("text-decoration");
  }
  set textDecoration(value2) {
    this.setProperty("text-decoration", value2);
  }
  get textDecorationColor() {
    return this.getPropertyValue("text-decoration-color");
  }
  set textDecorationColor(value2) {
    this.setProperty("text-decoration-color", value2);
  }
  get textDecorationLine() {
    return this.getPropertyValue("text-decoration-line");
  }
  set textDecorationLine(value2) {
    this.setProperty("text-decoration-line", value2);
  }
  get textDecorationSkipInk() {
    return this.getPropertyValue("text-decoration-skip-ink");
  }
  set textDecorationSkipInk(value2) {
    this.setProperty("text-decoration-skip-ink", value2);
  }
  get textDecorationStyle() {
    return this.getPropertyValue("text-decoration-style");
  }
  set textDecorationStyle(value2) {
    this.setProperty("text-decoration-style", value2);
  }
  get textIndent() {
    return this.getPropertyValue("text-indent");
  }
  set textIndent(value2) {
    this.setProperty("text-indent", value2);
  }
  get textOrientation() {
    return this.getPropertyValue("text-orientation");
  }
  set textOrientation(value2) {
    this.setProperty("text-orientation", value2);
  }
  get textOverflow() {
    return this.getPropertyValue("text-overflow");
  }
  set textOverflow(value2) {
    this.setProperty("text-overflow", value2);
  }
  get textRendering() {
    return this.getPropertyValue("text-rendering");
  }
  set textRendering(value2) {
    this.setProperty("text-rendering", value2);
  }
  get textShadow() {
    return this.getPropertyValue("text-shadow");
  }
  set textShadow(value2) {
    this.setProperty("text-shadow", value2);
  }
  get textSizeAdjust() {
    return this.getPropertyValue("text-size-adjust");
  }
  set textSizeAdjust(value2) {
    this.setProperty("text-size-adjust", value2);
  }
  get textTransform() {
    return this.getPropertyValue("text-transform");
  }
  set textTransform(value2) {
    this.setProperty("text-transform", value2);
  }
  get textUnderlinePosition() {
    return this.getPropertyValue("text-underline-position");
  }
  set textUnderlinePosition(value2) {
    this.setProperty("text-underline-position", value2);
  }
  get top() {
    return this.getPropertyValue("top");
  }
  set top(value2) {
    this.setProperty("top", value2);
  }
  get touchAction() {
    return this.getPropertyValue("touch-action");
  }
  set touchAction(value2) {
    this.setProperty("touch-action", value2);
  }
  get transform() {
    return this.getPropertyValue("transform");
  }
  set transform(value2) {
    this.setProperty("transform", value2);
  }
  get transformBox() {
    return this.getPropertyValue("transform-box");
  }
  set transformBox(value2) {
    this.setProperty("transform-box", value2);
  }
  get transformOrigin() {
    return this.getPropertyValue("transform-origin");
  }
  set transformOrigin(value2) {
    this.setProperty("transform-origin", value2);
  }
  get transformStyle() {
    return this.getPropertyValue("transform-style");
  }
  set transformStyle(value2) {
    this.setProperty("transform-style", value2);
  }
  get transition() {
    return this.getPropertyValue("transition");
  }
  set transition(value2) {
    this.setProperty("transition", value2);
  }
  get transitionDelay() {
    return this.getPropertyValue("transition-delay");
  }
  set transitionDelay(value2) {
    this.setProperty("transition-delay", value2);
  }
  get transitionDuration() {
    return this.getPropertyValue("transition-duration");
  }
  set transitionDuration(value2) {
    this.setProperty("transition-duration", value2);
  }
  get transitionProperty() {
    return this.getPropertyValue("transition-property");
  }
  set transitionProperty(value2) {
    this.setProperty("transition-property", value2);
  }
  get transitionTimingFunction() {
    return this.getPropertyValue("transition-timing-function");
  }
  set transitionTimingFunction(value2) {
    this.setProperty("transition-timing-function", value2);
  }
  get textEmphasisColor() {
    return this.getPropertyValue("text-emphasis-color");
  }
  set textEmphasisColor(value2) {
    this.setProperty("text-emphasis-color", value2);
  }
  get textEmphasisPosition() {
    return this.getPropertyValue("text-emphasis-position");
  }
  set textEmphasisPosition(value2) {
    this.setProperty("text-emphasis-position", value2);
  }
  get textEmphasisStyle() {
    return this.getPropertyValue("text-emphasis-style");
  }
  set textEmphasisStyle(value2) {
    this.setProperty("text-emphasis-style", value2);
  }
  get unicodeBidi() {
    return this.getPropertyValue("unicode-bidi");
  }
  set unicodeBidi(value2) {
    this.setProperty("unicode-bidi", value2);
  }
  get unicodeRange() {
    return this.getPropertyValue("unicode-range");
  }
  set unicodeRange(value2) {
    this.setProperty("unicode-range", value2);
  }
  get userSelect() {
    return this.getPropertyValue("user-select");
  }
  set userSelect(value2) {
    this.setProperty("user-select", value2);
  }
  get userZoom() {
    return this.getPropertyValue("user-zoom");
  }
  set userZoom(value2) {
    this.setProperty("user-zoom", value2);
  }
  get vectorEffect() {
    return this.getPropertyValue("vector-effect");
  }
  set vectorEffect(value2) {
    this.setProperty("vector-effect", value2);
  }
  get verticalAlign() {
    return this.getPropertyValue("vertical-align");
  }
  set verticalAlign(value2) {
    this.setProperty("vertical-align", value2);
  }
  get visibility() {
    return this.getPropertyValue("visibility");
  }
  set visibility(value2) {
    this.setProperty("visibility", value2);
  }
  get whiteSpace() {
    return this.getPropertyValue("white-space");
  }
  set whiteSpace(value2) {
    this.setProperty("white-space", value2);
  }
  get widows() {
    return this.getPropertyValue("widows");
  }
  set widows(value2) {
    this.setProperty("widows", value2);
  }
  get width() {
    return this.getPropertyValue("width");
  }
  set width(value2) {
    this.setProperty("width", value2);
  }
  get willChange() {
    return this.getPropertyValue("will-change");
  }
  set willChange(value2) {
    this.setProperty("will-change", value2);
  }
  get wordBreak() {
    return this.getPropertyValue("word-break");
  }
  set wordBreak(value2) {
    this.setProperty("word-break", value2);
  }
  get wordSpacing() {
    return this.getPropertyValue("word-spacing");
  }
  set wordSpacing(value2) {
    this.setProperty("word-spacing", value2);
  }
  get wordWrap() {
    return this.getPropertyValue("word-wrap");
  }
  set wordWrap(value2) {
    this.setProperty("word-wrap", value2);
  }
  get writingMode() {
    return this.getPropertyValue("writing-mode");
  }
  set writingMode(value2) {
    this.setProperty("writing-mode", value2);
  }
  get x() {
    return this.getPropertyValue("x");
  }
  set x(value2) {
    this.setProperty("x", value2);
  }
  get y() {
    return this.getPropertyValue("y");
  }
  set y(value2) {
    this.setProperty("y", value2);
  }
  get zIndex() {
    return this.getPropertyValue("z-index");
  }
  set zIndex(value2) {
    this.setProperty("z-index", value2);
  }
  get zoom() {
    return this.getPropertyValue("zoom");
  }
  set zoom(value2) {
    this.setProperty("zoom", value2);
  }
  get containerType() {
    return this.getPropertyValue("container-type");
  }
  set containerType(value2) {
    this.setProperty("container-type", value2);
  }
  get containerName() {
    return this.getPropertyValue("container-name");
  }
  set containerName(value2) {
    this.setProperty("container-name", value2);
  }
  get aspectRatio() {
    return this.getPropertyValue("aspect-ratio");
  }
  set aspectRatio(value2) {
    this.setProperty("aspect-ratio", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this.#getPropertyManager().size();
  }
  /**
   * Returns the style decleration as a CSS text.
   *
   * @returns CSS text.
   */
  get cssText() {
    if (this.#element && this.#computed) {
      return "";
    }
    return this.#getPropertyManager().toString();
  }
  /**
   * Sets CSS text.
   *
   * @param cssText CSS text.
   */
  set cssText(cssText2) {
    if (this.#computed) {
      throw new this[window].DOMException(`Failed to execute 'cssText' on 'CSSStyleDeclaration': These styles are computed, and the properties are therefore read-only.`, DOMExceptionNameEnum_default.domException);
    }
    if (this.#element) {
      this.#cache.propertyManager = new CSSStyleDeclarationPropertyManager({ cssText: cssText2 });
      this.#cache.attributeValue = cssText2;
      this.#element.setAttribute("style", this.#cache.propertyManager.toString());
    } else {
      this.#cache.propertyManager = new CSSStyleDeclarationPropertyManager({ cssText: cssText2 });
    }
  }
  /**
   * Returns item.
   *
   * @param index Index.
   * @returns Item.
   */
  item(index) {
    return this.#getPropertyManager().item(index);
  }
  /**
   * Set a property.
   *
   * @param name Property name.
   * @param value Value. Must not contain "!important" as that should be set using the priority parameter.
   * @param [priority] Can be "important", or an empty string.
   */
  setProperty(name2, value2, priority) {
    if (this.#computed) {
      throw new this[window].DOMException(`Failed to execute 'setProperty' on 'CSSStyleDeclaration': These styles are computed, and therefore the '${name2}' property is read-only.`, DOMExceptionNameEnum_default.domException);
    }
    if (priority !== "" && priority !== void 0 && priority !== "important") {
      return;
    }
    const stringValue = String(value2).trim();
    const propertyManager = this.#getPropertyManager();
    if (stringValue) {
      propertyManager.set(name2, stringValue, !!priority);
    } else {
      propertyManager.remove(name2);
    }
    if (this.#element) {
      this.#cache.attributeValue = propertyManager.toString();
      if (this.#cache.attributeValue) {
        this.#element.setAttribute("style", this.#cache.attributeValue);
      } else {
        this.#element.removeAttribute("style");
      }
    }
  }
  /**
   * Removes a property.
   *
   * @param name Property name in kebab case.
   * @param value Value. Must not contain "!important" as that should be set using the priority parameter.
   * @param [priority] Can be "important", or an empty string.
   */
  removeProperty(name2) {
    if (this.#computed) {
      throw new this[window].DOMException(`Failed to execute 'removeProperty' on 'CSSStyleDeclaration': These styles are computed, and therefore the '${name2}' property is read-only.`, DOMExceptionNameEnum_default.domException);
    }
    const propertyManager = this.#getPropertyManager();
    propertyManager.remove(name2);
    if (this.#element) {
      this.#cache.attributeValue = propertyManager.toString();
      if (this.#cache.attributeValue) {
        this.#element.setAttribute("style", this.#cache.attributeValue);
      } else {
        this.#element.removeAttribute("style");
      }
    }
  }
  /**
   * Returns a property.
   *
   * @param name Property name in kebab case.
   * @returns Property value.
   */
  getPropertyValue(name2) {
    return this.#getPropertyManager().get(name2)?.value || "";
  }
  /**
   * Returns a property.
   *
   * @param name Property name in kebab case.
   * @returns "important" if set to be important.
   */
  getPropertyPriority(name2) {
    return this.#getPropertyManager().get(name2)?.important ? "important" : "";
  }
  /**
   * Returns property manager.
   *
   * @returns Property manager.
   */
  #getPropertyManager() {
    const element = this.#element;
    const cache2 = this.#cache;
    if (!element) {
      if (!cache2.propertyManager) {
        cache2.propertyManager = new CSSStyleDeclarationPropertyManager();
      }
      return cache2.propertyManager;
    }
    if (this.#computed) {
      return new CSSStyleDeclarationComputedStyle(element).getComputedStyle();
    }
    const attributeValue2 = element.getAttribute("style") || "";
    if (cache2.attributeValue !== attributeValue2) {
      cache2.propertyManager = new CSSStyleDeclarationPropertyManager({ cssText: attributeValue2 });
    }
    return cache2.propertyManager;
  }
};

// node_modules/happy-dom/lib/css/rules/CSSContainerRule.js
var CSSContainerRule = class extends CSSRule {
  type = CSSRuleTypeEnum_default.containerRule;
  cssRules = [];
  conditionText = "";
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    let cssText2 = "";
    for (const cssRule of this.cssRules) {
      cssText2 += cssRule.cssText;
    }
    return `@container ${this.conditionText} { ${cssText2} }`;
  }
};

// node_modules/happy-dom/lib/css/rules/CSSFontFaceRule.js
var CSSFontFaceRule = class extends CSSRule {
  type = CSSRuleTypeEnum_default.fontFaceRule;
  [cssText] = "";
  #style = null;
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!this.#style) {
      this.#style = new CSSStyleDeclaration(illegalConstructor, this[window]);
      this.#style.parentRule = this;
      this.#style.cssText = this[cssText];
    }
    return this.#style;
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    return `@font-face { ${this.style.cssText} }`;
  }
};

// node_modules/happy-dom/lib/css/rules/CSSKeyframeRule.js
var CSSKeyframeRule = class extends CSSRule {
  type = CSSRuleTypeEnum_default.keyframeRule;
  keyText;
  [cssText] = "";
  #style = null;
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!this.#style) {
      this.#style = new CSSStyleDeclaration(illegalConstructor, this[window]);
      this.#style.parentRule = this;
      this.#style.cssText = this[cssText];
    }
    return this.#style;
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    return `${this.keyText} { ${this.style.cssText} }`;
  }
};

// node_modules/happy-dom/lib/css/rules/CSSKeyframesRule.js
var CSS_RULE_REGEXP = /([^{]+){([^}]+)}/;
var CSSKeyframesRule = class extends CSSRule {
  type = CSSRuleTypeEnum_default.keyframesRule;
  cssRules = [];
  name = null;
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    let cssText2 = "";
    for (const cssRule of this.cssRules) {
      cssText2 += cssRule.cssText + " ";
    }
    return `@keyframes ${this.name} { ${cssText2}}`;
  }
  /**
   * Appends a rule.
   *
   * @param rule Rule. E.g. "0% { transform: rotate(360deg); }".
   */
  appendRule(rule) {
    const match = rule.match(CSS_RULE_REGEXP);
    if (match) {
      const cssRule = new CSSKeyframeRule(illegalConstructor, this[window]);
      const style2 = new CSSStyleDeclaration(illegalConstructor, this[window]);
      cssRule.parentRule = this;
      cssRule.keyText = match[1].trim();
      style2.cssText = match[2].trim();
      style2.parentRule = this;
      cssRule.style = style2;
    }
  }
  /**
   * Removes a rule.
   *
   * @param rule Rule. E.g. "0%".
   */
  deleteRule(rule) {
    for (let i = 0, max = this.cssRules.length; i < max; i++) {
      if (this.cssRules[i].keyText === rule) {
        this.cssRules.splice(i, 1);
        break;
      }
    }
  }
};

// node_modules/happy-dom/lib/css/MediaList.js
var MediaList = class {
  length = 0;
  /**
   * Media text.
   *
   * @returns Media text.
   */
  get mediaText() {
    const mediaText = [];
    for (let i = 0; i < this.length; i++) {
      mediaText.push(this[i]);
    }
    return mediaText.join(", ");
  }
  /**
   * Returns item.
   *
   * @param index Index.
   * @returns Item.
   */
  item(index) {
    return this[index] || "";
  }
  /**
   * Appends a medium.
   *
   * @param medium Medium.
   */
  appendMedium(medium) {
    this[this.length] = medium;
    this.length++;
  }
  /**
   * Deletes a medium.
   *
   * @param medium Medium.
   */
  deleteMedium(medium) {
    let isDeleted = false;
    for (let i = 0; i < this.length; i++) {
      if (isDeleted) {
        this[i - 1] = this[i];
      }
      if (this[i] === medium) {
        isDeleted = true;
      }
    }
    if (isDeleted) {
      this.length--;
    }
  }
};

// node_modules/happy-dom/lib/css/rules/CSSMediaRule.js
var CSSMediaRule = class extends CSSRule {
  type = CSSRuleTypeEnum_default.mediaRule;
  cssRules = [];
  media = new MediaList();
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    let cssText2 = "";
    for (const cssRule of this.cssRules) {
      cssText2 += cssRule.cssText;
    }
    return `@media ${this.conditionText} { ${cssText2} }`;
  }
  /**
   * Returns conditional text.
   *
   * @returns Conditional text.
   */
  get conditionText() {
    return this.media.mediaText;
  }
};

// node_modules/happy-dom/lib/css/rules/CSSStyleRule.js
var CSSStyleRule = class extends CSSRule {
  type = CSSRuleTypeEnum_default.styleRule;
  styleMap = /* @__PURE__ */ new Map();
  selectorText = "";
  [cssText] = "";
  #style = null;
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!this.#style) {
      this.#style = new CSSStyleDeclaration(illegalConstructor, this[window]);
      this.#style.parentRule = this;
      this.#style.cssText = this[cssText];
    }
    return this.#style;
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    return `${this.selectorText} { ${this.style.cssText} }`;
  }
};

// node_modules/happy-dom/lib/css/rules/CSSSupportsRule.js
var CSSSupportsRule = class extends CSSRule {
  type = CSSRuleTypeEnum_default.supportsRule;
  cssRules = [];
  conditionText = "";
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    let cssText2 = "";
    for (const cssRule of this.cssRules) {
      cssText2 += cssRule.cssText;
    }
    return `@supports ${this.conditionText} { ${cssText2} }`;
  }
};

// node_modules/happy-dom/lib/config/NamespaceURI.js
var NamespaceURI_default = {
  html: "http://www.w3.org/1999/xhtml",
  svg: "http://www.w3.org/2000/svg",
  mathML: "http://www.w3.org/1998/Math/MathML",
  xml: "http://www.w3.org/XML/1998/namespace",
  xlink: "http://www.w3.org/1999/xlink",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/happy-dom/lib/utilities/StringUtility.js
var ASCII_LOWER_CASE_CACHE = /* @__PURE__ */ new Map();
var ASCII_UPPER_CASE_CACHE = /* @__PURE__ */ new Map();
var StringUtility = class {
  /**
   * ASCII lowercase.
   *
   * @see https://infra.spec.whatwg.org/#ascii-lowercase
   * @param text Text.
   * @returns Lowercase text.
   */
  static asciiLowerCase(text) {
    const cached = ASCII_LOWER_CASE_CACHE.get(text);
    if (cached) {
      return cached;
    }
    let newText = "";
    for (const char of text) {
      const value2 = char.charCodeAt(0);
      if (value2 >= 65 && value2 <= 90) {
        newText += String.fromCharCode(value2 + 32);
      } else {
        newText += char;
      }
    }
    ASCII_LOWER_CASE_CACHE.set(text, newText);
    return newText;
  }
  /**
   * ASCII uppercase.
   *
   * @see https://infra.spec.whatwg.org/#ascii-uppercase
   * @param text Text.
   * @returns Uppercase text.
   */
  static asciiUpperCase(text) {
    const cached = ASCII_UPPER_CASE_CACHE.get(text);
    if (cached) {
      return cached;
    }
    let newText = "";
    for (const char of text) {
      const value2 = char.charCodeAt(0);
      if (value2 >= 97 && value2 <= 122) {
        newText += String.fromCharCode(value2 - 32);
      } else {
        newText += char;
      }
    }
    ASCII_UPPER_CASE_CACHE.set(text, newText);
    return newText;
  }
};

// node_modules/happy-dom/lib/custom-element/CustomElementUtility.js
var PCEN_CHAR = "[-_.]|[0-9]|[a-z]|\xB7|[\xC0-\xD6]|[\xD8-\xF6]|[\xF8-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u203F-\u2040]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD]|[\u{10000}-\u{EFFFF}]";
var PCEN_REGEXP = new RegExp(`^[a-z](${PCEN_CHAR})*-(${PCEN_CHAR})*$`, "u");
var RESERVED_NAMES = [
  "annotation-xml",
  "color-profile",
  "font-face",
  "font-face-src",
  "font-face-uri",
  "font-face-format",
  "font-face-name",
  "missing-glyph"
];
var CustomElementUtility = class {
  /**
   * Returns true if the tag name is a valid custom element name.
   *
   * @see https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
   * @param name Tag name.
   * @returns True if valid.
   */
  static isValidCustomElementName(name2) {
    return PCEN_REGEXP.test(name2) && !RESERVED_NAMES.includes(name2);
  }
};

// node_modules/happy-dom/lib/custom-element/CustomElementRegistry.js
var CustomElementRegistry = class {
  [registry] = /* @__PURE__ */ new Map();
  [classRegistry] = /* @__PURE__ */ new Map();
  [callbacks] = /* @__PURE__ */ new Map();
  [destroyed] = false;
  #window;
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    if (!window2) {
      throw new TypeError("Illegal constructor");
    }
    this.#window = window2;
  }
  /**
   * Defines a custom element class.
   *
   * @param name Tag name of element.
   * @param elementClass Element class.
   * @param [options] Options.
   * @param [options.extends] Extends tag name.
   */
  define(name2, elementClass, options2) {
    if (this[destroyed]) {
      return;
    }
    if (!CustomElementUtility.isValidCustomElementName(name2)) {
      throw new this.#window.DOMException(`Failed to execute 'define' on 'CustomElementRegistry': "${name2}" is not a valid custom element name`);
    }
    if (this[registry].has(name2)) {
      throw new this.#window.DOMException(`Failed to execute 'define' on 'CustomElementRegistry': the name "${name2}" has already been used with this registry`);
    }
    if (this[classRegistry].has(elementClass)) {
      throw new this.#window.DOMException("Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry");
    }
    const tagName2 = StringUtility.asciiUpperCase(name2);
    elementClass.prototype[window] = this.#window;
    elementClass.prototype[ownerDocument] = this.#window.document;
    elementClass.prototype[tagName] = tagName2;
    elementClass.prototype[localName] = name2;
    elementClass.prototype[namespaceURI] = NamespaceURI_default.html;
    const observedAttributes = /* @__PURE__ */ new Set();
    const elementObservervedAttributes = elementClass.observedAttributes;
    if (Array.isArray(elementObservervedAttributes)) {
      for (const attribute of elementObservervedAttributes) {
        observedAttributes.add(String(attribute).toLowerCase());
      }
    }
    this[registry].set(name2, {
      elementClass,
      extends: options2 && options2.extends ? options2.extends.toLowerCase() : null,
      observedAttributes,
      livecycleCallbacks: {
        connectedCallback: elementClass.prototype.connectedCallback,
        disconnectedCallback: elementClass.prototype.disconnectedCallback,
        attributeChangedCallback: elementClass.prototype.attributeChangedCallback
      }
    });
    this[classRegistry].set(elementClass, name2);
    const callbacks2 = this[callbacks].get(name2);
    if (callbacks2) {
      this[callbacks].delete(name2);
      for (const callback of callbacks2) {
        callback();
      }
    }
  }
  /**
   * Returns a defined element class.
   *
   * @param name Tag name of element.
   * @returns HTMLElement Class defined or undefined.
   */
  get(name2) {
    return this[registry].get(name2)?.elementClass;
  }
  /**
   * Upgrades a custom element directly, even before it is connected to its shadow root.
   *
   * Not implemented yet.
   *
   * @param _root Root node.
   */
  upgrade(_root) {
  }
  /**
   * When defined.
   *
   * @param name Tag name of element.
   */
  whenDefined(name2) {
    if (this[destroyed]) {
      return Promise.reject(new this.#window.DOMException(`Failed to execute 'whenDefined' on 'CustomElementRegistry': The custom element registry has been destroyed.`));
    }
    if (!CustomElementUtility.isValidCustomElementName(name2)) {
      return Promise.reject(new this.#window.DOMException(`Failed to execute 'whenDefined' on 'CustomElementRegistry': Invalid custom element name: "${name2}"`));
    }
    if (this.get(name2)) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const callbacks2 = this[callbacks].get(name2);
      if (callbacks2) {
        callbacks2.push(resolve);
      } else {
        this[callbacks].set(name2, [resolve]);
      }
    });
  }
  /**
   * Reverse lookup searching for name by given element class.
   *
   * @param elementClass Class constructor.
   * @returns Found tag name or `null`.
   */
  getName(elementClass) {
    return this[classRegistry].get(elementClass) || null;
  }
  /**
   * Destroys the registry.
   */
  [destroy]() {
    this[destroyed] = true;
    for (const definition of this[registry].values()) {
      definition.elementClass.prototype[window] = null;
      definition.elementClass.prototype[ownerDocument] = null;
      definition.elementClass.prototype[tagName] = null;
      definition.elementClass.prototype[localName] = null;
      definition.elementClass.prototype[namespaceURI] = null;
    }
    this[registry] = /* @__PURE__ */ new Map();
    this[classRegistry] = /* @__PURE__ */ new Map();
    this[callbacks] = /* @__PURE__ */ new Map();
  }
};

// node_modules/happy-dom/lib/event/Touch.js
var Touch = class {
  identifier;
  target;
  clientX;
  clientY;
  screenX;
  screenY;
  pageX;
  pageY;
  radiusX;
  radiusY;
  rotationAngle;
  force;
  /**
   * Constructor.
   *
   * @param [touchInit] Touch init.
   */
  constructor(touchInit) {
    this.identifier = touchInit.identifier;
    this.target = touchInit.target;
    this.clientX = touchInit.clientX ?? 0;
    this.clientY = touchInit.clientY ?? 0;
    this.screenX = touchInit.screenX ?? 0;
    this.screenY = touchInit.screenY ?? 0;
    this.pageX = touchInit.pageX ?? 0;
    this.pageY = touchInit.pageY ?? 0;
    this.radiusX = touchInit.radiusX ?? 0;
    this.radiusY = touchInit.radiusY ?? 0;
    this.rotationAngle = touchInit.rotationAngle ?? 0;
    this.force = touchInit.force ?? 0;
  }
};

// node_modules/happy-dom/lib/event/UIEvent.js
var UIEvent = class extends Event {
  static NONE = 0;
  static CAPTURING_PHASE = 1;
  static AT_TARGET = 2;
  static BUBBLING_PHASE = 3;
  detail;
  layerX = 0;
  layerY = 0;
  pageX = 0;
  pageY = 0;
  view;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.detail = eventInit?.detail ?? 0;
    this.view = eventInit?.view ?? null;
  }
};

// node_modules/happy-dom/lib/event/events/AnimationEvent.js
var AnimationEvent = class extends Event {
  animationName;
  elapsedTime;
  pseudoElement;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.animationName = eventInit?.animationName ?? "";
    this.elapsedTime = eventInit?.elapsedTime ?? 0;
    this.pseudoElement = eventInit?.pseudoElement ?? "";
  }
};

// node_modules/happy-dom/lib/event/events/ClipboardEvent.js
var ClipboardEvent = class extends Event {
  clipboardData;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.clipboardData = eventInit?.clipboardData ?? null;
  }
};

// node_modules/happy-dom/lib/event/events/CustomEvent.js
var CustomEvent = class extends Event {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [detail];
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this[detail] = eventInit?.detail ?? null;
  }
  /**
   * Returns detail.
   *
   * @returns Detail.
   */
  get detail() {
    return this[detail];
  }
  /**
   * Init event.
   *
   * @deprecated
   * @param type Type.
   * @param [bubbles=false] "true" if it bubbles.
   * @param [cancelable=false] "true" if it cancelable.
   * @param [detail=null] Custom event detail.
   */
  initCustomEvent(type2, bubbles2 = false, cancelable2 = false, detail2 = null) {
    this[type] = type2;
    this[bubbles] = bubbles2;
    this[cancelable] = cancelable2;
    this[detail] = detail2;
  }
};

// node_modules/happy-dom/lib/event/events/ErrorEvent.js
var ErrorEvent = class extends UIEvent {
  message;
  filename;
  lineno;
  colno;
  error;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.message = eventInit?.message ?? "";
    this.filename = eventInit?.filename ?? "";
    this.lineno = eventInit?.lineno ?? 0;
    this.colno = eventInit?.colno ?? 0;
    this.error = eventInit?.error ?? null;
  }
};

// node_modules/happy-dom/lib/event/events/FocusEvent.js
var FocusEvent = class extends UIEvent {
  relatedTarget;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.relatedTarget = eventInit?.relatedTarget ?? null;
  }
};

// node_modules/happy-dom/lib/event/events/HashChangeEvent.js
var HashChangeEvent = class extends Event {
  newURL;
  oldURL;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.newURL = eventInit?.newURL ?? "";
    this.oldURL = eventInit?.oldURL ?? "";
  }
};

// node_modules/happy-dom/lib/event/events/InputEvent.js
var InputEvent = class extends UIEvent {
  data;
  dataTransfer;
  inputType;
  isComposing;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.data = eventInit?.data ?? "";
    this.dataTransfer = eventInit?.dataTransfer ?? null;
    this.inputType = eventInit?.inputType ?? "";
    this.isComposing = eventInit?.isComposing ?? false;
  }
};

// node_modules/happy-dom/lib/event/events/KeyboardEvent.js
var KeyboardEvent = class extends UIEvent {
  static DOM_KEY_LOCATION_STANDARD = 0;
  static DOM_KEY_LOCATION_LEFT = 1;
  static DOM_KEY_LOCATION_RIGHT = 2;
  static DOM_KEY_LOCATION_NUMPAD = 3;
  altKey;
  code;
  ctrlKey;
  isComposing;
  key;
  location;
  metaKey;
  repeat;
  shiftKey;
  /**
   * @deprecated
   */
  keyCode;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.altKey = eventInit?.altKey ?? false;
    this.code = eventInit?.code ?? "";
    this.ctrlKey = eventInit?.ctrlKey ?? false;
    this.isComposing = eventInit?.isComposing ?? false;
    this.key = eventInit?.key ?? "";
    this.location = eventInit?.location ?? 0;
    this.metaKey = eventInit?.metaKey ?? false;
    this.repeat = eventInit?.repeat ?? false;
    this.shiftKey = eventInit?.shiftKey ?? false;
    this.keyCode = eventInit?.keyCode ?? 0;
  }
  /**
   * Returns the state of a modifier key.
   *
   * @param key A modifier key value.
   * @returns True if it's pressed, false otherwise.
   */
  getModifierState(key) {
    if (arguments.length < 1) {
      throw new TypeError("Failed to execute 'getModifierState' on 'KeyboardEvent': 1 argument required, but only 0 present.");
    }
    switch (String(key).toLowerCase()) {
      case "alt":
      case "altgraph":
        return this.altKey;
      case "control":
        return this.ctrlKey;
      case "meta":
        return this.metaKey;
      case "shift":
        return this.shiftKey;
      default:
        return false;
    }
  }
};

// node_modules/happy-dom/lib/event/events/MessageEvent.js
var MessageEvent = class extends Event {
  data;
  origin;
  lastEventId;
  source;
  ports;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.data = eventInit?.data ?? null;
    this.origin = eventInit?.origin ?? "";
    this.lastEventId = eventInit?.lastEventId ?? "";
    this.source = eventInit?.source ?? null;
    this.ports = eventInit?.ports ?? [];
  }
};

// node_modules/happy-dom/lib/event/events/MouseEvent.js
var MouseEvent = class extends UIEvent {
  altKey;
  button;
  buttons;
  clientX;
  clientY;
  ctrlKey;
  metaKey;
  movementX;
  movementY;
  offsetX;
  offsetY;
  region;
  relatedTarget;
  screenX;
  screenY;
  shiftKey;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.altKey = eventInit?.altKey ?? false;
    this.button = eventInit?.button ?? 0;
    this.buttons = eventInit?.buttons ?? 0;
    this.clientX = eventInit?.clientX ?? 0;
    this.clientY = eventInit?.clientY ?? 0;
    this.ctrlKey = eventInit?.ctrlKey ?? false;
    this.metaKey = eventInit?.metaKey ?? false;
    this.movementX = eventInit?.movementX ?? 0;
    this.movementY = eventInit?.movementY ?? 0;
    this.region = eventInit?.region ?? "";
    this.relatedTarget = eventInit?.relatedTarget ?? null;
    this.screenX = eventInit?.screenX ?? 0;
    this.screenY = eventInit?.screenY ?? 0;
    this.shiftKey = eventInit?.shiftKey ?? false;
  }
};

// node_modules/happy-dom/lib/event/events/PointerEvent.js
var PointerEvent = class extends MouseEvent {
  pointerId;
  width;
  height;
  pressure;
  tangentialPressure;
  tiltX;
  tiltY;
  twist;
  altitudeAngle;
  azimuthAngle;
  pointerType;
  isPrimary;
  coalescedEvents;
  predictedEvents;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.pointerId = eventInit?.pointerId ?? 0;
    this.width = eventInit?.width ?? 1;
    this.height = eventInit?.height ?? 1;
    this.pressure = eventInit?.pressure ?? 0;
    this.tangentialPressure = eventInit?.tangentialPressure ?? 0;
    this.tiltX = eventInit?.tiltX ?? 0;
    this.tiltY = eventInit?.tiltY ?? 0;
    this.twist = eventInit?.twist ?? 0;
    this.altitudeAngle = eventInit?.altitudeAngle ?? 0;
    this.azimuthAngle = eventInit?.azimuthAngle ?? 0;
    this.pointerType = eventInit?.pointerType ?? "";
    this.isPrimary = eventInit?.isPrimary ?? false;
    this.coalescedEvents = eventInit?.coalescedEvents ?? [];
    this.predictedEvents = eventInit?.predictedEvents ?? [];
  }
  getCoalescedEvents = () => this.coalescedEvents;
  getPredictedEvents = () => this.predictedEvents;
};

// node_modules/happy-dom/lib/event/events/ProgressEvent.js
var ProgressEvent = class extends Event {
  lengthComputable;
  loaded;
  total;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2);
    this.lengthComputable = eventInit?.lengthComputable ?? false;
    this.loaded = eventInit?.loaded ?? 0;
    this.total = eventInit?.total ?? 0;
  }
};

// node_modules/happy-dom/lib/event/events/StorageEvent.js
var StorageEvent = class extends Event {
  key;
  oldValue;
  newValue;
  url;
  storageArea;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2);
    this.key = eventInit?.key ?? null;
    this.oldValue = eventInit?.oldValue ?? null;
    this.newValue = eventInit?.newValue ?? null;
    this.url = eventInit?.url ?? "";
    this.storageArea = eventInit?.storageArea ?? null;
  }
};

// node_modules/happy-dom/lib/event/events/SubmitEvent.js
var SubmitEvent = class extends Event {
  submitter;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.submitter = eventInit?.submitter ?? null;
  }
};

// node_modules/happy-dom/lib/event/events/TouchEvent.js
var TouchEvent = class extends UIEvent {
  altKey;
  changedTouches;
  ctrlKey;
  metaKey;
  shiftKey;
  targetTouches;
  touches;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.altKey = eventInit?.altKey ?? false;
    this.changedTouches = eventInit?.changedTouches ?? [];
    this.ctrlKey = eventInit?.ctrlKey ?? false;
    this.metaKey = eventInit?.metaKey ?? false;
    this.shiftKey = eventInit?.shiftKey ?? false;
    this.targetTouches = eventInit?.targetTouches ?? [];
    this.touches = eventInit?.touches ?? [];
  }
};

// node_modules/happy-dom/lib/event/events/WheelEvent.js
var WheelEvent = class extends UIEvent {
  static DOM_DELTA_PIXEL = 0;
  static DOM_DELTA_LINE = 1;
  static DOM_DELTA_PAGE = 2;
  deltaX;
  deltaY;
  deltaZ;
  deltaMode;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.deltaX = eventInit?.deltaX ?? 0;
    this.deltaY = eventInit?.deltaY ?? 0;
    this.deltaZ = eventInit?.deltaZ ?? 0;
    this.deltaMode = eventInit?.deltaMode ?? 0;
  }
};

// node_modules/happy-dom/lib/url/URL.js
import { URL as NodeJSURL } from "url";
import { Blob as NodeJSBlob } from "buffer";
var URL2 = class extends NodeJSURL {
  /**
   * Creates a string containing a URL representing the object given in the parameter.
   *
   * @param object Object.
   * @returns URL.
   */
  static createObjectURL(object) {
    if (object instanceof Blob) {
      const blob = new NodeJSBlob([object[buffer]], { type: object.type });
      return super.createObjectURL(blob);
    }
    return super.createObjectURL(object);
  }
};

// node_modules/happy-dom/lib/fetch/utilities/FetchRequestReferrerUtility.js
import { isIP } from "net";
var REQUEST_REFERRER_UNSUPPORTED_PROTOCOL_REGEXP = /^(about|blob|data):$/;
var REFERRER_POLICIES = [
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
];
var FetchRequestReferrerUtility = class {
  /**
   * Prepares the request before being sent.
   *
   * @param originURL Origin URL.
   * @param request Request.
   */
  static prepareRequest(originURL, request) {
    if (!request.referrerPolicy) {
      request[referrerPolicy] = "strict-origin-when-cross-origin";
    }
    if (request.referrer && request.referrer !== "no-referrer") {
      request[referrer] = this.getSentReferrer(originURL, request);
    } else {
      request[referrer] = "no-referrer";
    }
  }
  /**
   * Returns initial referrer.
   *
   * @param window Window.
   * @param referrer Referrer.
   * @returns Initial referrer.
   */
  static getInitialReferrer(window2, referrer2) {
    if (referrer2 === "" || referrer2 === "no-referrer" || referrer2 === "client") {
      return referrer2;
    } else if (referrer2) {
      const referrerURL = referrer2 instanceof URL2 ? referrer2 : new URL2(referrer2, window2.location.href);
      return referrerURL.origin === window2.location.origin ? referrerURL : "client";
    }
    return "client";
  }
  /**
   * Returns referrer policy from header.
   *
   * @see https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header
   * @param headers Response headers
   * @returns Policy.
   */
  static getReferrerPolicyFromHeader(headers2) {
    const referrerPolicyHeader = headers2.get("Referrer-Policy");
    if (!referrerPolicyHeader) {
      return "";
    }
    const policyTokens = referrerPolicyHeader.split(/[,\s]+/);
    let policy = "";
    for (const token of policyTokens) {
      if (token && REFERRER_POLICIES.includes(token)) {
        policy = token;
      }
    }
    return policy;
  }
  /**
   * Returns the request referrer to be used as the value for the "Referer" header.
   *
   * Based on:
   * https://github.com/node-fetch/node-fetch/blob/main/src/utils/referrer.js (MIT)
   *
   * @see https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer
   * @param originURL Origin URL.
   * @param request Request.
   * @returns Request referrer.
   */
  static getSentReferrer(originURL, request) {
    if (request.referrer === "about:client" && originURL.origin === "null") {
      return "no-referrer";
    }
    const requestURL = new URL2(request.url);
    const referrerURL = request.referrer === "about:client" ? new URL2(originURL.href) : new URL2(request.referrer);
    if (REQUEST_REFERRER_UNSUPPORTED_PROTOCOL_REGEXP.test(referrerURL.protocol)) {
      return "no-referrer";
    }
    referrerURL.username = "";
    referrerURL.password = "";
    referrerURL.hash = "";
    switch (request.referrerPolicy) {
      case "no-referrer":
        return "no-referrer";
      case "origin":
        return new URL2(referrerURL.origin);
      case "unsafe-url":
        return referrerURL;
      case "strict-origin":
        if (this.isURLPotentiallyTrustWorthy(referrerURL) && !this.isURLPotentiallyTrustWorthy(requestURL)) {
          return "no-referrer";
        }
        return new URL2(referrerURL.origin);
      case "strict-origin-when-cross-origin":
        if (referrerURL.origin === requestURL.origin) {
          return referrerURL;
        }
        if (this.isURLPotentiallyTrustWorthy(referrerURL) && !this.isURLPotentiallyTrustWorthy(requestURL)) {
          return "no-referrer";
        }
        return new URL2(referrerURL.origin);
      case "same-origin":
        if (referrerURL.origin === requestURL.origin) {
          return referrerURL;
        }
        return "no-referrer";
      case "origin-when-cross-origin":
        if (referrerURL.origin === requestURL.origin) {
          return referrerURL;
        }
        return new URL2(referrerURL.origin);
      case "no-referrer-when-downgrade":
        if (this.isURLPotentiallyTrustWorthy(referrerURL) && !this.isURLPotentiallyTrustWorthy(requestURL)) {
          return "no-referrer";
        }
        return referrerURL;
    }
    return "no-referrer";
  }
  /**
   * Returns "true" if the request's referrer is potentially trustworthy.
   *
   * @see https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy
   * @param url URL.
   * @returns "true" if the request's referrer is potentially trustworthy.
   */
  static isURLPotentiallyTrustWorthy(url2) {
    if (/^about:(blank|srcdoc)$/.test(url2.href)) {
      return true;
    }
    if (url2.protocol === "data:") {
      return true;
    }
    if (/^(blob|filesystem):$/.test(url2.protocol)) {
      return true;
    }
    return this.isOriginPotentiallyTrustWorthy(url2);
  }
  /**
   * Returns "true" if the request's referrer origin is potentially trustworthy.
   *
   * @see https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy
   * @param url URL.
   * @returns "true" if the request's referrer origin is potentially trustworthy.
   */
  static isOriginPotentiallyTrustWorthy(url2) {
    if (/^(http|ws)s:$/.test(url2.protocol)) {
      return true;
    }
    const hostIp = url2.host.replace(/(^\[)|(]$)/g, "");
    const hostIPVersion = isIP(hostIp);
    if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
      return true;
    }
    if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
      return true;
    }
    if (url2.host === "localhost" || url2.host.endsWith(".localhost")) {
      return false;
    }
    if (url2.protocol === "file:") {
      return true;
    }
    return false;
  }
};

// node_modules/happy-dom/lib/fetch/Fetch.js
import HTTP from "http";
import HTTPS from "https";
import Zlib from "zlib";
import { URL as URL5 } from "url";
import FS from "fs";
import Path2 from "path";
import Stream2 from "stream";

// node_modules/happy-dom/lib/fetch/data-uri/DataURIParser.js
var DataURIParser = class {
  /**
   * Returns a Buffer instance from the given data URI `uri`.
   *
   * @param uri Data URI.
   * @returns Buffer.
   */
  static parse(uri) {
    if (!/^data:/i.test(uri)) {
      throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    }
    uri = uri.replace(/\r?\n/g, "");
    const firstComma = uri.indexOf(",");
    if (firstComma === -1 || firstComma <= 4) {
      throw new TypeError("malformed data: URI");
    }
    const meta = uri.substring(5, firstComma).split(";");
    let charset = "";
    let base64 = false;
    let type2 = meta[0] || "text/plain";
    for (let i = 1; i < meta.length; i++) {
      if (meta[i] === "base64") {
        base64 = true;
      } else if (meta[i]) {
        type2 += `;${meta[i]}`;
        if (meta[i].indexOf("charset=") === 0) {
          charset = meta[i].substring(8);
        }
      }
    }
    if (!meta[0] && !charset.length) {
      type2 += ";charset=US-ASCII";
      charset = "US-ASCII";
    }
    const encoding = base64 ? "base64" : "ascii";
    const data2 = unescape(uri.substring(firstComma + 1));
    const buffer2 = Buffer.from(data2, encoding);
    return {
      type: type2,
      charset,
      buffer: buffer2
    };
  }
};

// node_modules/happy-dom/lib/fetch/utilities/FetchCORSUtility.js
import { URL as URL3 } from "url";
var FetchCORSUtility = class {
  /**
   * Validates request headers.
   *
   * @param originURL Origin URL.
   * @param targetURL Target URL.
   */
  static isCORS(originURL, targetURL) {
    originURL = typeof originURL === "string" ? new URL3(originURL) : originURL;
    targetURL = typeof targetURL === "string" ? new URL3(targetURL) : targetURL;
    if (targetURL.protocol === "about:" || targetURL.protocol === "javascript:") {
      return false;
    }
    return originURL.hostname !== targetURL.hostname && !originURL.hostname.endsWith(targetURL.hostname) || originURL.protocol !== targetURL.protocol;
  }
};

// node_modules/happy-dom/lib/fetch/Response.js
import { URLSearchParams as URLSearchParams3 } from "url";

// node_modules/happy-dom/lib/fetch/multipart/MultipartFormDataParser.js
import { ReadableStream as ReadableStream2 } from "stream/web";

// node_modules/happy-dom/lib/file/File.js
var File = class extends Blob {
  lastModified = null;
  name = null;
  /**
   * Constructor.
   *
   * @param bits File bits.
   * @param name File name.
   * @param [options] Options.
   * @param [options.type] MIME type.
   * @param [options.lastModifier] Last modified. Defaults to Date.now().
   * @param options.lastModified
   */
  constructor(bits, name2, options2) {
    if (arguments.length < 2) {
      throw new TypeError("Failed to construct 'File': 2 arguments required, but only " + arguments.length + " present.");
    }
    super(bits, options2);
    this.name = name2;
    this.lastModified = options2 && options2.lastModified ? options2.lastModified : Date.now();
  }
};

// node_modules/happy-dom/lib/fetch/multipart/MultipartReader.js
var MultipartParserStateEnum;
(function(MultipartParserStateEnum2) {
  MultipartParserStateEnum2[MultipartParserStateEnum2["boundary"] = 0] = "boundary";
  MultipartParserStateEnum2[MultipartParserStateEnum2["headerStart"] = 2] = "headerStart";
  MultipartParserStateEnum2[MultipartParserStateEnum2["header"] = 3] = "header";
  MultipartParserStateEnum2[MultipartParserStateEnum2["data"] = 5] = "data";
})(MultipartParserStateEnum || (MultipartParserStateEnum = {}));
var CHARACTER_CODE = {
  lf: 10,
  cr: 13
};
var MultipartReader = class {
  formData;
  boundary;
  boundaryIndex = 0;
  state = MultipartParserStateEnum.boundary;
  data = {
    contentDisposition: null,
    value: [],
    contentType: null,
    header: ""
  };
  /**
   * Constructor.
   *
   * @param window Window.
   * @param formData Form data.
   * @param boundary Boundary.
   */
  constructor(window2, boundary) {
    const boundaryHeader = `--${boundary}`;
    this.boundary = new Uint8Array(boundaryHeader.length);
    this.formData = new window2.FormData();
    for (let i = 0, max = boundaryHeader.length; i < max; i++) {
      this.boundary[i] = boundaryHeader.charCodeAt(i);
    }
  }
  /**
   * Appends data.
   *
   * @param data Data.
   */
  write(data2) {
    let char;
    let nextChar;
    for (let i = 0, max = data2.length; i < max; i++) {
      char = data2[i];
      nextChar = data2[i + 1];
      switch (this.state) {
        case MultipartParserStateEnum.boundary:
          if (char === this.boundary[this.boundaryIndex]) {
            this.boundaryIndex++;
          } else {
            this.boundaryIndex = 0;
          }
          if (this.boundaryIndex === this.boundary.length) {
            this.state = MultipartParserStateEnum.headerStart;
            this.boundaryIndex = 0;
          }
          break;
        case MultipartParserStateEnum.headerStart:
          if (nextChar !== CHARACTER_CODE.cr && nextChar !== CHARACTER_CODE.lf) {
            this.data.header = "";
            this.state = data2[i - 2] === CHARACTER_CODE.lf ? MultipartParserStateEnum.data : MultipartParserStateEnum.header;
          }
          break;
        case MultipartParserStateEnum.header:
          if (char === CHARACTER_CODE.cr) {
            if (this.data.header) {
              const headerParts = this.data.header.split(":");
              if (headerParts.length > 1) {
                const headerName = headerParts[0].toLowerCase();
                const headerValue = headerParts[1].trim();
                switch (headerName) {
                  case "content-disposition":
                    this.data.contentDisposition = this.getContentDisposition(headerValue);
                    break;
                  case "content-type":
                    this.data.contentType = headerValue;
                    break;
                }
              }
            }
            this.state = MultipartParserStateEnum.headerStart;
          } else {
            this.data.header += String.fromCharCode(char);
          }
          break;
        case MultipartParserStateEnum.data:
          if (char === this.boundary[this.boundaryIndex]) {
            this.boundaryIndex++;
          } else {
            this.boundaryIndex = 0;
          }
          if (this.boundaryIndex === this.boundary.length) {
            this.state = MultipartParserStateEnum.headerStart;
            if (this.data.value.length) {
              this.appendFormData(this.data.contentDisposition.name, Buffer.from(this.data.value.slice(0, -(this.boundary.length + 1))), this.data.contentDisposition.filename, this.data.contentType);
              this.data.value = [];
              this.data.contentDisposition = null;
              this.data.contentType = null;
            }
            this.boundaryIndex = 0;
          } else {
            this.data.value.push(char);
          }
          break;
      }
    }
  }
  /**
   * Ends the stream.
   *
   * @returns Form data.
   */
  end() {
    if (this.data.contentDisposition && this.data.value.length) {
      this.appendFormData(this.data.contentDisposition.name, Buffer.from(this.data.value.slice(0, -2)), this.data.contentDisposition.filename, this.data.contentType);
    }
    return this.formData;
  }
  /**
   * Appends data.
   *
   * @param key Key.
   * @param value value.
   * @param filename Filename.
   * @param type Type.
   */
  appendFormData(key, value2, filename, type2) {
    if (!value2.length) {
      return;
    }
    if (filename) {
      this.formData.append(key, new File([value2], filename, {
        type: type2
      }));
    } else {
      this.formData.append(key, value2.toString());
    }
  }
  /**
   * Returns content disposition.
   *
   * @param headerValue Header value.
   * @returns Content disposition.
   */
  getContentDisposition(headerValue) {
    const regex = /([a-z]+) *= *"([^"]+)"/g;
    const contentDisposition = {};
    let match;
    while (match = regex.exec(headerValue)) {
      contentDisposition[match[1]] = match[2];
    }
    return contentDisposition;
  }
};

// node_modules/happy-dom/lib/fetch/multipart/MultipartFormDataParser.js
import { Buffer as Buffer3 } from "buffer";
var MultipartFormDataParser = class {
  /**
   * Returns form data.
   *
   * @param window Window.
   * @param body Body.
   * @param contentType Content type header value.
   * @returns Form data.
   */
  static async streamToFormData(window2, body2, contentType2) {
    if (!/multipart/i.test(contentType2)) {
      throw new window2.DOMException(`Failed to build FormData object: The "content-type" header isn't of type "multipart/form-data".`, DOMExceptionNameEnum_default.invalidStateError);
    }
    const match = contentType2.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
    if (!match) {
      throw new window2.DOMException(`Failed to build FormData object: The "content-type" header doesn't contain any multipart boundary.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    const bodyReader = body2.getReader();
    const reader = new MultipartReader(window2, match[1] || match[2]);
    const chunks = [];
    let buffer2;
    const bytes = 0;
    let readResult = await bodyReader.read();
    while (!readResult.done) {
      if (body2[error]) {
        throw body2[error];
      }
      if (body2[aborted]) {
        throw new window2.DOMException("Failed to read response body: The stream was aborted.", DOMExceptionNameEnum_default.abortError);
      }
      reader.write(readResult.value);
      readResult = await bodyReader.read();
    }
    try {
      buffer2 = typeof chunks[0] === "string" ? Buffer3.from(chunks.join("")) : Buffer3.concat(chunks, bytes);
    } catch (error2) {
      throw new window2.DOMException(`Could not create Buffer from response body. Error: ${error2.message}.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    return {
      formData: reader.end(),
      buffer: buffer2
    };
  }
  /**
   * Converts a FormData object to a ReadableStream.
   *
   * @param formData FormData.
   * @returns Stream and type.
   */
  static formDataToStream(formData) {
    const boundary = "----HappyDOMFormDataBoundary" + Math.random().toString(36);
    const chunks = [];
    const prefix2 = `--${boundary}\r
Content-Disposition: form-data; name="`;
    for (const [name2, value2] of formData) {
      if (typeof value2 === "string") {
        chunks.push(Buffer3.from(`${prefix2}${this.escapeName(name2)}"\r
\r
${value2.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`));
      } else {
        chunks.push(Buffer3.from(`${prefix2}${this.escapeName(name2)}"; filename="${this.escapeName(value2.name, true)}"\r
Content-Type: ${value2.type || "application/octet-stream"}\r
\r
`));
        chunks.push(value2[buffer]);
        chunks.push(Buffer3.from("\r\n"));
      }
    }
    chunks.push(Buffer3.from(`--${boundary}--\r
`));
    const buffer2 = Buffer3.concat(chunks);
    return {
      contentType: `multipart/form-data; boundary=${boundary}`,
      contentLength: buffer2.length,
      buffer: buffer2,
      stream: new ReadableStream2({
        start(controller) {
          controller.enqueue(buffer2);
          controller.close();
        }
      })
    };
  }
  /**
   * Escapes a form data entry name.
   *
   * @param name Name.
   * @param filename Whether it is a filename.
   * @returns Escaped name.
   */
  static escapeName(name2, filename = false) {
    return (filename ? name2 : name2.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
  }
};

// node_modules/happy-dom/lib/fetch/utilities/FetchBodyUtility.js
import { ReadableStream as ReadableStream3 } from "stream/web";
import { URLSearchParams as URLSearchParams2 } from "url";

// node_modules/happy-dom/lib/form-data/FormData.js
var FormData = class {
  #entries = [];
  /**
   * Constructor.
   *
   * @param [form] Form.
   */
  constructor(form) {
    if (!form) {
      return;
    }
    const items2 = form[getFormControlItems]();
    for (const item of items2) {
      const name2 = item.name;
      if (name2) {
        switch (item[tagName]) {
          case "INPUT":
            switch (item.type) {
              case "file":
                if (item[files].length === 0) {
                  this.append(name2, new File([], "", { type: "application/octet-stream" }));
                } else {
                  for (const file of item[files]) {
                    this.append(name2, file);
                  }
                }
                break;
              case "checkbox":
              case "radio":
                if (item.checked) {
                  this.append(name2, item.value);
                }
                break;
              case "submit":
              case "reset":
              case "button":
                if (item.value) {
                  this.append(name2, item.value);
                }
                break;
              default:
                this.append(name2, item.value);
                break;
            }
            break;
          case "BUTTON":
            if (item.value) {
              this.append(name2, item.value);
            }
            break;
          case "TEXTAREA":
          case "SELECT":
            this.append(name2, item.value);
            break;
        }
      }
    }
  }
  /**
   * For each.
   *
   * @param callback Callback.
   */
  forEach(callback) {
    for (const entry of this.#entries) {
      callback.call(this, entry.value, entry.name, this);
    }
  }
  /**
   * Appends a new value onto an existing key.
   *
   * @param name Name.
   * @param value Value.
   * @param [filename] Filename.
   */
  append(name2, value2, filename) {
    if (filename && !(value2 instanceof Blob)) {
      throw new this[window].TypeError('Failed to execute "append" on "FormData": parameter 2 is not of type "Blob".');
    }
    this.#entries.push({
      name: name2,
      value: this.#parseValue(value2, filename)
    });
  }
  /**
   * Removes a value.
   *
   * @param name Name.
   */
  delete(name2) {
    const newEntries = [];
    for (const entry of this.#entries) {
      if (entry.name !== name2) {
        newEntries.push(entry);
      }
    }
    this.#entries = newEntries;
  }
  /**
   * Returns value.
   *
   * @param name Name.
   * @returns Value.
   */
  get(name2) {
    for (const entry of this.#entries) {
      if (entry.name === name2) {
        return entry.value;
      }
    }
    return null;
  }
  /**
   * Returns all values associated with the given name.
   *
   * @param name Name.
   * @returns Values.
   */
  getAll(name2) {
    const values2 = [];
    for (const entry of this.#entries) {
      if (entry.name === name2) {
        values2.push(entry.value);
      }
    }
    return values2;
  }
  /**
   * Returns whether a FormData object contains a certain key.
   *
   * @param name Name.
   * @returns "true" if the FormData object contains the key.
   */
  has(name2) {
    for (const entry of this.#entries) {
      if (entry.name === name2) {
        return true;
      }
    }
    return false;
  }
  /**
   * Sets a new value for an existing key inside a FormData object, or adds the key/value if it does not already exist.
   *
   * @param name Name.
   * @param value Value.
   * @param [filename] Filename.
   */
  set(name2, value2, filename) {
    for (const entry of this.#entries) {
      if (entry.name === name2) {
        entry.value = this.#parseValue(value2, filename);
        return;
      }
    }
    this.append(name2, value2);
  }
  /**
   * Returns an iterator, allowing you to go through all keys of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *keys() {
    for (const entry of this.#entries) {
      yield entry.name;
    }
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *values() {
    for (const entry of this.#entries) {
      yield entry.value;
    }
  }
  /**
   * Returns an iterator, allowing you to go through all key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *entries() {
    for (const entry of this.#entries) {
      yield [entry.name, entry.value];
    }
  }
  /**
   * Iterator.
   *
   * @returns Iterator.
   */
  *[Symbol.iterator]() {
    for (const entry of this.#entries) {
      yield [entry.name, entry.value];
    }
  }
  /**
   * Parses a value.
   *
   * @param value Value.
   * @param [filename] Filename.
   * @returns Parsed value.
   */
  #parseValue(value2, filename) {
    if (value2 instanceof File) {
      if (filename) {
        const file = new File([], filename, { type: value2.type, lastModified: value2.lastModified });
        file[buffer] = value2[buffer];
        return file;
      }
      return value2;
    }
    if (value2 instanceof Blob) {
      const file = new File([], "blob", { type: value2.type });
      file[buffer] = value2[buffer];
      return file;
    }
    return String(value2);
  }
};

// node_modules/happy-dom/lib/fetch/utilities/FetchBodyUtility.js
import { Buffer as Buffer4 } from "buffer";
import Stream from "stream";
var FetchBodyUtility = class {
  /**
   * Parses body and returns stream and type.
   *
   * Based on:
   * https://github.com/node-fetch/node-fetch/blob/main/src/body.js (MIT)
   *
   * @param body Body.
   * @returns Stream and type.
   */
  static getBodyStream(body2) {
    if (body2 === null || body2 === void 0) {
      return { stream: null, buffer: null, contentType: null, contentLength: null };
    } else if (body2 instanceof URLSearchParams2) {
      const buffer3 = Buffer4.from(body2.toString());
      return {
        buffer: buffer3,
        stream: this.toReadableStream(buffer3),
        contentType: "application/x-www-form-urlencoded;charset=UTF-8",
        contentLength: buffer3.length
      };
    } else if (body2 instanceof Blob) {
      const buffer3 = body2[buffer];
      return {
        buffer: buffer3,
        stream: this.toReadableStream(buffer3),
        contentType: body2.type,
        contentLength: body2.size
      };
    } else if (Buffer4.isBuffer(body2)) {
      return {
        buffer: body2,
        stream: this.toReadableStream(body2),
        contentType: null,
        contentLength: body2.length
      };
    } else if (body2 instanceof ArrayBuffer) {
      const buffer3 = Buffer4.from(body2);
      return {
        buffer: buffer3,
        stream: this.toReadableStream(buffer3),
        contentType: null,
        contentLength: body2.byteLength
      };
    } else if (ArrayBuffer.isView(body2)) {
      const buffer3 = Buffer4.from(body2.buffer, body2.byteOffset, body2.byteLength);
      return {
        buffer: buffer3,
        stream: this.toReadableStream(buffer3),
        contentType: null,
        contentLength: body2.byteLength
      };
    } else if (body2 instanceof ReadableStream3) {
      return {
        buffer: null,
        stream: body2,
        contentType: null,
        contentLength: null
      };
    } else if (body2 instanceof FormData) {
      return MultipartFormDataParser.formDataToStream(body2);
    }
    const buffer2 = Buffer4.from(String(body2));
    return {
      buffer: buffer2,
      stream: this.toReadableStream(buffer2),
      contentType: "text/plain;charset=UTF-8",
      contentLength: buffer2.length
    };
  }
  /**
   * Clones a request or body body stream.
   *
   * It is actually not cloning the stream.
   * It creates a pass through stream and pipes the original stream to it.
   *
   * @param window Window.
   * @param requestOrResponse Request or Response.
   * @param requestOrResponse.body Body.
   * @param requestOrResponse.bodyUsed Body used.
   * @returns New stream.
   */
  static cloneBodyStream(window2, requestOrResponse) {
    if (requestOrResponse.bodyUsed) {
      throw new window2.DOMException(`Failed to clone body stream of request: Request body is already used.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    if (requestOrResponse.body === null || requestOrResponse.body === void 0) {
      return null;
    }
    if (requestOrResponse[buffer]) {
      return this.toReadableStream(requestOrResponse[buffer]);
    }
    if (requestOrResponse.body[nodeStream]) {
      const stream12 = new Stream.PassThrough();
      const stream22 = new Stream.PassThrough();
      requestOrResponse.body[nodeStream].pipe(stream12);
      requestOrResponse.body[nodeStream].pipe(stream22);
      requestOrResponse.body = this.nodeToWebStream(stream12);
      return this.nodeToWebStream(stream22);
    }
    const [stream1, stream2] = requestOrResponse.body.tee();
    requestOrResponse.body == stream1;
    return stream2;
  }
  /**
   * Consume and convert an entire Body to a Buffer.
   *
   * Based on:
   * https://github.com/node-fetch/node-fetch/blob/main/src/body.js (MIT)
   *
   * @see https://fetch.spec.whatwg.org/#concept-body-consume-body
   * @param window Window.
   * @param body Body stream.
   * @returns Promise.
   */
  static async consumeBodyStream(window2, body2) {
    if (body2 === null || !(body2 instanceof ReadableStream3)) {
      return Buffer4.alloc(0);
    }
    if (body2[error]) {
      throw body2[error];
    }
    const reader = body2.getReader();
    const chunks = [];
    let bytes = 0;
    try {
      let readResult = await reader.read();
      while (!readResult.done) {
        if (body2[error]) {
          throw body2[error];
        }
        if (body2[aborted]) {
          throw new window2.DOMException("Failed to read response body: The stream was aborted.", DOMExceptionNameEnum_default.abortError);
        }
        const chunk = readResult.value;
        bytes += chunk.length;
        chunks.push(chunk);
        readResult = await reader.read();
      }
    } catch (error2) {
      if (error2 instanceof DOMException) {
        throw error2;
      }
      throw new window2.DOMException(`Failed to read response body. Error: ${error2.message}.`, DOMExceptionNameEnum_default.encodingError);
    }
    try {
      if (typeof chunks[0] === "string") {
        return Buffer4.from(chunks.join(""));
      }
      return Buffer4.concat(chunks, bytes);
    } catch (error2) {
      throw new window2.DOMException(`Could not create Buffer from response body. Error: ${error2.message}.`, DOMExceptionNameEnum_default.invalidStateError);
    }
  }
  /**
   * Wraps a given value in a browser ReadableStream.
   *
   * This method creates a ReadableStream and immediately enqueues and closes it
   * with the provided value, useful for stream API compatibility.
   *
   * @param value The value to be wrapped in a ReadableStream.
   * @returns ReadableStream
   */
  static toReadableStream(value2) {
    return new ReadableStream3({
      start(controller) {
        controller.enqueue(value2);
        controller.close();
      }
    });
  }
  /**
   * Wraps a Node.js stream into a browser-compatible ReadableStream.
   *
   * Enables the use of Node.js streams where browser ReadableStreams are required.
   * Handles 'data', 'end', and 'error' events from the Node.js stream.
   *
   * @param nodeStream The Node.js stream to be converted.
   * @returns ReadableStream
   */
  static nodeToWebStream(nodeStream2) {
    const readableStream = new ReadableStream3({
      start(controller) {
        nodeStream2.on("data", (chunk) => {
          controller.enqueue(chunk);
        });
        nodeStream2.on("end", () => {
          controller.close();
        });
        nodeStream2.on("error", (err) => {
          controller.error(err);
        });
      }
    });
    readableStream[nodeStream] = nodeStream2;
    return readableStream;
  }
};

// node_modules/happy-dom/lib/fetch/Response.js
import { Buffer as Buffer5 } from "buffer";
var REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308];
var Response = class {
  // Public properties
  body = null;
  bodyUsed = false;
  redirected = false;
  type = "basic";
  url = "";
  status;
  statusText;
  ok;
  headers;
  [cachedResponse] = null;
  [buffer] = null;
  /**
   * Constructor.
   *
   * @param body Body.
   * @param [init] Init.
   */
  constructor(body2, init) {
    if (!this[window]) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
    this.status = init?.status !== void 0 ? init.status : 200;
    this.statusText = init?.statusText || "";
    this.ok = this.status >= 200 && this.status < 300;
    this.headers = new Headers(init?.headers);
    this.headers.delete("Set-Cookie");
    this.headers.delete("Set-Cookie2");
    if (body2) {
      const { stream, buffer: buffer2, contentType: contentType2 } = FetchBodyUtility.getBodyStream(body2);
      this.body = stream;
      if (buffer2) {
        this[buffer] = buffer2;
      }
      if (contentType2 && !this.headers.has("Content-Type")) {
        this.headers.set("Content-Type", contentType2);
      }
    }
  }
  /**
   * Returns string tag.
   *
   * @returns String tag.
   */
  get [Symbol.toStringTag]() {
    return "Response";
  }
  /**
   * Returns array buffer.
   *
   * @returns Array buffer.
   */
  async arrayBuffer() {
    const window2 = this[window];
    if (this.bodyUsed) {
      throw new window2.DOMException(`Body has already been used for "${this.url}".`, DOMExceptionNameEnum_default.invalidStateError);
    }
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return new ArrayBuffer(0);
    }
    const asyncTaskManager2 = browserFrame[asyncTaskManager];
    this.bodyUsed = true;
    let buffer2 = this[buffer];
    if (!buffer2) {
      const taskID = asyncTaskManager2.startTask(() => {
        if (this.body) {
          this.body[aborted] = true;
        }
      });
      try {
        buffer2 = await FetchBodyUtility.consumeBodyStream(window2, this.body);
      } catch (error2) {
        asyncTaskManager2.endTask(taskID);
        throw error2;
      }
      asyncTaskManager2.endTask(taskID);
    }
    this.#storeBodyInCache(buffer2);
    return buffer2.buffer.slice(buffer2.byteOffset, buffer2.byteOffset + buffer2.byteLength);
  }
  /**
   * Returns blob.
   *
   * @returns Blob.
   */
  async blob() {
    const type2 = this.headers.get("Content-Type") || "";
    const buffer2 = await this.arrayBuffer();
    return new Blob([buffer2], { type: type2 });
  }
  /**
   * Returns buffer.
   *
   * @returns Buffer.
   */
  async buffer() {
    const window2 = this[window];
    if (this.bodyUsed) {
      throw new window2.DOMException(`Body has already been used for "${this.url}".`, DOMExceptionNameEnum_default.invalidStateError);
    }
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return Buffer5.alloc(0);
    }
    const asyncTaskManager2 = browserFrame[asyncTaskManager];
    this.bodyUsed = true;
    let buffer2 = this[buffer];
    if (!buffer2) {
      const taskID = asyncTaskManager2.startTask(() => {
        if (this.body) {
          this.body[aborted] = true;
        }
      });
      try {
        buffer2 = await FetchBodyUtility.consumeBodyStream(window2, this.body);
      } catch (error2) {
        asyncTaskManager2.endTask(taskID);
        throw error2;
      }
      asyncTaskManager2.endTask(taskID);
    }
    this.#storeBodyInCache(buffer2);
    return buffer2;
  }
  /**
   * Returns text.
   *
   * @returns Text.
   */
  async text() {
    const window2 = this[window];
    if (this.bodyUsed) {
      throw new window2.DOMException(`Body has already been used for "${this.url}".`, DOMExceptionNameEnum_default.invalidStateError);
    }
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return "";
    }
    const asyncTaskManager2 = browserFrame[asyncTaskManager];
    this.bodyUsed = true;
    let buffer2 = this[buffer];
    if (!buffer2) {
      const taskID = asyncTaskManager2.startTask(() => {
        if (this.body) {
          this.body[aborted] = true;
        }
      });
      try {
        buffer2 = await FetchBodyUtility.consumeBodyStream(window2, this.body);
      } catch (error2) {
        asyncTaskManager2.endTask(taskID);
        throw error2;
      }
      asyncTaskManager2.endTask(taskID);
    }
    this.#storeBodyInCache(buffer2);
    return new TextDecoder().decode(buffer2);
  }
  /**
   * Returns json.
   *
   * @returns JSON.
   */
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  /**
   * Returns form data.
   *
   * @returns Form data.
   */
  async formData() {
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return new window2.FormData();
    }
    const asyncTaskManager2 = browserFrame[asyncTaskManager];
    const contentType2 = this.headers.get("Content-Type");
    if (/multipart/i.test(contentType2)) {
      if (this.bodyUsed) {
        throw new window2.DOMException(`Body has already been used for "${this.url}".`, DOMExceptionNameEnum_default.invalidStateError);
      }
      this.bodyUsed = true;
      const taskID = browserFrame[asyncTaskManager].startTask(() => {
        if (this.body) {
          this.body[aborted] = true;
        }
      });
      let formData;
      let buffer2;
      try {
        const result2 = await MultipartFormDataParser.streamToFormData(window2, this.body, contentType2);
        formData = result2.formData;
        buffer2 = result2.buffer;
      } catch (error2) {
        asyncTaskManager2.endTask(taskID);
        throw error2;
      }
      this.#storeBodyInCache(buffer2);
      asyncTaskManager2.endTask(taskID);
      return formData;
    }
    if (contentType2?.startsWith("application/x-www-form-urlencoded")) {
      const parameters = new URLSearchParams3(await this.text());
      const formData = new window2.FormData();
      for (const [key, value2] of parameters) {
        formData.append(key, value2);
      }
      return formData;
    }
    throw new window2.DOMException(`Failed to build FormData object: The "content-type" header is neither "application/x-www-form-urlencoded" nor "multipart/form-data".`, DOMExceptionNameEnum_default.invalidStateError);
  }
  /**
   * Clones request.
   *
   * @returns Clone.
   */
  clone() {
    const window2 = this[window];
    const body2 = FetchBodyUtility.cloneBodyStream(window2, this);
    const response = new window2.Response(body2, {
      status: this.status,
      statusText: this.statusText,
      headers: this.headers
    });
    response[cachedResponse] = this[cachedResponse];
    response[buffer] = this[buffer];
    response.ok = this.ok;
    response.redirected = this.redirected;
    response.type = this.type;
    response.url = this.url;
    return response;
  }
  /**
   * Stores body in cache.
   *
   * @param buffer Buffer.
   */
  #storeBodyInCache(buffer2) {
    if (this[cachedResponse]?.response?.waitingForBody) {
      this[cachedResponse].response.body = buffer2;
      this[cachedResponse].response.waitingForBody = false;
    }
  }
  /**
   * Returns a redirect response.
   *
   * @param url URL.
   * @param status Status code.
   * @returns Response.
   */
  static redirect(url2, status = 302) {
    const window2 = this[window];
    if (!REDIRECT_STATUS_CODES.includes(status)) {
      throw new window2.DOMException("Failed to create redirect response: Invalid redirect status code.", DOMExceptionNameEnum_default.invalidStateError);
    }
    return new window2.Response(null, {
      headers: {
        location: new URL2(url2).toString()
      },
      status
    });
  }
  /**
   * Returns an error response.
   *
   * @param url URL.
   * @param status Status code.
   * @returns Response.
   */
  static error() {
    const response = new this[window].Response(null, { status: 0, statusText: "" });
    response.type = "error";
    return response;
  }
  /**
   * Returns an JSON response.
   *
   * @param injected Injected properties.
   * @param data Data.
   * @param [init] Init.
   * @returns Response.
   */
  static json(data2, init) {
    const window2 = this[window];
    const body2 = JSON.stringify(data2);
    if (body2 === void 0) {
      throw new window2.TypeError("data is not JSON serializable");
    }
    const headers2 = new window2.Headers(init && init.headers);
    if (!headers2.has("Content-Type")) {
      headers2.set("Content-Type", "application/json");
    }
    return new window2.Response(body2, {
      status: 200,
      ...init,
      headers: headers2
    });
  }
};

// node_modules/happy-dom/lib/cookie/urilities/CookieStringUtility.js
var CookieStringUtility = class {
  /**
   * Returns cookie.
   *
   * @param originURL Origin URL.
   * @param cookieString Cookie string.
   * @returns Cookie.
   */
  static stringToCookie(originURL, cookieString) {
    const parts = cookieString.split(";");
    const part = parts.shift();
    const index = part.indexOf("=");
    const key = index !== -1 ? part.slice(0, index).trim() : part.trim();
    const value2 = index !== -1 ? part.slice(index + 1).trim() : null;
    const cookie = Object.assign({}, DefaultCookie_default, {
      // Required
      key,
      value: value2,
      originURL
    });
    if (!cookie.key) {
      return null;
    }
    for (const part2 of parts) {
      const index2 = part2.indexOf("=");
      const key2 = index2 !== -1 ? part2.slice(0, index2).trim().toLowerCase() : part2.trim().toLowerCase();
      const value3 = index2 !== -1 ? part2.slice(index2 + 1).trim() : "";
      switch (key2) {
        case "expires":
          cookie.expires = new Date(value3);
          break;
        case "max-age":
          cookie.expires = new Date(parseInt(value3, 10) * 1e3 + Date.now());
          break;
        case "domain":
          cookie.domain = value3;
          break;
        case "path":
          cookie.path = value3[0] === "/" ? value3 : `/${value3}`;
          break;
        case "httponly":
          cookie.httpOnly = true;
          break;
        case "secure":
          cookie.secure = true;
          break;
        case "samesite":
          switch (value3.toLowerCase()) {
            case "strict":
              cookie.sameSite = CookieSameSiteEnum_default.strict;
              break;
            case "lax":
              cookie.sameSite = CookieSameSiteEnum_default.lax;
              break;
            case "none":
              cookie.sameSite = CookieSameSiteEnum_default.none;
          }
          break;
      }
    }
    const lowerKey = cookie.key.toLowerCase();
    if (lowerKey.startsWith("__secure-") && !cookie.secure) {
      return null;
    }
    if (lowerKey.startsWith("__host-") && (!cookie.secure || cookie.path !== "/" || cookie.domain)) {
      return null;
    }
    return cookie;
  }
  /**
   * Returns cookie string with key and value.
   *
   * @param cookies Cookies.
   * @returns Cookie string.
   */
  static cookiesToString(cookies) {
    const cookieString = [];
    for (const cookie of cookies) {
      if (cookie.value !== null) {
        cookieString.push(`${cookie.key}=${cookie.value}`);
      } else {
        cookieString.push(cookie.key);
      }
    }
    return cookieString.join("; ");
  }
};

// node_modules/happy-dom/lib/fetch/utilities/FetchRequestHeaderUtility.js
import { URL as URL4 } from "url";
var FORBIDDEN_HEADER_NAMES = [
  "accept-charset",
  "accept-encoding",
  "access-control-request-headers",
  "access-control-request-method",
  "connection",
  "content-length",
  "content-transfer-encoding",
  "cookie",
  "cookie2",
  "date",
  "dnt",
  "expect",
  "host",
  "keep-alive",
  "origin",
  "referer",
  "te",
  "trailer",
  "transfer-encoding",
  "upgrade",
  "via"
];
var FetchRequestHeaderUtility = class {
  /**
   * Validates request headers.
   *
   * @param headers Headers.
   */
  static removeForbiddenHeaders(headers2) {
    for (const key of Object.keys(headers2[entries])) {
      if (FORBIDDEN_HEADER_NAMES.includes(key) || key.startsWith("proxy-") || key.startsWith("sec-")) {
        delete headers2[entries][key];
      }
    }
  }
  /**
   * Returns "true" if the header is forbidden.
   *
   * @param name Header name.
   * @returns "true" if the header is forbidden.
   */
  static isHeaderForbidden(name2) {
    return FORBIDDEN_HEADER_NAMES.includes(name2.toLowerCase());
  }
  /**
   * Returns request headers.
   *
   * @param options Options.
   * @param options.browserFrame Browser frame.
   * @param options.window Window.
   * @param options.request Request.
   * @param [options.baseHeaders] Any base headers (may be overwritten by browser/window headers).
   * @returns Headers.
   */
  static getRequestHeaders(options2) {
    const headers2 = new Headers(options2.baseHeaders);
    options2.request.headers.forEach((value2, key) => {
      headers2.set(key, value2);
    });
    const originURL = new URL4(options2.window.location.href);
    const isCORS = FetchCORSUtility.isCORS(originURL, options2.request[url]);
    if (options2.request.credentials === "omit" || options2.request.credentials === "same-origin" && isCORS) {
      headers2.delete("authorization");
      headers2.delete("www-authenticate");
    }
    headers2.set("Accept-Encoding", "gzip, deflate, br");
    headers2.set("Connection", "close");
    if (!headers2.has("User-Agent")) {
      headers2.set("User-Agent", options2.window.navigator.userAgent);
    }
    if (options2.request[referrer] instanceof URL4) {
      headers2.set("Referer", options2.request[referrer].href);
    }
    if (options2.request.credentials === "include" || options2.request.credentials === "same-origin" && !isCORS) {
      const cookies = options2.browserFrame.page.context.cookieContainer.getCookies(originURL, false);
      if (cookies.length > 0) {
        headers2.set("Cookie", CookieStringUtility.cookiesToString(cookies));
      }
    }
    if (!headers2.has("Accept")) {
      headers2.set("Accept", "*/*");
    }
    if (!headers2.has("Content-Length") && options2.request[contentLength] !== null) {
      headers2.set("Content-Length", String(options2.request[contentLength]));
    }
    if (!headers2.has("Content-Type") && options2.request[contentType]) {
      headers2.set("Content-Type", options2.request[contentType]);
    }
    if (isCORS) {
      headers2.set("Origin", originURL.origin);
    }
    const httpRequestHeaders = {};
    for (const header of Object.values(headers2[entries])) {
      httpRequestHeaders[header.name] = header.value.join(", ");
    }
    return httpRequestHeaders;
  }
};

// node_modules/happy-dom/lib/fetch/utilities/FetchRequestValidationUtility.js
var VALID_REFERRER_POLICIES = [
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
];
var VALID_REDIRECTS = ["error", "manual", "follow"];
var SUPPORTED_SCHEMAS = ["data:", "http:", "https:"];
var FORBIDDEN_REQUEST_METHODS = ["TRACE", "TRACK", "CONNECT"];
var REQUEST_METHOD_REGEXP = /^[A-Z]+$/;
var FetchRequestValidationUtility = class {
  /**
   * Validates request method.
   *
   * @throws DOMException
   * @param request Request.
   */
  static validateMethod(request) {
    if (!request.method || FORBIDDEN_REQUEST_METHODS.includes(request.method)) {
      throw new DOMException(`'${request.method || ""}' is not a valid HTTP method.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    if (!REQUEST_METHOD_REGEXP.test(request.method)) {
      throw new DOMException(`'${request.method}' HTTP method is unsupported.`, DOMExceptionNameEnum_default.invalidStateError);
    }
  }
  /**
   * Validates request body.
   *
   * @throws DOMException
   * @param request Request.
   */
  static validateBody(request) {
    if (request.body && (request.method === "GET" || request.method === "HEAD")) {
      throw new DOMException(`Request with GET/HEAD method cannot have body.`, DOMExceptionNameEnum_default.invalidStateError);
    }
  }
  /**
   * Validates request URL.
   *
   * @throws DOMException
   * @param url URL.
   */
  static validateURL(url2) {
    if (url2.username !== "" || url2.password !== "") {
      throw new DOMException(`${url2} is an url with embedded credentials.`, DOMExceptionNameEnum_default.notSupportedError);
    }
  }
  /**
   * Validates request referrer policy.
   *
   * @throws DOMException
   * @param referrerPolicy Referrer policy.
   */
  static validateReferrerPolicy(referrerPolicy2) {
    if (!VALID_REFERRER_POLICIES.includes(referrerPolicy2)) {
      throw new DOMException(`Invalid referrer policy "${referrerPolicy2}".`, DOMExceptionNameEnum_default.syntaxError);
    }
  }
  /**
   * Validates request redirect.
   *
   * @throws DOMException
   * @param redirect Redirect.
   */
  static validateRedirect(redirect2) {
    if (!VALID_REDIRECTS.includes(redirect2)) {
      throw new DOMException(`Invalid redirect "${redirect2}".`, DOMExceptionNameEnum_default.syntaxError);
    }
  }
  /**
   * Validates request redirect.
   *
   * @throws DOMException
   * @param request
   * @param redirect Redirect.
   */
  static validateSchema(request) {
    if (!SUPPORTED_SCHEMAS.includes(request[url].protocol)) {
      throw new DOMException(`Failed to fetch from "${request.url}": URL scheme "${request[url].protocol.replace(/:$/, "")}" is not supported.`, DOMExceptionNameEnum_default.notSupportedError);
    }
  }
};

// node_modules/happy-dom/lib/fetch/utilities/FetchResponseRedirectUtility.js
var REDIRECT_STATUS_CODES2 = [301, 302, 303, 307, 308];
var MAX_REDIRECT_COUNT = 20;
var FetchResponseRedirectUtility = class {
  /**
   * Returns "true" if redirect.
   *
   * @param statusCode Status code.
   * @returns "true" if redirect.
   */
  static isRedirect(statusCode) {
    return REDIRECT_STATUS_CODES2.includes(statusCode);
  }
  /**
   * Returns "true" if max redirects is reached.
   *
   * @param redirectCount Redirect count.
   * @returns "true" if max redirects is reached.
   */
  static isMaxRedirectsReached(redirectCount) {
    return redirectCount >= MAX_REDIRECT_COUNT;
  }
};

// node_modules/happy-dom/lib/fetch/utilities/FetchResponseHeaderUtility.js
var FetchResponseHeaderUtility = class {
  /**
   * Appends headers to response.
   *
   * @param nodeResponse HTTP request.
   * @param options
   * @param options.browserFrame
   * @param options.requestURL
   * @param options.rawHeaders
   * @returns Headers.
   */
  static parseResponseHeaders(options2) {
    const headers2 = new Headers();
    let key = null;
    for (const header of options2.rawHeaders) {
      if (!key) {
        key = header;
      } else {
        const lowerName = key.toLowerCase();
        if (lowerName === "set-cookie" || lowerName === "set-cookie2") {
          options2.browserFrame.page.context.cookieContainer.addCookies([
            CookieStringUtility.stringToCookie(options2.requestURL, header)
          ]);
        } else {
          headers2.append(key, header);
        }
        key = null;
      }
    }
    return headers2;
  }
};

// node_modules/happy-dom/lib/fetch/certificate/FetchHTTPSCertificate.js
var FetchHTTPSCertificate_default = {
  cert: `-----BEGIN CERTIFICATE-----
MIIDYzCCAkugAwIBAgIUJRKB/H66hpet1VfUlm0CiXqePA4wDQYJKoZIhvcNAQEL
BQAwQTELMAkGA1UEBhMCU0UxDjAMBgNVBAgMBVNrYW5lMQ4wDAYDVQQHDAVNYWxt
bzESMBAGA1UECgwJSGFwcHkgRE9NMB4XDTIyMTAxMTIyMDM0OVoXDTMyMTAwODIy
MDM0OVowQTELMAkGA1UEBhMCU0UxDjAMBgNVBAgMBVNrYW5lMQ4wDAYDVQQHDAVN
YWxtbzESMBAGA1UECgwJSGFwcHkgRE9NMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAqerQSQEg/SxVxRiwlItithr5e5EMZo1nsqt/xOxagbmpW3IEmt0j
bpbH7iEF4DDEo7KAOwUCOwVWeFxRoag8lG2ax48wrgjlCna45XDn0Xeg1ARajL04
gs46HZ0VrzIloVGfln0zgt/Vum5BNqs9Oc5fQoBmoP3cAn3dn4ZVcP0AKthtcyPl
q2DuNRN0PV0D2RtMSiAy9l1Ko6N5x+sAeClDyOL+sTDLngZBVeZyOKt9Id15S8Zt
XtA6VMgHnnF3jChn7pag77rsd/y5iANAVNZYqRl+Eg7xaDcsvbgH46UBOrBcB39Q
tTh5Mtjoxep5e3ZDFG+kQ1HUE+iz5O5n0wIDAQABo1MwUTAdBgNVHQ4EFgQU69s9
YSobG/m2SN4L/7zTaF7iDbwwHwYDVR0jBBgwFoAU69s9YSobG/m2SN4L/7zTaF7i
DbwwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAi/WUXx2oal8L
YnPlIuKfh49n/K18wXSYG//oFYwxfVxqpYH8hUiXVm/GUcXCxS++hUkaKLqXmH9q
MKJiCrZr3vS+2nsBKopkICu/TLdROl0sAI9lByfnEbfSAzjxe1IWJdK8NdY0y5m5
9pEr/URVIAp/CxrneyASb4q0Jg5To3FR7vYc+2X6wZn0MundKMg6Dp9/A37jiF3l
Tt/EJp299YZcsUzh+LnRuggRjnoOVu1aLcLFlaUiwZfy9m8mLG6B/mdW/qNzNMh9
Oqvg1zfGdpz/4D/2UUUBn6pq1vbsoAaF3OesoA3mfDcegDf/H9woJlpT0Wql+e68
Y3FblSokcA==
-----END CERTIFICATE-----`,
  key: `-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCp6tBJASD9LFXF
GLCUi2K2Gvl7kQxmjWeyq3/E7FqBualbcgSa3SNulsfuIQXgMMSjsoA7BQI7BVZ4
XFGhqDyUbZrHjzCuCOUKdrjlcOfRd6DUBFqMvTiCzjodnRWvMiWhUZ+WfTOC39W6
bkE2qz05zl9CgGag/dwCfd2fhlVw/QAq2G1zI+WrYO41E3Q9XQPZG0xKIDL2XUqj
o3nH6wB4KUPI4v6xMMueBkFV5nI4q30h3XlLxm1e0DpUyAeecXeMKGfulqDvuux3
/LmIA0BU1lipGX4SDvFoNyy9uAfjpQE6sFwHf1C1OHky2OjF6nl7dkMUb6RDUdQT
6LPk7mfTAgMBAAECggEAKkwTkTjAt4UjzK56tl+EMQTB+ep/hb/JgoaChci4Nva6
m9LkJpDJ0yuhlTuPNOGu8XjrxsVWas7HWarRf0Zb3i7yip6wZYI9Ub+AA015x4DZ
/i0fRU2NFbK0cM67qSL4jxG8gj+kZP3HPGNZxHwX/53JxMolwgmvjMc8NgvAlSFd
NnV9h4xtbhUh1NGS5zmP3iU2rwnE8JrIEzwy6axLom7nekAgkdcbAr0UoBs8gcgH
aYNhU4Gz3tGcZZ0IXAfT/bJIH1Ko8AGv4pssWc3BXcmmNdm/+kzvHIxEIV7Qegmo
XG1ZyZCyD/0b4/3e8ySDBEDqwR+HeyTW2isWG2agAQKBgQDp44aTwr3dkIXY30xv
FPfUOipg/B49dWnffYJ9MWc1FT9ijNPAngWSk0EIiEQIazICcUBI4Yji6/KeyqLJ
GdLpDi1CkKqtyh73mjELinYp3EUQgEa77aQogGa2+nMOVfu+O5CtloUrv/A18jX3
+VEyaEASK0fWmnSI0OdlxQHIAQKBgQC5+xOls2F3MlKASvWRLlnW1wHqlDTtVoYg
5Nh8syZH4Ci2UH8tON3A5/7SWNM0t1cgV6Cw4zW8Z2spgIT/W0iYYrQ4hHL1xdCu
+CxL1km4Gy8Uwpsd+KdFahFqF/XTmLzW0HXLxWSK0fTwmdV0SFrKF3MXfTCU2AeZ
jJoMFb6P0wKBgQC3Odw6s0vkYAzLGhuZxfZkVvDOK5RRF0NKpttr0iEFL9EJFkPo
2KKK8jr3QTDy229BBJGUxsJi6u6VwS8HlehpVQbV59kd7oKV/EBBx0XMg1fDlopT
PNbmN7i/zbIG4AsoOyebJZjL7kBzMn1e9vzKHWtcEHXlw/hZGja8vjooAQKBgAeg
xK2HLfg1mCyq5meN/yFQsENu0LzrT5UJzddPgcJw7zqLEqxIKNBAs7Ls8by3yFsL
PQwERa/0jfCl1M6kb9XQNpQa2pw6ANUsWKTDpUJn2wZ+9N3F1RaDwzMWyH5lRVmK
M0qoTfdjpSg5Jwgd75taWt4bxGJWeflSSv8z5R0BAoGAWL8c527AbeBvx2tOYKkD
2TFranvANNcoMrbeviZSkkGvMNDP3p8b6juJwXOIeWNr8q4vFgCzLmq6d1/9gYm2
3XJwwyD0LKlqzkBrrKU47qrnmMosUrIRlrAzd3HbShOptxc6Iz2apSaUDKGKXkaw
gl5OpEjeliU7Mus0BVS858g=
-----END PRIVATE KEY-----`
};

// node_modules/happy-dom/lib/fetch/Fetch.js
import { Buffer as Buffer6 } from "buffer";

// node_modules/happy-dom/lib/fetch/utilities/VirtualServerUtility.js
import Path from "path";
var NOT_FOUND_HTML = "<html><head><title>Happy DOM Virtual Server - 404 Not Found</title></head><body><h1>Happy DOM Virtual Server - 404 Not Found</h1></body></html>";
var VirtualServerUtility = class {
  /**
   * Returns the filesystem path for a request URL if it matches a virtual server.
   *
   * @param window Window.
   * @param requestURL Request URL.
   */
  static getFilepath(window2, requestURL) {
    const browserSettings = new WindowBrowserContext(window2).getSettings();
    if (!browserSettings || !browserSettings.fetch.virtualServers) {
      return null;
    }
    for (const virtualServer of browserSettings.fetch.virtualServers) {
      let baseURL;
      if (typeof virtualServer.url === "string") {
        const url2 = new URL(virtualServer.url[virtualServer.url.length - 1] === "/" ? virtualServer.url.slice(0, -1) : virtualServer.url, window2.location.origin);
        if (requestURL.startsWith(url2.href)) {
          baseURL = url2;
        }
      } else if (virtualServer.url instanceof RegExp) {
        const match = requestURL.match(virtualServer.url);
        if (match) {
          baseURL = new URL(match[0][match[0].length - 1] === "/" ? match[0].slice(0, -1) : match[0], window2.location.origin);
        }
      }
      if (baseURL) {
        const path = requestURL.slice(baseURL.href.length).split("?")[0].split("#")[0];
        return Path.join(Path.resolve(virtualServer.directory), path.replaceAll("/", Path.sep));
      }
    }
    return null;
  }
  /**
   * Returns a 404 response.
   *
   * @param window Window.
   * @returns 404 response.
   */
  static getNotFoundResponse(window2) {
    return new window2.Response(NOT_FOUND_HTML, {
      status: 404,
      statusText: "Not Found",
      headers: {
        "Content-Type": "text/html"
      }
    });
  }
  /**
   * Returns a 404 response.
   *
   * @param window Window.
   * @returns 404 response.
   */
  static getNotFoundSyncResponse(window2) {
    return {
      status: 404,
      statusText: "Not Found",
      ok: false,
      url: null,
      redirected: false,
      headers: new window2.Headers({
        "Content-Type": "text/html"
      }),
      body: Buffer.from(NOT_FOUND_HTML)
    };
  }
};

// node_modules/happy-dom/lib/fetch/preload/PreloadUtility.js
var PreloadUtility = class {
  /**
   * Returns a key for a preload entry.
   *
   * @param options Options.
   * @param options.url URL.
   * @param options.destination Destination.
   * @param options.mode Mode.
   * @param options.credentialsMode Credentials mode.
   * @returns Key.
   */
  static getKey(options2) {
    return JSON.stringify({
      url: options2.url,
      destination: options2.destination,
      mode: options2.mode,
      credentialsMode: options2.credentialsMode
    });
  }
};

// node_modules/happy-dom/lib/fetch/Fetch.js
var LAST_CHUNK = Buffer6.from("0\r\n\r\n");
var Fetch = class _Fetch {
  reject = null;
  resolve = null;
  listeners = {
    onSignalAbort: this.onSignalAbort.bind(this)
  };
  isChunkedTransfer = false;
  isProperLastChunkReceived = false;
  previousChunk = null;
  nodeRequest = null;
  nodeResponse = null;
  response = null;
  responseHeaders = null;
  interceptor;
  request;
  redirectCount = 0;
  disableCache;
  disableSameOriginPolicy;
  disablePreload;
  #browserFrame;
  #window;
  #unfilteredHeaders = null;
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.browserFrame Browser frame.
   * @param options.window Window.
   * @param options.url URL.
   * @param [options.init] Init.
   * @param [options.redirectCount] Redirect count.
   * @param [options.contentType] Content Type.
   * @param [options.disableCache] Disables the use of cached responses. It will still store the response in the cache.
   * @param [options.disableSameOriginPolicy] Disables the Same-Origin policy.
   * @param [options.unfilteredHeaders] Unfiltered headers - necessary for preflight requests.
   * @param [options.disablePreload] Disables the use of preloaded responses.
   */
  constructor(options2) {
    this.#browserFrame = options2.browserFrame;
    this.#window = options2.window;
    this.#unfilteredHeaders = options2.unfilteredHeaders ?? null;
    this.request = typeof options2.url === "string" || options2.url instanceof URL5 ? new options2.window.Request(options2.url, options2.init) : options2.url;
    if (options2.contentType) {
      this.request[contentType] = options2.contentType;
    }
    this.redirectCount = options2.redirectCount ?? 0;
    this.disableCache = options2.disableCache ?? false;
    this.disableSameOriginPolicy = options2.disableSameOriginPolicy ?? this.#browserFrame.page.context.browser.settings.fetch.disableSameOriginPolicy ?? false;
    this.interceptor = this.#browserFrame.page.context.browser.settings.fetch.interceptor;
    this.disablePreload = options2.disablePreload ?? false;
  }
  /**
   * Sends request.
   *
   * @returns Response.
   */
  async send() {
    FetchRequestReferrerUtility.prepareRequest(new URL5(this.#window.location.href), this.request);
    if (this.interceptor?.beforeAsyncRequest) {
      const taskID = this.#browserFrame[asyncTaskManager].startTask();
      const response = await this.interceptor.beforeAsyncRequest({
        request: this.request,
        window: this.#window
      });
      this.#browserFrame[asyncTaskManager].endTask(taskID);
      if (response instanceof Response) {
        return response;
      }
    }
    FetchRequestValidationUtility.validateSchema(this.request);
    if (this.request.signal[aborted]) {
      if (this.request.signal[reason] !== void 0) {
        throw this.request.signal[reason];
      }
      throw new this[window].DOMException("signal is aborted without reason", DOMExceptionNameEnum_default.abortError);
    }
    if (this.request[url].protocol === "data:") {
      const result2 = DataURIParser.parse(this.request.url);
      this.response = new this.#window.Response(result2.buffer, {
        headers: { "Content-Type": result2.type }
      });
      const interceptedResponse = this.interceptor?.afterAsyncResponse ? await this.interceptor.afterAsyncResponse({
        window: this.#window,
        response: this.response,
        request: this.request
      }) : void 0;
      return interceptedResponse instanceof Response ? interceptedResponse : this.response;
    }
    if (this.request[url].protocol === "http:" && this.#window.location.protocol === "https:") {
      throw new this.#window.DOMException(`Mixed Content: The page at '${this.#window.location.href}' was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint '${this.request.url}'. This request has been blocked; the content must be served over HTTPS.`, DOMExceptionNameEnum_default.securityError);
    }
    if (!this.disableCache) {
      const cachedResponse2 = await this.getCachedResponse();
      if (cachedResponse2) {
        return cachedResponse2;
      }
    }
    if (!this.disablePreload) {
      const preloadKey = PreloadUtility.getKey({
        url: this.request.url,
        destination: "fetch",
        mode: this.request.mode,
        credentialsMode: this.request.credentials
      });
      const preloadEntry = this.#window.document[preloads].get(preloadKey);
      if (preloadEntry) {
        this.#window.document[preloads].delete(preloadKey);
        if (preloadEntry.response) {
          return preloadEntry.response;
        }
        const taskID = this.#browserFrame[asyncTaskManager].startTask();
        const response = await preloadEntry.onResponseAvailable();
        this.#browserFrame[asyncTaskManager].endTask(taskID);
        return response;
      }
    }
    const virtualServerResponse = await this.getVirtualServerResponse();
    if (virtualServerResponse) {
      return virtualServerResponse;
    }
    if (!this.disableSameOriginPolicy) {
      const compliesWithCrossOriginPolicy = await this.compliesWithCrossOriginPolicy();
      if (!compliesWithCrossOriginPolicy) {
        this.#browserFrame?.page?.console.warn(`Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at "${this.request.url}".`);
        throw new this.#window.DOMException(`Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at "${this.request.url}".`, DOMExceptionNameEnum_default.networkError);
      }
    }
    return await this.sendRequest();
  }
  /**
   * Returns cached response.
   *
   * @returns Response.
   */
  async getCachedResponse() {
    if (this.disableCache) {
      return null;
    }
    let cachedResponse2 = this.#browserFrame.page.context.responseCache.get(this.request);
    if (!cachedResponse2 || cachedResponse2.response.waitingForBody) {
      return null;
    }
    if (cachedResponse2.state === CachedResponseStateEnum_default.stale) {
      const headers2 = new Headers(cachedResponse2.request.headers);
      if (cachedResponse2.etag) {
        headers2.set("If-None-Match", cachedResponse2.etag);
      } else {
        if (!cachedResponse2.lastModified) {
          return null;
        }
        headers2.set("If-Modified-Since", new Date(cachedResponse2.lastModified).toUTCString());
      }
      const fetch = new _Fetch({
        browserFrame: this.#browserFrame,
        window: this.#window,
        url: this.request.url,
        init: { headers: headers2, method: cachedResponse2.request.method },
        disableCache: true,
        disableSameOriginPolicy: true
      });
      if (cachedResponse2.etag || !cachedResponse2.staleWhileRevalidate) {
        const validateResponse = await fetch.send();
        const body2 = validateResponse.status !== 304 ? await validateResponse.buffer() : null;
        cachedResponse2 = this.#browserFrame.page.context.responseCache.add(this.request, {
          ...validateResponse,
          body: body2,
          waitingForBody: false
        });
        if (validateResponse.status !== 304) {
          const response2 = new this.#window.Response(body2, {
            status: validateResponse.status,
            statusText: validateResponse.statusText,
            headers: validateResponse.headers
          });
          response2.url = validateResponse.url;
          response2[cachedResponse] = cachedResponse2;
          return response2;
        }
      } else {
        fetch.send().then((response2) => {
          response2.buffer().then((body2) => {
            this.#browserFrame.page.context.responseCache.add(this.request, {
              ...response2,
              body: body2,
              waitingForBody: false
            });
          });
        });
      }
    }
    if (!cachedResponse2 || cachedResponse2.response.waitingForBody) {
      return null;
    }
    const response = new this.#window.Response(cachedResponse2.response.body, {
      status: cachedResponse2.response.status,
      statusText: cachedResponse2.response.statusText,
      headers: cachedResponse2.response.headers
    });
    response.url = cachedResponse2.response.url;
    response[cachedResponse] = cachedResponse2;
    return response;
  }
  /**
   * Returns virtual server response.
   *
   * @returns Response.
   */
  async getVirtualServerResponse() {
    const filePath = VirtualServerUtility.getFilepath(this.#window, this.request.url);
    if (!filePath) {
      return null;
    }
    const taskID = this.#browserFrame[asyncTaskManager].startTask();
    if (this.request.method !== "GET") {
      this.#browserFrame?.page?.console.error(`${this.request.method} ${this.request.url} 404 (Not Found)`);
      const response2 = VirtualServerUtility.getNotFoundResponse(this.#window);
      const interceptedResponse2 = this.interceptor?.afterAsyncResponse ? await this.interceptor.afterAsyncResponse({
        window: this.#window,
        response: await response2,
        request: this.request
      }) : void 0;
      this.#browserFrame[asyncTaskManager].endTask(taskID);
      return interceptedResponse2 instanceof Response ? interceptedResponse2 : response2;
    }
    let buffer2;
    try {
      const stat = await FS.promises.stat(filePath);
      buffer2 = await FS.promises.readFile(stat.isDirectory() ? Path2.join(filePath, "index.html") : filePath);
    } catch (error2) {
      this.#browserFrame?.page?.console.error(`${this.request.method} ${this.request.url} 404 (Not Found)`);
      const response2 = VirtualServerUtility.getNotFoundResponse(this.#window);
      const interceptedResponse2 = this.interceptor?.afterAsyncResponse ? await this.interceptor.afterAsyncResponse({
        window: this.#window,
        response: await response2,
        request: this.request
      }) : void 0;
      this.#browserFrame[asyncTaskManager].endTask(taskID);
      return interceptedResponse2 instanceof Response ? interceptedResponse2 : response2;
    }
    const body2 = new this.#window.ReadableStream({
      start(controller) {
        setTimeout(() => {
          controller.enqueue(buffer2);
          controller.close();
        });
      }
    });
    const response = new this.#window.Response(body2);
    response[buffer] = buffer2;
    response.url = this.request.url;
    const interceptedResponse = this.interceptor?.afterAsyncResponse ? await this.interceptor.afterAsyncResponse({
      window: this.#window,
      response: await response,
      request: this.request
    }) : void 0;
    this.#browserFrame[asyncTaskManager].endTask(taskID);
    const returnResponse = interceptedResponse instanceof Response ? interceptedResponse : response;
    const cachedResponse2 = {
      ...returnResponse,
      body: buffer2,
      waitingForBody: false
    };
    response[cachedResponse] = this.#browserFrame.page?.context?.responseCache.add(this.request, cachedResponse2);
    return returnResponse;
  }
  /**
   * Checks if the request complies with the Cross-Origin policy.
   *
   * @returns True if it complies with the policy.
   */
  async compliesWithCrossOriginPolicy() {
    if (this.disableSameOriginPolicy || !FetchCORSUtility.isCORS(this.#window.location.href, this.request[url])) {
      return true;
    }
    const cachedPreflightResponse = this.#browserFrame.page.context.preflightResponseCache.get(this.request);
    if (cachedPreflightResponse) {
      if (cachedPreflightResponse.allowOrigin !== "*" && cachedPreflightResponse.allowOrigin !== this.#window.location.origin) {
        return false;
      }
      if (cachedPreflightResponse.allowMethods.length !== 0 && !cachedPreflightResponse.allowMethods.includes(this.request.method)) {
        return false;
      }
      return true;
    }
    const requestHeaders = [];
    for (const [header] of this.request.headers) {
      requestHeaders.push(header.toLowerCase());
    }
    const corsHeaders = new Headers({
      "Access-Control-Request-Method": this.request.method,
      Origin: this.#window.location.origin
    });
    if (requestHeaders.length > 0) {
      corsHeaders.set("Access-Control-Request-Headers", requestHeaders.slice().sort().join(","));
    }
    const fetch = new _Fetch({
      browserFrame: this.#browserFrame,
      window: this.#window,
      url: this.request.url,
      init: { method: "OPTIONS" },
      disableCache: true,
      disableSameOriginPolicy: true,
      unfilteredHeaders: corsHeaders
    });
    const response = await fetch.send();
    if (!response.ok) {
      return false;
    }
    const allowOrigin = response.headers.get("Access-Control-Allow-Origin");
    if (!allowOrigin) {
      return false;
    }
    if (allowOrigin !== "*" && allowOrigin !== this.#window.location.origin) {
      return false;
    }
    const allowMethods = [];
    if (response.headers.has("Access-Control-Allow-Methods")) {
      const allowMethodsHeader = response.headers.get("Access-Control-Allow-Methods");
      if (allowMethodsHeader !== "*") {
        for (const method2 of allowMethodsHeader.split(",")) {
          allowMethods.push(method2.trim().toUpperCase());
        }
      }
    }
    if (allowMethods.length !== 0 && !allowMethods.includes(this.request.method)) {
      return false;
    }
    return true;
  }
  /**
   * Sends request.
   *
   * @returns Response.
   */
  sendRequest() {
    return new Promise((resolve, reject) => {
      const taskID = this.#browserFrame[asyncTaskManager].startTask(() => this.onAsyncTaskManagerAbort());
      if (this.resolve) {
        throw new this.#window.Error("Fetch already sent.");
      }
      this.resolve = async (response) => {
        if (!this.disableCache && response instanceof Response && this.#browserFrame.page && this.#browserFrame.page.context) {
          response[cachedResponse] = this.#browserFrame.page.context.responseCache.add(this.request, {
            ...response,
            headers: this.responseHeaders,
            body: response[buffer],
            waitingForBody: !response[buffer] && !!response.body
          });
        }
        const interceptedResponse = this.interceptor?.afterAsyncResponse ? await this.interceptor.afterAsyncResponse({
          window: this.#window,
          response: await response,
          request: this.request
        }) : void 0;
        this.#browserFrame[asyncTaskManager].endTask(taskID);
        const returnResponse = interceptedResponse instanceof Response ? interceptedResponse : response;
        if (returnResponse instanceof Response && !returnResponse.ok) {
          this.#browserFrame?.page?.console.error(`${this.request.method} ${this.request.url} ${returnResponse.status} (${returnResponse.statusText})`);
        }
        resolve(returnResponse);
      };
      this.reject = (error2) => {
        this.#browserFrame[asyncTaskManager].endTask(taskID);
        reject(error2);
      };
      this.request.signal.addEventListener("abort", this.listeners.onSignalAbort);
      const send = (this.request[url].protocol === "https:" ? HTTPS : HTTP).request;
      this.nodeRequest = send(this.request[url].href, {
        method: this.request.method,
        headers: FetchRequestHeaderUtility.getRequestHeaders({
          browserFrame: this.#browserFrame,
          window: this.#window,
          request: this.request,
          baseHeaders: this.#unfilteredHeaders
        }),
        agent: false,
        rejectUnauthorized: true,
        key: this.request[url].protocol === "https:" ? FetchHTTPSCertificate_default.key : void 0,
        cert: this.request[url].protocol === "https:" ? FetchHTTPSCertificate_default.cert : void 0
      });
      this.nodeRequest.on("error", this.onError.bind(this));
      this.nodeRequest.on("socket", this.onSocket.bind(this));
      this.nodeRequest.on("response", this.onResponse.bind(this));
      if (this.request.body === null) {
        this.nodeRequest.end();
      } else {
        Stream2.pipeline(this.request.body, this.nodeRequest, (error2) => {
          if (error2) {
            this.onError(error2);
          }
        });
      }
    });
  }
  /**
   * Event listener for "socket" event.
   *
   * @param socket Socket.
   */
  onSocket(socket) {
    const onSocketClose = () => {
      if (this.isChunkedTransfer && !this.isProperLastChunkReceived) {
        const error2 = new this.#window.DOMException("Premature close.", DOMExceptionNameEnum_default.networkError);
        if (this.response && this.response.body) {
          this.response.body[error] = error2;
          if (!this.response.body.locked) {
            this.response.body.cancel(error2);
          }
        }
      }
    };
    const onData = (buffer2) => {
      this.isProperLastChunkReceived = Buffer6.compare(buffer2.slice(-5), LAST_CHUNK) === 0;
      if (!this.isProperLastChunkReceived && this.previousChunk) {
        this.isProperLastChunkReceived = Buffer6.compare(this.previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer6.compare(buffer2.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      this.previousChunk = buffer2;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    this.nodeRequest.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  }
  /**
   * Event listener for signal "abort" event.
   *
   * @param event Event.
   */
  onSignalAbort(event) {
    this.finalizeRequest();
    this.abort(event.target?.reason);
  }
  /**
   * Event listener for request "error" event.
   *
   * @param error Error.
   */
  onError(error2) {
    this.finalizeRequest();
    this.#browserFrame?.page?.console.error(error2);
    this.reject(new this.#window.DOMException(`Failed to execute "fetch()" on "Window" with URL "${this.request.url}": ${error2.message}`, DOMExceptionNameEnum_default.networkError));
  }
  /**
   * Triggered when the async task manager aborts.
   */
  onAsyncTaskManagerAbort() {
    const error2 = new this.#window.DOMException("The operation was aborted.", DOMExceptionNameEnum_default.abortError);
    this.request[aborted] = true;
    if (this.request.body) {
      this.request.body[error] = error2;
    }
    if (this.listeners.onSignalAbort) {
      this.request.signal.removeEventListener("abort", this.listeners.onSignalAbort);
    }
    if (this.nodeRequest && !this.nodeRequest.destroyed) {
      this.nodeRequest.destroy(error2);
    }
    if (this.nodeResponse && !this.nodeResponse.destroyed) {
      this.nodeResponse.destroy(error2);
    }
    if (this.response && this.response.body) {
      this.response.body[error] = error2;
      if (!this.response.body.locked) {
        this.response.body.cancel(error2);
      }
    }
  }
  /**
   * Event listener for request "response" event.
   *
   * @param nodeResponse Node response.
   */
  onResponse(nodeResponse) {
    this.isChunkedTransfer = nodeResponse.headers["transfer-encoding"] === "chunked" && !nodeResponse.headers["content-length"];
    this.nodeRequest.setTimeout(0);
    this.responseHeaders = FetchResponseHeaderUtility.parseResponseHeaders({
      browserFrame: this.#browserFrame,
      requestURL: this.request[url],
      rawHeaders: nodeResponse.rawHeaders
    });
    if (this.handleRedirectResponse(nodeResponse, this.responseHeaders)) {
      return;
    }
    nodeResponse.once("end", () => this.request.signal.removeEventListener("abort", this.listeners.onSignalAbort));
    let body2 = Stream2.pipeline(nodeResponse, new Stream2.PassThrough(), (error2) => {
      if (error2) {
      }
    });
    const responseOptions = {
      status: nodeResponse.statusCode,
      statusText: nodeResponse.statusMessage,
      headers: this.responseHeaders
    };
    const contentEncodingHeader = this.responseHeaders.get("Content-Encoding");
    if (this.request.method === "HEAD" || contentEncodingHeader === null || nodeResponse.statusCode === 204 || nodeResponse.statusCode === 304) {
      this.response = new this.#window.Response(FetchBodyUtility.nodeToWebStream(body2), responseOptions);
      this.response.redirected = this.redirectCount > 0;
      this.response.url = this.request.url;
      this.resolve(this.response);
      return;
    }
    if (contentEncodingHeader === "gzip" || contentEncodingHeader === "x-gzip") {
      const zlibOptions = {
        flush: Zlib.constants.Z_SYNC_FLUSH,
        finishFlush: Zlib.constants.Z_SYNC_FLUSH
      };
      body2 = Stream2.pipeline(body2, Zlib.createGunzip(zlibOptions), (error2) => {
        if (error2) {
        }
      });
      this.response = new this.#window.Response(FetchBodyUtility.nodeToWebStream(body2), responseOptions);
      this.response.redirected = this.redirectCount > 0;
      this.response.url = this.request.url;
      this.resolve(this.response);
      return;
    }
    if (contentEncodingHeader === "deflate" || contentEncodingHeader === "x-deflate") {
      const raw = Stream2.pipeline(nodeResponse, new Stream2.PassThrough(), (error2) => {
        if (error2) {
        }
      });
      raw.on("data", (chunk) => {
        if ((chunk[0] & 15) === 8) {
          body2 = Stream2.pipeline(body2, Zlib.createInflate(), (error2) => {
            if (error2) {
            }
          });
        } else {
          body2 = Stream2.pipeline(body2, Zlib.createInflateRaw(), (error2) => {
            if (error2) {
            }
          });
        }
        this.response = new this.#window.Response(FetchBodyUtility.nodeToWebStream(body2), responseOptions);
        this.response.redirected = this.redirectCount > 0;
        this.response.url = this.request.url;
        this.resolve(this.response);
      });
      raw.on("end", () => {
        if (!this.response) {
          this.response = new this.#window.Response(FetchBodyUtility.nodeToWebStream(body2), responseOptions);
          this.response.redirected = this.redirectCount > 0;
          this.response.url = this.request.url;
          this.resolve(this.response);
        }
      });
      return;
    }
    if (contentEncodingHeader === "br") {
      body2 = Stream2.pipeline(body2, Zlib.createBrotliDecompress(), (error2) => {
        if (error2) {
        }
      });
      this.response = new this.#window.Response(FetchBodyUtility.nodeToWebStream(body2), responseOptions);
      this.response.redirected = this.redirectCount > 0;
      this.response.url = this.request.url;
      this.resolve(this.response);
      return;
    }
    this.response = new this.#window.Response(FetchBodyUtility.nodeToWebStream(body2), responseOptions);
    this.response.redirected = this.redirectCount > 0;
    this.response.url = this.request.url;
    this.resolve(this.response);
  }
  /**
   * Handles redirect response.
   *
   * @param nodeResponse Node response.
   * @param responseHeaders Headers.
   * @returns True if redirect response was handled, false otherwise.
   */
  handleRedirectResponse(nodeResponse, responseHeaders) {
    if (!FetchResponseRedirectUtility.isRedirect(nodeResponse.statusCode)) {
      return false;
    }
    switch (this.request.redirect) {
      case "error":
        this.finalizeRequest();
        this.reject(new this.#window.DOMException(`URI requested responds with a redirect, redirect mode is set to "error": ${this.request.url}`, DOMExceptionNameEnum_default.abortError));
        return true;
      case "manual":
        return false;
      case "follow":
        const locationHeader = responseHeaders.get("Location");
        const shouldBecomeGetRequest = nodeResponse.statusCode === 303 || (nodeResponse.statusCode === 301 || nodeResponse.statusCode === 302) && this.request.method === "POST";
        let locationURL = null;
        if (locationHeader !== null) {
          try {
            locationURL = new URL5(locationHeader, this.request.url);
          } catch {
            this.finalizeRequest();
            this.reject(new this.#window.DOMException(`URI requested responds with an invalid redirect URL: ${locationHeader}`, DOMExceptionNameEnum_default.uriMismatchError));
            return true;
          }
        }
        if (locationURL === null) {
          return false;
        }
        if (FetchResponseRedirectUtility.isMaxRedirectsReached(this.redirectCount)) {
          this.finalizeRequest();
          this.reject(new this.#window.DOMException(`Maximum redirects reached at: ${this.request.url}`, DOMExceptionNameEnum_default.networkError));
          return true;
        }
        const headers2 = new Headers(this.request.headers);
        const requestInit = {
          method: this.request.method,
          signal: this.request.signal,
          referrer: this.request.referrer,
          referrerPolicy: this.request.referrerPolicy,
          credentials: this.request.credentials,
          headers: headers2,
          body: this.request[bodyBuffer]
        };
        if (this.request.credentials === "omit" || this.request.credentials === "same-origin" && FetchCORSUtility.isCORS(this.#window.location.href, locationURL)) {
          headers2.delete("authorization");
          headers2.delete("www-authenticate");
          headers2.delete("cookie");
          headers2.delete("cookie2");
        }
        if (this.request.signal[aborted]) {
          this.abort(this.request.signal[reason]);
          return true;
        }
        if (shouldBecomeGetRequest) {
          requestInit.method = "GET";
          requestInit.body = void 0;
          headers2.delete("Content-Length");
          headers2.delete("Content-Type");
        }
        const responseReferrerPolicy = FetchRequestReferrerUtility.getReferrerPolicyFromHeader(headers2);
        if (responseReferrerPolicy) {
          requestInit.referrerPolicy = responseReferrerPolicy;
        }
        const fetch = new _Fetch({
          browserFrame: this.#browserFrame,
          window: this.#window,
          url: locationURL,
          init: requestInit,
          redirectCount: this.redirectCount + 1,
          contentType: !shouldBecomeGetRequest ? this.request[contentType] : void 0
        });
        this.finalizeRequest();
        fetch.send().then((response) => this.resolve(response)).catch((error2) => this.reject(error2));
        return true;
      default:
        this.finalizeRequest();
        this.reject(new this.#window.DOMException(`Redirect option '${this.request.redirect}' is not a valid value of IRequestRedirect`));
        return true;
    }
  }
  /**
   * Finalizes the request.
   */
  finalizeRequest() {
    this.request.signal.removeEventListener("abort", this.listeners.onSignalAbort);
    this.nodeRequest.destroy();
  }
  /**
   * Aborts the request.
   *
   * @param reason Reason.
   */
  abort(reason2) {
    const error2 = new this.#window.DOMException("The operation was aborted." + (reason2 ? " " + reason2.toString() : ""), DOMExceptionNameEnum_default.abortError);
    this.request[aborted] = true;
    if (this.request.body) {
      this.request.body[error] = error2;
    }
    if (this.nodeRequest && !this.nodeRequest.destroyed) {
      this.nodeRequest.destroy(error2);
    }
    if (this.nodeResponse && !this.nodeResponse.destroyed) {
      this.nodeResponse.destroy(error2);
    }
    if (this.response && this.response.body) {
      this.response.body[error] = error2;
      if (!this.response.body.locked) {
        this.response.body.cancel(error2);
      }
    }
    if (this.reject) {
      this.reject(reason2 !== void 0 ? reason2 : error2);
    }
  }
};

// node_modules/happy-dom/lib/history/HistoryScrollRestorationEnum.js
var HistoryScrollRestorationEnum;
(function(HistoryScrollRestorationEnum2) {
  HistoryScrollRestorationEnum2["auto"] = "auto";
  HistoryScrollRestorationEnum2["manual"] = "manual";
})(HistoryScrollRestorationEnum || (HistoryScrollRestorationEnum = {}));
var HistoryScrollRestorationEnum_default = HistoryScrollRestorationEnum;

// node_modules/happy-dom/lib/browser/utilities/BrowserFrameURL.js
import { URL as URL6 } from "url";
var BrowserFrameURL = class {
  /**
   * Returns relative URL.
   *
   * @param frame Frame.
   * @param url URL.
   * @returns Relative URL.
   */
  static getRelativeURL(frame, url2) {
    url2 = url2 ? String(url2) : "about:blank";
    if (url2.startsWith("about:") || url2.startsWith("javascript:")) {
      return new URL6(url2);
    }
    try {
      return new URL6(url2, frame.window.location.href);
    } catch (e) {
      return new URL6("about:blank");
    }
  }
};

// node_modules/happy-dom/lib/history/History.js
var History = class {
  #browserFrame;
  #window;
  #currentHistoryItem;
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   * @param window Owner window.
   */
  constructor(browserFrame, window2) {
    if (!browserFrame) {
      throw new TypeError("Illegal constructor");
    }
    this.#browserFrame = browserFrame;
    this.#window = window2;
    const history2 = browserFrame[history];
    for (let i = history2.length - 1; i >= 0; i--) {
      if (history2[i].isCurrent) {
        this.#currentHistoryItem = history2[i];
        break;
      }
    }
  }
  /**
   * Returns the history length.
   *
   * @returns History length.
   */
  get length() {
    return this.#browserFrame?.[history].length || 0;
  }
  /**
   * Returns an any value representing the state at the top of the history stack. This is a way to look at the state without having to wait for a popstate event.
   *
   * @returns State.
   */
  get state() {
    return this.#currentHistoryItem.state;
  }
  /**
   * Returns scroll restoration.
   *
   * @returns Sroll restoration.
   */
  get scrollRestoration() {
    return this.#currentHistoryItem.scrollRestoration;
  }
  /**
   * Sets scroll restoration.
   *
   * @param scrollRestoration Sroll restoration.
   */
  set scrollRestoration(scrollRestoration) {
    switch (scrollRestoration) {
      case HistoryScrollRestorationEnum_default.auto:
      case HistoryScrollRestorationEnum_default.manual:
        this.#currentHistoryItem.scrollRestoration = scrollRestoration;
        break;
    }
  }
  /**
   * Goes to the previous page in session history.
   */
  back() {
    if (!this.#window.closed) {
      this.#browserFrame?.goBack();
    }
  }
  /**
   * Goes to the next page in session history.
   */
  forward() {
    if (!this.#window.closed) {
      this.#browserFrame?.goForward();
    }
  }
  /**
   * Load a specific page from the session history.
   *
   * @param delta Delta.
   * @param _delta
   */
  go(delta) {
    if (!this.#window.closed) {
      this.#browserFrame?.goSteps(delta);
    }
  }
  /**
   * Pushes the given data onto the session history stack.
   *
   * @param state State.
   * @param title Title.
   * @param [url] URL.
   */
  pushState(state2, title, url2) {
    if (this.#window.closed) {
      return;
    }
    const history2 = this.#browserFrame?.[history];
    if (!history2) {
      return;
    }
    const location2 = this.#window[location];
    const newURL = url2 ? BrowserFrameURL.getRelativeURL(this.#browserFrame, url2) : location2;
    if (url2 && newURL.origin !== location2.origin) {
      throw new this.#window.DOMException(`Failed to execute 'pushState' on 'History': A history state object with URL '${url2.toString()}' cannot be created in a document with origin '${location2.origin}' and URL '${location2.href}'.`, DOMExceptionNameEnum_default.securityError);
    }
    let previousHistoryItem;
    for (let i = history2.length - 1; i >= 0; i--) {
      if (history2[i].isCurrent) {
        previousHistoryItem = history2[i];
        previousHistoryItem.isCurrent = false;
        history2.length = i + 1;
        break;
      }
    }
    const newHistoryItem = {
      title: title || this.#window.document.title,
      href: newURL.href,
      state: JSON.parse(JSON.stringify(state2)),
      scrollRestoration: this.#currentHistoryItem.scrollRestoration,
      method: previousHistoryItem?.method || "GET",
      formData: previousHistoryItem?.formData || null,
      isCurrent: true
    };
    history2.push(newHistoryItem);
    location2[setURL](this.#browserFrame, newHistoryItem.href);
    this.#currentHistoryItem = newHistoryItem;
  }
  /**
   * This method modifies the current history entry, replacing it with a new state.
   *
   * @param state State.
   * @param title Title.
   * @param [url] URL.
   */
  replaceState(state2, title, url2) {
    if (this.#window.closed) {
      return;
    }
    const history2 = this.#browserFrame?.[history];
    if (!history2) {
      return;
    }
    const location2 = this.#window[location];
    const newURL = url2 ? BrowserFrameURL.getRelativeURL(this.#browserFrame, url2) : location2;
    if (url2 && newURL.origin !== location2.origin) {
      throw new this.#window.DOMException(`Failed to execute 'pushState' on 'History': A history state object with URL '${url2.toString()}' cannot be created in a document with origin '${location2.origin}' and URL '${location2.href}'.`, DOMExceptionNameEnum_default.securityError);
    }
    for (let i = history2.length - 1; i >= 0; i--) {
      if (history2[i].isCurrent) {
        const newHistoryItem = {
          title: title || this.#window.document.title,
          href: newURL.href,
          state: JSON.parse(JSON.stringify(state2)),
          scrollRestoration: history2[i].scrollRestoration,
          method: history2[i].method,
          formData: history2[i].formData,
          isCurrent: true
        };
        history2[i] = newHistoryItem;
        this.#currentHistoryItem = newHistoryItem;
        break;
      }
    }
    if (url2) {
      location2[setURL](this.#browserFrame, this.#currentHistoryItem.href);
    }
  }
  /**
   * Destroys the history.
   *
   * This will make sure that the History API can't access page data from the next history item.
   */
  [destroy]() {
    this.#browserFrame = null;
  }
};

// node_modules/happy-dom/lib/intersection-observer/IntersectionObserver.js
var IntersectionObserver = class {
  // @ts-ignore
  #callback;
  // @ts-ignore
  #options;
  /**
   * Constructor.
   *
   * @param callback Callback.
   * @param options Options.
   */
  constructor(callback, options2) {
    this.#callback = callback;
    this.#options = options2 || {};
  }
  /**
   * Starts observing.
   *
   * @param _target Target.
   */
  observe(_target) {
  }
  /**
   * Disconnects.
   */
  disconnect() {
  }
  /**
   * Unobserves an element.
   *
   * @param _target Target.
   */
  unobserve(_target) {
  }
  /**
   * Returns an array of IntersectionObserverEntry objects for all observed targets.
   *
   * @returns Records.
   */
  takeRecords() {
    return [];
  }
};

// node_modules/happy-dom/lib/intersection-observer/IntersectionObserverEntry.js
var IntersectionObserverEntry = class {
  boundingClientRect = null;
  intersectionRatio = 0;
  intersectionRect = null;
  isIntersecting = false;
  rootBounds = null;
  target = null;
  time = 0;
  /**
   * Constructor.
   *
   * @param init Options to initialize the intersection observer entry.
   */
  constructor(init) {
    Object.assign(this, init);
  }
};

// node_modules/happy-dom/lib/location/Location.js
import { URL as URL7 } from "url";
var Location = class {
  // Public properties
  [Symbol.toStringTag] = "Location";
  // Private properties
  #browserFrame;
  #url;
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   * @param url URL.
   */
  constructor(browserFrame, url2) {
    if (!browserFrame) {
      throw new TypeError("Illegal constructor");
    }
    this.#browserFrame = browserFrame;
    this.#url = new URL7(url2);
  }
  /**
   * Returns hash.
   *
   * @returns Hash.
   */
  get hash() {
    return this.#url.hash;
  }
  /**
   * Sets hash.
   *
   * @param hash Value.
   */
  set hash(hash) {
    if (!this.#browserFrame) {
      return;
    }
    const oldURL = this.#url.href;
    this.#url.hash = hash;
    const newURL = this.#url.href;
    if (newURL !== oldURL) {
      this.#browserFrame.window?.dispatchEvent(new HashChangeEvent("hashchange", { oldURL, newURL }));
      this.#browserFrame.window?.document?.[clearCache]();
    }
  }
  /**
   * Returns host.
   *
   * @returns Host.
   */
  get host() {
    return this.#url.host;
  }
  /**
   * Sets host.
   *
   * @param host Value.
   */
  set host(host2) {
    const url2 = new URL7(this.#url.href);
    url2.host = host2;
    this.href = url2.href;
  }
  /**
   * Returns hostname.
   *
   * @returns Hostname.
   */
  get hostname() {
    return this.#url.hostname;
  }
  /**
   * Sets hostname.
   *
   * @param hostname Value.
   */
  set hostname(hostname) {
    const url2 = new URL7(this.#url.href);
    url2.hostname = hostname;
    this.href = url2.href;
  }
  /**
   * Override set href.
   */
  get href() {
    return this.#url.href;
  }
  /**
   * Override set href.
   */
  set href(url2) {
    if (!this.#browserFrame) {
      return;
    }
    this.#browserFrame.goto(url2).catch((error2) => {
      if (this.#browserFrame.page?.console) {
        this.#browserFrame.page.console.error(error2);
      } else {
        throw error2;
      }
    });
  }
  /**
   * Returns origin.
   *
   * @returns Origin.
   */
  get origin() {
    return this.#url.origin;
  }
  /**
   * Returns pathname
   *
   * @returns Pathname.
   */
  get pathname() {
    return this.#url.pathname;
  }
  /**
   * Sets pathname.
   *
   * @param pathname Value.
   */
  set pathname(pathname) {
    const url2 = new URL7(this.#url.href);
    url2.pathname = pathname;
    this.href = url2.href;
  }
  /**
   * Returns port.
   *
   * @returns Port.
   */
  get port() {
    return this.#url.port;
  }
  /**
   * Sets port.
   *
   * @param port Value.
   */
  set port(port) {
    const url2 = new URL7(this.#url.href);
    url2.port = port;
    this.href = url2.href;
  }
  /**
   * Returns protocol.
   *
   * @returns Protocol.
   */
  get protocol() {
    return this.#url.protocol;
  }
  /**
   * Sets protocol.
   *
   * @param protocol Value.
   */
  set protocol(protocol) {
    const url2 = new URL7(this.#url.href);
    url2.protocol = protocol;
    this.href = url2.href;
  }
  /**
   * Returns search.
   *
   * @returns Search.
   */
  get search() {
    return this.#url.search;
  }
  /**
   * Sets search.
   *
   * @param search Value.
   */
  set search(search) {
    const url2 = new URL7(this.#url.href);
    url2.search = search;
    this.href = url2.href;
  }
  /**
   * Replaces the current resource with the one at the provided URL. The difference from the assign() method is that after using replace() the current page will not be saved in session History, meaning the user won't be able to use the back button to navigate to it.
   *
   * @param url URL.
   */
  replace(url2) {
    this.href = String(url2);
  }
  /**
   * Loads the resource at the URL provided in parameter.
   *
   * @param url URL.
   */
  assign(url2) {
    this.href = String(url2);
  }
  /**
   * Reloads the resource from the current URL.
   */
  reload() {
    if (!this.#browserFrame) {
      return;
    }
    this.#browserFrame.goto(this.href).catch((error2) => {
      if (this.#browserFrame.page?.console) {
        this.#browserFrame.page.console.error(error2);
      } else {
        throw error2;
      }
    });
  }
  /**
   * Replaces the current URL state with the provided one without navigating to the new URL.
   *
   * @param browserFrame Browser frame that must match the current one as validation.
   * @param url URL.
   */
  [setURL](browserFrame, url2) {
    if (!this.#browserFrame) {
      return;
    }
    if (this.#browserFrame !== browserFrame) {
      throw new Error("Failed to set URL. Browser frame mismatch.");
    }
    this.#url.href = url2;
  }
  /**
   * Destroys the location.
   */
  [destroy]() {
    this.#browserFrame = null;
  }
  /**
   * Returns the URL as a string.
   *
   * @returns URL as a string.
   */
  toString() {
    return this.#url.toString();
  }
};

// node_modules/happy-dom/lib/mutation-observer/MutationRecord.js
var MutationRecord = class {
  type = null;
  target = null;
  addedNodes = [];
  removedNodes = [];
  previousSibling = null;
  nextSibling = null;
  attributeName = null;
  attributeNamespace = null;
  oldValue = null;
  /**
   * Constructor.
   *
   * @param init Options to initialize the mutation record.
   */
  constructor(init) {
    Object.assign(this, init);
  }
};

// node_modules/happy-dom/lib/navigator/MimeType.js
var MimeType = class {
  description;
  enabledPlugin;
  suffixes;
  type;
  /**
   * Constructor.
   *
   * @param description
   * @param enabledPlugin
   * @param suffixes
   * @param type
   */
  constructor(description, enabledPlugin, suffixes, type2) {
    this.description = description;
    this.enabledPlugin = enabledPlugin;
    this.suffixes = suffixes;
    this.type = type2;
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object MimeType]";
  }
};

// node_modules/happy-dom/lib/navigator/MimeTypeArray.js
var MimeTypeArray = class {
  length;
  /**
   * Constructor.
   *
   * @param mimeTypes
   */
  constructor(mimeTypes) {
    for (let i = 0, max = mimeTypes.length; i < max; i++) {
      this[i] = mimeTypes[i];
      this[mimeTypes[i].type] = mimeTypes[i];
    }
    this.length = mimeTypes.length;
  }
  /**
   * @param index
   */
  item(index) {
    return this[index] || null;
  }
  /**
   * @param name
   */
  namedItem(name2) {
    return this[name2] || null;
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object MimeTypeArray]";
  }
};

// node_modules/happy-dom/lib/navigator/PluginArray.js
var PluginArray = class {
  length;
  /**
   * Constructor.
   *
   * @param plugins Plugins.
   */
  constructor(plugins) {
    for (let i = 0, max = plugins.length; i < max; i++) {
      this[i] = plugins[i];
      this[plugins[i].name] = plugins[i];
    }
    this.length = plugins.length;
  }
  /**
   * Returns an item.
   *
   * @param index Index.
   * @returns Plugin.
   */
  item(index) {
    return this[index] || null;
  }
  /**
   * Returns an item.
   *
   * @param name Name.
   * @returns Plugin.
   */
  namedItem(name2) {
    return this[name2] || null;
  }
  /**
   * Refreshes the list.
   */
  refresh() {
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object PluginArray]";
  }
};

// node_modules/happy-dom/lib/permissions/PermissionNameEnum.js
var PermissionNameEnum;
(function(PermissionNameEnum2) {
  PermissionNameEnum2["geolocation"] = "geolocation";
  PermissionNameEnum2["notifications"] = "notifications";
  PermissionNameEnum2["push"] = "push";
  PermissionNameEnum2["midi"] = "midi";
  PermissionNameEnum2["camera"] = "camera";
  PermissionNameEnum2["microphone"] = "microphone";
  PermissionNameEnum2["backgroundFetch"] = "background-fetch";
  PermissionNameEnum2["backgroundSync"] = "background-sync";
  PermissionNameEnum2["persistentStorage"] = "persistent-storage";
  PermissionNameEnum2["ambientLightSensor"] = "ambient-light-sensor";
  PermissionNameEnum2["accelerometer"] = "accelerometer";
  PermissionNameEnum2["gyroscope"] = "gyroscope";
  PermissionNameEnum2["magnetometer"] = "magnetometer";
  PermissionNameEnum2["screenWakeLock"] = "screen-wake-lock";
  PermissionNameEnum2["nfc"] = "nfc";
  PermissionNameEnum2["displayCapture"] = "display-capture";
  PermissionNameEnum2["accessibilityEvents"] = "accessibility-events";
  PermissionNameEnum2["clipboardRead"] = "clipboard-read";
  PermissionNameEnum2["clipboardWrite"] = "clipboard-write";
  PermissionNameEnum2["paymentHandler"] = "payment-handler";
  PermissionNameEnum2["idleDetection"] = "idle-detection";
  PermissionNameEnum2["periodicBackgroundSync"] = "periodic-background-sync";
  PermissionNameEnum2["systemWakeLock"] = "system-wake-lock";
  PermissionNameEnum2["storageAccess"] = "storage-access";
  PermissionNameEnum2["windowManagement"] = "window-management";
  PermissionNameEnum2["windowPlacement"] = "window-placement";
  PermissionNameEnum2["localFonts"] = "local-fonts";
  PermissionNameEnum2["topLevelStorageAccess"] = "top-level-storage-access";
})(PermissionNameEnum || (PermissionNameEnum = {}));
var PermissionNameEnum_default = PermissionNameEnum;

// node_modules/happy-dom/lib/permissions/Permissions.js
var Permissions = class {
  #permissionStatus = {};
  #window;
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    if (!window2?.document) {
      new TypeError("Invalid constructor");
    }
    this.#window = window2;
  }
  /**
   * Returns scroll restoration.
   *
   * @param permissionDescriptor Permission descriptor.
   * @param permissionDescriptor.name Permission name.
   * @param [permissionDescriptor.userVisibleOnly] User visible only.
   * @param [permissionDescriptor.sysex] Sysex.
   * @returns Permission status.
   */
  async query(permissionDescriptor) {
    if (this.#permissionStatus[permissionDescriptor.name]) {
      return this.#permissionStatus[permissionDescriptor.name];
    }
    if (!Object.values(PermissionNameEnum_default).includes(permissionDescriptor.name)) {
      throw new Error(`Failed to execute 'query' on 'Permissions': Failed to read the 'name' property from 'PermissionDescriptor': The provided value '${permissionDescriptor.name}' is not a valid enum value of type PermissionName.`);
    }
    this.#permissionStatus[permissionDescriptor.name] = new this.#window.PermissionStatus("granted");
    return this.#permissionStatus[permissionDescriptor.name];
  }
};

// node_modules/happy-dom/lib/navigator/Navigator.js
var Navigator = class {
  #window;
  #clipboard;
  #permissions;
  /**
   * Constructor.
   *
   * @param window Owner window.
   */
  constructor(window2) {
    if (!window2) {
      throw new TypeError("Invalid constructor");
    }
    this.#window = window2;
    this.#clipboard = new Clipboard(window2);
    this.#permissions = new Permissions(window2);
  }
  /**
   * False if setting a cookie will be ignored and true otherwise.
   */
  get cookieEnabled() {
    return true;
  }
  /**
   * TODO: Not implemented.
   */
  get credentials() {
    return null;
  }
  /**
   * TODO: Not implemented.
   */
  get geolocation() {
    return null;
  }
  /**
   * String representing the preferred language of the user, usually the language of the browser UI.
   */
  get language() {
    return "en-US";
  }
  /**
   * Array of string representing the user's preferred languages.
   */
  get languages() {
    return ["en-US", "en"];
  }
  /**
   * TODO: Not implemented.
   */
  get locks() {
    return null;
  }
  /**
   * Maximum number of simultaneous touch contact points are supported by the current device.
   */
  get maxTouchPoints() {
    return new WindowBrowserContext(this.#window).getSettings()?.navigator.maxTouchPoints || 0;
  }
  /**
   * Number of logical processors available to run threads on the user's computer.
   */
  get hardwareConcurrency() {
    return 8;
  }
  /**
   * Browser app code name.
   */
  get appCodeName() {
    return "Mozilla";
  }
  /**
   * Browser app name.
   */
  get appName() {
    return "Netscape";
  }
  /**
   * Browser app version.
   */
  get appVersion() {
    const userAgent = this.userAgent;
    const index = userAgent.indexOf("/");
    return index > -1 ? userAgent.substring(index + 1) : "";
  }
  /**
   * Browser platform.
   */
  get platform() {
    const userAgent = this.userAgent;
    const indexStart = userAgent.indexOf("(");
    const indexEnd = userAgent.indexOf(")");
    return indexStart > -1 && indexEnd > -1 ? userAgent.substring(indexStart + 1, indexEnd) : "";
  }
  /**
   * Browser product.
   */
  get product() {
    return "Gecko";
  }
  /**
   * Browser product sub.
   */
  get productSub() {
    return "20100101";
  }
  /**
   * Browser vendor.
   */
  get vendor() {
    return "";
  }
  /**
   * Browser vendor sub.
   */
  get vendorSub() {
    return "";
  }
  /**
   * Browser user agent.
   *
   * "appCodeName/appVersion number (Platform; Security; OS-or-CPU; Localization; rv: revision-version-number) product/productSub Application-Name Application-Name-version".
   */
  get userAgent() {
    return new WindowBrowserContext(this.#window).getSettings()?.navigator.userAgent || "";
  }
  /**
   * Boolean value indicating whether the browser is working online.
   */
  get onLine() {
    return true;
  }
  /**
   * Returns a Permissions object that can be used to query and update permission status of APIs covered by the Permissions API.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/permissions
   * @returns Permissions.
   */
  get permissions() {
    return this.#permissions;
  }
  /**
   * Returns a Clipboard object providing access to the contents of the system clipboard.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/clipboard
   * @returns Clipboard.
   */
  get clipboard() {
    return this.#clipboard;
  }
  /**
   * Boolean Indicates whether the user agent is controlled by automation.
   */
  get webdriver() {
    return true;
  }
  /**
   * The user's Do Not Track setting, which indicates whether the user is requesting web sites and advertisers to not track them.
   *
   * The value of the property reflects that of the DNT HTTP header, i.e. Values of "1", "0", or "unspecified".
   */
  get doNotTrack() {
    return "unspecified";
  }
  /**
   * Browser mime-types.
   */
  get mimeTypes() {
    return new MimeTypeArray([]);
  }
  /**
   * Browser plugins.
   */
  get plugins() {
    return new PluginArray([]);
  }
  /**
   * Sends an HTTP POST request containing a small amount of data to a web server.
   *
   * @param url URL.
   * @param data Data.
   * @returns "true" if the user agent successfully queued the data for transfer. Otherwise, it returns "false".
   */
  sendBeacon(url2, data2) {
    this.#window.fetch(url2, {
      method: "POST",
      body: data2
    });
    return true;
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object Navigator]";
  }
};

// node_modules/happy-dom/lib/navigator/Plugin.js
var Plugin = class {
  length = 0;
  description;
  filename;
  name;
  /**
   * Constructor.
   *
   * @param mimeTypes Mime types.
   * @param description Description.
   * @param filename Filename.
   * @param name Name.
   */
  constructor(mimeTypes, description, filename, name2) {
    this.description = description;
    this.filename = filename;
    this.name = name2;
    for (let i = 0, max = mimeTypes.length; i < max; i++) {
      this[i] = mimeTypes[i];
      this[mimeTypes[i].type] = mimeTypes[i];
    }
    this.length = mimeTypes.length;
  }
  /**
   * Item.
   *
   * @param index Number.
   * @returns IMimeType.
   */
  item(index) {
    return this[index] || null;
  }
  /**
   * NamedItem.
   *
   * @param name String.
   * @returns IMimeType.
   */
  namedItem(name2) {
    return this[name2] || null;
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object Plugin]";
  }
};

// node_modules/happy-dom/lib/nodes/node/NodeDocumentPositionEnum.js
var NodeDocumentPositionEnum;
(function(NodeDocumentPositionEnum2) {
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["disconnect"] = 1] = "disconnect";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["preceding"] = 2] = "preceding";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["following"] = 4] = "following";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["contains"] = 8] = "contains";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["containedBy"] = 16] = "containedBy";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["implementationSpecific"] = 32] = "implementationSpecific";
})(NodeDocumentPositionEnum || (NodeDocumentPositionEnum = {}));
var NodeDocumentPositionEnum_default = NodeDocumentPositionEnum;

// node_modules/happy-dom/lib/nodes/node/NodeUtility.js
var NodeUtility = class _NodeUtility {
  /**
   * Returns whether the passed node is a text node, and narrows its type.
   *
   * @param node The node to be tested.
   * @returns "true" if the node is a text node.
   */
  static isTextNode(node) {
    return node?.[nodeType] === NodeTypeEnum_default.textNode;
  }
  /**
   * Returns boolean indicating if "ancestorNode" is an inclusive ancestor of "referenceNode".
   *
   * Based on:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/helpers/node.js
   *
   * @see https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor
   * @param ancestorNode Ancestor node.
   * @param referenceNode Reference node.
   * @param [includeShadowRoots = false] Include shadow roots.
   * @returns "true" if inclusive ancestor.
   */
  static isInclusiveAncestor(ancestorNode, referenceNode, includeShadowRoots = false) {
    if (ancestorNode === null || referenceNode === null) {
      return false;
    }
    if (ancestorNode === referenceNode) {
      return true;
    }
    if (!ancestorNode[nodeArray].length) {
      return false;
    }
    if (includeShadowRoots && referenceNode[isConnected] !== ancestorNode[isConnected]) {
      return false;
    }
    if (includeShadowRoots && ancestorNode === referenceNode[ownerDocument] && referenceNode[isConnected]) {
      return true;
    }
    let parent2 = referenceNode[parentNode];
    while (parent2) {
      if (ancestorNode === parent2) {
        return true;
      }
      parent2 = parent2[parentNode] ? parent2[parentNode] : includeShadowRoots && parent2.host ? parent2.host : null;
    }
    return false;
  }
  /**
   * Returns boolean indicating if nodeB is following nodeA in the document tree.
   *
   * Based on:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/helpers/node.js
   *
   * @see https://dom.spec.whatwg.org/#concept-tree-following
   * @param nodeA Node A.
   * @param nodeB Node B.
   * @returns "true" if following.
   */
  static isFollowing(nodeA, nodeB) {
    if (nodeA === nodeB) {
      return false;
    }
    let current = nodeB;
    while (current) {
      current = this.following(current);
      if (current === nodeA) {
        return true;
      }
    }
    return false;
  }
  /**
   * Node length.
   *
   * Based on:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/helpers/node.js
   *
   * @see https://dom.spec.whatwg.org/#concept-node-length
   * @param node Node.
   * @returns Node length.
   */
  static getNodeLength(node) {
    switch (node[nodeType]) {
      case NodeTypeEnum_default.documentTypeNode:
        return 0;
      case NodeTypeEnum_default.textNode:
      case NodeTypeEnum_default.processingInstructionNode:
      case NodeTypeEnum_default.commentNode:
        return node.data.length;
      default:
        return node[nodeArray].length;
    }
  }
  /**
   * Returns boolean indicating if nodeB is following nodeA in the document tree.
   *
   * Based on:
   * https://github.com/jsdom/js-symbol-tree/blob/master/lib/SymbolTree.js#L220
   *
   * @param node Node.
   * @param [root] Root.
   * @returns Following node.
   */
  static following(node, root2) {
    const firstChild = node.firstChild;
    if (firstChild) {
      return firstChild;
    }
    let current = node;
    while (current) {
      if (current === root2) {
        return null;
      }
      const nextSibling = current.nextSibling;
      if (nextSibling) {
        return nextSibling;
      }
      current = current[parentNode];
    }
    return null;
  }
  /**
   * Returns the next sibling or parents sibling.
   *
   * @param node Node.
   * @returns Next descendant node.
   */
  static nextDescendantNode(node) {
    while (node && !node.nextSibling) {
      node = node[parentNode];
    }
    if (!node) {
      return null;
    }
    return node.nextSibling;
  }
  /**
   * Needed by https://dom.spec.whatwg.org/#concept-node-equals
   *
   * @param elementA
   * @param elementB
   */
  static attributeListsEqual(elementA, elementB) {
    const attributesA = Array.from(elementA[attributes][items].values());
    const attributesB = Array.from(elementB[attributes][items].values());
    for (const attributeA of attributesA) {
      let found = false;
      for (const attributeB of attributesB) {
        if (attributeA[namespaceURI] === attributeB[namespaceURI] && attributeA.localName === attributeB.localName && attributeA[value] === attributeB[value]) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
   * Check if node nodeA equals node nodeB.
   * Reference: https://dom.spec.whatwg.org/#concept-node-equals
   *
   * @param nodeA Node A.
   * @param nodeB Node B.
   */
  static isEqualNode(nodeA, nodeB) {
    if (nodeA[nodeType] !== nodeB[nodeType]) {
      return false;
    }
    switch (nodeA[nodeType]) {
      case NodeTypeEnum_default.documentTypeNode:
        const documentTypeA = nodeA;
        const documentTypeB = nodeB;
        if (documentTypeA.name !== documentTypeB.name || documentTypeA.publicId !== documentTypeB.publicId || documentTypeA.systemId !== documentTypeB.systemId) {
          return false;
        }
        break;
      case NodeTypeEnum_default.elementNode:
        const elementA = nodeA;
        const elementB = nodeB;
        if (elementA[namespaceURI] !== elementB[namespaceURI] || elementA[prefix] !== elementB[prefix] || elementA[localName] !== elementB[localName] || elementA[attributes][items].size !== elementB[attributes][items].size) {
          return false;
        }
        break;
      case NodeTypeEnum_default.attributeNode:
        const attributeA = nodeA;
        const attributeB = nodeB;
        if (attributeA[namespaceURI] !== attributeB[namespaceURI] || attributeA.localName !== attributeB.localName || attributeA[value] !== attributeB[value]) {
          return false;
        }
        break;
      case NodeTypeEnum_default.processingInstructionNode:
        const processingInstructionA = nodeA;
        const processingInstructionB = nodeB;
        if (processingInstructionA.target !== processingInstructionB.target || processingInstructionA.data !== processingInstructionB.data) {
          return false;
        }
        break;
      case NodeTypeEnum_default.textNode:
      case NodeTypeEnum_default.commentNode:
        const textOrCommentA = nodeA;
        const textOrCommentB = nodeB;
        if (textOrCommentA.data !== textOrCommentB.data) {
          return false;
        }
        break;
    }
    if (nodeA[nodeType] === NodeTypeEnum_default.elementNode && !_NodeUtility.attributeListsEqual(nodeA, nodeB)) {
      return false;
    }
    if (nodeA[nodeArray].length !== nodeB[nodeArray].length) {
      return false;
    }
    for (let i = 0; i < nodeA[nodeArray].length; i++) {
      const childNodeA = nodeA[nodeArray][i];
      const childNodeB = nodeB[nodeArray][i];
      if (!_NodeUtility.isEqualNode(childNodeA, childNodeB)) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/happy-dom/lib/mutation-observer/MutationTypeEnum.js
var MutationTypeEnum;
(function(MutationTypeEnum2) {
  MutationTypeEnum2["attributes"] = "attributes";
  MutationTypeEnum2["characterData"] = "characterData";
  MutationTypeEnum2["childList"] = "childList";
})(MutationTypeEnum || (MutationTypeEnum = {}));
var MutationTypeEnum_default = MutationTypeEnum;

// node_modules/happy-dom/lib/nodes/NodeFactory.js
var NodeFactory = class {
  static ownerDocuments = [];
  /**
   * Creates a node instance with the given owner document.
   *
   * @param ownerDocument Owner document.
   * @param nodeClass Node class.
   * @param [args] Node arguments.
   * @returns Node instance.
   */
  static createNode(ownerDocument2, nodeClass, ...args) {
    if (!nodeClass.prototype[window]) {
      this.ownerDocuments.push(ownerDocument2);
    }
    return new nodeClass(...args);
  }
  /**
   * Pulls an owner document from the queue.
   *
   * @returns Document.
   */
  static pullOwnerDocument() {
    return this.ownerDocuments.pop();
  }
};

// node_modules/happy-dom/lib/nodes/node/Node.js
var Node = class _Node extends EventTarget {
  // Public properties
  static ELEMENT_NODE = NodeTypeEnum_default.elementNode;
  static ATTRIBUTE_NODE = NodeTypeEnum_default.attributeNode;
  static TEXT_NODE = NodeTypeEnum_default.textNode;
  static CDATA_SECTION_NODE = NodeTypeEnum_default.cdataSectionNode;
  static COMMENT_NODE = NodeTypeEnum_default.commentNode;
  static DOCUMENT_NODE = NodeTypeEnum_default.documentNode;
  static DOCUMENT_TYPE_NODE = NodeTypeEnum_default.documentTypeNode;
  static DOCUMENT_FRAGMENT_NODE = NodeTypeEnum_default.documentFragmentNode;
  static PROCESSING_INSTRUCTION_NODE = NodeTypeEnum_default.processingInstructionNode;
  static DOCUMENT_POSITION_CONTAINED_BY = NodeDocumentPositionEnum_default.containedBy;
  static DOCUMENT_POSITION_CONTAINS = NodeDocumentPositionEnum_default.contains;
  static DOCUMENT_POSITION_DISCONNECTED = NodeDocumentPositionEnum_default.disconnect;
  static DOCUMENT_POSITION_FOLLOWING = NodeDocumentPositionEnum_default.following;
  static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = NodeDocumentPositionEnum_default.implementationSpecific;
  static DOCUMENT_POSITION_PRECEDING = NodeDocumentPositionEnum_default.preceding;
  // Internal properties
  [isConnected] = false;
  [parentNode] = null;
  [nodeType];
  [rootNode] = null;
  [styleNode] = null;
  [textAreaNode] = null;
  [formNode] = null;
  [selectNode] = null;
  [mutationListeners] = [];
  [nodeArray] = [];
  [elementArray] = [];
  [childNodes] = null;
  [assignedToSlot] = null;
  [cache] = {
    querySelector: /* @__PURE__ */ new Map(),
    querySelectorAll: /* @__PURE__ */ new Map(),
    matches: /* @__PURE__ */ new Map(),
    elementsByTagName: /* @__PURE__ */ new Map(),
    elementsByTagNameNS: /* @__PURE__ */ new Map(),
    elementByTagName: /* @__PURE__ */ new Map(),
    elementById: /* @__PURE__ */ new Map(),
    computedStyle: null
  };
  [affectsCache] = [];
  /**
   * Constructor.
   */
  constructor() {
    super();
    if (this[window]) {
      this[ownerDocument] = this[window].document;
    } else {
      const ownerDocument2 = NodeFactory.pullOwnerDocument();
      if (!ownerDocument2) {
        throw new TypeError("Illegal constructor");
      }
      this[ownerDocument] = ownerDocument2;
      this[window] = ownerDocument2[window];
    }
  }
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns connected state.
   *
   * @returns Connected state.
   */
  get isConnected() {
    return this[isConnected];
  }
  /**
   * Returns owner document.
   *
   * @returns Owner document.
   */
  get ownerDocument() {
    return this[ownerDocument];
  }
  /**
   * Returns parent node.
   *
   * @returns Parent node.
   */
  get parentNode() {
    return this[parentNode];
  }
  /**
   * Returns node type.
   *
   * @returns Node type.
   */
  get nodeType() {
    return this[nodeType];
  }
  /**
   * Get child nodes.
   *
   * @returns Child nodes list.
   */
  get childNodes() {
    if (!this[childNodes]) {
      this[childNodes] = new NodeList_default(illegalConstructor, this[nodeArray]);
    }
    return this[childNodes];
  }
  /**
   * Get text value of children.
   *
   * @returns Text content.
   */
  get textContent() {
    return null;
  }
  /**
   * Sets text content.
   *
   * @param _textContent Text content.
   */
  set textContent(_textContent) {
  }
  /**
   * Node value.
   *
   * @returns Node value.
   */
  get nodeValue() {
    return null;
  }
  /**
   * Sets node value.
   */
  set nodeValue(_nodeValue) {
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return "";
  }
  /**
   * Previous sibling.
   *
   * @returns Node.
   */
  get previousSibling() {
    if (this[parentNode]) {
      const nodeArray2 = this[parentNode][nodeArray];
      const index = nodeArray2.indexOf(this);
      if (index > 0) {
        return nodeArray2[index - 1];
      }
    }
    return null;
  }
  /**
   * Next sibling.
   *
   * @returns Node.
   */
  get nextSibling() {
    if (this[parentNode]) {
      const nodeArray2 = this[parentNode][nodeArray];
      const index = nodeArray2.indexOf(this);
      if (index > -1 && index + 1 < nodeArray2.length) {
        return nodeArray2[index + 1];
      }
    }
    return null;
  }
  /**
   * First child.
   *
   * @returns Node.
   */
  get firstChild() {
    const nodeArray2 = this[nodeArray];
    if (nodeArray2.length > 0) {
      return nodeArray2[0];
    }
    return null;
  }
  /**
   * Last child.
   *
   * @returns Node.
   */
  get lastChild() {
    const nodeArray2 = this[nodeArray];
    if (nodeArray2.length > 0) {
      return nodeArray2[nodeArray2.length - 1];
    }
    return null;
  }
  /**
   * Returns parent element.
   *
   * @returns Element.
   */
  get parentElement() {
    let parent2 = this[parentNode];
    while (parent2 && parent2[nodeType] !== NodeTypeEnum_default.elementNode) {
      parent2 = parent2[parentNode];
    }
    return parent2;
  }
  /**
   * Returns base URI.
   *
   * @returns Base URI.
   */
  get baseURI() {
    const base = this[ownerDocument].querySelector("base");
    if (base) {
      return base.href;
    }
    return this[window].location.href;
  }
  /**
   * Returns "true" if the node has child nodes.
   *
   * @returns "true" if the node has child nodes.
   */
  hasChildNodes() {
    return this[nodeArray].length > 0;
  }
  /**
   * Returns "true" if this node contains the other node.
   *
   * @param otherNode Node to test with.
   * @returns "true" if this node contains the other node.
   */
  contains(otherNode) {
    if (otherNode === void 0) {
      return false;
    }
    return NodeUtility.isInclusiveAncestor(this, otherNode);
  }
  /**
   * Returns closest root node (Document or ShadowRoot).
   *
   * @param options Options.
   * @param options.composed A Boolean that indicates whether the shadow root should be returned (false, the default), or a root node beyond shadow root (true).
   * @returns Node.
   */
  getRootNode(options2) {
    if (!this[isConnected]) {
      return this;
    }
    if (this[rootNode] && !options2?.composed) {
      return this[rootNode];
    }
    return this[ownerDocument];
  }
  /**
   * Clones a node.
   *
   * @param [deep=false] "true" to clone deep.
   * @returns Cloned node.
   */
  cloneNode(deep = false) {
    return this[cloneNode](deep);
  }
  /**
   * Append a child node to childNodes.
   *
   * @param  node Node to append.
   * @returns Appended node.
   */
  appendChild(node) {
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'appendChild' on 'Node': 1 argument required, but only 0 present`);
    }
    return this[appendChild](node);
  }
  /**
   * Remove Child element from childNodes array.
   *
   * @param node Node to remove.
   * @returns Removed node.
   */
  removeChild(node) {
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'removeChild' on 'Node': 1 argument required, but only 0 present`);
    }
    return this[removeChild](node);
  }
  /**
   * Inserts a node before another.
   *
   * @param newNode Node to insert.
   * @param referenceNode Node to insert before.
   * @returns Inserted node.
   */
  insertBefore(newNode, referenceNode) {
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'insertBefore' on 'Node': 2 arguments required, but only ${arguments.length} present.`);
    }
    return this[insertBefore](newNode, referenceNode);
  }
  /**
   * Replaces a node with another.
   *
   * @param newChild New child.
   * @param oldChild Old child.
   * @returns Replaced node.
   */
  replaceChild(newChild, oldChild) {
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'replaceChild' on 'Node': 2 arguments required, but only ${arguments.length} present.`);
    }
    return this[replaceChild](newChild, oldChild);
  }
  /**
   * Clones a node.
   *
   * @param [deep=false] "true" to clone deep.
   * @returns Cloned node.
   */
  [cloneNode](deep = false) {
    const clone2 = NodeFactory.createNode(this[ownerDocument], this.constructor);
    if (clone2[nodeArray].length) {
      const childNodes2 = clone2[nodeArray];
      while (childNodes2.length) {
        clone2.removeChild(childNodes2[0]);
      }
    }
    if (deep) {
      for (const childNode of this[nodeArray]) {
        const childClone = childNode.cloneNode(true);
        childClone[parentNode] = clone2;
        clone2[nodeArray].push(childClone);
        if (childClone[nodeType] === NodeTypeEnum_default.elementNode) {
          clone2[elementArray].push(childClone);
        }
      }
    }
    return clone2;
  }
  /**
   * Append a child node to childNodes.
   *
   * @param  node Node to append.
   * @param [disableValidations=false] "true" to disable validations.
   * @returns Appended node.
   */
  [appendChild](node, disableValidations = false) {
    if (node[proxy]) {
      node = node[proxy];
    }
    const self2 = this[proxy] || this;
    if (!disableValidations) {
      if (node === self2) {
        throw new this[window].DOMException("Failed to execute 'appendChild' on 'Node': Not possible to append a node as a child of itself.");
      }
      if (NodeUtility.isInclusiveAncestor(node, self2, true)) {
        throw new this[window].DOMException("Failed to execute 'appendChild' on 'Node': The new node is a parent of the node to insert to.", DOMExceptionNameEnum_default.domException);
      }
    }
    if (node[nodeType] === NodeTypeEnum_default.documentFragmentNode) {
      const childNodes2 = node[nodeArray];
      while (childNodes2.length) {
        this.appendChild(childNodes2[0]);
      }
      return node;
    }
    if (node[parentNode]) {
      node[parentNode][removeChild](node);
    }
    node[parentNode] = self2;
    node[clearCache]();
    this[nodeArray].push(node);
    if (node[nodeType] === NodeTypeEnum_default.elementNode) {
      this[elementArray].push(node);
    }
    node[connectedToNode]();
    for (const mutationListener of this[mutationListeners]) {
      if (mutationListener.options?.subtree && mutationListener.callback.deref()) {
        node[observeMutations](mutationListener);
      }
    }
    this[reportMutation](new MutationRecord({
      target: self2,
      type: MutationTypeEnum_default.childList,
      addedNodes: [node]
    }));
    return node;
  }
  /**
   * Remove Child element from childNodes array.
   *
   * @param node Node to remove.
   * @returns Removed node.
   */
  [removeChild](node) {
    if (node[proxy]) {
      node = node[proxy];
    }
    node[parentNode] = null;
    node[clearCache]();
    const index = this[nodeArray].indexOf(node);
    if (index === -1) {
      throw new this[window].DOMException(`Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.`);
    }
    this[nodeArray].splice(index, 1);
    if (node[nodeType] === NodeTypeEnum_default.elementNode) {
      const index2 = this[elementArray].indexOf(node);
      if (index2 !== -1) {
        this[elementArray].splice(index2, 1);
      }
    }
    if (node[assignedToSlot]) {
      const index2 = node[assignedToSlot][assignedNodes].indexOf(node);
      if (index2 !== -1) {
        node[assignedToSlot][assignedNodes].splice(index2, 1);
      }
      node[assignedToSlot] = null;
    }
    node[disconnectedFromNode]();
    for (const mutationListener of this[mutationListeners]) {
      if (mutationListener.options?.subtree && mutationListener.callback.deref()) {
        node[unobserveMutations](mutationListener);
      }
    }
    this[reportMutation](new MutationRecord({
      target: this[proxy] || this,
      type: MutationTypeEnum_default.childList,
      removedNodes: [node]
    }));
    return node;
  }
  /**
   * Inserts a node before another.
   *
   * @param newNode Node to insert.
   * @param referenceNode Node to insert before.
   * @param [disableValidations=false] "true" to disable validations.
   * @returns Inserted node.
   */
  [insertBefore](newNode, referenceNode, disableValidations = false) {
    if (newNode[proxy]) {
      newNode = newNode[proxy];
    }
    if (referenceNode && referenceNode[proxy]) {
      referenceNode = referenceNode[proxy];
    }
    if (newNode === referenceNode) {
      return newNode;
    }
    const self2 = this[proxy] || this;
    if (!disableValidations) {
      if (newNode === self2) {
        throw new this[window].DOMException("Failed to execute 'insertBefore' on 'Node': Not possible to insert a node as a child of itself.");
      }
      if (NodeUtility.isInclusiveAncestor(newNode, self2, true)) {
        throw new this[window].DOMException("Failed to execute 'insertBefore' on 'Node': The new node is a parent of the node to insert to.", DOMExceptionNameEnum_default.domException);
      }
    }
    if (newNode[nodeType] === NodeTypeEnum_default.documentFragmentNode) {
      const childNodes2 = newNode[nodeArray];
      while (childNodes2.length > 0) {
        this[insertBefore](childNodes2[0], referenceNode, true);
      }
      return newNode;
    }
    if (!referenceNode) {
      this[appendChild](newNode, true);
      return newNode;
    }
    const nodeArray2 = this[nodeArray];
    if (!nodeArray2.includes(referenceNode)) {
      throw new this[window].DOMException("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.");
    }
    if (newNode[parentNode]) {
      newNode[parentNode][removeChild](newNode);
    }
    newNode[parentNode] = self2;
    newNode[clearCache]();
    const index = nodeArray2.indexOf(referenceNode);
    if (newNode[nodeType] === NodeTypeEnum_default.elementNode) {
      const elementArray2 = this[elementArray];
      if (referenceNode[nodeType] === NodeTypeEnum_default.elementNode) {
        elementArray2.splice(elementArray2.indexOf(referenceNode), 0, newNode);
      } else {
        let isInserted = false;
        for (let i = index, max = nodeArray2.length; i < max; i++) {
          if (nodeArray2[i][nodeType] === NodeTypeEnum_default.elementNode) {
            elementArray2.splice(elementArray2.indexOf(nodeArray2[i]), 0, newNode);
            isInserted = true;
            break;
          }
        }
        if (!isInserted) {
          elementArray2.push(newNode);
        }
      }
    }
    nodeArray2.splice(index, 0, newNode);
    newNode[connectedToNode]();
    for (const mutationListener of this[mutationListeners]) {
      if (mutationListener.options?.subtree && mutationListener.callback.deref()) {
        newNode[observeMutations](mutationListener);
      }
    }
    this[reportMutation](new MutationRecord({
      target: self2,
      type: MutationTypeEnum_default.childList,
      addedNodes: [newNode]
    }));
    return newNode;
  }
  /**
   * Replaces a node with another.
   *
   * @param newChild New child.
   * @param oldChild Old child.
   * @returns Replaced node.
   */
  [replaceChild](newChild, oldChild) {
    this.insertBefore(newChild, oldChild);
    this.removeChild(oldChild);
    return oldChild;
  }
  /**
   * Compares two nodes.
   * Two nodes are equal if they have the same type, defining the same attributes, and so on.
   *
   * @param node  Node to compare.
   * @returns boolean - `true` if two nodes are equal.
   */
  isEqualNode(node) {
    return NodeUtility.isEqualNode(this, node);
  }
  /**
   * Converts the node to a string.
   *
   * @param listener Listener.
   */
  toString() {
    return `[object ${this.constructor.name}]`;
  }
  /**
   * Observeres mutations on the node.
   *
   * Used by MutationObserver and internal logic.
   *
   * @param listener Listener.
   */
  [observeMutations](listener) {
    this[mutationListeners].push(listener);
    if (listener.options.subtree) {
      for (const node of this[nodeArray]) {
        node[observeMutations](listener);
      }
    }
  }
  /**
   * Stops observing mutations on the node.
   *
   * Used by MutationObserver and internal logic.
   *
   * @param listener Listener.
   */
  [unobserveMutations](listener) {
    const index = this[mutationListeners].indexOf(listener);
    if (index !== -1) {
      this[mutationListeners].splice(index, 1);
    }
    if (listener.options.subtree) {
      for (const node of this[nodeArray]) {
        node[unobserveMutations](listener);
      }
    }
  }
  /**
   * Reports a mutation on the node.
   *
   * Used by MutationObserver and internal logic.
   *
   * @param record Mutation record.
   */
  [reportMutation](record) {
    this[clearCache]();
    const mutationListeners2 = this[mutationListeners];
    if (!mutationListeners2.length) {
      return;
    }
    for (let i = 0, max = mutationListeners2.length; i < max; i++) {
      const mutationListener = mutationListeners2[i];
      const callback = mutationListener.callback.deref();
      if (callback) {
        switch (record.type) {
          case MutationTypeEnum_default.childList:
            if (mutationListener.options.childList) {
              callback(record);
            }
            break;
          case MutationTypeEnum_default.attributes:
            if (mutationListener.options.attributes && (!mutationListener.options.attributeFilter || mutationListener.options.attributeFilter.includes(record.attributeName))) {
              callback(record);
            }
            break;
          case MutationTypeEnum_default.characterData:
            if (mutationListener.options?.characterData) {
              callback(record);
            }
            break;
        }
      } else {
        mutationListeners2.splice(i, 1);
        i--;
        max--;
      }
    }
  }
  /**
   * Clears query selector cache.
   */
  [clearCache]() {
    const cache2 = this[cache];
    if (cache2.querySelector.size) {
      for (const item of cache2.querySelector.values()) {
        if (item.result) {
          item.result = null;
        }
      }
      cache2.querySelector = /* @__PURE__ */ new Map();
    }
    if (cache2.querySelectorAll.size) {
      for (const item of cache2.querySelectorAll.values()) {
        if (item.result) {
          item.result = null;
        }
      }
      cache2.querySelectorAll = /* @__PURE__ */ new Map();
    }
    if (cache2.matches.size) {
      for (const item of cache2.matches.values()) {
        if (item.result) {
          item.result = null;
        }
      }
      cache2.matches = /* @__PURE__ */ new Map();
    }
    if (cache2.elementsByTagName.size) {
      for (const item of cache2.elementsByTagName.values()) {
        if (item.result) {
          item.result = null;
        }
      }
      cache2.elementsByTagName = /* @__PURE__ */ new Map();
    }
    if (cache2.elementsByTagNameNS.size) {
      for (const item of cache2.elementsByTagNameNS.values()) {
        if (item.result) {
          item.result = null;
        }
      }
      cache2.elementsByTagNameNS = /* @__PURE__ */ new Map();
    }
    if (cache2.elementByTagName.size) {
      for (const item of cache2.elementByTagName.values()) {
        if (item.result) {
          item.result = null;
        }
      }
      cache2.elementByTagName = /* @__PURE__ */ new Map();
    }
    if (cache2.elementById.size) {
      for (const item of cache2.elementById.values()) {
        if (item.result) {
          item.result = null;
        }
      }
      cache2.elementById = /* @__PURE__ */ new Map();
    }
    const affectsCache2 = this[affectsCache];
    if (affectsCache2.length) {
      for (const item of affectsCache2) {
        item.result = null;
      }
      this[affectsCache] = [];
    }
    const document = this[ownerDocument];
    if (document && document[affectsComputedStyleCache].length) {
      for (const item of document[affectsComputedStyleCache]) {
        item.result = null;
      }
      document[affectsComputedStyleCache] = [];
    }
  }
  /**
   * Called when connected to a node.
   */
  [connectedToNode]() {
    const parentNode2 = this[parentNode];
    const parent2 = parentNode2 || this[host];
    let isConnected2 = false;
    let isDisconnected = false;
    if (!this[isConnected] && parent2[isConnected]) {
      this[isConnected] = true;
      isConnected2 = true;
    } else if (this[isConnected] && !parent2[isConnected]) {
      this[isConnected] = false;
      isDisconnected = true;
    }
    this[ownerDocument] = parent2[ownerDocument] || parent2;
    this[window] = parent2[window] || parent2[defaultView];
    if (parentNode2) {
      if (this[nodeType] !== NodeTypeEnum_default.documentFragmentNode) {
        this[rootNode] = parentNode2[rootNode];
      }
      if (parentNode2[styleNode] && this[tagName] !== "STYLE") {
        this[styleNode] = parentNode2[styleNode];
      }
      if (parentNode2[textAreaNode] && this[tagName] !== "TEXTAREA") {
        this[textAreaNode] = parentNode2[textAreaNode];
      }
      if (parentNode2[formNode] && this[tagName] !== "FORM") {
        this[formNode] = parentNode2[formNode];
      }
      if (parentNode2[selectNode] && this[tagName] !== "SELECT") {
        this[selectNode] = parentNode2[selectNode];
      }
    }
    const childNodes2 = this[nodeArray];
    for (let i = 0, max = childNodes2.length; i < max; i++) {
      childNodes2[i][parentNode] = this;
      childNodes2[i][connectedToNode]();
    }
    if (this[shadowRoot]) {
      this[shadowRoot][connectedToNode]();
    }
    if (isConnected2) {
      this[connectedToDocument]();
    } else if (isDisconnected) {
      this[disconnectedFromDocument]();
    }
  }
  /**
   * Called when disconnected from a node.
   */
  [disconnectedFromNode]() {
    if (this[nodeType] !== NodeTypeEnum_default.documentFragmentNode) {
      this[rootNode] = null;
    }
    if (this[tagName] !== "STYLE") {
      this[styleNode] = null;
    }
    if (this[tagName] !== "TEXTAREA") {
      this[textAreaNode] = null;
    }
    if (this[tagName] !== "FORM") {
      this[formNode] = null;
    }
    if (this[tagName] !== "SELECT") {
      this[selectNode] = null;
    }
    if (this[isConnected]) {
      this[isConnected] = false;
      this[disconnectedFromDocument]();
    }
    const childNodes2 = this[nodeArray];
    for (let i = 0, max = childNodes2.length; i < max; i++) {
      childNodes2[i][connectedToNode]();
    }
    if (this[shadowRoot]) {
      this[shadowRoot][disconnectedFromNode]();
    }
  }
  /**
   * Called when connected to document.
   */
  [connectedToDocument]() {
    if (this[shadowRoot]) {
      this[shadowRoot][connectedToDocument]();
    }
  }
  /**
   * Called when disconnected from document.
   */
  [disconnectedFromDocument]() {
    if (this[ownerDocument][activeElement] === this) {
      this[ownerDocument][clearCache]();
      this[ownerDocument][activeElement] = null;
    }
    if (this[shadowRoot]) {
      this[shadowRoot][disconnectedFromDocument]();
    }
  }
  /**
   * Reports the position of its argument node relative to the node on which it is called.
   *
   * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
   * @param otherNode Other node.
   */
  compareDocumentPosition(otherNode) {
    if (this === otherNode) {
      return 0;
    }
    let node1 = otherNode;
    let node2 = this[proxy] || this;
    let attr1 = null;
    let attr2 = null;
    if (node1[nodeType] === NodeTypeEnum_default.attributeNode) {
      attr1 = node1;
      node1 = attr1[ownerElement];
    }
    if (node2[nodeType] === NodeTypeEnum_default.attributeNode) {
      attr2 = node2;
      node2 = attr2[ownerElement];
      if (attr1 !== null && node1 !== null && node2 === node1) {
        for (const attribute of node2[attributes][items].values()) {
          if (NodeUtility.isEqualNode(attribute, attr1)) {
            return _Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | _Node.DOCUMENT_POSITION_PRECEDING;
          }
          if (NodeUtility.isEqualNode(attribute, attr2)) {
            return _Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | _Node.DOCUMENT_POSITION_FOLLOWING;
          }
        }
      }
    }
    const node2Ancestors = [];
    let node2Ancestor = node2;
    while (node2Ancestor) {
      if (node2Ancestor === node1) {
        return _Node.DOCUMENT_POSITION_CONTAINS | _Node.DOCUMENT_POSITION_PRECEDING;
      }
      node2Ancestors.push(node2Ancestor);
      node2Ancestor = node2Ancestor[parentNode];
    }
    const node1Ancestors = [];
    let node1Ancestor = node1;
    while (node1Ancestor) {
      if (node1Ancestor === node2) {
        return _Node.DOCUMENT_POSITION_CONTAINED_BY | _Node.DOCUMENT_POSITION_FOLLOWING;
      }
      node1Ancestors.push(node1Ancestor);
      node1Ancestor = node1Ancestor[parentNode];
    }
    const reverseArrayIndex = (array, reverseIndex) => {
      return array[array.length - 1 - reverseIndex];
    };
    const root2 = reverseArrayIndex(node2Ancestors, 0);
    if (!root2 || root2 !== reverseArrayIndex(node1Ancestors, 0)) {
      return _Node.DOCUMENT_POSITION_DISCONNECTED | _Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | _Node.DOCUMENT_POSITION_FOLLOWING;
    }
    let commonAncestorIndex = 0;
    const ancestorsMinLength = Math.min(node2Ancestors.length, node1Ancestors.length);
    for (let i = 0; i < ancestorsMinLength; ++i) {
      const node2Ancestor2 = reverseArrayIndex(node2Ancestors, i);
      const node1Ancestor2 = reverseArrayIndex(node1Ancestors, i);
      if (node2Ancestor2 !== node1Ancestor2) {
        break;
      }
      commonAncestorIndex = i;
    }
    const commonAncestor = reverseArrayIndex(node2Ancestors, commonAncestorIndex);
    let indexes = 0;
    let node2Index = -1;
    let node1Index = -1;
    const node2Node = reverseArrayIndex(node2Ancestors, commonAncestorIndex + 1);
    const node1Node = reverseArrayIndex(node1Ancestors, commonAncestorIndex + 1);
    const computeNodeIndexes = (nodes) => {
      for (const childNode of nodes) {
        computeNodeIndexes(childNode[nodeArray]);
        if (childNode === node2Node) {
          node2Index = indexes;
        } else if (childNode === node1Node) {
          node1Index = indexes;
        }
        if (node2Index !== -1 && node1Index !== -1) {
          break;
        }
        indexes++;
      }
    };
    computeNodeIndexes(commonAncestor[nodeArray]);
    return node1Index < node2Index ? _Node.DOCUMENT_POSITION_PRECEDING : _Node.DOCUMENT_POSITION_FOLLOWING;
  }
  /**
   * Normalizes the sub-tree of the node, i.e. joins adjacent text nodes, and
   * removes all empty text nodes.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/normalize
   */
  normalize() {
    let child = this.firstChild;
    while (child) {
      if (NodeUtility.isTextNode(child)) {
        while (NodeUtility.isTextNode(child.nextSibling)) {
          child.data += child.nextSibling.data;
          child.nextSibling.remove();
        }
        if (!child.data.length) {
          const node = child;
          child = child.nextSibling;
          node.remove();
          continue;
        }
      } else {
        child.normalize();
      }
      child = child.nextSibling;
    }
  }
  /**
   * Determines whether the given node is equal to the current node.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/isSameNode
   * @param node Node to check.
   * @returns True if the given node is equal to the current node, otherwise false.
   */
  isSameNode(node) {
    return this === node;
  }
};
Node.prototype.ELEMENT_NODE = NodeTypeEnum_default.elementNode;
Node.prototype.ATTRIBUTE_NODE = NodeTypeEnum_default.attributeNode;
Node.prototype.TEXT_NODE = NodeTypeEnum_default.textNode;
Node.prototype.CDATA_SECTION_NODE = NodeTypeEnum_default.cdataSectionNode;
Node.prototype.COMMENT_NODE = NodeTypeEnum_default.commentNode;
Node.prototype.DOCUMENT_NODE = NodeTypeEnum_default.documentNode;
Node.prototype.DOCUMENT_TYPE_NODE = NodeTypeEnum_default.documentTypeNode;
Node.prototype.DOCUMENT_FRAGMENT_NODE = NodeTypeEnum_default.documentFragmentNode;
Node.prototype.PROCESSING_INSTRUCTION_NODE = NodeTypeEnum_default.processingInstructionNode;
Node.prototype.DOCUMENT_POSITION_CONTAINED_BY = NodeDocumentPositionEnum_default.containedBy;
Node.prototype.DOCUMENT_POSITION_CONTAINS = NodeDocumentPositionEnum_default.contains;
Node.prototype.DOCUMENT_POSITION_DISCONNECTED = NodeDocumentPositionEnum_default.disconnect;
Node.prototype.DOCUMENT_POSITION_FOLLOWING = NodeDocumentPositionEnum_default.following;
Node.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = NodeDocumentPositionEnum_default.implementationSpecific;
Node.prototype.DOCUMENT_POSITION_PRECEDING = NodeDocumentPositionEnum_default.preceding;

// node_modules/happy-dom/lib/nodes/attr/Attr.js
var Attr = class extends Node {
  [nodeType] = NodeTypeEnum_default.attributeNode;
  [namespaceURI] = null;
  [name] = null;
  [localName] = null;
  [prefix] = null;
  [value] = null;
  [specified] = true;
  [ownerElement] = null;
  /**
   * Returns specified.
   *
   * @returns Specified.
   */
  get specified() {
    return this[specified];
  }
  /**
   * Returns owner element.
   *
   * @returns Owner element.
   */
  get ownerElement() {
    return this[ownerElement];
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    return this[value];
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    this[value] = value2;
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this[name];
  }
  /**
   * Returns local name.
   *
   * @returns Local name.
   */
  get localName() {
    return this[localName];
  }
  /**
   * Returns prefix.
   *
   * @returns Prefix.
   */
  get prefix() {
    return this[prefix];
  }
  /**
   * @override
   */
  get textContent() {
    return this[value];
  }
  /**
   * Returns namespace URI.
   *
   * @returns Namespace URI.
   */
  get namespaceURI() {
    return this[namespaceURI];
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[namespaceURI] = this[namespaceURI];
    clone2[name] = this[name];
    clone2[localName] = this[localName];
    clone2[prefix] = this[prefix];
    clone2[value] = this[value];
    clone2[specified] = this[specified];
    return clone2;
  }
};

// node_modules/happy-dom/lib/nodes/character-data/CharacterDataUtility.js
var CharacterDataUtility = class {
  /**
   * Appends the given DOMString to the CharacterData.data string; when this method returns, data contains the concatenated DOMString.
   *
   * @param characterData Character data.
   * @param data Data.
   */
  static appendData(characterData, data2) {
    characterData.data += data2;
  }
  /**
   * Removes the specified amount of characters, starting at the specified offset, from the CharacterData.data string; when this method returns, data contains the shortened DOMString.
   *
   * @param characterData Character data.
   * @param offset Offset.
   * @param count Count.
   */
  static deleteData(characterData, offset2, count) {
    characterData.data = characterData.data.substring(0, offset2) + characterData.data.substring(offset2 + count);
  }
  /**
   * Inserts the specified characters, at the specified offset, in the CharacterData.data string; when this method returns, data contains the modified DOMString.
   *
   * @param characterData Character data.
   * @param offset Offset.
   * @param data Data.
   */
  static insertData(characterData, offset2, data2) {
    characterData.data = characterData.data.substring(0, offset2) + data2 + characterData.data.substring(offset2);
  }
  /**
   * Replaces the specified amount of characters, starting at the specified offset, with the specified DOMString; when this method returns, data contains the modified DOMString.
   *
   * @param characterData Character data.
   * @param offset Offset.
   * @param count Count.
   * @param data Data.
   */
  static replaceData(characterData, offset2, count, data2) {
    characterData.data = characterData.data.substring(0, offset2) + data2 + characterData.data.substring(offset2 + count);
  }
  /**
   * Returns a DOMString containing the part of CharacterData.data of the specified length and starting at the specified offset.
   *
   * @param characterData Character data.
   * @param offset Offset.
   * @param count Count.
   */
  static substringData(characterData, offset2, count) {
    return characterData.data.substring(offset2, offset2 + count);
  }
};

// node_modules/happy-dom/lib/nodes/child-node/NonDocumentChildNodeUtility.js
var NonDocumentChildNodeUtility = class {
  /**
   * Previous element sibling.
   *
   * @param childNode Child node.
   * @returns Element.
   */
  static previousElementSibling(childNode) {
    let sibling = childNode.previousSibling;
    while (sibling && sibling[nodeType] !== NodeTypeEnum_default.elementNode) {
      sibling = sibling.previousSibling;
    }
    return sibling;
  }
  /**
   * Next element sibling.
   *
   * @param childNode Child node.
   * @returns Element.
   */
  static nextElementSibling(childNode) {
    let sibling = childNode.nextSibling;
    while (sibling && sibling[nodeType] !== NodeTypeEnum_default.elementNode) {
      sibling = sibling.nextSibling;
    }
    return sibling;
  }
};

// node_modules/happy-dom/lib/nodes/child-node/ChildNodeUtility.js
var ChildNodeUtility = class {
  /**
   * Removes the node from its parent.
   *
   * @param childNode Child node.
   */
  static remove(childNode) {
    if (childNode[parentNode]) {
      childNode[parentNode].removeChild(childNode);
    }
  }
  /**
   * The Node.replaceWith() method replaces this Node in the children list of its parent with a set of Node or DOMString objects.
   *
   * @param childNode Child node.
   * @param nodes List of Node or DOMString.
   */
  static replaceWith(childNode, ...nodes) {
    const parent2 = childNode[parentNode];
    if (!parent2) {
      throw new DOMException("This element has no parent node.");
    }
    for (const node of nodes) {
      if (node instanceof Node) {
        parent2.insertBefore(node, childNode);
      } else {
        parent2.insertBefore(parent2[ownerDocument].createTextNode(String(node)), childNode);
      }
    }
    parent2.removeChild(childNode);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just before this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param childNode Child node.
   * @param nodes List of Node or DOMString.
   */
  static before(childNode, ...nodes) {
    const parent2 = childNode[parentNode];
    if (!parent2) {
      return;
    }
    for (const node of nodes) {
      if (node instanceof Node) {
        parent2.insertBefore(node, childNode);
      } else {
        parent2.insertBefore(parent2[ownerDocument].createTextNode(String(node)), childNode);
      }
    }
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just after this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param childNode Child node.
   * @param nodes List of Node or DOMString.
   */
  static after(childNode, ...nodes) {
    const parent2 = childNode[parentNode];
    if (!parent2) {
      return;
    }
    const nextSibling = childNode.nextSibling;
    for (const node of nodes) {
      const insertedNode = node instanceof Node ? node : parent2[ownerDocument].createTextNode(String(node));
      if (!nextSibling) {
        parent2.appendChild(insertedNode);
      } else {
        parent2.insertBefore(insertedNode, nextSibling);
      }
    }
  }
};

// node_modules/happy-dom/lib/nodes/character-data/CharacterData.js
var CharacterData = class extends Node {
  [data] = "";
  /**
   * Constructor.
   *
   * @param [data] Data.
   */
  constructor(data2) {
    super();
    this[data] = data2 !== void 0 ? String(data2) : "";
  }
  /**
   * Returns text content.
   *
   * @returns Text content.
   */
  get length() {
    return this[data].length;
  }
  /**
   * Returns text content.
   *
   * @returns Text content.
   */
  get data() {
    return this[data];
  }
  /**
   * Sets text content.
   *
   * @param textContent Text content.
   */
  set data(data2) {
    const oldValue = this[data];
    this[data] = String(data2);
    this[reportMutation](new MutationRecord({
      target: this,
      type: MutationTypeEnum_default.characterData,
      oldValue
    }));
  }
  /**
   * Returns text content.
   *
   * @returns Text content.
   */
  get textContent() {
    return this[data];
  }
  /**
   * Sets text content.
   *
   * @param textContent Text content.
   */
  set textContent(textContent) {
    this.data = textContent;
  }
  /**
   * Returns node value.
   *
   * @returns Node value.
   */
  get nodeValue() {
    return this[data];
  }
  /**
   * Sets node value.
   *
   * @param nodeValue Node value.
   */
  set nodeValue(nodeValue) {
    this.textContent = nodeValue;
  }
  /**
   * Previous element sibling.
   *
   * @returns Element.
   */
  get previousElementSibling() {
    return NonDocumentChildNodeUtility.previousElementSibling(this);
  }
  /**
   * Next element sibling.
   *
   * @returns Element.
   */
  get nextElementSibling() {
    return NonDocumentChildNodeUtility.nextElementSibling(this);
  }
  /**
   * Appends the given DOMString to the CharacterData.data string; when this method returns, data contains the concatenated DOMString.
   *
   * @param data Data.
   */
  appendData(data2) {
    CharacterDataUtility.appendData(this, data2);
  }
  /**
   * Removes the specified amount of characters, starting at the specified offset, from the CharacterData.data string; when this method returns, data contains the shortened DOMString.
   *
   * @param offset Offset.
   * @param count Count.
   */
  deleteData(offset2, count) {
    CharacterDataUtility.deleteData(this, offset2, count);
  }
  /**
   * Inserts the specified characters, at the specified offset, in the CharacterData.data string; when this method returns, data contains the modified DOMString.
   *
   * @param offset Offset.
   * @param data Data.
   */
  insertData(offset2, data2) {
    CharacterDataUtility.insertData(this, offset2, data2);
  }
  /**
   * Replaces the specified amount of characters, starting at the specified offset, with the specified DOMString; when this method returns, data contains the modified DOMString.
   *
   * @param offset Offset.
   * @param count Count.
   * @param data Data.
   */
  replaceData(offset2, count, data2) {
    CharacterDataUtility.replaceData(this, offset2, count, data2);
  }
  /**
   * Returns a DOMString containing the part of CharacterData.data of the specified length and starting at the specified offset.
   *
   * @param offset Offset.
   * @param count Count.
   */
  substringData(offset2, count) {
    return CharacterDataUtility.substringData(this, offset2, count);
  }
  /**
   * Removes the object from its parent children list.
   */
  remove() {
    ChildNodeUtility.remove(this);
  }
  /**
   * The Node.replaceWith() method replaces this Node in the children list of its parent with a set of Node or DOMString objects.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceWith(...nodes) {
    ChildNodeUtility.replaceWith(this, ...nodes);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just before this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  before(...nodes) {
    ChildNodeUtility.before(this, ...nodes);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just after this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  after(...nodes) {
    ChildNodeUtility.after(this, ...nodes);
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[data] = this[data];
    return clone2;
  }
};

// node_modules/happy-dom/lib/nodes/document-type/DocumentType.js
var DocumentType = class extends Node {
  [nodeType] = NodeTypeEnum_default.documentTypeNode;
  [name] = "";
  [publicId] = "";
  [systemId] = "";
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this[name];
  }
  /**
   * Returns public ID.
   *
   * @returns Public ID.
   */
  get publicId() {
    return this[publicId];
  }
  /**
   * Returns system ID.
   *
   * @returns System ID.
   */
  get systemId() {
    return this[systemId];
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return this.name;
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return "[object DocumentType]";
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[name] = this[name];
    clone2[publicId] = this[publicId];
    clone2[systemId] = this[systemId];
    return clone2;
  }
};

// node_modules/happy-dom/lib/nodes/document/DocumentReadyStateEnum.js
var DocumentReadyStateEnum;
(function(DocumentReadyStateEnum2) {
  DocumentReadyStateEnum2["loading"] = "loading";
  DocumentReadyStateEnum2["interactive"] = "interactive";
  DocumentReadyStateEnum2["complete"] = "complete";
})(DocumentReadyStateEnum || (DocumentReadyStateEnum = {}));
var DocumentReadyStateEnum_default = DocumentReadyStateEnum;

// node_modules/happy-dom/lib/nodes/document/DocumentReadyStateManager.js
var DocumentReadyStateManager = class {
  totalTasks = 0;
  readyStateCallbacks = [];
  window = null;
  immediate = null;
  isComplete = false;
  /**
   * Constructor.
   *
   * @param window
   */
  constructor(window2) {
    this.window = window2;
  }
  /**
   * Returns a promise that is fulfilled when ready state is complete.
   *
   * @returns Promise.
   */
  waitUntilComplete() {
    return new Promise((resolve) => {
      if (this.isComplete) {
        resolve();
      } else {
        this.readyStateCallbacks.push(resolve);
        this.startTask();
        this.endTask();
      }
    });
  }
  /**
   * Starts a task.
   */
  startTask() {
    if (this.isComplete) {
      return;
    }
    if (this.immediate) {
      this.window.cancelAnimationFrame(this.immediate);
      this.immediate = null;
    }
    this.totalTasks++;
  }
  /**
   * Ends a task.
   */
  endTask() {
    if (this.isComplete) {
      return;
    }
    if (this.immediate) {
      this.window.cancelAnimationFrame(this.immediate);
      this.immediate = null;
    }
    this.totalTasks--;
    this.immediate = this.window.requestAnimationFrame(() => {
      this.immediate = null;
      if (this.totalTasks <= 0) {
        const callbacks2 = this.readyStateCallbacks;
        this.readyStateCallbacks = [];
        this.isComplete = true;
        for (const callback of callbacks2) {
          callback();
        }
      }
    });
  }
};

// node_modules/happy-dom/lib/dom/DOMRectReadOnly.js
var DOMRectReadOnly = class _DOMRectReadOnly {
  [x] = 0;
  [y] = 0;
  [width] = 0;
  [height] = 0;
  /**
   * Constructor.
   *
   * @param [x] X position.
   * @param [y] Y position.
   * @param [width] Width.
   * @param [height] Height.
   */
  constructor(x3, y3, width2, height2) {
    this[x] = x3 !== void 0 && x3 !== null ? Number(x3) : 0;
    this[y] = y3 !== void 0 && y3 !== null ? Number(y3) : 0;
    this[width] = width2 !== void 0 && width2 !== null ? Number(width2) : 0;
    this[height] = height2 !== void 0 && height2 !== null ? Number(height2) : 0;
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    return this[y];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this[width];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this[height];
  }
  /**
   * Returns top.
   *
   * @returns Top.
   */
  get top() {
    return Math.min(this[y], this[y] + this[height]);
  }
  /**
   * Returns right.
   *
   * @returns Right.
   */
  get right() {
    return Math.max(this[x], this[x] + this[width]);
  }
  /**
   * Returns bottom.
   *
   * @returns Bottom.
   */
  get bottom() {
    return Math.max(this[y], this[y] + this[height]);
  }
  /**
   * Returns left.
   *
   * @returns Left.
   */
  get left() {
    return Math.min(this[x], this[x] + this[width]);
  }
  /**
   * Returns the JSON representation of the object.
   *
   * @returns JSON representation.
   */
  toJSON() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height,
      top: this.top,
      right: this.right,
      bottom: this.bottom,
      left: this.left
    };
  }
  /**
   * Returns a new DOMRectReadOnly object.
   *
   * @param other
   * @returns Cloned object.
   */
  static fromRect(other) {
    return new _DOMRectReadOnly(other.x, other.y, other.width, other.height);
  }
};

// node_modules/happy-dom/lib/dom/DOMRect.js
var DOMRect = class _DOMRect extends DOMRectReadOnly {
  /**
   * Sets x.
   *
   * @param value X.
   */
  set x(value2) {
    this[x] = value2;
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    return this[x];
  }
  /**
   * Sets y.
   *
   * @param value Y.
   */
  set y(value2) {
    this[y] = value2;
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    return this[y];
  }
  /**
   * Sets width.
   *
   * @param value Width.
   */
  set width(value2) {
    this[width] = value2;
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this[width];
  }
  /**
   * Sets height.
   *
   * @param value Height.
   */
  set height(value2) {
    this[height] = value2;
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this[height];
  }
  /**
   * Returns a new DOMRect object.
   *
   * @param other
   * @returns Cloned object.
   */
  static fromRect(other) {
    return new _DOMRect(other.x, other.y, other.width, other.height);
  }
};

// node_modules/happy-dom/lib/dom/DOMTokenList.js
var ATTRIBUTE_SPLIT_REGEXP = /[\t\f\n\r ]+/;
var DOMTokenList = class _DOMTokenList {
  [ownerElement];
  [attributeName];
  [cache] = {
    items: [],
    attributeValue: ""
  };
  [supports];
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param ownerElement Owner element.
   * @param attributeName Attribute name.
   * @param [supports] Supports.
   */
  constructor(illegalConstructorSymbol, ownerElement2, attributeName2, supports2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[ownerElement] = ownerElement2;
    this[attributeName] = attributeName2;
    this[supports] = supports2 || [];
    const methodBinder = new ClassMethodBinder(this, [_DOMTokenList]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property === "length") {
          return target2[getTokenList]().length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return target2[getTokenList]()[index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys(target2) {
        return Object.keys(target2[getTokenList]());
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        return !isNaN(index) && index >= 0 && index < target2[getTokenList]().length;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        const items2 = target2[getTokenList]();
        if (!isNaN(index) && items2[index]) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[getTokenList]().length;
  }
  /**
   * Set value.
   *
   * @param value Value.
   */
  set value(value2) {
    this[ownerElement].setAttribute(this[attributeName], value2);
  }
  /**
   * Get value.
   */
  get value() {
    return this[ownerElement].getAttribute(this[attributeName]);
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  [Symbol.iterator]() {
    return this[getTokenList]().values();
  }
  /**
   * Get ClassName.
   *
   * @param index Index.
   * */
  item(index) {
    const items2 = this[getTokenList]();
    if (typeof index === "number") {
      return items2[index] ? items2[index] : null;
    }
    index = Number(index);
    index = isNaN(index) ? 0 : index;
    return items2[index] ? items2[index] : null;
  }
  /**
   * Replace Token.
   *
   * @param token Token.
   * @param newToken NewToken.
   */
  replace(token, newToken) {
    const list = this[getTokenList]();
    const index = list.indexOf(token);
    if (index === -1) {
      return false;
    }
    list[index] = newToken;
    this[ownerElement].setAttribute(this[attributeName], list.join(" "));
    return true;
  }
  /**
   * Supports.
   *
   * @param token Token.
   */
  supports(token) {
    return this[supports].includes(token);
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  values() {
    return this[getTokenList]().values();
  }
  /**
   * Returns an iterator, allowing you to go through all key/value pairs contained in this object.
   */
  entries() {
    return this[getTokenList]().entries();
  }
  /**
   * Executes a provided callback function once for each DOMTokenList element.
   *
   * @param callback
   * @param thisArg
   */
  forEach(callback, thisArg) {
    return this[getTokenList]().forEach(callback, thisArg);
  }
  /**
   * Returns an iterator, allowing you to go through all keys of the key/value pairs contained in this object.
   *
   */
  keys() {
    return this[getTokenList]().keys();
  }
  /**
   * Adds tokens.
   *
   * @param tokens Tokens.
   */
  add(...tokens) {
    const list = this[getTokenList]();
    for (const token of tokens) {
      const index = list.indexOf(token);
      if (index === -1) {
        list.push(token);
      } else {
        list[index] = token;
      }
    }
    this[ownerElement].setAttribute(this[attributeName], list.join(" "));
  }
  /**
   * Removes tokens.
   *
   * @param tokens Tokens.
   */
  remove(...tokens) {
    const list = this[getTokenList]();
    for (const token of tokens) {
      const index = list.indexOf(token);
      if (index !== -1) {
        list.splice(index, 1);
      }
    }
    this[ownerElement].setAttribute(this[attributeName], list.join(" "));
  }
  /**
   * Check if the list contains a class.
   *
   * @param className Class name.
   * @returns TRUE if it contains.
   */
  contains(className) {
    return this[getTokenList]().includes(className);
  }
  /**
   * Toggle a class name.
   *
   * @param token A string representing the class name you want to toggle.
   * @param [force] If included, turns the toggle into a one way-only operation. If set to `false`, then class name will only be removed, but not added. If set to `true`, then class name will only be added, but not removed.
   * @returns A boolean value, `true` or `false`, indicating whether class name is in the list after the call or not.
   */
  toggle(token, force) {
    let shouldAdd;
    if (force !== void 0) {
      shouldAdd = force;
    } else {
      shouldAdd = !this.contains(token);
    }
    if (shouldAdd) {
      this.add(token);
      return true;
    }
    this.remove(token);
    return false;
  }
  /**
   * Returns token list from attribute value.
   *
   * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
   */
  [getTokenList]() {
    const attributeValue2 = this[ownerElement].getAttribute(this[attributeName]) ?? "";
    const cache2 = this[cache];
    if (cache2.attributeValue === attributeValue2) {
      return cache2.items;
    }
    const items2 = [];
    const trimmed = attributeValue2.trim();
    if (trimmed) {
      for (const item of trimmed.split(ATTRIBUTE_SPLIT_REGEXP)) {
        if (!items2.includes(item)) {
          items2.push(item);
        }
      }
    }
    cache2.attributeValue = attributeValue2;
    cache2.items = items2;
    return items2;
  }
  /**
   * Returns DOMTokenList value.
   */
  toString() {
    return this.value || "";
  }
};

// node_modules/happy-dom/lib/tree-walker/NodeFilter.js
var NodeFilter_default = {
  FILTER_ACCEPT: 1,
  FILTER_REJECT: 2,
  FILTER_SKIP: 3,
  SHOW_ALL: -1,
  SHOW_ELEMENT: 1,
  SHOW_ATTRIBUTE: 2,
  SHOW_TEXT: 4,
  SHOW_CDATA_SECTION: 8,
  SHOW_ENTITY_REFERENCE: 16,
  SHOW_ENTITY: 32,
  SHOW_PROCESSING_INSTRUCTION: 64,
  SHOW_COMMENT: 128,
  SHOW_DOCUMENT: 256,
  SHOW_DOCUMENT_TYPE: 512,
  SHOW_DOCUMENT_FRAGMENT: 1024,
  SHOW_NOTATION: 2048
};

// node_modules/happy-dom/lib/tree-walker/NodeFilterMask.js
var NodeFilterMask_default = {
  /* ELEMENT_NODE */
  1: NodeFilter_default.SHOW_ELEMENT,
  /* ATTRIBUTE_NODE */
  2: NodeFilter_default.SHOW_ATTRIBUTE,
  /* TEXT_NODE */
  3: NodeFilter_default.SHOW_TEXT,
  /* CDATA_SECTION_NODE */
  4: NodeFilter_default.SHOW_CDATA_SECTION,
  /* ENTITY_REFERENCE_NODE */
  5: NodeFilter_default.SHOW_ENTITY_REFERENCE,
  /* ENTITY_NODE */
  6: NodeFilter_default.SHOW_PROCESSING_INSTRUCTION,
  /* PROCESSING_INSTRUCTION_NODE */
  7: NodeFilter_default.SHOW_PROCESSING_INSTRUCTION,
  /* COMMENT_NODE */
  8: NodeFilter_default.SHOW_COMMENT,
  /* DOCUMENT_NODE */
  9: NodeFilter_default.SHOW_DOCUMENT,
  /* DOCUMENT_TYPE_NODE */
  10: NodeFilter_default.SHOW_DOCUMENT_TYPE,
  /* DOCUMENT_FRAGMENT_NODE */
  11: NodeFilter_default.SHOW_DOCUMENT_FRAGMENT,
  /* NOTATION_NODE */
  12: NodeFilter_default.SHOW_NOTATION
};

// node_modules/happy-dom/lib/tree-walker/TreeWalker.js
var TraverseChildrenTypeEnum;
(function(TraverseChildrenTypeEnum2) {
  TraverseChildrenTypeEnum2["first"] = "first";
  TraverseChildrenTypeEnum2["last"] = "last";
})(TraverseChildrenTypeEnum || (TraverseChildrenTypeEnum = {}));
var TraverseSiblingsTypeEnum;
(function(TraverseSiblingsTypeEnum2) {
  TraverseSiblingsTypeEnum2["next"] = "next";
  TraverseSiblingsTypeEnum2["previous"] = "previous";
})(TraverseSiblingsTypeEnum || (TraverseSiblingsTypeEnum = {}));
var TreeWalker = class {
  root = null;
  whatToShow = -1;
  filter = null;
  currentNode = null;
  /**
   * Constructor.
   *
   * @param root Root.
   * @param [whatToShow] What to show.
   * @param [filter] Filter.
   */
  constructor(root2, whatToShow = -1, filter = null) {
    if (!(root2 instanceof Node)) {
      throw new DOMException("Parameter 1 was not of type Node.");
    }
    this.root = root2;
    this.whatToShow = whatToShow;
    this.filter = filter;
    this.currentNode = root2;
  }
  /**
   * Moves the current Node to the first visible ancestor node in the document order, and returns the found node. It also moves the current node to this one. If no such node exists, or if it is before that the root node defined at the object construction, returns null and the current node is not changed.
   *
   * @returns Current node.
   */
  parentNode() {
    let node = this.currentNode;
    while (node !== null && node !== this.root) {
      node = node.parentNode;
      if (node !== null && this[filterNode](node) === NodeFilter_default.FILTER_ACCEPT) {
        this.currentNode = node;
        return this.currentNode;
      }
    }
    return null;
  }
  /**
   * Moves the current Node to the first visible child of the current node, and returns the found child. It also moves the current node to this child. If no such child exists, returns null and the current node is not changed.
   *
   * @returns Current node.
   */
  firstChild() {
    return this.#traverseChildren(TraverseChildrenTypeEnum.first);
  }
  /**
   * Moves the current Node to the last visible child of the current node, and returns the found child. It also moves the current node to this child. If no such child exists, null is returned and the current node is not changed.
   *
   * @returns Current node.
   */
  lastChild() {
    return this.#traverseChildren(TraverseChildrenTypeEnum.last);
  }
  /**
   * Moves the current Node to its next sibling, if any, and returns the found sibling. If there is no such node, null is returned and the current node is not changed.
   *
   * @returns Current node.
   */
  nextSibling() {
    return this.#traverseSiblings(TraverseSiblingsTypeEnum.next);
  }
  /**
   * Moves the current Node to its previous sibling, if any, and returns the found sibling. If there is no such node, return null and the current node is not changed.
   *
   * @returns Current node.
   */
  previousSibling() {
    return this.#traverseSiblings(TraverseSiblingsTypeEnum.previous);
  }
  /**
   * Moves the current Node to the previous visible node in the document order, and returns the found node. It also moves the current node to this one. If no such node exists, or if it is before that the root node defined at the object construction, returns null and the current node is not changed.
   *
   * @returns Current node.
   */
  previousNode() {
    let node = this.currentNode;
    while (node !== this.root) {
      let sibling = node.previousSibling;
      while (sibling !== null) {
        let node2 = sibling;
        let result2 = this[filterNode](node2);
        while (result2 !== NodeFilter_default.FILTER_REJECT && node2[nodeArray].length) {
          node2 = node2.lastChild;
          result2 = this[filterNode](node2);
        }
        if (result2 === NodeFilter_default.FILTER_ACCEPT) {
          this.currentNode = node2;
          return node2;
        }
        sibling = node2.previousSibling;
      }
      if (node === this.root || node.parentNode === null) {
        return null;
      }
      node = node.parentNode;
      if (this[filterNode](node) === NodeFilter_default.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
    return null;
  }
  /**
   * Moves the current Node to the next visible node in the document order.
   *
   * @returns Current node.
   */
  nextNode() {
    let node = this.currentNode;
    let result2 = NodeFilter_default.FILTER_ACCEPT;
    while (true) {
      while (result2 !== NodeFilter_default.FILTER_REJECT && node[nodeArray].length) {
        node = node.firstChild;
        result2 = this[filterNode](node);
        if (result2 === NodeFilter_default.FILTER_ACCEPT) {
          this.currentNode = node;
          return node;
        }
      }
      while (node !== null) {
        if (node === this.root) {
          return null;
        }
        const sibling = node.nextSibling;
        if (sibling !== null) {
          node = sibling;
          break;
        }
        node = node.parentNode;
      }
      if (node === null) {
        return null;
      }
      result2 = this[filterNode](node);
      if (result2 === NodeFilter_default.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
  }
  /**
   * Filters a node.
   *
   * Based on solution:
   * https://gist.github.com/shawndumas/1132009.
   *
   * @param node Node.
   * @returns Child nodes.
   */
  [filterNode](node) {
    const mask = NodeFilterMask_default[node.nodeType];
    if (mask && (this.whatToShow & mask) == 0) {
      return NodeFilter_default.FILTER_SKIP;
    }
    if (typeof this.filter === "function") {
      return this.filter(node);
    }
    if (this.filter) {
      return this.filter.acceptNode(node);
    }
    return NodeFilter_default.FILTER_ACCEPT;
  }
  /**
   * Traverses children.
   *
   * @param type Type.
   * @returns Node.
   */
  #traverseChildren(type2) {
    let node = this.currentNode;
    node = type2 === TraverseChildrenTypeEnum.first ? node.firstChild : node.lastChild;
    while (node !== null) {
      const result2 = this[filterNode](node);
      if (result2 === NodeFilter_default.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
      if (result2 === NodeFilter_default.FILTER_SKIP) {
        const child = type2 === TraverseChildrenTypeEnum.first ? node.firstChild : node.lastChild;
        if (child !== null) {
          node = child;
          continue;
        }
      }
      while (node !== null) {
        const sibling = type2 === TraverseChildrenTypeEnum.first ? node.nextSibling : node.previousSibling;
        if (sibling !== null) {
          node = sibling;
          break;
        }
        const parent2 = node.parentNode;
        if (parent2 === null || parent2 === this.root || parent2 === this.currentNode) {
          return null;
        }
        node = parent2;
      }
    }
    return null;
  }
  /**
   * Traverses siblings.
   *
   * @param type Type.
   * @returns Node.
   */
  #traverseSiblings(type2) {
    let node = this.currentNode;
    if (node === this.root) {
      return null;
    }
    while (true) {
      let sibling = type2 === TraverseSiblingsTypeEnum.next ? node.nextSibling : node.previousSibling;
      while (sibling !== null) {
        const node2 = sibling;
        const result2 = this[filterNode](node2);
        if (result2 === NodeFilter_default.FILTER_ACCEPT) {
          this.currentNode = node2;
          return node2;
        }
        sibling = type2 === TraverseSiblingsTypeEnum.next ? node2.firstChild : node2.lastChild;
        if (result2 === NodeFilter_default.FILTER_REJECT || sibling === null) {
          sibling = type2 === TraverseSiblingsTypeEnum.next ? node2.nextSibling : node2.previousSibling;
        }
      }
      node = node.parentNode;
      if (node === null || node === this.root) {
        return null;
      }
      if (this[filterNode](node) === NodeFilter_default.FILTER_ACCEPT) {
        return null;
      }
    }
  }
};

// node_modules/happy-dom/lib/tree-walker/NodeIterator.js
var NodeIterator = class {
  #root = null;
  #whatToShow = -1;
  #filter = null;
  #walker;
  #atRoot = true;
  /**
   * Constructor.
   *
   * @param root Root.
   * @param [whatToShow] What to show.
   * @param [filter] Filter.
   */
  constructor(root2, whatToShow = -1, filter = null) {
    this.#root = root2;
    this.#whatToShow = whatToShow;
    this.#filter = filter;
    this.#walker = new TreeWalker(root2, whatToShow, filter);
  }
  /**
   * Returns root.
   *
   * @returns Root.
   */
  get root() {
    return this.#root;
  }
  /**
   * Returns what to show.
   *
   * @returns What to show.
   */
  get whatToShow() {
    return this.#whatToShow;
  }
  /**
   * Returns filter.
   *
   * @returns Filter.
   */
  get filter() {
    return this.#filter;
  }
  /**
   * Moves the current Node to the next visible node in the document order.
   *
   * @returns Current node.
   */
  nextNode() {
    if (this.#atRoot) {
      this.#atRoot = false;
      if (this.#walker[filterNode](this.#root) !== NodeFilter_default.FILTER_ACCEPT) {
        return this.#walker.nextNode();
      }
      return this.#root;
    }
    return this.#walker.nextNode();
  }
  /**
   * Moves the current Node to the previous visible node in the document order, and returns the found node. It also moves the current node to this one. If no such node exists, or if it is before that the root node defined at the object construction, returns null and the current node is not changed.
   *
   * @returns Current node.
   */
  previousNode() {
    return this.#walker.previousNode();
  }
};

// node_modules/happy-dom/lib/dom-implementation/DOMImplementation.js
var DOMImplementation = class {
  #document;
  /**
   * Constructor.
   *
   * @param document Document.
   */
  constructor(document) {
    this.#document = document;
  }
  /**
   * Creates and returns an XML Document.
   *
   * TODO: Not fully implemented.
   *
   * @param _namespaceURI Namespace URI.
   * @param _qualifiedName Qualified name.
   * @param [_docType] Document type.
   */
  createDocument(_namespaceURI, _qualifiedName, _docType) {
    return new this.#document[window].HTMLDocument();
  }
  /**
   * Creates and returns an HTML Document.
   */
  createHTMLDocument() {
    return new this.#document[window].HTMLDocument();
  }
  /**
   * Creates and returns an HTML Document.
   *
   * @param qualifiedName Qualified name.
   * @param publicId Public ID.
   * @param systemId System ID.
   */
  createDocumentType(qualifiedName, publicId2, systemId2) {
    const documentType = NodeFactory.createNode(this.#document, DocumentType);
    documentType[name] = qualifiedName;
    documentType[publicId] = publicId2;
    documentType[systemId] = systemId2;
    return documentType;
  }
};

// node_modules/happy-dom/lib/nodes/element/HTMLCollection.js
var HTMLCollection = class _HTMLCollection {
  [query];
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param query Query function.
   */
  constructor(illegalConstructorSymbol, query2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[query] = query2;
    const methodBinder = new ClassMethodBinder(this, this.constructor !== _HTMLCollection ? [this.constructor, _HTMLCollection] : [_HTMLCollection]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property === "length") {
          return query2().length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return query2()[index];
        }
        return target2.namedItem(property) || void 0;
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys() {
        const keys = [];
        const items2 = query2();
        for (let i = 0; i < items2.length; i++) {
          const item = items2[i];
          const name2 = item.getAttribute("id") || item.getAttribute("name");
          keys.push(String(i));
          if (name2) {
            keys.push(name2);
          }
        }
        return keys;
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        const items2 = query2();
        const index = Number(property);
        if (!isNaN(index) && index >= 0 && index < items2.length) {
          return true;
        }
        property = String(property);
        for (let i = 0; i < items2.length; i++) {
          const item = items2[i];
          const name2 = item.getAttribute("id") || item.getAttribute("name");
          if (name2 && name2 === property) {
            return true;
          }
        }
        return false;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const items2 = query2();
        const index = Number(property);
        if (!isNaN(index) && index >= 0 && index < items2.length) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
        for (let i = 0; i < items2.length; i++) {
          const item = items2[i];
          const name2 = item.getAttribute("id") || item.getAttribute("name");
          if (name2 && name2 === property) {
            return {
              value: item,
              writable: false,
              enumerable: true,
              configurable: true
            };
          }
        }
      }
    });
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[query]().length;
  }
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns `[object HTMLCollection]`.
   *
   * @returns `[object HTMLCollection]`.
   */
  toLocaleString() {
    return `[object ${this.constructor.name}]`;
  }
  /**
   * Returns `[object HTMLCollection]`.
   *
   * @returns `[object HTMLCollection]`.
   */
  toString() {
    return `[object ${this.constructor.name}]`;
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    const items2 = this[query]();
    return index >= 0 && items2[index] ? items2[index] : null;
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  [Symbol.iterator]() {
    const items2 = this[query]();
    return items2[Symbol.iterator]();
  }
  /**
   * Returns named item.
   *
   * @param name Name.
   * @returns Node.
   */
  namedItem(name2) {
    const items2 = this[query]();
    name2 = String(name2);
    for (const item of items2) {
      if (item.getAttribute("id") === name2 || item.getAttribute("name") === name2) {
        return item;
      }
    }
    return null;
  }
};

// node_modules/happy-dom/lib/range/RangeUtility.js
var RangeUtility = class {
  /**
   * Compares boundary points.
   *
   * Based on logic from:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/range/boundary-point.js
   *
   * @see https://dom.spec.whatwg.org/#concept-range-bp-after
   * @param pointA Point A.
   * @param pointB Point B.
   * @returns A number, -1, 0, or 1, indicating whether the corresponding boundary-point of the Range is respectively before, equal to, or after the corresponding boundary-point of sourceRange.
   */
  static compareBoundaryPointsPosition(pointA, pointB) {
    if (pointA.node === pointB.node) {
      if (pointA.offset === pointB.offset) {
        return 0;
      } else if (pointA.offset < pointB.offset) {
        return -1;
      }
      return 1;
    }
    if (NodeUtility.isFollowing(pointA.node, pointB.node)) {
      return this.compareBoundaryPointsPosition(pointB, pointA) === -1 ? 1 : -1;
    }
    if (NodeUtility.isInclusiveAncestor(pointA.node, pointB.node)) {
      let child = pointB.node;
      while (child[parentNode] !== pointA.node) {
        child = child[parentNode];
      }
      if (child[parentNode][nodeArray].indexOf(child) < pointA.offset) {
        return 1;
      }
    }
    return -1;
  }
  /**
   * Validates a boundary point.
   *
   * @throws DOMException
   * @param point Boundary point.
   */
  static validateBoundaryPoint(point) {
    if (point.node[nodeType] === NodeTypeEnum_default.documentTypeNode) {
      throw new DOMException(`DocumentType Node can't be used as boundary point.`, DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    if (point.offset > NodeUtility.getNodeLength(point.node)) {
      throw new DOMException(`Offset out of bound.`, DOMExceptionNameEnum_default.indexSizeError);
    }
  }
  /**
   * Returns "true" if contained.
   *
   * @param node Node.
   * @param range Range.
   * @returns "true" if contained.
   */
  static isContained(node, range) {
    return this.compareBoundaryPointsPosition({ node, offset: 0 }, { node: range.startContainer, offset: range.startOffset }) === 1 && this.compareBoundaryPointsPosition({ node, offset: NodeUtility.getNodeLength(node) }, { node: range.endContainer, offset: range.endOffset }) === -1;
  }
  /**
   * Returns "true" if partially contained.
   *
   * @param node Node.
   * @param range Range.
   * @returns "true" if partially contained.
   */
  static isPartiallyContained(node, range) {
    return NodeUtility.isInclusiveAncestor(node, range.startContainer) && !NodeUtility.isInclusiveAncestor(node, range.endContainer) || !NodeUtility.isInclusiveAncestor(node, range.startContainer) && NodeUtility.isInclusiveAncestor(node, range.endContainer);
  }
};

// node_modules/happy-dom/lib/selection/SelectionDirectionEnum.js
var SelectionDirectionEnum;
(function(SelectionDirectionEnum2) {
  SelectionDirectionEnum2[SelectionDirectionEnum2["forwards"] = 1] = "forwards";
  SelectionDirectionEnum2[SelectionDirectionEnum2["backwards"] = -1] = "backwards";
  SelectionDirectionEnum2[SelectionDirectionEnum2["directionless"] = 0] = "directionless";
})(SelectionDirectionEnum || (SelectionDirectionEnum = {}));
var SelectionDirectionEnum_default = SelectionDirectionEnum;

// node_modules/happy-dom/lib/selection/Selection.js
var Selection = class {
  #ownerDocument = null;
  #range = null;
  #direction = SelectionDirectionEnum_default.directionless;
  /**
   * Constructor.
   *
   * @param ownerDocument Owner document.
   */
  constructor(ownerDocument2) {
    this.#ownerDocument = ownerDocument2;
  }
  /**
   * Returns range count.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-rangecount
   * @returns Range count.
   */
  get rangeCount() {
    return this.#range ? 1 : 0;
  }
  /**
   * Returns collapsed state.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-iscollapsed
   * @returns "true" if collapsed.
   */
  get isCollapsed() {
    return this.#range === null || this.#range.collapsed;
  }
  /**
   * Returns type.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-type
   * @returns Type.
   */
  get type() {
    if (!this.#range) {
      return "None";
    } else if (this.#range.collapsed) {
      return "Caret";
    }
    return "Range";
  }
  /**
   * Returns anchor node.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-anchornode
   * @returns Node.
   */
  get anchorNode() {
    if (!this.#range) {
      return null;
    }
    return this.#direction === SelectionDirectionEnum_default.forwards ? this.#range.startContainer : this.#range.endContainer;
  }
  /**
   * Returns anchor offset.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-anchoroffset
   * @returns Node.
   */
  get anchorOffset() {
    if (!this.#range) {
      return 0;
    }
    return this.#direction === SelectionDirectionEnum_default.forwards ? this.#range.startOffset : this.#range.endOffset;
  }
  /**
   * Returns anchor node.
   *
   * @deprecated
   * @alias anchorNode
   * @returns Node.
   */
  get baseNode() {
    return this.anchorNode;
  }
  /**
   * Returns anchor offset.
   *
   * @deprecated
   * @alias anchorOffset
   * @returns Node.
   */
  get baseOffset() {
    return this.anchorOffset;
  }
  /**
   * Returns focus node.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-focusnode
   * @returns Node.
   */
  get focusNode() {
    return this.anchorNode;
  }
  /**
   * Returns focus offset.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-focusoffset
   * @returns Node.
   */
  get focusOffset() {
    return this.anchorOffset;
  }
  /**
   * Returns focus node.
   *
   * @deprecated
   * @alias focusNode
   * @returns Node.
   */
  get extentNode() {
    return this.focusNode;
  }
  /**
   * Returns focus offset.
   *
   * @deprecated
   * @alias focusOffset
   * @returns Node.
   */
  get extentOffset() {
    return this.focusOffset;
  }
  /**
   * Adds a range.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-addrange
   * @param newRange Range.
   */
  addRange(newRange) {
    if (!newRange) {
      throw new this.#ownerDocument[window].TypeError("Failed to execute addRange on Selection. Parameter 1 is not of type Range.");
    }
    if (!this.#range && newRange[ownerDocument] === this.#ownerDocument) {
      this.#associateRange(newRange);
    }
  }
  /**
   * Returns Range.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-getrangeat
   * @param index Index.
   * @returns Range.
   */
  getRangeAt(index) {
    if (!this.#range || index !== 0) {
      throw new this.#ownerDocument[window].DOMException("Invalid range index.", DOMExceptionNameEnum_default.indexSizeError);
    }
    return this.#range;
  }
  /**
   * Removes a range from a selection.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-removerange
   * @param range Range.
   */
  removeRange(range) {
    if (this.#range !== range) {
      throw new this.#ownerDocument[window].DOMException("Invalid range.", DOMExceptionNameEnum_default.notFoundError);
    }
    this.#associateRange(null);
  }
  /**
   * Removes all ranges.
   */
  removeAllRanges() {
    this.#associateRange(null);
  }
  /**
   * Removes all ranges.
   *
   * @alias removeAllRanges()
   */
  empty() {
    this.removeAllRanges();
  }
  /**
   * Collapses the current selection to a single point.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-collapse
   * @param node Node.
   * @param offset Offset.
   */
  collapse(node, offset2) {
    if (node === null) {
      this.removeAllRanges();
      return;
    }
    if (node[nodeType] === NodeTypeEnum_default.documentTypeNode) {
      throw new this.#ownerDocument[window].DOMException("DocumentType Node can't be used as boundary point.", DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    if (offset2 > NodeUtility.getNodeLength(node)) {
      throw new this.#ownerDocument[window].DOMException("Invalid range index.", DOMExceptionNameEnum_default.indexSizeError);
    }
    if (node[ownerDocument] !== this.#ownerDocument) {
      return;
    }
    const newRange = new this.#ownerDocument[window].Range();
    newRange[start].node = node;
    newRange[start].offset = offset2;
    newRange[end].node = node;
    newRange[end].offset = offset2;
    this.#associateRange(newRange);
  }
  /**
   * Collapses the current selection to a single point.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-setposition
   * @alias collapse()
   * @param node Node.
   * @param offset Offset.
   */
  setPosition(node, offset2) {
    this.collapse(node, offset2);
  }
  /**
   * Collapses the selection to the end.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-collapsetoend
   */
  collapseToEnd() {
    if (this.#range === null) {
      throw new this.#ownerDocument[window].DOMException("There is no selection to collapse.", DOMExceptionNameEnum_default.invalidStateError);
    }
    const { node, offset: offset2 } = this.#range[end];
    const newRange = new this.#ownerDocument[window].Range();
    newRange[start].node = node;
    newRange[start].offset = offset2;
    newRange[end].node = node;
    newRange[end].offset = offset2;
    this.#associateRange(newRange);
  }
  /**
   * Collapses the selection to the start.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-collapsetostart
   */
  collapseToStart() {
    if (!this.#range) {
      throw new this.#ownerDocument[window].DOMException("There is no selection to collapse.", DOMExceptionNameEnum_default.invalidStateError);
    }
    const { node, offset: offset2 } = this.#range[start];
    const newRange = new this.#ownerDocument[window].Range();
    newRange[start].node = node;
    newRange[start].offset = offset2;
    newRange[end].node = node;
    newRange[end].offset = offset2;
    this.#associateRange(newRange);
  }
  /**
   * Indicates whether a specified node is part of the selection.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-containsnode
   * @param node Node.
   * @param [allowPartialContainment] Set to "true" to allow partial containment.
   * @returns Always returns "true" for now.
   */
  containsNode(node, allowPartialContainment = false) {
    if (!this.#range || node[ownerDocument] !== this.#ownerDocument) {
      return false;
    }
    const startIsBeforeNode = RangeUtility.compareBoundaryPointsPosition(this.#range[start], {
      node,
      offset: 0
    }) === -1;
    const endIsAfterNode = RangeUtility.compareBoundaryPointsPosition(this.#range[end], {
      node,
      offset: NodeUtility.getNodeLength(node)
    }) === 1;
    return allowPartialContainment ? startIsBeforeNode || endIsAfterNode : startIsBeforeNode && endIsAfterNode;
  }
  /**
   * Deletes the selected text from the document's DOM.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-deletefromdocument
   */
  deleteFromDocument() {
    if (this.#range) {
      this.#range.deleteContents();
    }
  }
  /**
   * Moves the focus of the selection to a specified point.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-extend
   * @param node Node.
   * @param offset Offset.
   */
  extend(node, offset2) {
    if (node[ownerDocument] !== this.#ownerDocument) {
      return;
    }
    if (!this.#range) {
      throw new this.#ownerDocument[window].DOMException("There is no selection to extend.", DOMExceptionNameEnum_default.invalidStateError);
    }
    const anchorNode = this.anchorNode;
    const anchorOffset = this.anchorOffset;
    const newRange = new this.#ownerDocument[window].Range();
    newRange[start].node = node;
    newRange[start].offset = 0;
    newRange[end].node = node;
    newRange[end].offset = 0;
    if (node[ownerDocument] !== this.#range[ownerDocument]) {
      newRange[start].offset = offset2;
      newRange[end].offset = offset2;
    } else if (RangeUtility.compareBoundaryPointsPosition({ node: anchorNode, offset: anchorOffset }, { node, offset: offset2 }) <= 0) {
      newRange[start].node = anchorNode;
      newRange[start].offset = anchorOffset;
      newRange[end].node = node;
      newRange[end].offset = offset2;
    } else {
      newRange[start].node = node;
      newRange[start].offset = offset2;
      newRange[end].node = anchorNode;
      newRange[end].offset = anchorOffset;
    }
    this.#associateRange(newRange);
    this.#direction = RangeUtility.compareBoundaryPointsPosition({ node, offset: offset2 }, { node: anchorNode, offset: anchorOffset }) === -1 ? SelectionDirectionEnum_default.backwards : SelectionDirectionEnum_default.forwards;
  }
  /**
   * Selects all children.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-selectallchildren
   * @param node Node.
   */
  selectAllChildren(node) {
    if (node[nodeType] === NodeTypeEnum_default.documentTypeNode) {
      throw new this.#ownerDocument[window].DOMException("DocumentType Node can't be used as boundary point.", DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    if (node[ownerDocument] !== this.#ownerDocument) {
      return;
    }
    const length2 = node[nodeArray].length;
    const newRange = new this.#ownerDocument[window].Range();
    newRange[start].node = node;
    newRange[start].offset = 0;
    newRange[end].node = node;
    newRange[end].offset = length2;
    this.#associateRange(newRange);
  }
  /**
   * Sets the selection to be a range including all or parts of two specified DOM nodes, and any content located between them.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-setbaseandextent
   * @param anchorNode Anchor node.
   * @param anchorOffset Anchor offset.
   * @param focusNode Focus node.
   * @param focusOffset Focus offset.
   */
  setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) {
    if (anchorOffset > NodeUtility.getNodeLength(anchorNode) || focusOffset > NodeUtility.getNodeLength(focusNode)) {
      throw new this.#ownerDocument[window].DOMException("Invalid anchor or focus offset.", DOMExceptionNameEnum_default.indexSizeError);
    }
    if (anchorNode[ownerDocument] !== this.#ownerDocument || focusNode[ownerDocument] !== this.#ownerDocument) {
      return;
    }
    const anchor = { node: anchorNode, offset: anchorOffset };
    const focus = { node: focusNode, offset: focusOffset };
    const newRange = new this.#ownerDocument[window].Range();
    if (RangeUtility.compareBoundaryPointsPosition(anchor, focus) === -1) {
      newRange[start] = anchor;
      newRange[end] = focus;
    } else {
      newRange[start] = focus;
      newRange[end] = anchor;
    }
    this.#associateRange(newRange);
    this.#direction = RangeUtility.compareBoundaryPointsPosition(focus, anchor) === -1 ? SelectionDirectionEnum_default.backwards : SelectionDirectionEnum_default.forwards;
  }
  /**
   * Returns string currently being represented by the selection object.
   *
   * @returns Selection as string.
   */
  toString() {
    return this.#range ? this.#range.toString() : "";
  }
  /**
   * Sets the current range.
   *
   * @param range Range.
   */
  #associateRange(range) {
    const oldRange = this.#range;
    this.#range = range;
    this.#direction = range === null ? SelectionDirectionEnum_default.directionless : SelectionDirectionEnum_default.forwards;
    if (oldRange !== this.#range) {
      this.#ownerDocument.dispatchEvent(new Event("selectionchange"));
    }
  }
};

// node_modules/happy-dom/lib/nodes/document/VisibilityStateEnum.js
var VisibilityStateEnum;
(function(VisibilityStateEnum2) {
  VisibilityStateEnum2["hidden"] = "hidden";
  VisibilityStateEnum2["visible"] = "visible";
  VisibilityStateEnum2["prerender"] = "prerender";
})(VisibilityStateEnum || (VisibilityStateEnum = {}));
var VisibilityStateEnum_default = VisibilityStateEnum;

// node_modules/happy-dom/lib/nodes/document/Document.js
import { URL as URL8 } from "url";

// node_modules/happy-dom/lib/config/HTMLElementConfigContentModelEnum.js
var HTMLElementConfigContentModelEnum;
(function(HTMLElementConfigContentModelEnum2) {
  HTMLElementConfigContentModelEnum2["rawText"] = "rawText";
  HTMLElementConfigContentModelEnum2["noSelfDescendants"] = "noSelfDescendants";
  HTMLElementConfigContentModelEnum2["noFirstLevelSelfDescendants"] = "noFirstLevelSelfDescendants";
  HTMLElementConfigContentModelEnum2["noForbiddenFirstLevelDescendants"] = "noForbiddenFirstLevelDescendants";
  HTMLElementConfigContentModelEnum2["noDescendants"] = "noDescendants";
  HTMLElementConfigContentModelEnum2["permittedDescendants"] = "permittedDescendants";
  HTMLElementConfigContentModelEnum2["textOrComments"] = "textOrComments";
  HTMLElementConfigContentModelEnum2["anyDescendants"] = "anyDescendants";
})(HTMLElementConfigContentModelEnum || (HTMLElementConfigContentModelEnum = {}));
var HTMLElementConfigContentModelEnum_default = HTMLElementConfigContentModelEnum;

// node_modules/happy-dom/lib/config/HTMLElementConfig.js
var HTMLElementConfig_default = {
  a: {
    className: "HTMLAnchorElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noSelfDescendants
  },
  abbr: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  address: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  area: {
    className: "HTMLAreaElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  article: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  aside: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  audio: {
    className: "HTMLAudioElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  b: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  base: {
    className: "HTMLBaseElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  bdi: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  bdo: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  body: {
    className: "HTMLBodyElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  template: {
    className: "HTMLTemplateElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  form: {
    className: "HTMLFormElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  input: {
    className: "HTMLInputElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  textarea: {
    className: "HTMLTextAreaElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  script: {
    className: "HTMLScriptElement",
    contentModel: HTMLElementConfigContentModelEnum_default.rawText
  },
  img: {
    className: "HTMLImageElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  link: {
    className: "HTMLLinkElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  style: {
    className: "HTMLStyleElement",
    contentModel: HTMLElementConfigContentModelEnum_default.rawText
  },
  label: {
    className: "HTMLLabelElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  slot: {
    className: "HTMLSlotElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  meta: {
    className: "HTMLMetaElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  blockquote: {
    className: "HTMLQuoteElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  br: {
    className: "HTMLBRElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  button: {
    className: "HTMLButtonElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  canvas: {
    className: "HTMLCanvasElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  caption: {
    className: "HTMLTableCaptionElement",
    contentModel: HTMLElementConfigContentModelEnum_default.textOrComments
  },
  cite: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  code: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  col: {
    className: "HTMLTableColElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants,
    permittedParents: ["colgroup"]
  },
  colgroup: {
    className: "HTMLTableColElement",
    contentModel: HTMLElementConfigContentModelEnum_default.permittedDescendants,
    permittedDescendants: ["col"]
  },
  data: {
    className: "HTMLDataElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  datalist: {
    className: "HTMLDataListElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  dd: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noForbiddenFirstLevelDescendants,
    forbiddenDescendants: ["dt", "dd"]
  },
  del: {
    className: "HTMLModElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  details: {
    className: "HTMLDetailsElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  dfn: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  dialog: {
    className: "HTMLDialogElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  div: {
    className: "HTMLDivElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  dl: {
    className: "HTMLDListElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  dt: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noForbiddenFirstLevelDescendants,
    forbiddenDescendants: ["dt", "dd"]
  },
  em: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  embed: {
    className: "HTMLEmbedElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  fieldset: {
    className: "HTMLFieldSetElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  figcaption: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  figure: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  footer: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  h1: {
    className: "HTMLHeadingElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants
  },
  h2: {
    className: "HTMLHeadingElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants
  },
  h3: {
    className: "HTMLHeadingElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants
  },
  h4: {
    className: "HTMLHeadingElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants
  },
  h5: {
    className: "HTMLHeadingElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants
  },
  h6: {
    className: "HTMLHeadingElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants
  },
  head: {
    className: "HTMLHeadElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  header: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  hgroup: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  hr: {
    className: "HTMLHRElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  html: {
    className: "HTMLHtmlElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  i: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  iframe: {
    className: "HTMLIFrameElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  ins: {
    className: "HTMLModElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  kbd: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  legend: {
    className: "HTMLLegendElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  li: {
    className: "HTMLLIElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants
  },
  main: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  map: {
    className: "HTMLMapElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  mark: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  menu: {
    className: "HTMLMenuElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  meter: {
    className: "HTMLMeterElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  nav: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  noscript: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  object: {
    className: "HTMLObjectElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  ol: {
    className: "HTMLOListElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  optgroup: {
    className: "HTMLOptGroupElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants
  },
  option: {
    className: "HTMLOptionElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noForbiddenFirstLevelDescendants,
    forbiddenDescendants: ["option", "optgroup"]
  },
  output: {
    className: "HTMLOutputElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  p: {
    className: "HTMLParagraphElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  param: {
    className: "HTMLParamElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  picture: {
    className: "HTMLPictureElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  pre: {
    className: "HTMLPreElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  progress: {
    className: "HTMLProgressElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  q: {
    className: "HTMLQuoteElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  rb: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  rp: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noForbiddenFirstLevelDescendants,
    forbiddenDescendants: ["rp", "rt"]
  },
  rt: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noForbiddenFirstLevelDescendants,
    forbiddenDescendants: ["rp", "rt"]
  },
  rtc: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  ruby: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  s: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  samp: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  section: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  select: {
    className: "HTMLSelectElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  small: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  source: {
    className: "HTMLSourceElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  span: {
    className: "HTMLSpanElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  strong: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  sub: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  summary: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  sup: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  table: {
    className: "HTMLTableElement",
    contentModel: HTMLElementConfigContentModelEnum_default.permittedDescendants,
    permittedDescendants: ["caption", "colgroup", "thead", "tfoot", "tbody"],
    moveForbiddenDescendant: { exclude: [] }
  },
  tbody: {
    className: "HTMLTableSectionElement",
    contentModel: HTMLElementConfigContentModelEnum_default.permittedDescendants,
    permittedDescendants: ["tr"],
    permittedParents: ["table"],
    moveForbiddenDescendant: { exclude: ["caption", "colgroup", "thead", "tfoot", "tbody"] }
  },
  td: {
    className: "HTMLTableCellElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noForbiddenFirstLevelDescendants,
    forbiddenDescendants: ["td", "th", "tr", "tbody", "tfoot", "thead"],
    permittedParents: ["tr"]
  },
  tfoot: {
    className: "HTMLTableSectionElement",
    contentModel: HTMLElementConfigContentModelEnum_default.permittedDescendants,
    permittedDescendants: ["tr"],
    permittedParents: ["table"],
    moveForbiddenDescendant: { exclude: ["caption", "colgroup", "thead", "tfoot", "tbody"] }
  },
  th: {
    className: "HTMLTableCellElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noForbiddenFirstLevelDescendants,
    forbiddenDescendants: ["td", "th", "tr", "tbody", "tfoot", "thead"],
    permittedParents: ["tr"]
  },
  thead: {
    className: "HTMLTableSectionElement",
    contentModel: HTMLElementConfigContentModelEnum_default.permittedDescendants,
    permittedDescendants: ["tr"],
    permittedParents: ["table"],
    moveForbiddenDescendant: { exclude: ["caption", "colgroup", "thead", "tfoot", "tbody"] }
  },
  time: {
    className: "HTMLTimeElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  title: {
    className: "HTMLTitleElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  tr: {
    className: "HTMLTableRowElement",
    contentModel: HTMLElementConfigContentModelEnum_default.permittedDescendants,
    permittedDescendants: ["td", "th"],
    permittedParents: ["tbody", "tfoot", "thead"],
    addPermittedParent: "tbody",
    moveForbiddenDescendant: { exclude: ["caption", "colgroup", "thead", "tfoot", "tbody", "tr"] }
  },
  track: {
    className: "HTMLTrackElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  },
  u: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  ul: {
    className: "HTMLUListElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  var: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  video: {
    className: "HTMLVideoElement",
    contentModel: HTMLElementConfigContentModelEnum_default.anyDescendants
  },
  wbr: {
    className: "HTMLElement",
    contentModel: HTMLElementConfigContentModelEnum_default.noDescendants
  }
};

// node_modules/happy-dom/lib/config/SVGElementConfig.js
var SVGElementConfig_default = {
  svg: { localName: "svg", className: "SVGSVGElement" },
  animate: { localName: "animate", className: "SVGAnimateElement" },
  animatemotion: { localName: "animateMotion", className: "SVGAnimateMotionElement" },
  animatetransform: { localName: "animateTransform", className: "SVGAnimateTransformElement" },
  circle: { localName: "circle", className: "SVGCircleElement" },
  clippath: { localName: "clipPath", className: "SVGClipPathElement" },
  defs: { localName: "defs", className: "SVGDefsElement" },
  desc: { localName: "desc", className: "SVGDescElement" },
  ellipse: { localName: "ellipse", className: "SVGEllipseElement" },
  feblend: { localName: "feBlend", className: "SVGFEBlendElement" },
  fecolormatrix: { localName: "feColorMatrix", className: "SVGFEColorMatrixElement" },
  fecomponenttransfer: {
    localName: "feComponentTransfer",
    className: "SVGFEComponentTransferElement"
  },
  fecomposite: { localName: "feComposite", className: "SVGFECompositeElement" },
  feconvolvematrix: { localName: "feConvolveMatrix", className: "SVGFEConvolveMatrixElement" },
  fediffuselighting: { localName: "feDiffuseLighting", className: "SVGFEDiffuseLightingElement" },
  fedisplacementmap: { localName: "feDisplacementMap", className: "SVGFEDisplacementMapElement" },
  fedistantlight: { localName: "feDistantLight", className: "SVGFEDistantLightElement" },
  fedropshadow: { localName: "feDropShadow", className: "SVGFEDropShadowElement" },
  feflood: { localName: "feFlood", className: "SVGFEFloodElement" },
  fefunca: { localName: "feFuncA", className: "SVGFEFuncAElement" },
  fefuncb: { localName: "feFuncB", className: "SVGFEFuncBElement" },
  fefuncg: { localName: "feFuncG", className: "SVGFEFuncGElement" },
  fefuncr: { localName: "feFuncR", className: "SVGFEFuncRElement" },
  fegaussianblur: { localName: "feGaussianBlur", className: "SVGFEGaussianBlurElement" },
  feimage: { localName: "feImage", className: "SVGFEImageElement" },
  femerge: { localName: "feMerge", className: "SVGFEMergeElement" },
  femergenode: { localName: "feMergeNode", className: "SVGFEMergeNodeElement" },
  femorphology: { localName: "feMorphology", className: "SVGFEMorphologyElement" },
  feoffset: { localName: "feOffset", className: "SVGFEOffsetElement" },
  fepointlight: { localName: "fePointLight", className: "SVGFEPointLightElement" },
  fespecularlighting: {
    localName: "feSpecularLighting",
    className: "SVGFESpecularLightingElement"
  },
  fespotlight: { localName: "feSpotLight", className: "SVGFESpotLightElement" },
  fetile: { localName: "feTile", className: "SVGFETileElement" },
  feturbulence: { localName: "feTurbulence", className: "SVGFETurbulenceElement" },
  filter: { localName: "filter", className: "SVGFilterElement" },
  foreignobject: { localName: "foreignObject", className: "SVGForeignObjectElement" },
  g: { localName: "g", className: "SVGGElement" },
  image: { localName: "image", className: "SVGImageElement" },
  line: { localName: "line", className: "SVGLineElement" },
  lineargradient: { localName: "linearGradient", className: "SVGLinearGradientElement" },
  marker: { localName: "marker", className: "SVGMarkerElement" },
  mask: { localName: "mask", className: "SVGMaskElement" },
  metadata: { localName: "metadata", className: "SVGMetadataElement" },
  mpath: { localName: "mpath", className: "SVGMPathElement" },
  path: { localName: "path", className: "SVGPathElement" },
  pattern: { localName: "pattern", className: "SVGPatternElement" },
  polygon: { localName: "polygon", className: "SVGPolygonElement" },
  polyline: { localName: "polyline", className: "SVGPolylineElement" },
  radialgradient: { localName: "radialGradient", className: "SVGRadialGradientElement" },
  rect: { localName: "rect", className: "SVGRectElement" },
  script: { localName: "script", className: "SVGScriptElement" },
  set: { localName: "set", className: "SVGSetElement" },
  stop: { localName: "stop", className: "SVGStopElement" },
  style: { localName: "style", className: "SVGStyleElement" },
  switch: { localName: "switch", className: "SVGSwitchElement" },
  symbol: { localName: "symbol", className: "SVGSymbolElement" },
  text: { localName: "text", className: "SVGTextElement" },
  textpath: { localName: "textPath", className: "SVGTextPathElement" },
  title: { localName: "title", className: "SVGTitleElement" },
  tspan: { localName: "tspan", className: "SVGTSpanElement" },
  use: { localName: "use", className: "SVGUseElement" },
  view: { localName: "view", className: "SVGViewElement" }
};

// node_modules/happy-dom/lib/utilities/XMLEncodeUtility.js
var XMLEncodeUtility = class {
  /**
   * Encodes attribute value.
   *
   * @param value Value.
   * @returns Escaped value.
   */
  static encodeXMLAttributeValue(value2) {
    if (value2 === null) {
      return "";
    }
    return value2.replace(/&/gu, "&amp;").replace(/"/gu, "&quot;").replace(/</gu, "&lt;").replace(/>/gu, "&gt;").replace(/\t/gu, "&#x9;").replace(/\n/gu, "&#xA;").replace(/\r/gu, "&#xD;");
  }
  /**
   * Decodes attribute value.
   *
   * @param value Value.
   * @returns Decoded value.
   */
  static decodeXMLAttributeValue(value2) {
    if (value2 === null) {
      return "";
    }
    return value2.replace(/&quot;/gu, '"').replace(/&lt;/gu, "<").replace(/&gt;/gu, ">").replace(/&#x9;/gu, "	").replace(/&#xA;/gu, "\n").replace(/&#xD;/gu, "\r").replace(/&amp;/gu, "&");
  }
  /**
   * Encodes attribute value.
   *
   * @param value Value.
   * @returns Escaped value.
   */
  static encodeHTMLAttributeValue(value2) {
    if (value2 === null) {
      return "";
    }
    return value2.replace(/&/gu, "&amp;").replace(/"/gu, "&quot;");
  }
  /**
   * Decodes attribute value.
   *
   * @param value Value.
   * @returns Decoded value.
   */
  static decodeHTMLAttributeValue(value2) {
    if (value2 === null) {
      return "";
    }
    return value2.replace(/&quot;/gu, '"').replace(/&amp;/gu, "&");
  }
  /**
   * Encodes text content.
   *
   * @param text Value.
   * @returns Escaped value.
   */
  static encodeTextContent(text) {
    if (text === null) {
      return "";
    }
    return text.replace(/&/gu, "&amp;").replace(/\xA0/gu, "&nbsp;").replace(/</gu, "&lt;").replace(/>/gu, "&gt;");
  }
  /**
   * Decodes text content.
   *
   * @param text Value.
   * @returns Decoded value.
   */
  static decodeTextContent(text) {
    if (text === null) {
      return "";
    }
    return text.replace(/&nbsp;/gu, String.fromCharCode(160)).replace(/&lt;/gu, "<").replace(/&gt;/gu, ">").replace(/&amp;/gu, "&");
  }
  /**
   * Decodes HTML entities.
   *
   * @param value Value.
   * @returns Decoded value.
   */
  static decodeHTMLEntities(value2) {
    if (value2 === null) {
      return "";
    }
    return value2.replace(/&lt;/gu, "<").replace(/&gt;/gu, ">").replace(/&nbsp;/gu, String.fromCharCode(160)).replace(/&quot;/gu, '"').replace(/&apos;/gu, "'").replace(/&#(\d+);/gu, (_match, dec) => String.fromCharCode(parseInt(dec, 10))).replace(/&#x([A-Fa-f\d]+);/gu, (_match, hex) => String.fromCharCode(parseInt(hex, 16))).replace(/&amp;/gu, "&");
  }
  /**
   * Decodes XML entities.
   *
   * @param value Value.
   * @returns Decoded value.
   */
  static decodeXMLEntities(value2) {
    if (value2 === null) {
      return "";
    }
    return value2.replace(/&lt;/gu, "<").replace(/&gt;/gu, ">").replace(/&quot;/gu, '"').replace(/&apos;/gu, "'").replace(/&#(\d+);/gu, (_match, dec) => String.fromCharCode(parseInt(dec, 10))).replace(/&#x([A-Fa-f\d]+);/gu, (_match, hex) => String.fromCharCode(parseInt(hex, 16))).replace(/&amp;/gu, "&");
  }
};

// node_modules/happy-dom/lib/html-parser/HTMLParser.js
var MARKUP_REGEXP = /<([^\s/!>?]+)|<\/([^\s/!>?]+)\s*>|(<!--)|(-->|--!>)|(<!)|(<\?)|(\/>)|(>)/gm;
var ATTRIBUTE_REGEXP = /\s*([a-zA-Z0-9-_:.$@?\\<\[\]]+)\s*=\s*([a-zA-Z0-9-_:.$@?{}/<]+)|\s*([a-zA-Z0-9-_:.$@?\\<\[\]]+)\s*=\s*"([^"]*)("{0,1})|\s*([a-zA-Z0-9-_:.$@?\\<\[\]]+)\s*=\s*'([^']*)('{0,1})|\s*([a-zA-Z0-9-_:.$@?\\<\[\]]+)/gm;
var DOCUMENT_TYPE_ATTRIBUTE_REGEXP = /"([^"]+)"/gm;
var SPACE_REGEXP3 = /\s+/;
var SPACE_IN_BEGINNING_REGEXP = /^\s+/;
var MarkupReadStateEnum;
(function(MarkupReadStateEnum3) {
  MarkupReadStateEnum3["any"] = "any";
  MarkupReadStateEnum3["startTag"] = "startTag";
  MarkupReadStateEnum3["comment"] = "comment";
  MarkupReadStateEnum3["documentType"] = "documentType";
  MarkupReadStateEnum3["processingInstruction"] = "processingInstruction";
  MarkupReadStateEnum3["rawTextElement"] = "rawTextElement";
})(MarkupReadStateEnum || (MarkupReadStateEnum = {}));
var HTMLDocumentStructureLevelEnum;
(function(HTMLDocumentStructureLevelEnum2) {
  HTMLDocumentStructureLevelEnum2[HTMLDocumentStructureLevelEnum2["root"] = 0] = "root";
  HTMLDocumentStructureLevelEnum2[HTMLDocumentStructureLevelEnum2["doctype"] = 1] = "doctype";
  HTMLDocumentStructureLevelEnum2[HTMLDocumentStructureLevelEnum2["documentElement"] = 2] = "documentElement";
  HTMLDocumentStructureLevelEnum2[HTMLDocumentStructureLevelEnum2["head"] = 3] = "head";
  HTMLDocumentStructureLevelEnum2[HTMLDocumentStructureLevelEnum2["additionalHeadWithoutBody"] = 4] = "additionalHeadWithoutBody";
  HTMLDocumentStructureLevelEnum2[HTMLDocumentStructureLevelEnum2["body"] = 5] = "body";
  HTMLDocumentStructureLevelEnum2[HTMLDocumentStructureLevelEnum2["afterBody"] = 6] = "afterBody";
})(HTMLDocumentStructureLevelEnum || (HTMLDocumentStructureLevelEnum = {}));
var HTMLParser = class {
  window;
  evaluateScripts = false;
  rootNode = null;
  rootDocument = null;
  nodeStack = [];
  tagNameStack = [];
  documentStructure = null;
  startTagIndex = 0;
  markupRegExp = null;
  nextElement = null;
  currentNode = null;
  readState = MarkupReadStateEnum.any;
  /**
   * Constructor.
   *
   * @param window Window.
   * @param [options] Options.
   * @param [options.evaluateScripts] Set to "true" to enable script execution
   */
  constructor(window2, options2) {
    this.window = window2;
    if (options2?.evaluateScripts) {
      this.evaluateScripts = true;
    }
  }
  /**
   * Parses HTML a root element containing nodes found.
   *
   * @param html HTML string.
   * @param [rootNode] Root node.
   * @returns Root node.
   */
  parse(html, rootNode2) {
    this.rootNode = rootNode2 || this.window.document.createDocumentFragment();
    this.rootDocument = this.rootNode instanceof Document ? this.rootNode : this.window.document;
    this.nodeStack = [this.rootNode];
    this.tagNameStack = [null];
    this.currentNode = this.rootNode;
    this.readState = MarkupReadStateEnum.any;
    this.documentStructure = null;
    this.startTagIndex = 0;
    this.markupRegExp = new RegExp(MARKUP_REGEXP, "gm");
    if (this.rootNode instanceof Document) {
      const { doctype, documentElement, head, body: body2 } = this.rootNode;
      if (!documentElement || !head || !body2) {
        throw new Error('Failed to parse HTML: The root node must have "documentElement", "head" and "body".\n\nWe should not end up here and it is therefore a bug in Happy DOM. Please report this issue.');
      }
      this.documentStructure = {
        nodes: {
          doctype: doctype || null,
          documentElement,
          head,
          body: body2
        },
        level: HTMLDocumentStructureLevelEnum.root
      };
    }
    if (this.rootNode instanceof this.window.HTMLHtmlElement) {
      const head = this.rootDocument.createElement("head");
      const body2 = this.rootDocument.createElement("body");
      while (this.rootNode[nodeArray].length > 0) {
        this.rootNode[removeChild](this.rootNode[nodeArray][this.rootNode[nodeArray].length - 1]);
      }
      this.rootNode[appendChild](head);
      this.rootNode[appendChild](body2);
      this.documentStructure = {
        nodes: {
          doctype: null,
          documentElement: this.rootNode,
          head,
          body: body2
        },
        level: HTMLDocumentStructureLevelEnum.documentElement
      };
    }
    let match;
    let lastIndex = 0;
    html = String(html);
    while (match = this.markupRegExp.exec(html)) {
      switch (this.readState) {
        case MarkupReadStateEnum.any:
          if (match.index !== lastIndex && (match[1] || match[2] || match[3] || match[4] || match[5] !== void 0 || match[6])) {
            this.parsePlainText(html.substring(lastIndex, match.index));
          }
          if (match[1]) {
            this.nextElement = this.getStartTagElement(match[1]);
            this.startTagIndex = this.markupRegExp.lastIndex;
            this.readState = MarkupReadStateEnum.startTag;
          } else if (match[2]) {
            this.parseEndTag(match[2]);
          } else if (match[3]) {
            this.startTagIndex = this.markupRegExp.lastIndex;
            this.readState = MarkupReadStateEnum.comment;
          } else if (match[5] !== void 0) {
            this.startTagIndex = this.markupRegExp.lastIndex;
            this.readState = MarkupReadStateEnum.documentType;
          } else if (match[6]) {
            this.startTagIndex = this.markupRegExp.lastIndex;
            this.readState = MarkupReadStateEnum.processingInstruction;
          } else {
            this.parsePlainText(html.substring(lastIndex, this.markupRegExp.lastIndex));
          }
          break;
        case MarkupReadStateEnum.startTag:
          if (match[7] || match[8] || match[2]) {
            if (this.nextElement) {
              const attributeString = html.substring(this.startTagIndex, match[2] ? this.markupRegExp.lastIndex - 1 : match.index);
              const isSelfClosed = !!match[7];
              this.parseEndOfStartTag(attributeString, isSelfClosed);
            } else {
              this.readState = MarkupReadStateEnum.any;
            }
          }
          break;
        case MarkupReadStateEnum.comment:
          if (match[4]) {
            this.parseComment(html.substring(this.startTagIndex, match.index));
          }
          break;
        case MarkupReadStateEnum.documentType:
          if (match[7] || match[8]) {
            this.parseDocumentType(html.substring(this.startTagIndex, match.index));
          }
          break;
        case MarkupReadStateEnum.processingInstruction:
          if (match[7] || match[8]) {
            this.parseComment("?" + html.substring(this.startTagIndex, match.index));
          }
          break;
        case MarkupReadStateEnum.rawTextElement:
          if (match[2]) {
            this.parseRawTextElementContent(match[2], html.substring(this.startTagIndex, match.index));
          }
          break;
      }
      lastIndex = this.markupRegExp.lastIndex;
    }
    if (lastIndex !== html.length && this.currentNode) {
      this.parsePlainText(html.substring(lastIndex));
    }
    return this.rootNode;
  }
  /**
   * Parses plain text.
   *
   * @param text Text.
   */
  parsePlainText(text) {
    if (this.documentStructure) {
      const level = this.documentStructure.level;
      const { documentElement, head, body: body2 } = this.documentStructure.nodes;
      const htmlText = (this.currentNode === this.rootNode || this.currentNode === documentElement) && level < HTMLDocumentStructureLevelEnum.head && body2[elementArray].length === 0 ? text.replace(SPACE_IN_BEGINNING_REGEXP, "") : text;
      if (htmlText) {
        const textNode = this.rootDocument.createTextNode(XMLEncodeUtility.decodeHTMLEntities(htmlText));
        if (this.currentNode === head && level === HTMLDocumentStructureLevelEnum.additionalHeadWithoutBody) {
          documentElement[insertBefore](textNode, body2, true);
        } else if (this.currentNode === this.rootNode || this.currentNode === documentElement || this.currentNode === head && level >= HTMLDocumentStructureLevelEnum.body) {
          if (level === HTMLDocumentStructureLevelEnum.head) {
            documentElement[insertBefore](textNode, body2, true);
          } else if (body2.lastChild?.[nodeType] === NodeTypeEnum_default.textNode) {
            body2.lastChild[data] += text;
          } else {
            body2[appendChild](textNode, true);
          }
        } else {
          this.currentNode[appendChild](textNode, true);
        }
      }
    } else {
      const textNode = this.rootDocument.createTextNode(XMLEncodeUtility.decodeHTMLEntities(text));
      this.currentNode[appendChild](textNode, true);
    }
  }
  /**
   * Parses end of start tag.
   *
   * @param attributeString Attribute string.
   * @param isSelfClosed Is self closed.
   */
  parseEndOfStartTag(attributeString, isSelfClosed) {
    if (attributeString && (!this.documentStructure || this.nextElement !== this.documentStructure.nodes.head || this.documentStructure.level < HTMLDocumentStructureLevelEnum.body)) {
      const attributeRegexp = new RegExp(ATTRIBUTE_REGEXP, "gm");
      let attributeMatch;
      while (attributeMatch = attributeRegexp.exec(attributeString)) {
        if (attributeMatch[1] && attributeMatch[2] || attributeMatch[3] && attributeMatch[5] === '"' || attributeMatch[6] && attributeMatch[8] === "'" || attributeMatch[9]) {
          const name2 = attributeMatch[1] || attributeMatch[3] || attributeMatch[6] || attributeMatch[9] || "";
          const rawValue = attributeMatch[2] || attributeMatch[4] || attributeMatch[7] || "";
          const value2 = rawValue ? XMLEncodeUtility.decodeHTMLAttributeValue(rawValue) : "";
          const attributes2 = this.nextElement[attributes];
          if (this.nextElement[namespaceURI] === NamespaceURI_default.svg) {
            const nameParts = name2.split(":");
            let namespaceURI2 = null;
            switch (nameParts[0]) {
              case "xmlns":
                namespaceURI2 = !nameParts[1] || nameParts[1] === "xlink" ? NamespaceURI_default.xmlns : null;
                break;
              case "xlink":
                namespaceURI2 = NamespaceURI_default.xlink;
                break;
            }
            if (!attributes2.getNamedItemNS(namespaceURI2, nameParts[1] ?? name2)) {
              const attribute = NodeFactory.createNode(this.rootDocument, this.window.Attr);
              attribute[namespaceURI] = namespaceURI2;
              attribute[name] = name2;
              attribute[localName] = namespaceURI2 && nameParts[1] ? nameParts[1] : name2;
              attribute[prefix] = namespaceURI2 && nameParts[1] ? nameParts[0] : null;
              attribute[value] = value2;
              attributes2[setNamedItem](attribute);
            }
          } else if (!attributes2.getNamedItem(name2)) {
            const attributeItem = this.rootDocument.createAttribute(name2);
            attributeItem[value] = value2;
            attributes2[setNamedItem](attributeItem);
          }
          this.startTagIndex += attributeMatch[0].length;
        } else if (!attributeMatch[1] && (attributeMatch[3] && !attributeMatch[5] || attributeMatch[6] && !attributeMatch[8])) {
          return;
        }
      }
    }
    const tagName2 = this.nextElement[tagName];
    const lowerTagName = tagName2.toLowerCase();
    const config = HTMLElementConfig_default[lowerTagName];
    let previousCurrentNode = null;
    while (previousCurrentNode !== this.rootNode) {
      const parentLowerTagName = this.currentNode[tagName]?.toLowerCase();
      const parentConfig = HTMLElementConfig_default[parentLowerTagName];
      if (previousCurrentNode === this.currentNode) {
        throw new Error("Failed to parse HTML: The parser is stuck in an infinite loop. Please report this issue.");
      }
      previousCurrentNode = this.currentNode;
      if (config?.contentModel === HTMLElementConfigContentModelEnum_default.noFirstLevelSelfDescendants && this.tagNameStack[this.tagNameStack.length - 1] === tagName2 || parentConfig?.contentModel === HTMLElementConfigContentModelEnum_default.textOrComments || parentConfig?.contentModel === HTMLElementConfigContentModelEnum_default.noForbiddenFirstLevelDescendants && parentConfig?.forbiddenDescendants?.includes(lowerTagName) || parentConfig?.contentModel === HTMLElementConfigContentModelEnum_default.permittedDescendants && !parentConfig?.permittedDescendants?.includes(lowerTagName) && (!config || !config.addPermittedParent || HTMLElementConfig_default[config.addPermittedParent].permittedParents && !HTMLElementConfig_default[config.addPermittedParent].permittedParents.includes(parentLowerTagName) || HTMLElementConfig_default[config.addPermittedParent].permittedDescendants && !HTMLElementConfig_default[config.addPermittedParent].permittedDescendants.includes(lowerTagName))) {
        if (parentConfig?.contentModel === HTMLElementConfigContentModelEnum_default.permittedDescendants && parentConfig.moveForbiddenDescendant && !parentConfig.moveForbiddenDescendant.exclude.includes(lowerTagName)) {
          let before = this.currentNode;
          while (before) {
            if (!before.parentNode || !HTMLElementConfig_default[before.parentNode[localName]]?.permittedDescendants || HTMLElementConfig_default[before.parentNode[localName]]?.permittedDescendants?.includes(lowerTagName)) {
              break;
            } else {
              before = before.parentNode;
            }
          }
          if (before && before.parentNode) {
            before.parentNode.insertBefore(this.nextElement, before);
          } else {
            before.appendChild(this.nextElement);
          }
          this.startTagIndex = this.markupRegExp.lastIndex;
          this.readState = MarkupReadStateEnum.any;
          return;
        }
        this.nodeStack.pop();
        this.tagNameStack.pop();
        this.currentNode = this.nodeStack[this.nodeStack.length - 1] || this.rootNode;
      } else if (config?.contentModel === HTMLElementConfigContentModelEnum_default.noSelfDescendants && this.tagNameStack.includes(tagName2)) {
        while (this.currentNode !== this.rootNode) {
          if (this.currentNode[tagName] === tagName2) {
            this.nodeStack.pop();
            this.tagNameStack.pop();
            this.currentNode = this.nodeStack[this.nodeStack.length - 1] || this.rootNode;
            break;
          }
          this.nodeStack.pop();
          this.tagNameStack.pop();
          this.currentNode = this.nodeStack[this.nodeStack.length - 1] || this.rootNode;
        }
      } else if (config?.permittedParents && !config.permittedParents.includes(parentLowerTagName)) {
        if (!config.addPermittedParent || HTMLElementConfig_default[config.addPermittedParent].permittedParents && !HTMLElementConfig_default[config.addPermittedParent].permittedParents.includes(parentLowerTagName) || HTMLElementConfig_default[config.addPermittedParent].permittedDescendants && !HTMLElementConfig_default[config.addPermittedParent].permittedDescendants.includes(lowerTagName)) {
          this.readState = MarkupReadStateEnum.any;
          this.startTagIndex = this.markupRegExp.lastIndex;
          return;
        }
        const permittedParent = this.rootDocument.createElement(config.addPermittedParent);
        this.currentNode[appendChild](permittedParent, true);
        this.nodeStack.push(permittedParent);
        this.tagNameStack.push(permittedParent[tagName]);
        this.currentNode = permittedParent;
      } else {
        break;
      }
    }
    if (this.documentStructure) {
      const { documentElement, head, body: body2 } = this.documentStructure.nodes;
      const level = this.documentStructure.level;
      if ((!config || config.contentModel !== HTMLElementConfigContentModelEnum_default.rawText) && this.nextElement !== documentElement && this.nextElement !== head && this.nextElement !== body2) {
        if (documentElement && (this.currentNode === this.rootNode || this.currentNode === documentElement || this.currentNode === head && level >= HTMLDocumentStructureLevelEnum.body)) {
          if (level < HTMLDocumentStructureLevelEnum.body) {
            this.documentStructure.level = HTMLDocumentStructureLevelEnum.afterBody;
          }
          body2[appendChild](this.nextElement, true);
        } else {
          this.currentNode[appendChild](this.nextElement, true);
        }
      }
    } else {
      this.currentNode[appendChild](this.nextElement, true);
    }
    if (!this.documentStructure || this.nextElement !== this.documentStructure.nodes.body || this.documentStructure.level <= HTMLDocumentStructureLevelEnum.body) {
      this.currentNode = this.nextElement;
      this.nodeStack.push(this.currentNode);
      this.tagNameStack.push(tagName2);
      if (this.documentStructure && this.nextElement === this.documentStructure.nodes.body) {
        this.documentStructure.level = HTMLDocumentStructureLevelEnum.afterBody;
      }
      if (config?.contentModel === HTMLElementConfigContentModelEnum_default.noDescendants || isSelfClosed && this.currentNode[namespaceURI] === NamespaceURI_default.svg) {
        this.nodeStack.pop();
        this.tagNameStack.pop();
        this.currentNode = this.nodeStack[this.nodeStack.length - 1] || this.rootNode;
        this.readState = MarkupReadStateEnum.any;
      } else {
        this.readState = config?.contentModel === HTMLElementConfigContentModelEnum_default.rawText ? MarkupReadStateEnum.rawTextElement : MarkupReadStateEnum.any;
      }
    } else {
      this.readState = MarkupReadStateEnum.any;
    }
    this.startTagIndex = this.markupRegExp.lastIndex;
  }
  /**
   * Parses end tag.
   *
   * @param tagName Tag name.
   */
  parseEndTag(tagName2) {
    const name2 = this.currentNode[namespaceURI] === NamespaceURI_default.html ? StringUtility.asciiUpperCase(tagName2) : SVGElementConfig_default[StringUtility.asciiLowerCase(tagName2)]?.localName || tagName2;
    const index = this.tagNameStack.lastIndexOf(name2);
    if (index !== -1) {
      this.nodeStack.splice(index, this.nodeStack.length - index);
      this.tagNameStack.splice(index, this.tagNameStack.length - index);
      this.currentNode = this.nodeStack[this.nodeStack.length - 1] || this.rootNode;
    }
  }
  /**
   * Parses comment.
   *
   * @param comment Comment.
   */
  parseComment(comment) {
    const commentNode = this.rootDocument.createComment(XMLEncodeUtility.decodeHTMLEntities(comment));
    if (this.documentStructure) {
      const level = this.documentStructure.level;
      const { documentElement, head, body: body2 } = this.documentStructure.nodes;
      let beforeNode = null;
      if (this.currentNode === this.rootNode && level === HTMLDocumentStructureLevelEnum.root) {
        beforeNode = documentElement;
      } else if (this.currentNode === documentElement && level === HTMLDocumentStructureLevelEnum.documentElement) {
        beforeNode = head;
      } else if (this.currentNode === documentElement && level === HTMLDocumentStructureLevelEnum.head) {
        beforeNode = body2;
      }
      this.currentNode[insertBefore](commentNode, beforeNode, true);
    } else {
      this.currentNode[appendChild](commentNode, true);
    }
    this.readState = MarkupReadStateEnum.any;
  }
  /**
   * Parses document type.
   *
   * @param text Text.
   */
  parseDocumentType(text) {
    const decodedText = XMLEncodeUtility.decodeHTMLEntities(text);
    if (this.documentStructure) {
      let { doctype } = this.documentStructure.nodes;
      const documentType = this.getDocumentType(decodedText);
      if (documentType) {
        if (this.currentNode === this.rootNode && this.documentStructure.level === HTMLDocumentStructureLevelEnum.root) {
          if (doctype) {
            doctype[name] = documentType.name;
            doctype[publicId] = documentType.publicId;
            doctype[systemId] = documentType.systemId;
          } else {
            doctype = this.rootNode.implementation.createDocumentType(documentType.name, documentType.publicId, documentType.systemId);
            this.rootNode.insertBefore(doctype, this.rootNode.documentElement);
          }
          this.documentStructure.level = HTMLDocumentStructureLevelEnum.doctype;
        }
      } else {
        this.parseComment(decodedText);
      }
    } else {
      if (!this.getDocumentType(decodedText)) {
        this.parseComment(decodedText);
      }
    }
    this.readState = MarkupReadStateEnum.any;
  }
  /**
   * Parses raw text content for elements such as <script> and <style>.
   *
   * @param tagName End tag name.
   * @param text Text.
   */
  parseRawTextElementContent(tagName2, text) {
    const upperTagName = StringUtility.asciiUpperCase(tagName2);
    if (upperTagName !== this.currentNode[tagName]) {
      return;
    }
    if (upperTagName === "SCRIPT") {
      this.currentNode[evaluateScript] = this.evaluateScripts;
    } else if (upperTagName === "LINK") {
      this.currentNode[evaluateCSS] = this.evaluateScripts;
    }
    this.currentNode[appendChild](this.rootDocument.createTextNode(text), true);
    const rawTextElement = this.currentNode;
    this.nodeStack.pop();
    this.tagNameStack.pop();
    this.currentNode = this.nodeStack[this.nodeStack.length - 1] || this.rootNode;
    this.readState = MarkupReadStateEnum.any;
    if (this.documentStructure) {
      const { documentElement, body: body2 } = this.documentStructure.nodes;
      if (documentElement && (this.currentNode === this.rootNode || this.currentNode === documentElement)) {
        body2[appendChild](rawTextElement, true);
      } else {
        this.currentNode[appendChild](rawTextElement, true);
      }
    } else {
      this.currentNode[appendChild](rawTextElement, true);
    }
  }
  /**
   * Creates an element or returns a reference to it.
   *
   * @param tagName Tag name.
   */
  getStartTagElement(tagName2) {
    const lowerTagName = StringUtility.asciiLowerCase(tagName2);
    const namespaceURI2 = this.currentNode[namespaceURI];
    if (lowerTagName === "svg") {
      return this.rootDocument.createElementNS(NamespaceURI_default.svg, "svg");
    }
    if (namespaceURI2 === NamespaceURI_default.svg) {
      return this.rootDocument.createElementNS(NamespaceURI_default.svg, SVGElementConfig_default[lowerTagName]?.localName || tagName2);
    }
    switch (lowerTagName) {
      case "html":
        if (!this.documentStructure) {
          return null;
        }
        if (this.documentStructure.level < HTMLDocumentStructureLevelEnum.documentElement) {
          this.documentStructure.level = HTMLDocumentStructureLevelEnum.documentElement;
        }
        return this.documentStructure.nodes.documentElement ?? null;
      case "head":
        if (!this.documentStructure) {
          return null;
        }
        if (this.documentStructure.level < HTMLDocumentStructureLevelEnum.head) {
          this.documentStructure.level = HTMLDocumentStructureLevelEnum.head;
        } else if (this.documentStructure.level === HTMLDocumentStructureLevelEnum.head) {
          this.documentStructure.level = HTMLDocumentStructureLevelEnum.additionalHeadWithoutBody;
        }
        return this.documentStructure.nodes.head ?? null;
      case "body":
        if (!this.documentStructure) {
          return null;
        }
        if (this.documentStructure.level < HTMLDocumentStructureLevelEnum.body) {
          this.documentStructure.level = HTMLDocumentStructureLevelEnum.body;
        }
        return this.documentStructure.nodes.body ?? null;
      default:
        return this.rootDocument.createElementNS(NamespaceURI_default.html, lowerTagName);
    }
  }
  /**
   * Returns document type.
   *
   * @param value Value.
   * @returns Document type.
   */
  getDocumentType(value2) {
    if (!value2.toUpperCase().startsWith("DOCTYPE")) {
      return null;
    }
    const docTypeSplit = value2.split(SPACE_REGEXP3);
    if (docTypeSplit.length <= 1) {
      return null;
    }
    const docTypeString = docTypeSplit.slice(1).join(" ");
    const attributes2 = [];
    const attributeRegExp = new RegExp(DOCUMENT_TYPE_ATTRIBUTE_REGEXP, "gm");
    const isPublic = docTypeString.toUpperCase().includes("PUBLIC");
    let attributeMatch;
    while (attributeMatch = attributeRegExp.exec(docTypeString)) {
      attributes2.push(attributeMatch[1]);
    }
    const publicId2 = isPublic ? attributes2[0] || "" : "";
    const systemId2 = isPublic ? attributes2[1] || "" : attributes2[0] || "";
    return {
      name: docTypeSplit[1].toLowerCase(),
      publicId: publicId2,
      systemId: systemId2
    };
  }
};

// node_modules/happy-dom/lib/nodes/document/Document.js
var PROCESSING_INSTRUCTION_TARGET_REGEXP = /^[a-z][a-z0-9-]+$/;
var Document = class extends Node {
  // Internal properties
  [children] = null;
  [activeElement] = null;
  [nextActiveElement] = null;
  [currentScript] = null;
  [rootNode] = this;
  [isFirstWrite] = true;
  [isFirstWriteAfterOpen] = false;
  [nodeType] = NodeTypeEnum_default.documentNode;
  [isConnected] = true;
  [adoptedStyleSheets] = [];
  [implementation] = new DOMImplementation(this);
  [readyState] = DocumentReadyStateEnum_default.interactive;
  [referrer] = "";
  [defaultView] = null;
  [forms] = null;
  [affectsComputedStyleCache] = [];
  [ownerDocument] = null;
  [elementIdMap] = /* @__PURE__ */ new Map();
  [contentType] = "text/html";
  [xmlProcessingInstruction] = null;
  [preloads] = /* @__PURE__ */ new Map();
  [propertyEventListeners] = /* @__PURE__ */ new Map();
  // Private properties
  #selection = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onreadystatechange() {
    return this[propertyEventListeners].get("onreadystatechange") ?? null;
  }
  set onreadystatechange(value2) {
    this[propertyEventListeners].set("onreadystatechange", value2);
  }
  get onpointerlockchange() {
    return this[propertyEventListeners].get("onpointerlockchange") ?? null;
  }
  set onpointerlockchange(value2) {
    this[propertyEventListeners].set("onpointerlockchange", value2);
  }
  get onpointerlockerror() {
    return this[propertyEventListeners].get("onpointerlockerror") ?? null;
  }
  set onpointerlockerror(value2) {
    this[propertyEventListeners].set("onpointerlockerror", value2);
  }
  get onbeforecopy() {
    return this[propertyEventListeners].get("onbeforecopy") ?? null;
  }
  set onbeforecopy(value2) {
    this[propertyEventListeners].set("onbeforecopy", value2);
  }
  get onbeforecut() {
    return this[propertyEventListeners].get("onbeforecut") ?? null;
  }
  set onbeforecut(value2) {
    this[propertyEventListeners].set("onbeforecut", value2);
  }
  get onbeforepaste() {
    return this[propertyEventListeners].get("onbeforepaste") ?? null;
  }
  set onbeforepaste(value2) {
    this[propertyEventListeners].set("onbeforepaste", value2);
  }
  get onfreeze() {
    return this[propertyEventListeners].get("onfreeze") ?? null;
  }
  set onfreeze(value2) {
    this[propertyEventListeners].set("onfreeze", value2);
  }
  get onprerenderingchange() {
    return this[propertyEventListeners].get("onprerenderingchange") ?? null;
  }
  set onprerenderingchange(value2) {
    this[propertyEventListeners].set("onprerenderingchange", value2);
  }
  get onresume() {
    return this[propertyEventListeners].get("onresume") ?? null;
  }
  set onresume(value2) {
    this[propertyEventListeners].set("onresume", value2);
  }
  get onsearch() {
    return this[propertyEventListeners].get("onsearch") ?? null;
  }
  set onsearch(value2) {
    this[propertyEventListeners].set("onsearch", value2);
  }
  get onvisibilitychange() {
    return this[propertyEventListeners].get("onvisibilitychange") ?? null;
  }
  set onvisibilitychange(value2) {
    this[propertyEventListeners].set("onvisibilitychange", value2);
  }
  get onfullscreenchange() {
    return this[propertyEventListeners].get("onfullscreenchange") ?? null;
  }
  set onfullscreenchange(value2) {
    this[propertyEventListeners].set("onfullscreenchange", value2);
  }
  get onfullscreenerror() {
    return this[propertyEventListeners].get("onfullscreenerror") ?? null;
  }
  set onfullscreenerror(value2) {
    this[propertyEventListeners].set("onfullscreenerror", value2);
  }
  get onwebkitfullscreenchange() {
    return this[propertyEventListeners].get("onwebkitfullscreenchange") ?? null;
  }
  set onwebkitfullscreenchange(value2) {
    this[propertyEventListeners].set("onwebkitfullscreenchange", value2);
  }
  get onwebkitfullscreenerror() {
    return this[propertyEventListeners].get("onwebkitfullscreenerror") ?? null;
  }
  set onwebkitfullscreenerror(value2) {
    this[propertyEventListeners].set("onwebkitfullscreenerror", value2);
  }
  get onbeforexrselect() {
    return this[propertyEventListeners].get("onbeforexrselect") ?? null;
  }
  set onbeforexrselect(value2) {
    this[propertyEventListeners].set("onbeforexrselect", value2);
  }
  get onabort() {
    return this[propertyEventListeners].get("onabort") ?? null;
  }
  set onabort(value2) {
    this[propertyEventListeners].set("onabort", value2);
  }
  get onbeforeinput() {
    return this[propertyEventListeners].get("onbeforeinput") ?? null;
  }
  set onbeforeinput(value2) {
    this[propertyEventListeners].set("onbeforeinput", value2);
  }
  get onbeforematch() {
    return this[propertyEventListeners].get("onbeforematch") ?? null;
  }
  set onbeforematch(value2) {
    this[propertyEventListeners].set("onbeforematch", value2);
  }
  get onbeforetoggle() {
    return this[propertyEventListeners].get("onbeforetoggle") ?? null;
  }
  set onbeforetoggle(value2) {
    this[propertyEventListeners].set("onbeforetoggle", value2);
  }
  get onblur() {
    return this[propertyEventListeners].get("onblur") ?? null;
  }
  set onblur(value2) {
    this[propertyEventListeners].set("onblur", value2);
  }
  get oncancel() {
    return this[propertyEventListeners].get("oncancel") ?? null;
  }
  set oncancel(value2) {
    this[propertyEventListeners].set("oncancel", value2);
  }
  get oncanplay() {
    return this[propertyEventListeners].get("oncanplay") ?? null;
  }
  set oncanplay(value2) {
    this[propertyEventListeners].set("oncanplay", value2);
  }
  get oncanplaythrough() {
    return this[propertyEventListeners].get("oncanplaythrough") ?? null;
  }
  set oncanplaythrough(value2) {
    this[propertyEventListeners].set("oncanplaythrough", value2);
  }
  get onchange() {
    return this[propertyEventListeners].get("onchange") ?? null;
  }
  set onchange(value2) {
    this[propertyEventListeners].set("onchange", value2);
  }
  get onclick() {
    return this[propertyEventListeners].get("onclick") ?? null;
  }
  set onclick(value2) {
    this[propertyEventListeners].set("onclick", value2);
  }
  get onclose() {
    return this[propertyEventListeners].get("onclose") ?? null;
  }
  set onclose(value2) {
    this[propertyEventListeners].set("onclose", value2);
  }
  get oncontentvisibilityautostatechange() {
    return this[propertyEventListeners].get("oncontentvisibilityautostatechange") ?? null;
  }
  set oncontentvisibilityautostatechange(value2) {
    this[propertyEventListeners].set("oncontentvisibilityautostatechange", value2);
  }
  get oncontextlost() {
    return this[propertyEventListeners].get("oncontextlost") ?? null;
  }
  set oncontextlost(value2) {
    this[propertyEventListeners].set("oncontextlost", value2);
  }
  get oncontextmenu() {
    return this[propertyEventListeners].get("oncontextmenu") ?? null;
  }
  set oncontextmenu(value2) {
    this[propertyEventListeners].set("oncontextmenu", value2);
  }
  get oncontextrestored() {
    return this[propertyEventListeners].get("oncontextrestored") ?? null;
  }
  set oncontextrestored(value2) {
    this[propertyEventListeners].set("oncontextrestored", value2);
  }
  get oncuechange() {
    return this[propertyEventListeners].get("oncuechange") ?? null;
  }
  set oncuechange(value2) {
    this[propertyEventListeners].set("oncuechange", value2);
  }
  get ondblclick() {
    return this[propertyEventListeners].get("ondblclick") ?? null;
  }
  set ondblclick(value2) {
    this[propertyEventListeners].set("ondblclick", value2);
  }
  get ondrag() {
    return this[propertyEventListeners].get("ondrag") ?? null;
  }
  set ondrag(value2) {
    this[propertyEventListeners].set("ondrag", value2);
  }
  get ondragend() {
    return this[propertyEventListeners].get("ondragend") ?? null;
  }
  set ondragend(value2) {
    this[propertyEventListeners].set("ondragend", value2);
  }
  get ondragenter() {
    return this[propertyEventListeners].get("ondragenter") ?? null;
  }
  set ondragenter(value2) {
    this[propertyEventListeners].set("ondragenter", value2);
  }
  get ondragleave() {
    return this[propertyEventListeners].get("ondragleave") ?? null;
  }
  set ondragleave(value2) {
    this[propertyEventListeners].set("ondragleave", value2);
  }
  get ondragover() {
    return this[propertyEventListeners].get("ondragover") ?? null;
  }
  set ondragover(value2) {
    this[propertyEventListeners].set("ondragover", value2);
  }
  get ondragstart() {
    return this[propertyEventListeners].get("ondragstart") ?? null;
  }
  set ondragstart(value2) {
    this[propertyEventListeners].set("ondragstart", value2);
  }
  get ondrop() {
    return this[propertyEventListeners].get("ondrop") ?? null;
  }
  set ondrop(value2) {
    this[propertyEventListeners].set("ondrop", value2);
  }
  get ondurationchange() {
    return this[propertyEventListeners].get("ondurationchange") ?? null;
  }
  set ondurationchange(value2) {
    this[propertyEventListeners].set("ondurationchange", value2);
  }
  get onemptied() {
    return this[propertyEventListeners].get("onemptied") ?? null;
  }
  set onemptied(value2) {
    this[propertyEventListeners].set("onemptied", value2);
  }
  get onended() {
    return this[propertyEventListeners].get("onended") ?? null;
  }
  set onended(value2) {
    this[propertyEventListeners].set("onended", value2);
  }
  get onerror() {
    return this[propertyEventListeners].get("onerror") ?? null;
  }
  set onerror(value2) {
    this[propertyEventListeners].set("onerror", value2);
  }
  get onfocus() {
    return this[propertyEventListeners].get("onfocus") ?? null;
  }
  set onfocus(value2) {
    this[propertyEventListeners].set("onfocus", value2);
  }
  get onformdata() {
    return this[propertyEventListeners].get("onformdata") ?? null;
  }
  set onformdata(value2) {
    this[propertyEventListeners].set("onformdata", value2);
  }
  get oninput() {
    return this[propertyEventListeners].get("oninput") ?? null;
  }
  set oninput(value2) {
    this[propertyEventListeners].set("oninput", value2);
  }
  get oninvalid() {
    return this[propertyEventListeners].get("oninvalid") ?? null;
  }
  set oninvalid(value2) {
    this[propertyEventListeners].set("oninvalid", value2);
  }
  get onkeydown() {
    return this[propertyEventListeners].get("onkeydown") ?? null;
  }
  set onkeydown(value2) {
    this[propertyEventListeners].set("onkeydown", value2);
  }
  get onkeypress() {
    return this[propertyEventListeners].get("onkeypress") ?? null;
  }
  set onkeypress(value2) {
    this[propertyEventListeners].set("onkeypress", value2);
  }
  get onkeyup() {
    return this[propertyEventListeners].get("onkeyup") ?? null;
  }
  set onkeyup(value2) {
    this[propertyEventListeners].set("onkeyup", value2);
  }
  get onload() {
    return this[propertyEventListeners].get("onload") ?? null;
  }
  set onload(value2) {
    this[propertyEventListeners].set("onload", value2);
  }
  get onloadeddata() {
    return this[propertyEventListeners].get("onloadeddata") ?? null;
  }
  set onloadeddata(value2) {
    this[propertyEventListeners].set("onloadeddata", value2);
  }
  get onloadedmetadata() {
    return this[propertyEventListeners].get("onloadedmetadata") ?? null;
  }
  set onloadedmetadata(value2) {
    this[propertyEventListeners].set("onloadedmetadata", value2);
  }
  get onloadstart() {
    return this[propertyEventListeners].get("onloadstart") ?? null;
  }
  set onloadstart(value2) {
    this[propertyEventListeners].set("onloadstart", value2);
  }
  get onmousedown() {
    return this[propertyEventListeners].get("onmousedown") ?? null;
  }
  set onmousedown(value2) {
    this[propertyEventListeners].set("onmousedown", value2);
  }
  get onmouseenter() {
    return this[propertyEventListeners].get("onmouseenter") ?? null;
  }
  set onmouseenter(value2) {
    this[propertyEventListeners].set("onmouseenter", value2);
  }
  get onmouseleave() {
    return this[propertyEventListeners].get("onmouseleave") ?? null;
  }
  set onmouseleave(value2) {
    this[propertyEventListeners].set("onmouseleave", value2);
  }
  get onmousemove() {
    return this[propertyEventListeners].get("onmousemove") ?? null;
  }
  set onmousemove(value2) {
    this[propertyEventListeners].set("onmousemove", value2);
  }
  get onmouseout() {
    return this[propertyEventListeners].get("onmouseout") ?? null;
  }
  set onmouseout(value2) {
    this[propertyEventListeners].set("onmouseout", value2);
  }
  get onmouseover() {
    return this[propertyEventListeners].get("onmouseover") ?? null;
  }
  set onmouseover(value2) {
    this[propertyEventListeners].set("onmouseover", value2);
  }
  get onmouseup() {
    return this[propertyEventListeners].get("onmouseup") ?? null;
  }
  set onmouseup(value2) {
    this[propertyEventListeners].set("onmouseup", value2);
  }
  get onmousewheel() {
    return this[propertyEventListeners].get("onmousewheel") ?? null;
  }
  set onmousewheel(value2) {
    this[propertyEventListeners].set("onmousewheel", value2);
  }
  get onpause() {
    return this[propertyEventListeners].get("onpause") ?? null;
  }
  set onpause(value2) {
    this[propertyEventListeners].set("onpause", value2);
  }
  get onplay() {
    return this[propertyEventListeners].get("onplay") ?? null;
  }
  set onplay(value2) {
    this[propertyEventListeners].set("onplay", value2);
  }
  get onplaying() {
    return this[propertyEventListeners].get("onplaying") ?? null;
  }
  set onplaying(value2) {
    this[propertyEventListeners].set("onplaying", value2);
  }
  get onprogress() {
    return this[propertyEventListeners].get("onprogress") ?? null;
  }
  set onprogress(value2) {
    this[propertyEventListeners].set("onprogress", value2);
  }
  get onratechange() {
    return this[propertyEventListeners].get("onratechange") ?? null;
  }
  set onratechange(value2) {
    this[propertyEventListeners].set("onratechange", value2);
  }
  get onreset() {
    return this[propertyEventListeners].get("onreset") ?? null;
  }
  set onreset(value2) {
    this[propertyEventListeners].set("onreset", value2);
  }
  get onresize() {
    return this[propertyEventListeners].get("onresize") ?? null;
  }
  set onresize(value2) {
    this[propertyEventListeners].set("onresize", value2);
  }
  get onscroll() {
    return this[propertyEventListeners].get("onscroll") ?? null;
  }
  set onscroll(value2) {
    this[propertyEventListeners].set("onscroll", value2);
  }
  get onsecuritypolicyviolation() {
    return this[propertyEventListeners].get("onsecuritypolicyviolation") ?? null;
  }
  set onsecuritypolicyviolation(value2) {
    this[propertyEventListeners].set("onsecuritypolicyviolation", value2);
  }
  get onseeked() {
    return this[propertyEventListeners].get("onseeked") ?? null;
  }
  set onseeked(value2) {
    this[propertyEventListeners].set("onseeked", value2);
  }
  get onseeking() {
    return this[propertyEventListeners].get("onseeking") ?? null;
  }
  set onseeking(value2) {
    this[propertyEventListeners].set("onseeking", value2);
  }
  get onselect() {
    return this[propertyEventListeners].get("onselect") ?? null;
  }
  set onselect(value2) {
    this[propertyEventListeners].set("onselect", value2);
  }
  get onslotchange() {
    return this[propertyEventListeners].get("onslotchange") ?? null;
  }
  set onslotchange(value2) {
    this[propertyEventListeners].set("onslotchange", value2);
  }
  get onstalled() {
    return this[propertyEventListeners].get("onstalled") ?? null;
  }
  set onstalled(value2) {
    this[propertyEventListeners].set("onstalled", value2);
  }
  get onsubmit() {
    return this[propertyEventListeners].get("onsubmit") ?? null;
  }
  set onsubmit(value2) {
    this[propertyEventListeners].set("onsubmit", value2);
  }
  get onsuspend() {
    return this[propertyEventListeners].get("onsuspend") ?? null;
  }
  set onsuspend(value2) {
    this[propertyEventListeners].set("onsuspend", value2);
  }
  get ontimeupdate() {
    return this[propertyEventListeners].get("ontimeupdate") ?? null;
  }
  set ontimeupdate(value2) {
    this[propertyEventListeners].set("ontimeupdate", value2);
  }
  get ontoggle() {
    return this[propertyEventListeners].get("ontoggle") ?? null;
  }
  set ontoggle(value2) {
    this[propertyEventListeners].set("ontoggle", value2);
  }
  get onvolumechange() {
    return this[propertyEventListeners].get("onvolumechange") ?? null;
  }
  set onvolumechange(value2) {
    this[propertyEventListeners].set("onvolumechange", value2);
  }
  get onwaiting() {
    return this[propertyEventListeners].get("onwaiting") ?? null;
  }
  set onwaiting(value2) {
    this[propertyEventListeners].set("onwaiting", value2);
  }
  get onwebkitanimationend() {
    return this[propertyEventListeners].get("onwebkitanimationend") ?? null;
  }
  set onwebkitanimationend(value2) {
    this[propertyEventListeners].set("onwebkitanimationend", value2);
  }
  get onwebkitanimationiteration() {
    return this[propertyEventListeners].get("onwebkitanimationiteration") ?? null;
  }
  set onwebkitanimationiteration(value2) {
    this[propertyEventListeners].set("onwebkitanimationiteration", value2);
  }
  get onwebkitanimationstart() {
    return this[propertyEventListeners].get("onwebkitanimationstart") ?? null;
  }
  set onwebkitanimationstart(value2) {
    this[propertyEventListeners].set("onwebkitanimationstart", value2);
  }
  get onwebkittransitionend() {
    return this[propertyEventListeners].get("onwebkittransitionend") ?? null;
  }
  set onwebkittransitionend(value2) {
    this[propertyEventListeners].set("onwebkittransitionend", value2);
  }
  get onwheel() {
    return this[propertyEventListeners].get("onwheel") ?? null;
  }
  set onwheel(value2) {
    this[propertyEventListeners].set("onwheel", value2);
  }
  get onauxclick() {
    return this[propertyEventListeners].get("onauxclick") ?? null;
  }
  set onauxclick(value2) {
    this[propertyEventListeners].set("onauxclick", value2);
  }
  get ongotpointercapture() {
    return this[propertyEventListeners].get("ongotpointercapture") ?? null;
  }
  set ongotpointercapture(value2) {
    this[propertyEventListeners].set("ongotpointercapture", value2);
  }
  get onlostpointercapture() {
    return this[propertyEventListeners].get("onlostpointercapture") ?? null;
  }
  set onlostpointercapture(value2) {
    this[propertyEventListeners].set("onlostpointercapture", value2);
  }
  get onpointerdown() {
    return this[propertyEventListeners].get("onpointerdown") ?? null;
  }
  set onpointerdown(value2) {
    this[propertyEventListeners].set("onpointerdown", value2);
  }
  get onpointermove() {
    return this[propertyEventListeners].get("onpointermove") ?? null;
  }
  set onpointermove(value2) {
    this[propertyEventListeners].set("onpointermove", value2);
  }
  get onpointerrawupdate() {
    return this[propertyEventListeners].get("onpointerrawupdate") ?? null;
  }
  set onpointerrawupdate(value2) {
    this[propertyEventListeners].set("onpointerrawupdate", value2);
  }
  get onpointerup() {
    return this[propertyEventListeners].get("onpointerup") ?? null;
  }
  set onpointerup(value2) {
    this[propertyEventListeners].set("onpointerup", value2);
  }
  get onpointercancel() {
    return this[propertyEventListeners].get("onpointercancel") ?? null;
  }
  set onpointercancel(value2) {
    this[propertyEventListeners].set("onpointercancel", value2);
  }
  get onpointerover() {
    return this[propertyEventListeners].get("onpointerover") ?? null;
  }
  set onpointerover(value2) {
    this[propertyEventListeners].set("onpointerover", value2);
  }
  get onpointerout() {
    return this[propertyEventListeners].get("onpointerout") ?? null;
  }
  set onpointerout(value2) {
    this[propertyEventListeners].set("onpointerout", value2);
  }
  get onpointerenter() {
    return this[propertyEventListeners].get("onpointerenter") ?? null;
  }
  set onpointerenter(value2) {
    this[propertyEventListeners].set("onpointerenter", value2);
  }
  get onpointerleave() {
    return this[propertyEventListeners].get("onpointerleave") ?? null;
  }
  set onpointerleave(value2) {
    this[propertyEventListeners].set("onpointerleave", value2);
  }
  get onselectstart() {
    return this[propertyEventListeners].get("onselectstart") ?? null;
  }
  set onselectstart(value2) {
    this[propertyEventListeners].set("onselectstart", value2);
  }
  get onselectionchange() {
    return this[propertyEventListeners].get("onselectionchange") ?? null;
  }
  set onselectionchange(value2) {
    this[propertyEventListeners].set("onselectionchange", value2);
  }
  get onanimationend() {
    return this[propertyEventListeners].get("onanimationend") ?? null;
  }
  set onanimationend(value2) {
    this[propertyEventListeners].set("onanimationend", value2);
  }
  get onanimationiteration() {
    return this[propertyEventListeners].get("onanimationiteration") ?? null;
  }
  set onanimationiteration(value2) {
    this[propertyEventListeners].set("onanimationiteration", value2);
  }
  get onanimationstart() {
    return this[propertyEventListeners].get("onanimationstart") ?? null;
  }
  set onanimationstart(value2) {
    this[propertyEventListeners].set("onanimationstart", value2);
  }
  get ontransitionrun() {
    return this[propertyEventListeners].get("ontransitionrun") ?? null;
  }
  set ontransitionrun(value2) {
    this[propertyEventListeners].set("ontransitionrun", value2);
  }
  get ontransitionstart() {
    return this[propertyEventListeners].get("ontransitionstart") ?? null;
  }
  set ontransitionstart(value2) {
    this[propertyEventListeners].set("ontransitionstart", value2);
  }
  get ontransitionend() {
    return this[propertyEventListeners].get("ontransitionend") ?? null;
  }
  set ontransitionend(value2) {
    this[propertyEventListeners].set("ontransitionend", value2);
  }
  get ontransitioncancel() {
    return this[propertyEventListeners].get("ontransitioncancel") ?? null;
  }
  set ontransitioncancel(value2) {
    this[propertyEventListeners].set("ontransitioncancel", value2);
  }
  get oncopy() {
    return this[propertyEventListeners].get("oncopy") ?? null;
  }
  set oncopy(value2) {
    this[propertyEventListeners].set("oncopy", value2);
  }
  get oncut() {
    return this[propertyEventListeners].get("oncut") ?? null;
  }
  set oncut(value2) {
    this[propertyEventListeners].set("oncut", value2);
  }
  get onpaste() {
    return this[propertyEventListeners].get("onpaste") ?? null;
  }
  set onpaste(value2) {
    this[propertyEventListeners].set("onpaste", value2);
  }
  get onscrollend() {
    return this[propertyEventListeners].get("onscrollend") ?? null;
  }
  set onscrollend(value2) {
    this[propertyEventListeners].set("onscrollend", value2);
  }
  get onscrollsnapchange() {
    return this[propertyEventListeners].get("onscrollsnapchange") ?? null;
  }
  set onscrollsnapchange(value2) {
    this[propertyEventListeners].set("onscrollsnapchange", value2);
  }
  get onscrollsnapchanging() {
    return this[propertyEventListeners].get("onscrollsnapchanging") ?? null;
  }
  set onscrollsnapchanging(value2) {
    this[propertyEventListeners].set("onscrollsnapchanging", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns adopted style sheets.
   *
   * @returns Adopted style sheets.
   */
  get adoptedStyleSheets() {
    return this[adoptedStyleSheets];
  }
  /**
   * Sets adopted style sheets.
   *
   * @param value Adopted style sheets.
   */
  set adoptedStyleSheets(value2) {
    this[adoptedStyleSheets] = value2;
  }
  /**
   * Returns DOM implementation.
   *
   * @returns DOM implementation.
   */
  get implementation() {
    return this[implementation];
  }
  /**
   * Returns document ready state.
   *
   * @returns Document ready state.
   */
  get readyState() {
    return this[readyState];
  }
  /**
   * Returns referrer.
   *
   * @returns Referrer.
   */
  get referrer() {
    return this[referrer];
  }
  /**
   * Returns default view.
   *
   * @returns Default view.
   */
  get defaultView() {
    return this[defaultView];
  }
  /**
   * Returns document children.
   */
  get children() {
    if (!this[children]) {
      const elements2 = this[elementArray];
      this[children] = new HTMLCollection(illegalConstructor, () => elements2);
    }
    return this[children];
  }
  /**
   * Returns character set.
   *
   * @deprecated
   * @returns Character set.
   */
  get charset() {
    return this.characterSet;
  }
  /**
   * Returns character set.
   *
   * @returns Character set.
   */
  get characterSet() {
    const charset = QuerySelector.querySelector(this, "meta[charset]")?.getAttributeNS(null, "charset");
    return charset ? charset : "UTF-8";
  }
  /**
   * Returns title.
   *
   * @returns Title.
   */
  get title() {
    const element = ParentNodeUtility.getElementByTagName(this, "title");
    if (element) {
      return element.text.trim();
    }
    return "";
  }
  /**
   * Returns set title.
   *
   */
  set title(title) {
    const element = ParentNodeUtility.getElementByTagName(this, "title");
    if (element) {
      element.textContent = title;
    } else {
      const newElement = this.createElement("title");
      newElement.textContent = title;
      this.head.appendChild(newElement);
    }
  }
  /**
   * Returns a collection of all area elements and a elements in a document with a value for the href attribute.
   */
  get links() {
    return QuerySelector.querySelectorAll(this, "a[href],area[href]");
  }
  /**
   * Returns a collection of all form elements in a document.
   */
  get forms() {
    if (!this[forms]) {
      this[forms] = ParentNodeUtility.getElementsByTagName(this, "form");
    }
    return this[forms];
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get childElementCount() {
    return this[elementArray].length;
  }
  /**
   * First element child.
   *
   * @returns Element.
   */
  get firstElementChild() {
    return this[elementArray][0] ?? null;
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get lastElementChild() {
    const children2 = this[elementArray];
    return children2[children2.length - 1] ?? null;
  }
  /**
   * Returns cookie string.
   *
   * @returns Cookie.
   */
  get cookie() {
    const browserFrame = new WindowBrowserContext(this[window]).getBrowserFrame();
    if (!browserFrame) {
      return "";
    }
    return CookieStringUtility.cookiesToString(browserFrame.page.context.cookieContainer.getCookies(new URL8(this[window].location.href), true));
  }
  /**
   * Sets a cookie string.
   *
   * @param cookie Cookie string.
   */
  set cookie(cookie) {
    const browserFrame = new WindowBrowserContext(this[window]).getBrowserFrame();
    if (!browserFrame) {
      return;
    }
    browserFrame.page.context.cookieContainer.addCookies([
      CookieStringUtility.stringToCookie(new URL8(this[window].location.href), cookie)
    ]);
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return "#document";
  }
  /**
   * Returns <html> element.
   *
   * @returns Element.
   */
  get documentElement() {
    return this[elementArray][0] ?? null;
  }
  /**
   * Returns document type element.
   *
   * @returns Document type.
   */
  get doctype() {
    for (const node of this[nodeArray]) {
      if (node instanceof DocumentType) {
        return node;
      }
    }
    return null;
  }
  /**
   * Returns <body> element.
   *
   * @returns Element.
   */
  get body() {
    const documentElement = this.documentElement;
    return documentElement ? ParentNodeUtility.getElementByTagName(documentElement, "body") : null;
  }
  /**
   * Returns <head> element.
   *
   * @returns Element.
   */
  get head() {
    const documentElement = this.documentElement;
    return documentElement ? ParentNodeUtility.getElementByTagName(documentElement, "head") : null;
  }
  /**
   * Returns CSS style sheets.
   *
   * @returns CSS style sheets.
   */
  get styleSheets() {
    const styles = QuerySelector.querySelectorAll(this, 'link[rel="stylesheet"][href],style');
    const styleSheets = [];
    for (const style2 of styles) {
      const sheet2 = style2.sheet;
      if (sheet2) {
        styleSheets.push(sheet2);
      }
    }
    return styleSheets;
  }
  /**
   * Returns active element.
   *
   * @returns Active element.
   */
  get activeElement() {
    if (this[activeElement] && !this[activeElement][isConnected]) {
      this[activeElement] = null;
    }
    if (this[activeElement] && this[activeElement] instanceof Element) {
      let rootNode2 = this[activeElement].getRootNode();
      let activeElement2 = this[activeElement];
      while (rootNode2 !== this) {
        activeElement2 = rootNode2.host;
        rootNode2 = activeElement2 ? activeElement2.getRootNode() : this;
      }
      return activeElement2;
    }
    return this[activeElement] || this.body || this.documentElement || null;
  }
  /**
   * Returns scrolling element.
   *
   * @returns Scrolling element.
   */
  get scrollingElement() {
    return this.documentElement;
  }
  /**
   * Returns location.
   *
   * @returns Location.
   */
  get location() {
    return this[window].location;
  }
  /**
   * Returns scripts.
   *
   * @returns Scripts.
   */
  get scripts() {
    return this.getElementsByTagName("script");
  }
  /**
   * Returns base URI.
   *
   * @override
   * @returns Base URI.
   */
  get baseURI() {
    const element = ParentNodeUtility.getElementByTagName(this, "base");
    if (element) {
      return element.href;
    }
    return this[window].location.href;
  }
  /**
   * Returns URL.
   *
   * @returns URL of the current document.
   * */
  get URL() {
    return this[window].location.href;
  }
  /**
   * Returns document URI.
   *
   * @returns URL of the current document.
   * */
  get documentURI() {
    return this.URL;
  }
  /**
   * Returns domain.
   *
   * @returns Domain.
   * */
  get domain() {
    return this[window].location.hostname;
  }
  /**
   * Returns document visibility state.
   *
   * @returns the visibility state of the current document.
   * */
  get visibilityState() {
    if (this.defaultView) {
      return VisibilityStateEnum_default.visible;
    }
    return VisibilityStateEnum_default.hidden;
  }
  /**
   * Returns document hidden state.
   *
   * @returns the hidden state of the current document.
   * */
  get hidden() {
    if (this.defaultView) {
      return false;
    }
    return true;
  }
  /**
   * Gets the currently executing script element.
   *
   * @returns the currently executing script element.
   */
  get currentScript() {
    return this[currentScript];
  }
  /**
   * Returns content type.
   *
   * @returns Content type.
   */
  get contentType() {
    return this[contentType];
  }
  /**
   * Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  append(...nodes) {
    ParentNodeUtility.append(this, ...nodes);
  }
  /**
   * Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  prepend(...nodes) {
    ParentNodeUtility.prepend(this, ...nodes);
  }
  /**
   * Replaces the existing children of a node with a specified new set of children.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceChildren(...nodes) {
    ParentNodeUtility.replaceChildren(this, ...nodes);
  }
  /**
   * Query CSS selector to find matching elments.
   *
   * @param selector CSS selector.
   * @returns Matching elements.
   */
  querySelectorAll(selector) {
    return QuerySelector.querySelectorAll(this, selector);
  }
  /**
   * Query CSS Selector to find matching node.
   *
   * @param selector CSS selector.
   * @returns Matching element.
   */
  querySelector(selector) {
    return QuerySelector.querySelector(this, selector);
  }
  /**
   * Returns true if the command is supported.
   * @deprecated
   * @param _ Command.
   * @returns True if the command is supported, false otherwise.
   */
  queryCommandSupported(_) {
    if (!arguments.length) {
      throw new this[window].TypeError("Failed to execute 'queryCommandSupported' on 'Document': 1 argument required, but only 0 present.");
    }
    return true;
  }
  /**
   * Returns an elements by class name.
   *
   * @param className Tag name.
   * @returns Matching element.
   */
  getElementsByClassName(className) {
    return ParentNodeUtility.getElementsByClassName(this, className);
  }
  /**
   * Returns an elements by tag name.
   *
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagName(tagName2) {
    return ParentNodeUtility.getElementsByTagName(this, tagName2);
  }
  /**
   * Returns an elements by tag name and namespace.
   *
   * @param namespaceURI Namespace URI.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagNameNS(namespaceURI2, tagName2) {
    return ParentNodeUtility.getElementsByTagNameNS(this, namespaceURI2, tagName2);
  }
  /**
   * Returns an element by ID.
   *
   * @param id ID.
   * @returns Matching element.
   */
  getElementById(id2) {
    return ParentNodeUtility.getElementById(this, id2);
  }
  /**
   * Returns an element by Name.
   *
   * @returns Matching element.
   * @param name
   */
  getElementsByName(name2) {
    return QuerySelector.querySelectorAll(this, `[name="${name2}"]`);
  }
  /**
   * Replaces the document HTML with new HTML.
   *
   * @param html HTML.
   */
  write(html) {
    if (this[isFirstWrite] || this[isFirstWriteAfterOpen]) {
      if (this[isFirstWrite]) {
        if (!this[isFirstWriteAfterOpen]) {
          this.open();
        }
        this[isFirstWrite] = false;
      }
      const { documentElement, head, body: body2 } = this;
      if (!documentElement || !head || !body2) {
        this.open();
      }
      this[isFirstWrite] = false;
      this[isFirstWriteAfterOpen] = false;
      new HTMLParser(this[window], {
        evaluateScripts: true
      }).parse(html, this);
    } else {
      new HTMLParser(this[window], {
        evaluateScripts: true
      }).parse(html, this.body);
    }
  }
  /**
   * Opens the document.
   *
   * @returns Document.
   */
  open() {
    this[isFirstWriteAfterOpen] = true;
    for (const eventType of this[listeners].bubbling.keys()) {
      const listeners2 = this[listeners].bubbling.get(eventType);
      if (listeners2) {
        for (const listener of listeners2) {
          this.removeEventListener(eventType, listener);
        }
      }
    }
    for (const eventType of this[listeners].capturing.keys()) {
      const listeners2 = this[listeners].capturing.get(eventType);
      if (listeners2) {
        for (const listener of listeners2) {
          this.removeEventListener(eventType, listener);
        }
      }
    }
    const childNodes2 = this[nodeArray];
    while (childNodes2.length) {
      this.removeChild(childNodes2[0]);
    }
    const doctype = this[implementation].createDocumentType("html", "", "");
    const documentElement = this.createElement("html");
    const bodyElement = this.createElement("body");
    const headElement = this.createElement("head");
    this.appendChild(doctype);
    this.appendChild(documentElement);
    documentElement.appendChild(headElement);
    documentElement.appendChild(bodyElement);
    return this;
  }
  /**
   * Closes the document.
   */
  close() {
  }
  /**
   * Creates an element.
   *
   * @param qualifiedName Tag name.
   * @param [options] Options.
   * @param [options.is] Tag name of a custom element previously defined via customElements.define().
   * @returns Element.
   */
  createElement(qualifiedName, options2) {
    return this.createElementNS(NamespaceURI_default.html, StringUtility.asciiLowerCase(String(qualifiedName)), options2);
  }
  /**
   * Creates an element with the specified namespace URI and qualified name.
   *
   * @param namespaceURI Namespace URI.
   * @param qualifiedName Tag name.
   * @param [options] Options.
   * @param [options.is] Tag name of a custom element previously defined via customElements.define().
   * @returns Element.
   */
  createElementNS(namespaceURI2, qualifiedName, options2) {
    const window2 = this[window];
    qualifiedName = String(qualifiedName);
    if (!qualifiedName) {
      throw new window2.DOMException("Failed to execute 'createElementNS' on 'Document': The qualified name provided is empty.");
    }
    const parts = qualifiedName.split(":");
    const localName2 = parts[1] ?? parts[0];
    const prefix2 = parts[1] ? parts[0] : null;
    switch (namespaceURI2) {
      case NamespaceURI_default.svg:
        const config = SVGElementConfig_default[qualifiedName.toLowerCase()];
        const svgElementClass = config && config.localName === qualifiedName ? window2[config.className] : window2.SVGElement;
        const svgElement = NodeFactory.createNode(this, svgElementClass);
        svgElement[tagName] = qualifiedName;
        svgElement[localName] = localName2;
        svgElement[prefix] = prefix2;
        svgElement[namespaceURI] = namespaceURI2;
        svgElement[isValue] = options2 && options2.is ? String(options2.is) : null;
        return svgElement;
      case NamespaceURI_default.html:
        const customElementDefinition = window2.customElements[registry]?.get(options2 && options2.is ? String(options2.is) : qualifiedName);
        if (customElementDefinition) {
          const element2 = new customElementDefinition.elementClass();
          element2[tagName] = StringUtility.asciiUpperCase(qualifiedName);
          element2[localName] = localName2;
          element2[prefix] = prefix2;
          element2[namespaceURI] = namespaceURI2;
          element2[isValue] = options2 && options2.is ? String(options2.is) : null;
          return element2;
        }
        const elementClass = HTMLElementConfig_default[qualifiedName] ? window2[HTMLElementConfig_default[qualifiedName].className] : null;
        if (elementClass) {
          const element2 = NodeFactory.createNode(this, elementClass);
          element2[tagName] = StringUtility.asciiUpperCase(qualifiedName);
          element2[localName] = localName2;
          element2[prefix] = prefix2;
          element2[namespaceURI] = namespaceURI2;
          element2[isValue] = options2 && options2.is ? String(options2.is) : null;
          return element2;
        }
        const unknownElementClass = qualifiedName.includes("-") ? window2.HTMLElement : window2.HTMLUnknownElement;
        const unknownElement = NodeFactory.createNode(this, unknownElementClass);
        unknownElement[tagName] = StringUtility.asciiUpperCase(qualifiedName);
        unknownElement[localName] = localName2;
        unknownElement[prefix] = prefix2;
        unknownElement[namespaceURI] = namespaceURI2;
        unknownElement[isValue] = options2 && options2.is ? String(options2.is) : null;
        return unknownElement;
      default:
        const element = NodeFactory.createNode(this, Element);
        element[tagName] = qualifiedName;
        element[localName] = localName2;
        element[prefix] = prefix2;
        element[namespaceURI] = namespaceURI2;
        element[isValue] = options2 && options2.is ? String(options2.is) : null;
        return element;
    }
  }
  /* eslint-enable jsdoc/valid-types */
  /**
   * Creates a text node.
   *
   * @param [data] Text data.
   * @returns Text node.
   */
  createTextNode(data2) {
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'createTextNode' on 'Document': 1 argument required, but only ${arguments.length} present.`);
    }
    return NodeFactory.createNode(this, this[window].Text, String(data2));
  }
  /**
   * Creates a comment node.
   *
   * @param [data] Text data.
   * @returns Text node.
   */
  createComment(data2) {
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'createComment' on 'Document': 1 argument required, but only ${arguments.length} present.`);
    }
    return NodeFactory.createNode(this, this[window].Comment, String(data2));
  }
  /**
   * Creates a document fragment.
   *
   * @returns Document fragment.
   */
  createDocumentFragment() {
    return NodeFactory.createNode(this, this[window].DocumentFragment);
  }
  /**
   * Creates a node iterator.
   *
   * @param root Root.
   * @param [whatToShow] What to show.
   * @param [filter] Filter.
   */
  createNodeIterator(root2, whatToShow = -1, filter = null) {
    return new NodeIterator(root2, whatToShow, filter);
  }
  /**
   * Creates a Tree Walker.
   *
   * @param root Root.
   * @param [whatToShow] What to show.
   * @param [filter] Filter.
   */
  createTreeWalker(root2, whatToShow = -1, filter = null) {
    return new TreeWalker(root2, whatToShow, filter);
  }
  /**
   * Creates an event.
   *
   * @deprecated
   * @param type Type.
   * @returns Event.
   */
  createEvent(type2) {
    if (typeof this[window][type2] === "function") {
      return new this[window][type2]("init");
    }
    return new Event("init");
  }
  /**
   * Creates an Attr node.
   *
   * @param qualifiedName Name.
   * @returns Attribute.
   */
  createAttribute(qualifiedName) {
    const attribute = NodeFactory.createNode(this, this[window].Attr);
    const name2 = StringUtility.asciiLowerCase(qualifiedName);
    const parts = name2.split(":");
    attribute[name] = name2;
    attribute[localName] = parts[1] ?? name2;
    attribute[prefix] = parts[1] ? parts[0] : null;
    return attribute;
  }
  /**
   * Creates a namespaced Attr node.
   *
   * @param namespaceURI Namespace URI.
   * @param qualifiedName Qualified name.
   * @returns Element.
   */
  createAttributeNS(namespaceURI2, qualifiedName) {
    const attribute = NodeFactory.createNode(this, this[window].Attr);
    const parts = qualifiedName.split(":");
    attribute[namespaceURI] = namespaceURI2;
    attribute[name] = qualifiedName;
    attribute[localName] = parts[1] ?? qualifiedName;
    attribute[prefix] = parts[1] ? parts[0] : null;
    if (!namespaceURI2 && attribute[prefix]) {
      throw new this[window].DOMException(`Failed to execute 'createAttributeNS' on 'Document': The namespace URI provided ('${namespaceURI2 || ""}') is not valid for the qualified name provided ('${qualifiedName}').`, DOMExceptionNameEnum_default.namespaceError);
    }
    return attribute;
  }
  /**
   * Imports a node.
   *
   * @param node Node to import.
   * @param [deep=false] Set to "true" if the clone should be deep.
   */
  importNode(node, deep = false) {
    if (!(node instanceof Node)) {
      throw new this[window].DOMException("Parameter 1 was not of type Node.");
    }
    const clone2 = node.cloneNode(deep);
    this.#importNode(clone2);
    return clone2;
  }
  /**
   * Creates a range.
   *
   * @returns Range.
   */
  createRange() {
    return new this[window].Range();
  }
  /**
   * Adopts a node.
   *
   * @param node Node to adopt.
   * @returns Adopted node.
   */
  adoptNode(node) {
    if (!(node instanceof Node)) {
      throw new this[window].DOMException("Parameter 1 was not of type Node.");
    }
    const adopted = node[parentNode] ? node[parentNode].removeChild(node) : node;
    const document = this;
    Object.defineProperty(adopted, "ownerDocument", { value: document });
    return adopted;
  }
  /**
   * Returns selection.
   *
   * @returns Selection.
   */
  getSelection() {
    if (!this.#selection) {
      this.#selection = new Selection(this);
    }
    return this.#selection;
  }
  /**
   * Returns a boolean value indicating whether the document or any element inside the document has focus.
   *
   * @returns "true" if the document has focus.
   */
  hasFocus() {
    return !!this.activeElement;
  }
  /**
   * Creates a Processing Instruction node.
   *
   * @param target Target.
   * @param data Data.
   * @returns ProcessingInstruction.
   */
  createProcessingInstruction(target2, data2) {
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'createProcessingInstruction' on 'Document': 2 arguments required, but only ${arguments.length} present.`);
    }
    target2 = String(target2);
    data2 = String(data2);
    if (!target2 || !PROCESSING_INSTRUCTION_TARGET_REGEXP.test(target2)) {
      throw new this[window].DOMException(`Failed to execute 'createProcessingInstruction' on 'Document': The target provided ('${target2}') is not a valid name.`);
    }
    if (data2.includes("?>")) {
      throw new this[window].DOMException(`Failed to execute 'createProcessingInstruction' on 'Document': The data provided ('?>') contains '?>'`);
    }
    const element = NodeFactory.createNode(this, this[window].ProcessingInstruction);
    element[data] = data2;
    element[target] = target2;
    return element;
  }
  /**
   * Get element at a given point.
   *
   * @param _x horizontal coordinate
   * @param _y vertical coordinate
   * @returns Always returns null since Happy DOM does not render elements.
   */
  elementFromPoint(_x, _y) {
    return null;
  }
  /**
   * Imports a node.
   *
   * @param node Node.
   */
  #importNode(node) {
    node[ownerDocument] = this;
    for (const child of node[nodeArray]) {
      this.#importNode(child);
    }
  }
};

// node_modules/happy-dom/lib/nodes/parent-node/ParentNodeUtility.js
var ParentNodeUtility = class {
  /**
   * Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param parentNode Parent node.
   * @param nodes List of Node or DOMString.
   */
  static append(parentNode2, ...nodes) {
    for (const node of nodes) {
      if (node instanceof Node) {
        parentNode2.appendChild(node);
      } else {
        parentNode2.appendChild(parentNode2[ownerDocument].createTextNode(String(node)));
      }
    }
  }
  /**
   * Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param parentNode Parent node.
   * @param nodes List of Node or DOMString.
   */
  static prepend(parentNode2, ...nodes) {
    const firstChild = parentNode2.firstChild;
    for (const node of nodes) {
      if (node instanceof Node) {
        parentNode2.insertBefore(node, firstChild);
      } else {
        parentNode2.insertBefore(parentNode2[ownerDocument].createTextNode(String(node)), firstChild);
      }
    }
  }
  /**
   * Replaces the existing children of a ParentNode with a specified new set of children.
   *
   * @param parentNode Parent node.
   * @param nodes List of Node or DOMString.
   */
  static replaceChildren(parentNode2, ...nodes) {
    const childNodes2 = parentNode2[nodeArray];
    while (childNodes2.length) {
      parentNode2.removeChild(childNodes2[0]);
    }
    this.append(parentNode2, ...nodes);
  }
  /**
   * Returns an elements by class name.
   *
   * @param parentNode Parent node.
   * @param className Tag name.
   * @returns Matching element.
   */
  static getElementsByClassName(parentNode2, className) {
    return new HTMLCollection(illegalConstructor, () => QuerySelector.querySelectorAll(parentNode2, `.${className.replace(/\s+/gm, ".")}`)[items]);
  }
  /**
   * Returns an elements by tag name.
   *
   * @param parentNode Parent node.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  static getElementsByTagName(parentNode2, tagName2) {
    const upperTagName = tagName2.toUpperCase();
    const includeAll = tagName2 === "*";
    const find = (parent2, cachedResult) => {
      const elements2 = [];
      for (const element of parent2[elementArray]) {
        if (includeAll || element[tagName].toUpperCase() === upperTagName) {
          elements2.push(element);
        }
        element[affectsCache].push(cachedResult);
        for (const foundElement of find(element, cachedResult)) {
          elements2.push(foundElement);
        }
      }
      return elements2;
    };
    const query2 = () => {
      const cache2 = parentNode2[cache].elementsByTagName;
      const cachedItems = cache2.get(tagName2);
      if (cachedItems?.result) {
        const items3 = cachedItems.result.deref();
        if (items3) {
          return items3;
        }
      }
      const cachedResult = { result: null };
      const items2 = find(parentNode2, cachedResult);
      cachedResult.result = new WeakRef(items2);
      cache2.set(tagName2, cachedResult);
      return items2;
    };
    return new HTMLCollection(illegalConstructor, query2);
  }
  /**
   * Returns an elements by tag name and namespace.
   *
   * @param parentNode Parent node.
   * @param namespaceURI Namespace URI.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  static getElementsByTagNameNS(parentNode2, namespaceURI2, tagName2) {
    const formattedTagName = namespaceURI2 === NamespaceURI_default.html && parentNode2[ownerDocument][contentType] === "text/html" ? tagName2.toUpperCase() : tagName2;
    const includeAll = tagName2 === "*";
    const find = (parent2, cachedResult) => {
      const elements2 = [];
      for (const element of parent2[elementArray]) {
        if ((includeAll || element[tagName] === formattedTagName) && element[namespaceURI] === namespaceURI2) {
          elements2.push(element);
        }
        element[affectsCache].push(cachedResult);
        for (const foundElement of find(element, cachedResult)) {
          elements2.push(foundElement);
        }
      }
      return elements2;
    };
    const query2 = () => {
      const cache2 = parentNode2[cache].elementsByTagNameNS;
      const cachedItems = cache2.get(tagName2);
      if (cachedItems?.result) {
        const items3 = cachedItems.result.deref();
        if (items3) {
          return items3;
        }
      }
      const cachedResult = { result: null };
      const items2 = find(parentNode2, cachedResult);
      cachedResult.result = new WeakRef(items2);
      cache2.set(tagName2, cachedResult);
      return items2;
    };
    return new HTMLCollection(illegalConstructor, query2);
  }
  /**
   * Returns the first element matching a tag name.
   * This is not part of the browser standard and is only used internally (used in Document).
   *
   * @param parentNode Parent node.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  static getElementByTagName(parentNode2, tagName2) {
    const upperTagName = tagName2.toUpperCase();
    const find = (parent2, cachedResult2) => {
      for (const element of parent2[elementArray]) {
        element[affectsCache].push(cachedResult2);
        if (element[tagName] === upperTagName) {
          return element;
        }
        const foundElement = find(element, cachedResult2);
        if (foundElement) {
          return foundElement;
        }
      }
      return null;
    };
    const cache2 = parentNode2[cache].elementByTagName;
    const cachedItem = cache2.get(tagName2);
    if (cachedItem?.result) {
      const item2 = cachedItem.result.deref();
      if (item2) {
        return item2;
      }
    }
    const cachedResult = { result: null };
    const item = find(parentNode2, cachedResult);
    cachedResult.result = item ? new WeakRef(item) : { deref: () => null };
    cache2.set(tagName2, cachedResult);
    return item;
  }
  /**
   * Returns an element by ID.
   *
   * @param parentNode Parent node.
   * @param id ID.
   * @returns Matching element.
   */
  static getElementById(parentNode2, id2) {
    id2 = String(id2);
    if (parentNode2 instanceof Document) {
      const entry = parentNode2[elementIdMap].get(id2);
      if (entry?.elements.length > 0) {
        return entry.elements[0];
      }
      return null;
    }
    const find = (parent2, cachedResult2) => {
      for (const element of parent2[elementArray]) {
        element[affectsCache].push(cachedResult2);
        if (element.getAttribute("id") === id2) {
          return element;
        }
        const foundElement = find(element, cachedResult2);
        if (foundElement) {
          return foundElement;
        }
      }
      return null;
    };
    const cache2 = parentNode2[cache].elementById;
    const cachedItem = cache2.get(id2);
    if (cachedItem?.result) {
      const item2 = cachedItem.result.deref();
      if (item2) {
        return item2;
      }
    }
    const cachedResult = { result: null };
    const item = find(parentNode2, cachedResult);
    cachedResult.result = item ? new WeakRef(item) : { deref: () => null };
    cache2.set(id2, cachedResult);
    return item;
  }
};

// node_modules/happy-dom/lib/dom/DOMRectList.js
var DOMRectList = class extends Array {
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   */
  constructor(illegalConstructorSymbol) {
    super();
    if (illegalConstructorSymbol !== 1 && illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    return this[index] ?? null;
  }
};

// node_modules/happy-dom/lib/nodes/element/NamedNodeMap.js
var NamedNodeMap = class {
  // Items by attribute namespaceURI
  [itemsByNamespaceURI] = /* @__PURE__ */ new Map();
  // Items by attribute name
  [itemsByName] = /* @__PURE__ */ new Map();
  // All items
  [items] = /* @__PURE__ */ new Map();
  /**
   * Constructor.
   *
   * @param ownerElement Owner element.
   */
  constructor(ownerElement2) {
    this[ownerElement] = ownerElement2;
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[items].size;
  }
  /**
   * Returns string.
   *
   * @returns string.
   */
  get [Symbol.toStringTag]() {
    return "NamedNodeMap";
  }
  /**
   * Returns string.
   *
   * @returns string.
   */
  toString() {
    return "[object NamedNodeMap]";
  }
  /**
   * Iterator.
   *
   * @returns Iterator.
   */
  [Symbol.iterator]() {
    return this[items].values();
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    const items2 = Array.from(this[items].values());
    return index >= 0 && items2[index] ? items2[index] : null;
  }
  /**
   * Returns named item.
   *
   * @param name Name.
   * @returns Item.
   */
  getNamedItem(name2) {
    name2 = String(name2);
    if (this[ownerElement][namespaceURI] === NamespaceURI_default.html && this[ownerElement][ownerDocument][contentType] === "text/html") {
      return this[itemsByName].get(StringUtility.asciiLowerCase(name2))?.[0] || null;
    }
    return this[itemsByName].get(name2)?.[0] || null;
  }
  /**
   * Returns item by name and namespace.
   *
   * @param namespace Namespace.
   * @param localName Local name of the attribute.
   * @returns Item.
   */
  getNamedItemNS(namespace, localName2) {
    const item = this[itemsByNamespaceURI].get(`${namespace || ""}:${localName2}`);
    if (item && (!item[prefix] || item[namespaceURI])) {
      return item;
    }
    return null;
  }
  /**
   * Sets named item.
   *
   * @param item Item.
   * @returns Replaced item.
   */
  setNamedItem(item) {
    return this[setNamedItem](item);
  }
  /**
   * Adds a new namespaced item.
   *
   * @alias setNamedItem()
   * @param item Item.
   * @returns Replaced item.
   */
  setNamedItemNS(item) {
    return this[setNamedItem](item);
  }
  /**
   * Removes an item.
   *
   * @throws DOMException
   * @param name Name of item.
   * @returns Removed item.
   */
  removeNamedItem(name2) {
    const item = this.getNamedItem(name2);
    if (!item) {
      throw new DOMException(`Failed to execute 'removeNamedItem' on 'NamedNodeMap': No item with name '${name2}' was found.`, DOMExceptionNameEnum_default.notFoundError);
    }
    this[removeNamedItem](item);
    return item;
  }
  /**
   * Removes a namespaced item.
   *
   * @param namespace Namespace.
   * @param localName Local name of the item.
   * @returns Removed item.
   */
  removeNamedItemNS(namespace, localName2) {
    const item = this.getNamedItemNS(namespace, localName2);
    if (!item) {
      throw new DOMException(`Failed to execute 'removeNamedItemNS' on 'NamedNodeMap': No item with name '${localName2}' in namespace '${namespace}' was found.`, DOMExceptionNameEnum_default.notFoundError);
    }
    this[removeNamedItem](item);
    return item;
  }
  /**
   * Sets named item.
   *
   * @param item Item.
   * @param [ignoreListeners] Ignore listeners.
   * @returns Replaced item.
   */
  [setNamedItem](item, ignoreListeners = false) {
    if (item[ownerElement] !== null && item[ownerElement] !== this[ownerElement]) {
      throw new this[ownerElement][window].DOMException("The attribute is in use.", DOMExceptionNameEnum_default.inUseAttributeError);
    }
    item[ownerElement] = this[ownerElement];
    const replacedItem = this.getNamedItemNS(item[namespaceURI], item[localName]) || null;
    const itemsByName2 = this[itemsByName].get(item[name]);
    if (replacedItem === item) {
      return item;
    }
    this[itemsByNamespaceURI].set(`${item[namespaceURI] || ""}:${item[localName]}`, item);
    this[items].set(`${item[namespaceURI] || ""}:${item[name]}`, item);
    if (!itemsByName2?.length) {
      this[itemsByName].set(item[name], [item]);
    } else {
      const index = itemsByName2.indexOf(replacedItem);
      if (index !== -1) {
        itemsByName2.splice(index, 1);
      }
      itemsByName2.push(item);
    }
    if (!ignoreListeners) {
      this[ownerElement][onSetAttribute](item, replacedItem);
    }
    return replacedItem;
  }
  /**
   * Removes named item.
   *
   * @param item Item.
   * @param ignoreListeners
   */
  [removeNamedItem](item, ignoreListeners = false) {
    item[ownerElement] = null;
    this[itemsByNamespaceURI].delete(`${item[namespaceURI] || ""}:${item[localName]}`);
    this[items].delete(`${item[namespaceURI] || ""}:${item[name]}`);
    const itemsByName2 = this[itemsByName].get(item[name]);
    if (itemsByName2?.length) {
      const index = itemsByName2.indexOf(item);
      if (index !== -1) {
        itemsByName2.splice(index, 1);
      }
      if (!itemsByName2.length) {
        this[itemsByName].delete(item[name]);
      }
    }
    if (!ignoreListeners) {
      this[ownerElement][onRemoveAttribute](item);
    }
  }
};

// node_modules/happy-dom/lib/nodes/element/NamedNodeMapProxyFactory.js
var NamedNodeMapProxyFactory = class {
  /**
   * Constructor.
   *
   * @param namedNodeMap
   */
  static createProxy(namedNodeMap) {
    const methodBinder = new ClassMethodBinder(this, [NamedNodeMap]);
    return new Proxy(namedNodeMap, {
      get: (target2, property) => {
        if (property === "length") {
          return namedNodeMap[items].size;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return target2.item(index);
        }
        return target2.getNamedItem(property) || void 0;
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys() {
        const keys = Array.from(namedNodeMap[items].keys());
        for (let i = 0, max = namedNodeMap[items].size; i < max; i++) {
          keys.push(String(i));
        }
        return keys;
      },
      has(target2, property) {
        if (typeof property === "symbol") {
          return false;
        }
        if (property in target2 || namedNodeMap[items].has(property)) {
          return true;
        }
        const index = Number(property);
        if (!isNaN(index) && index >= 0 && index < namedNodeMap[items].size) {
          return true;
        }
        return false;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        if (!isNaN(index)) {
          if (index >= 0) {
            const itemByIndex = target2.item(index);
            if (itemByIndex) {
              return {
                value: itemByIndex,
                writable: false,
                enumerable: true,
                configurable: true
              };
            }
          }
          return;
        }
        const items2 = namedNodeMap[items].get(property);
        if (items2) {
          return {
            value: items2,
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
};

// node_modules/happy-dom/lib/html-serializer/HTMLSerializer.js
var HTMLSerializer = class {
  options = {
    serializableShadowRoots: false,
    shadowRoots: null,
    allShadowRoots: false
  };
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.serializableShadowRoots] If shadow roots should be serialized.
   * @param [options.shadowRoots] Shadow roots to serialize.
   * @param [options.allShadowRoots] If all shadow roots should be serialized.
   */
  constructor(options2) {
    if (options2) {
      if (options2.serializableShadowRoots) {
        this.options.serializableShadowRoots = options2.serializableShadowRoots;
      }
      if (options2.shadowRoots) {
        this.options.shadowRoots = options2.shadowRoots;
      }
      if (options2.allShadowRoots) {
        this.options.allShadowRoots = options2.allShadowRoots;
      }
    }
  }
  /**
   * Renders an element as HTML.
   *
   * @param root Root element.
   * @returns Result.
   */
  serializeToString(root2) {
    switch (root2[nodeType]) {
      case NodeTypeEnum_default.elementNode:
        const element = root2;
        const prefix2 = element[prefix];
        const localName2 = element[localName];
        const config = HTMLElementConfig_default[element[localName]];
        const tagName2 = prefix2 ? `${prefix2}:${localName2}` : localName2;
        if (config?.contentModel === HTMLElementConfigContentModelEnum_default.noDescendants) {
          return `<${tagName2}${this.getAttributes(element)}>`;
        }
        let innerHTML = "";
        if (element.shadowRoot && (this.options.allShadowRoots || this.options.serializableShadowRoots && element.shadowRoot[serializable] || this.options.shadowRoots?.includes(element.shadowRoot))) {
          innerHTML += `<template shadowrootmode="${element.shadowRoot[mode]}"${element.shadowRoot[serializable] ? ' shadowrootserializable=""' : ""}>`;
          for (const node of element.shadowRoot[nodeArray]) {
            innerHTML += this.serializeToString(node);
          }
          innerHTML += "</template>";
        }
        const childNodes2 = tagName2 === "template" ? root2.content[nodeArray] : root2[nodeArray];
        for (const node of childNodes2) {
          innerHTML += this.serializeToString(node);
        }
        return `<${tagName2}${this.getAttributes(element)}>${innerHTML}</${tagName2}>`;
      case Node.DOCUMENT_FRAGMENT_NODE:
      case Node.DOCUMENT_NODE:
        let html = "";
        for (const node of root2[nodeArray]) {
          html += this.serializeToString(node);
        }
        return html;
      case NodeTypeEnum_default.commentNode:
        return `<!--${root2.textContent}-->`;
      case NodeTypeEnum_default.processingInstructionNode:
        return `<!--?${root2.target} ${root2.textContent}?-->`;
      case NodeTypeEnum_default.textNode:
        const parentElement = root2.parentElement;
        if (parentElement) {
          const parentConfig = HTMLElementConfig_default[parentElement[localName]];
          if (parentConfig?.contentModel === HTMLElementConfigContentModelEnum_default.rawText) {
            return root2.textContent;
          }
        }
        return XMLEncodeUtility.encodeTextContent(root2.textContent);
      case NodeTypeEnum_default.documentTypeNode:
        const doctype = root2;
        const identifier = doctype.publicId ? " PUBLIC" : doctype.systemId ? " SYSTEM" : "";
        const publicId2 = doctype.publicId ? ` "${doctype.publicId}"` : "";
        const systemId2 = doctype.systemId ? ` "${doctype.systemId}"` : "";
        return `<!DOCTYPE ${doctype.name}${identifier}${publicId2}${systemId2}>`;
    }
    return "";
  }
  /**
   * Returns attributes as a string.
   *
   * @param element Element.
   * @returns Attributes.
   */
  getAttributes(element) {
    let attributeString = "";
    const attributes2 = element[attributes][items];
    if (!attributes2.has(":is") && element[isValue]) {
      attributeString += ' is="' + XMLEncodeUtility.encodeHTMLAttributeValue(element[isValue]) + '"';
    }
    for (const attribute of attributes2.values()) {
      const escapedValue = XMLEncodeUtility.encodeHTMLAttributeValue(attribute[value]);
      attributeString += " " + attribute[name] + '="' + escapedValue + '"';
    }
    return attributeString;
  }
};

// node_modules/happy-dom/lib/utilities/AttributeUtility.js
var HTML_INVALID_ATTRIBUTE_NAME_CHARACTER_REGEX = /[\x00-\x1F\x7F\x80-\x9F "\'><=\/\uFDD0-\uFDEF\uFFFE\uFFFF\u1FFFE\u1FFFF\u2FFFE\u2FFFF\u3FFFE\u3FFFF\u4FFFE\u4FFFF\u5FFFE\u5FFFF\u6FFFE\u6FFFF\u7FFFE\u7FFFF\u8FFFE\u8FFFF\u9FFFE\u9FFFF\uAFFFE\uAFFFF\uBFFFE\uBFFFF\uCFFFE\uCFFFF\uDFFFE\uDFFFF\uEFFFE\uEFFFF\uFFFFE\uFFFFF\u10FFFE\u10FFFF]/;
var AttributeUtility = class {
  /**
   *
   * @param name the attribute name
   * @param contentType the attribute has to be valid in
   * @param context the context in which the error occurred in
   * @param context.method
   * @param context.instance
   */
  static validateAttributeName(name2, contentType2, context) {
    const { method: method2, instance } = context;
    if (contentType2 === "text/html") {
      const normalizedName = String(name2).toLowerCase();
      if (HTML_INVALID_ATTRIBUTE_NAME_CHARACTER_REGEX.test(normalizedName) || normalizedName.length === 0 || normalizedName[0] === "-") {
        throw new DOMException(`Uncaught InvalidCharacterError: Failed to execute '${method2}' on '${instance}': '${name2}' is not a valid attribute name.`, DOMExceptionNameEnum_default.invalidCharacterError);
      }
    }
  }
};

// node_modules/happy-dom/lib/nodes/element/ElementEventAttributeUtility.js
var ElementEventAttributeUtility = class {
  /**
   * Evaluates code in attribute and returns event listener.
   *
   * @param element
   * @param property Property.
   * @returns Result.
   */
  static getEventListener(element, property) {
    const cached = element[propertyEventListeners].get(property);
    if (cached) {
      return cached;
    }
    const window2 = element[ownerDocument][defaultView];
    const browserSettings = new WindowBrowserContext(window2).getSettings();
    if (!browserSettings) {
      return null;
    }
    const code = element.getAttribute(property);
    if (!code) {
      return null;
    }
    let newCode = `(function anonymous($happy_dom, event) {
//# sourceURL=${window2.location.href}
`;
    if (browserSettings && !browserSettings.disableErrorCapturing && browserSettings.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch) {
      newCode += "try {\n";
    }
    newCode += code;
    if (browserSettings && !browserSettings.disableErrorCapturing && browserSettings.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch) {
      newCode += "\n} catch(e) { $happy_dom.dispatchError(e); }\n";
    }
    newCode += "})";
    let listener = null;
    try {
      listener = window2.eval(newCode).bind(element, {
        dispatchError: window2[dispatchError]
      });
    } catch (e) {
      const error2 = new window2.SyntaxError(`Failed to read the '${property}' property from '${element.constructor.name}': ${e.message}`);
      if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum_default.tryAndCatch) {
        throw error2;
      } else {
        window2[dispatchError](error2);
        return null;
      }
    }
    if (listener) {
      element[propertyEventListeners].set(property, listener);
    }
    return listener;
  }
};

// node_modules/happy-dom/lib/nodes/element/Element.js
var Element = class extends Node {
  static [tagName] = null;
  static [localName] = null;
  static [namespaceURI] = null;
  // Internal properties
  [classList] = null;
  [isValue] = null;
  [nodeType] = NodeTypeEnum_default.elementNode;
  [prefix] = null;
  [shadowRoot] = null;
  [scrollHeight] = 0;
  [scrollWidth] = 0;
  [scrollTop] = 0;
  [scrollLeft] = 0;
  [attributes] = new NamedNodeMap(this);
  [attributesProxy] = null;
  [children] = null;
  [computedStyle] = null;
  [propertyEventListeners] = /* @__PURE__ */ new Map();
  /**
   * Constructor.
   */
  constructor() {
    super();
    if (!this[tagName]) {
      this[tagName] = null;
    }
    if (!this[localName]) {
      this[localName] = null;
    }
    if (!this[namespaceURI]) {
      this[namespaceURI] = null;
    }
  }
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onfullscreenerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onfullscreenerror");
  }
  set onfullscreenerror(value2) {
    this[propertyEventListeners].set("onfullscreenerror", value2);
  }
  get onfullscreenchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onfullscreenchange");
  }
  set onfullscreenchange(value2) {
    this[propertyEventListeners].set("onfullscreenchange", value2);
  }
  get onbeforecopy() {
    return ElementEventAttributeUtility.getEventListener(this, "onbeforecopy");
  }
  set onbeforecopy(value2) {
    this[propertyEventListeners].set("onbeforecopy", value2);
  }
  get onbeforecut() {
    return ElementEventAttributeUtility.getEventListener(this, "onbeforecut");
  }
  set onbeforecut(value2) {
    this[propertyEventListeners].set("onbeforecut", value2);
  }
  get onbeforepaste() {
    return ElementEventAttributeUtility.getEventListener(this, "onbeforepaste");
  }
  set onbeforepaste(value2) {
    this[propertyEventListeners].set("onbeforepaste", value2);
  }
  get onsearch() {
    return ElementEventAttributeUtility.getEventListener(this, "onsearch");
  }
  set onsearch(value2) {
    this[propertyEventListeners].set("onsearch", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns tag name.
   *
   * @returns Tag name.
   */
  get tagName() {
    return this[tagName];
  }
  /**
   * Returns prefix.
   *
   * @returns Prefix.
   */
  get prefix() {
    return this[prefix];
  }
  /**
   * Returns shadow root.
   *
   * @returns Shadow root.
   */
  get shadowRoot() {
    const shadowRoot2 = this[shadowRoot];
    return shadowRoot2 && shadowRoot2[mode] === "open" ? shadowRoot2 : null;
  }
  /**
   * Returns scroll height.
   *
   * @returns Scroll height.
   */
  get scrollHeight() {
    return this[scrollHeight];
  }
  /**
   * Returns scroll width.
   *
   * @returns Scroll width.
   */
  get scrollWidth() {
    return this[scrollWidth];
  }
  /**
   * Returns scroll top.
   *
   * @returns Scroll top.
   */
  get scrollTop() {
    return this[scrollTop];
  }
  /**
   * Sets scroll top.
   *
   * @param value Scroll top.
   */
  set scrollTop(value2) {
    this[scrollTop] = value2;
  }
  /**
   * Returns scroll left.
   *
   * @returns Scroll left.
   */
  get scrollLeft() {
    return this[scrollLeft];
  }
  /**
   * Sets scroll left.
   *
   * @param value Scroll left.
   */
  set scrollLeft(value2) {
    this[scrollLeft] = value2;
  }
  /**
   * Returns attributes.
   *
   * @returns Attributes.
   */
  get attributes() {
    if (!this[attributesProxy]) {
      this[attributesProxy] = NamedNodeMapProxyFactory.createProxy(this[attributes]);
    }
    return this[attributesProxy];
  }
  /**
   * Returns namespace URI.
   *
   * @returns Namespace URI.
   */
  get namespaceURI() {
    return this[namespaceURI];
  }
  /**
   * Returns element children.
   */
  get children() {
    if (!this[children]) {
      const elements2 = this[elementArray];
      this[children] = new HTMLCollection(illegalConstructor, () => elements2);
    }
    return this[children];
  }
  /**
   * Returns class list.
   *
   * @returns Class list.
   */
  get classList() {
    if (!this[classList]) {
      this[classList] = new DOMTokenList(illegalConstructor, this, "class");
    }
    return this[classList];
  }
  /**
   * Sets class list.
   *
   * @param value Class list.
   */
  set classList(value2) {
    this.setAttribute("class", value2);
  }
  /**
   * Returns ID.
   *
   * @returns ID.
   */
  get id() {
    return this.getAttribute("id") || "";
  }
  /**
   * Sets ID.
   *
   * @param id ID.
   */
  set id(id2) {
    this.setAttribute("id", id2);
  }
  /**
   * Returns class name.
   *
   * @returns Class name.
   */
  get className() {
    return this.getAttribute("class") || "";
  }
  /**
   * Sets class name.
   *
   * @param className Class name.
   */
  set className(className) {
    this.setAttribute("class", className);
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return this[tagName];
  }
  /**
   * Local name.
   *
   * @returns Local name.
   */
  get localName() {
    return this[localName];
  }
  /**
   * Returns role.
   *
   * @returns Role.
   */
  get role() {
    return this.getAttribute("role") || "";
  }
  /**
   * Sets role.
   *
   * @param role Role.
   */
  set role(role) {
    this.setAttribute("role", role);
  }
  /**
   * Previous element sibling.
   *
   * @returns Element.
   */
  get previousElementSibling() {
    return NonDocumentChildNodeUtility.previousElementSibling(this);
  }
  /**
   * Next element sibling.
   *
   * @returns Element.
   */
  get nextElementSibling() {
    return NonDocumentChildNodeUtility.nextElementSibling(this);
  }
  /**
   * Get text value of children.
   *
   * @returns Text content.
   */
  get textContent() {
    let result2 = "";
    for (const childNode of this[nodeArray]) {
      if (childNode[nodeType] === NodeTypeEnum_default.elementNode || childNode[nodeType] === NodeTypeEnum_default.textNode) {
        result2 += childNode.textContent;
      }
    }
    return result2;
  }
  /**
   * Sets text content.
   *
   * @param textContent Text content.
   */
  set textContent(textContent) {
    const childNodes2 = this[nodeArray];
    while (childNodes2.length) {
      this.removeChild(childNodes2[0]);
    }
    if (textContent) {
      this.appendChild(this[ownerDocument].createTextNode(textContent));
    }
  }
  /**
   * Returns inner HTML.
   *
   * @returns HTML.
   */
  get innerHTML() {
    return this.getHTML();
  }
  /**
   * Sets inner HTML.
   *
   * @param html HTML.
   */
  set innerHTML(html) {
    const childNodes2 = this[nodeArray];
    while (childNodes2.length) {
      this.removeChild(childNodes2[0]);
    }
    new HTMLParser(this[window]).parse(html, this);
  }
  /**
   * Returns outer HTML.
   *
   * @returns HTML.
   */
  get outerHTML() {
    return new HTMLSerializer().serializeToString(this);
  }
  /**
   * Returns outer HTML.
   *
   * @param html HTML.
   */
  set outerHTML(html) {
    const childNodes2 = new HTMLParser(this[window]).parse(html)[nodeArray];
    this.replaceWith(...childNodes2);
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get childElementCount() {
    return this[elementArray].length;
  }
  /**
   * First element child.
   *
   * @returns Element.
   */
  get firstElementChild() {
    return this[elementArray][0] ?? null;
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get lastElementChild() {
    const children2 = this[elementArray];
    return children2[children2.length - 1] ?? null;
  }
  /**
   * Returns slot.
   *
   * @returns Slot.
   */
  get slot() {
    return this.getAttributeNS(null, "slot") || "";
  }
  /**
   * Returns slot.
   *
   * @param slot Slot.
   */
  set slot(title) {
    this.setAttribute("slot", title);
  }
  /**
   * Returns inner HTML and optionally the content of shadow roots.
   *
   * @deprecated
   * @param [options] Options.
   * @param [options.includeShadowRoots] Set to "true" to include shadow roots.
   * @returns HTML.
   */
  getInnerHTML(options2) {
    const serializer = new HTMLSerializer({
      allShadowRoots: !!options2?.includeShadowRoots
    });
    let html = "";
    for (const node of this[nodeArray]) {
      html += serializer.serializeToString(node);
    }
    return html;
  }
  /**
   * Returns inner HTML and optionally the content of shadow roots.
   *
   * @param [options] Options.
   * @param [options.serializableShadowRoots] A boolean value that specifies whether to include serializable shadow roots. The default value is false.
   * @param [options.shadowRoots] An array of ShadowRoot objects to serialize. These are included regardless of whether they are marked as serializable, or if they are open or closed. The default value is an empty array.
   * @returns HTML.
   */
  getHTML(options2) {
    const serializer = new HTMLSerializer({
      serializableShadowRoots: !!options2?.serializableShadowRoots,
      shadowRoots: options2?.shadowRoots ?? null
    });
    let html = "";
    for (const node of this[nodeArray]) {
      html += serializer.serializeToString(node);
    }
    return html;
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[tagName] = this[tagName];
    clone2[localName] = this[localName];
    clone2[namespaceURI] = this[namespaceURI];
    if (this[shadowRoot]?.[clonable]) {
      clone2[shadowRoot] = this[shadowRoot].cloneNode(deep);
      clone2[shadowRoot][host] = clone2;
    }
    clone2[attributes] = new NamedNodeMap(clone2);
    for (const attr of this[attributes][items].values()) {
      clone2[attributes].setNamedItem(attr.cloneNode(deep));
    }
    return clone2;
  }
  /**
   * Removes the node from its parent.
   */
  remove() {
    ChildNodeUtility.remove(this);
  }
  /**
   * The Node.replaceWith() method replaces this Node in the children list of its parent with a set of Node or DOMString objects.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceWith(...nodes) {
    ChildNodeUtility.replaceWith(this, ...nodes);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just before this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  before(...nodes) {
    ChildNodeUtility.before(this, ...nodes);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just after this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  after(...nodes) {
    ChildNodeUtility.after(this, ...nodes);
  }
  /**
   * Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  append(...nodes) {
    ParentNodeUtility.append(this, ...nodes);
  }
  /**
   * Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  prepend(...nodes) {
    ParentNodeUtility.prepend(this, ...nodes);
  }
  /**
   * Replaces the existing children of a node with a specified new set of children.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceChildren(...nodes) {
    ParentNodeUtility.replaceChildren(this, ...nodes);
  }
  /**
   * Inserts a node to the given position.
   *
   * @param position Position to insert element.
   * @param element Node to insert.
   * @returns Inserted node or null if couldn't insert.
   */
  insertAdjacentElement(position, element) {
    if (position === "beforebegin") {
      if (!this.parentElement) {
        return null;
      }
      this.parentElement.insertBefore(element, this);
    } else if (position === "afterbegin") {
      this.insertBefore(element, this.firstChild);
    } else if (position === "beforeend") {
      this.appendChild(element);
    } else if (position === "afterend") {
      if (!this.parentElement) {
        return null;
      }
      this.parentElement.insertBefore(element, this.nextSibling);
    }
    return element;
  }
  /**
   * Inserts an HTML string to the given position.
   *
   * @param position Position to insert text.
   * @param text HTML string to insert.
   */
  insertAdjacentHTML(position, text) {
    const childNodes2 = new HTMLParser(this[window]).parse(text)[nodeArray];
    while (childNodes2.length) {
      this.insertAdjacentElement(position, childNodes2[0]);
    }
  }
  /**
   * Inserts text to the given position.
   *
   * @param position Position to insert text.
   * @param text String to insert.
   */
  insertAdjacentText(position, text) {
    if (!text) {
      return;
    }
    const textNode = this[ownerDocument].createTextNode(text);
    this.insertAdjacentElement(position, textNode);
  }
  /**
   * Sets an attribute.
   *
   * @param name Name.
   * @param value Value.
   */
  setAttribute(name2, value2) {
    AttributeUtility.validateAttributeName(name2, this[ownerDocument][contentType], { method: "setAttribute", instance: "Element" });
    name2 = String(name2);
    const namespaceURI2 = this[namespaceURI];
    if (namespaceURI2 === NamespaceURI_default.html) {
      const attribute = this[ownerDocument].createAttribute(name2);
      attribute[value] = String(value2);
      this[attributes][setNamedItem](attribute);
    } else {
      const nameParts = name2.split(":");
      let attributeNamespaceURI = null;
      switch (nameParts[0]) {
        case "xmlns":
          attributeNamespaceURI = !nameParts[1] || nameParts[1] === "xlink" ? NamespaceURI_default.xmlns : null;
          break;
        case "xlink":
          attributeNamespaceURI = NamespaceURI_default.xlink;
          break;
      }
      const attribute = NodeFactory.createNode(this[ownerDocument], this[window].Attr);
      attribute[namespaceURI] = attributeNamespaceURI;
      attribute[name] = name2;
      attribute[localName] = attributeNamespaceURI && nameParts[1] ? nameParts[1] : name2;
      attribute[prefix] = attributeNamespaceURI && nameParts[1] ? nameParts[0] : null;
      attribute[value] = String(value2);
      this[attributes][setNamedItem](attribute);
    }
  }
  /**
   * Sets a namespace attribute.
   *
   * @param namespaceURI Namespace URI.
   * @param name Name.
   * @param value Value.
   */
  setAttributeNS(namespaceURI2, name2, value2) {
    const attribute = this[ownerDocument].createAttributeNS(namespaceURI2, name2);
    if (!namespaceURI2 && attribute[prefix]) {
      throw new this[window].DOMException(`Failed to execute 'setAttributeNS' on 'Element': '' is an invalid namespace for attributes.`, DOMExceptionNameEnum_default.namespaceError);
    }
    attribute[value] = String(value2);
    this[attributes].setNamedItemNS(attribute);
  }
  /**
   * Returns attribute names.
   *
   * @returns Attribute names.
   */
  getAttributeNames() {
    const names = [];
    for (const item of this[attributes][items].values()) {
      names.push(item[name]);
    }
    return names;
  }
  /**
   * Returns attribute value.
   *
   * @param name Name.
   */
  getAttribute(name2) {
    const attribute = this[attributes].getNamedItem(name2);
    if (attribute) {
      return attribute[value];
    }
    return null;
  }
  /**
   * Toggle an attribute.
   * Returns `true` if attribute name is eventually present, and `false` otherwise.
   *
   * @param name A DOMString specifying the name of the attribute to be toggled.
   * @param force A boolean value to determine whether the attribute should be added or removed, no matter whether the attribute is present or not at the moment.
   */
  toggleAttribute(name2, force) {
    name2 = name2.toLowerCase();
    const attribute = this[attributes].getNamedItem(name2);
    if (attribute) {
      if (force === true) {
        return true;
      }
      this[attributes][removeNamedItem](attribute);
      return false;
    }
    if (force === false) {
      return false;
    }
    this.setAttribute(name2, "");
    return true;
  }
  /**
   * Returns namespace attribute value.
   *
   * @param namespace Namespace URI.
   * @param localName Local name.
   */
  getAttributeNS(namespace, localName2) {
    const attribute = this.getAttributeNodeNS(namespace, localName2);
    if (attribute) {
      return attribute[value];
    }
    return null;
  }
  /**
   * Returns a boolean value indicating whether the specified element has the attribute or not.
   *
   * @param name Attribute name.
   * @returns True if attribute exists, false otherwise.
   */
  hasAttribute(name2) {
    return !!this.getAttributeNode(name2);
  }
  /**
   * Returns a boolean value indicating whether the specified element has the namespace attribute or not.
   *
   * @param namespace Namespace URI.
   * @param localName Local name.
   * @returns True if attribute exists, false otherwise.
   */
  hasAttributeNS(namespace, localName2) {
    return this[attributes].getNamedItemNS(namespace, localName2) !== null;
  }
  /**
   * Returns "true" if the element has attributes.
   *
   * @returns "true" if the element has attributes.
   */
  hasAttributes() {
    return this[attributes][items].size > 0;
  }
  /**
   * Removes an attribute.
   *
   * @param name Name.
   */
  removeAttribute(name2) {
    const item = this[attributes].getNamedItem(name2);
    if (item) {
      this[attributes][removeNamedItem](item);
    }
  }
  /**
   * Removes a namespace attribute.
   *
   * @param namespace Namespace URI.
   * @param localName Local name.
   */
  removeAttributeNS(namespace, localName2) {
    const item = this[attributes].getNamedItemNS(namespace, localName2);
    if (item) {
      this[attributes][removeNamedItem](item);
    }
  }
  /**
   * Attaches a shadow root.
   *
   * @param init Shadow root init.
   * @param init.mode Shadow root mode.
   * @param [init.clonable] Clonable.
   * @param [init.delegateFocus] Delegate focus.
   * @param [init.serializable] Serializable.
   * @param [init.slotAssignment] Slot assignment.
   * @returns Shadow root.
   */
  attachShadow(init) {
    const window2 = this[window];
    if (!init) {
      throw new window2.TypeError("Failed to execute 'attachShadow' on 'Element': 1 argument required, but only 0 present.");
    }
    if (!init.mode) {
      throw new window2.TypeError("Failed to execute 'attachShadow' on 'Element': Failed to read the 'mode' property from 'ShadowRootInit': Required member is undefined.");
    }
    if (init.mode !== "open" && init.mode !== "closed") {
      throw new window2.TypeError(`Failed to execute 'attachShadow' on 'Element': Failed to read the 'mode' property from 'ShadowRootInit': The provided value '${init.mode}' is not a valid enum value of type ShadowRootMode.`);
    }
    if (this[shadowRoot]) {
      throw new window2.DOMException("Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.");
    }
    const shadowRoot2 = NodeFactory.createNode(this[ownerDocument], this[window].ShadowRoot);
    this[shadowRoot] = shadowRoot2;
    shadowRoot2[host] = this;
    shadowRoot2[mode] = init.mode;
    shadowRoot2[clonable] = !!init.clonable;
    shadowRoot2[delegatesFocus] = !!init.delegateFocus;
    shadowRoot2[serializable] = !!init.serializable;
    shadowRoot2[slotAssignment] = init.slotAssignment === "manual" ? "manual" : "named";
    shadowRoot2[connectedToNode]();
    return this[shadowRoot];
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return this.outerHTML;
  }
  /**
   * Returns the size of an element and its position relative to the viewport.
   *
   * @returns DOM rect.
   */
  getBoundingClientRect() {
    return new DOMRect();
  }
  /**
   * Returns a collection of DOMRect objects that indicate the bounding rectangles for each CSS border box in a client.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getClientRects
   * @returns DOM rect list.
   */
  getClientRects() {
    const domRectList = new DOMRectList(illegalConstructor);
    domRectList.push(this.getBoundingClientRect());
    return domRectList;
  }
  /**
   * The matches() method checks to see if the Element would be selected by the provided selectorString.
   *
   * @param selector Selector.
   * @returns "true" if matching.
   */
  matches(selector) {
    return !!QuerySelector.matches(this, selector);
  }
  /**
   * Traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string.
   *
   * @param selector Selector.
   * @returns Closest matching element.
   */
  closest(selector) {
    let parent2 = this;
    while (parent2) {
      if (QuerySelector.matches(parent2, selector)) {
        return parent2;
      }
      parent2 = parent2.parentElement;
    }
    return null;
  }
  /**
   * Query CSS selector to find matching elements.
   *
   * @param selector CSS selector.
   * @returns Matching elements.
   */
  querySelectorAll(selector) {
    return QuerySelector.querySelectorAll(this, selector);
  }
  /**
   * Query CSS Selector to find matching node.
   *
   * @param selector CSS selector.
   * @returns Matching element.
   */
  querySelector(selector) {
    return QuerySelector.querySelector(this, selector);
  }
  /**
   * Returns an elements by class name.
   *
   * @param className Tag name.
   * @returns Matching element.
   */
  getElementsByClassName(className) {
    return ParentNodeUtility.getElementsByClassName(this, className);
  }
  /**
   * Returns an elements by tag name.
   *
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagName(tagName2) {
    return ParentNodeUtility.getElementsByTagName(this, tagName2);
  }
  /**
   * Returns an elements by tag name and namespace.
   *
   * @param namespaceURI Namespace URI.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagNameNS(namespaceURI2, tagName2) {
    return ParentNodeUtility.getElementsByTagNameNS(this, namespaceURI2, tagName2);
  }
  /**
   * The setAttributeNode() method adds a new Attr node to the specified element.
   *
   * @param attribute Attribute.
   * @returns Replaced attribute.
   */
  setAttributeNode(attribute) {
    return this[attributes].setNamedItem(attribute);
  }
  /**
   * The setAttributeNodeNS() method adds a new Attr node to the specified element.
   *
   * @param attribute Attribute.
   * @returns Replaced attribute.
   */
  setAttributeNodeNS(attribute) {
    return this[attributes].setNamedItemNS(attribute);
  }
  /**
   * Returns an Attr node.
   *
   * @param name Name.
   * @returns Replaced attribute.
   */
  getAttributeNode(name2) {
    return this[attributes].getNamedItem(name2);
  }
  /**
   * Returns a namespaced Attr node.
   *
   * @param namespace Namespace.
   * @param localName Name.
   * @returns Replaced attribute.
   */
  getAttributeNodeNS(namespace, localName2) {
    return this[attributes].getNamedItemNS(namespace, localName2);
  }
  /**
   * Removes an Attr node.
   *
   * @param attribute Attribute.
   * @returns Removed attribute.
   */
  removeAttributeNode(attribute) {
    if (attribute[ownerElement] !== this) {
      throw new this[window].DOMException("Failed to execute 'removeAttributeNode' on 'Element': The node provided is owned by another element.");
    }
    this[attributes][removeNamedItem](attribute);
    return attribute;
  }
  /**
   * Scrolls to a particular set of coordinates.
   *
   * @param x X position or options object.
   * @param y Y position.
   */
  scroll(x3, y3) {
    if (typeof x3 !== "object" && arguments.length === 1) {
      throw new this[window].TypeError("Failed to execute 'scroll' on 'Element': The provided value is not of type 'ScrollToOptions'.");
    }
    const options2 = typeof x3 === "object" ? x3 : { left: x3, top: y3 };
    if (options2.behavior === "smooth") {
      this[window].setTimeout(() => {
        if (options2.top !== void 0) {
          const top2 = Number(options2.top);
          this.scrollTop = isNaN(top2) ? 0 : top2;
        }
        if (options2.left !== void 0) {
          const left = Number(options2.left);
          this.scrollLeft = isNaN(left) ? 0 : left;
        }
      });
    } else {
      if (options2.top !== void 0) {
        const top2 = Number(options2.top);
        this.scrollTop = isNaN(top2) ? 0 : top2;
      }
      if (options2.left !== void 0) {
        const left = Number(options2.left);
        this.scrollLeft = isNaN(left) ? 0 : left;
      }
    }
  }
  /**
   * Scrolls to a particular set of coordinates.
   *
   * @param x X position or options object.
   * @param y Y position.
   */
  scrollTo(x3, y3) {
    if (typeof x3 !== "object" && arguments.length === 1) {
      throw new this[window].TypeError("Failed to execute 'scrollTo' on 'Element': The provided value is not of type 'ScrollToOptions'.");
    }
    this.scroll(x3, y3);
  }
  /**
   * Scrolls by a relative amount from the current position.
   *
   * @param x Pixels to scroll by from top or scroll options object.
   * @param y Pixels to scroll by from left.
   */
  scrollBy(x3, y3) {
    if (typeof x3 !== "object" && arguments.length === 1) {
      throw new this[window].TypeError("Failed to execute 'scrollBy' on 'Element': The provided value is not of type 'ScrollToOptions'.");
    }
    const options2 = typeof x3 === "object" ? x3 : { left: x3, top: y3 };
    this.scroll({
      left: this.scrollLeft + (options2.left ?? 0),
      top: this.scrollTop + (options2.top ?? 0),
      behavior: options2.behavior
    });
  }
  /**
   * Scrolls the element's ancestor containers such that the element on which scrollIntoView() is called is visible to the user.
   *
   * @param [_options] Options.
   */
  scrollIntoView(_options) {
  }
  /**
   * @override
   */
  [appendChild](node, disableValidations = false) {
    const returnValue2 = super[appendChild](node, disableValidations);
    this.#onSlotChange(node);
    return returnValue2;
  }
  /**
   * @override
   */
  [removeChild](node) {
    const returnValue2 = super[removeChild](node);
    this.#onSlotChange(node);
    return returnValue2;
  }
  /**
   * @override
   */
  [insertBefore](newNode, referenceNode, disableValidations = false) {
    const returnValue2 = super[insertBefore](newNode, referenceNode, disableValidations);
    this.#onSlotChange(newNode);
    return returnValue2;
  }
  /**
   * Triggered when an attribute is set.
   *
   * @param attribute Attribute.
   * @param replacedAttribute Replaced attribute.
   */
  [onSetAttribute](attribute, replacedAttribute) {
    if (!attribute[name]) {
      return null;
    }
    const oldValue = replacedAttribute ? replacedAttribute[value] : null;
    if (attribute[name] === "slot" && this[parentNode] && this[parentNode][shadowRoot]) {
      const shadowRoot2 = this[parentNode][shadowRoot];
      if (attribute[value] !== oldValue) {
        if (oldValue !== null) {
          const slot2 = shadowRoot2.querySelector(`slot[name="${replacedAttribute[value]}"]`);
          if (slot2) {
            slot2.dispatchEvent(new Event("slotchange", { bubbles: true }));
          }
        } else {
          const slot2 = shadowRoot2.querySelector("slot:not([name])");
          if (slot2) {
            slot2.dispatchEvent(new Event("slotchange", { bubbles: true }));
          }
        }
        const slot = shadowRoot2.querySelector(`slot[name="${attribute[value]}"]`);
        if (slot) {
          slot.dispatchEvent(new Event("slotchange", { bubbles: true }));
        }
      }
    }
    if (this[attribute[name]] !== void 0 && attribute[name][0] === "o" && attribute[name][1] === "n") {
      this[propertyEventListeners].delete(attribute[name]);
    }
    if (attribute[name] === "id" && this[isConnected]) {
      if (replacedAttribute?.[value]) {
        this.#removeIdentifierFromWindow(replacedAttribute[value]);
      }
      this.#addIdentifierToWindow(attribute[value]);
    }
    this[reportMutation](new MutationRecord({
      target: this,
      type: MutationTypeEnum_default.attributes,
      attributeName: attribute[name],
      oldValue
    }));
  }
  /**
   * Triggered when an attribute is set.
   *
   * @param removedAttribute Attribute.
   */
  [onRemoveAttribute](removedAttribute) {
    if (removedAttribute[name] === "slot" && this[parentNode] && this[parentNode][shadowRoot]) {
      const shadowRoot2 = this[parentNode][shadowRoot];
      const namedSlot = shadowRoot2.querySelector(`slot[name="${removedAttribute[value]}"]`);
      const defaultSlot = shadowRoot2.querySelector("slot:not([name])");
      if (namedSlot) {
        namedSlot.dispatchEvent(new Event("slotchange", { bubbles: true }));
      }
      if (defaultSlot) {
        defaultSlot.dispatchEvent(new Event("slotchange", { bubbles: true }));
      }
    }
    if (removedAttribute[name] === "id" && this[isConnected]) {
      this.#removeIdentifierFromWindow(removedAttribute[value]);
    }
    this[reportMutation](new MutationRecord({
      type: MutationTypeEnum_default.attributes,
      target: this,
      attributeName: removedAttribute[name],
      oldValue: removedAttribute[value]
    }));
  }
  /**
   * @override
   */
  [connectedToDocument]() {
    const id2 = this.getAttribute("id");
    if (id2) {
      this.#addIdentifierToWindow(id2);
    }
    super[connectedToDocument]();
    this[window][customElementReactionStack].enqueueReaction(this, "connectedCallback");
    if (this[shadowRoot]) {
      for (const childNode of this[nodeArray]) {
        this.#onSlotChange(childNode);
      }
    }
  }
  /**
   * @override
   */
  [disconnectedFromDocument]() {
    super[disconnectedFromDocument]();
    const id2 = this.getAttribute("id");
    if (id2) {
      this.#removeIdentifierFromWindow(id2);
    }
    this[window][customElementReactionStack].enqueueReaction(this, "disconnectedCallback");
  }
  /**
   * Adds identifier to the window object.
   *
   * @param id Identifier.
   */
  #addIdentifierToWindow(id2) {
    if (!id2) {
      return;
    }
    const document = this[ownerDocument];
    const window2 = this[window];
    if (this[rootNode] && this[rootNode] !== document) {
      return;
    }
    if (!document[elementIdMap].has(id2)) {
      document[elementIdMap].set(id2, { elements: [], htmlCollection: null });
    }
    const entry = document[elementIdMap].get(id2);
    const element = this[proxy] || this;
    entry.elements.push(element);
    if (entry.elements.length > 1) {
      if (!entry.htmlCollection) {
        entry.htmlCollection = new HTMLCollection(illegalConstructor, () => entry.elements);
      }
      if (!(id2 in window2) || window2[id2] === entry.elements[0]) {
        window2[id2] = entry.htmlCollection;
      }
    } else if (!(id2 in window2) || window2[id2] === entry.htmlCollection) {
      window2[id2] = element;
    }
  }
  /**
   * Removes identifier from the window object.
   *
   * @param id Identifier.
   */
  #removeIdentifierFromWindow(id2) {
    if (!id2) {
      return;
    }
    const document = this[ownerDocument];
    const window2 = this[window];
    if (this[rootNode] && this[rootNode] !== document) {
      return;
    }
    const entry = document[elementIdMap].get(id2);
    if (entry) {
      const element = this[proxy] || this;
      const index = entry.elements.indexOf(element);
      if (index !== -1) {
        entry.elements.splice(index, 1);
      }
      if (entry.elements.length === 1) {
        if (window2[id2] === entry.htmlCollection) {
          window2[id2] = entry.elements[0];
        }
        entry.htmlCollection = null;
      } else if (!entry.elements.length) {
        document[elementIdMap].delete(id2);
        if (window2[id2] === element || window2[id2] === entry.htmlCollection) {
          delete window2[id2];
        }
      }
    }
  }
  /**
   * Triggered when child nodes are changed.
   *
   * @param addedOrRemovedNode Changed node.
   */
  #onSlotChange(addedOrRemovedNode) {
    const shadowRoot2 = this[shadowRoot];
    if (!shadowRoot2 || !this[isConnected]) {
      return;
    }
    const slotName = addedOrRemovedNode["getAttribute"] ? addedOrRemovedNode.getAttribute("slot") : null;
    if (slotName) {
      const slot = shadowRoot2.querySelector(`slot[name="${slotName}"]`);
      if (slot) {
        slot.dispatchEvent(new Event("slotchange", { bubbles: true }));
      }
    } else if (addedOrRemovedNode[nodeType] !== NodeTypeEnum_default.commentNode) {
      const slot = shadowRoot2.querySelector("slot:not([name])");
      if (slot) {
        slot.dispatchEvent(new Event("slotchange", { bubbles: true }));
      }
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-element/HTMLElementUtility.js
var HTMLElementUtility = class {
  /**
   * Triggers a blur event.
   *
   * @param element Element.
   */
  static blur(element) {
    const target2 = element[proxy] || element;
    const document = target2[ownerDocument];
    if (document[activeElement] !== target2 || !target2[isConnected] || target2.disabled) {
      return;
    }
    const relatedTarget = document[nextActiveElement] ?? null;
    document[activeElement] = null;
    document[clearCache]();
    target2.dispatchEvent(new FocusEvent("blur", {
      relatedTarget,
      bubbles: false,
      composed: true,
      cancelable: true
    }));
    target2.dispatchEvent(new FocusEvent("focusout", {
      relatedTarget,
      bubbles: true,
      composed: true,
      cancelable: true
    }));
  }
  /**
   * Triggers a focus event.
   *
   * @param element Element.
   */
  static focus(element) {
    const target2 = element[proxy] || element;
    const document = target2[ownerDocument];
    if (document[activeElement] === target2 || !target2[isConnected] || target2.disabled) {
      return;
    }
    document[nextActiveElement] = target2;
    const relatedTarget = document[activeElement];
    if (document[activeElement] !== null) {
      document[activeElement].blur();
    }
    document[nextActiveElement] = null;
    document[activeElement] = target2;
    document[clearCache]();
    target2.dispatchEvent(new FocusEvent("focus", {
      relatedTarget,
      bubbles: false,
      composed: true
    }));
    target2.dispatchEvent(new FocusEvent("focusin", {
      relatedTarget,
      bubbles: true,
      composed: true
    }));
  }
};

// node_modules/happy-dom/lib/dom/DOMStringMapUtility.js
var DOMStringMapUtility = class {
  /**
   * Transforms a kebab cased string to camel case.
   *
   * @param text Text string.
   * @returns Camel cased string.
   */
  static kebabToCamelCase(text) {
    const parts = text.split("-");
    for (let i = 0, max = parts.length; i < max; i++) {
      parts[i] = i > 0 ? parts[i].charAt(0).toUpperCase() + parts[i].slice(1) : parts[i];
    }
    return parts.join("");
  }
  /**
   * Transforms a camel cased string to kebab case.
   *
   * @param text Text string.
   * @returns Kebab cased string.
   */
  static camelCaseToKebab(text) {
    return text.toString().replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? "-" : "") + $.toLowerCase());
  }
};

// node_modules/happy-dom/lib/dom/DOMStringMap.js
var DOMStringMap = class {
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param element Element.
   */
  constructor(illegalConstructorSymbol, element) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    return new Proxy(this, {
      get(_target, property) {
        const attribute = element.getAttribute("data-" + DOMStringMapUtility.camelCaseToKebab(property));
        if (attribute !== null) {
          return attribute;
        }
      },
      set(_target, property, value2) {
        element.setAttribute("data-" + DOMStringMapUtility.camelCaseToKebab(property), value2);
        return true;
      },
      deleteProperty(_target, property) {
        element.removeAttribute("data-" + DOMStringMapUtility.camelCaseToKebab(property));
        return true;
      },
      ownKeys(_target) {
        const keys = [];
        for (const items2 of element[attributes][itemsByName].values()) {
          if (items2[0][name].startsWith("data-")) {
            keys.push(DOMStringMapUtility.kebabToCamelCase(items2[0][name].replace("data-", "")));
          }
        }
        return keys;
      },
      has(_target, property) {
        return element.hasAttribute("data-" + DOMStringMapUtility.camelCaseToKebab(property));
      },
      defineProperty(_target, property, descriptor) {
        if (descriptor.value === void 0) {
          return false;
        }
        element.setAttribute("data-" + DOMStringMapUtility.camelCaseToKebab(property), descriptor.value);
        return true;
      },
      getOwnPropertyDescriptor(_target, property) {
        const attribute = element.getAttribute("data-" + DOMStringMapUtility.camelCaseToKebab(property));
        if (!attribute) {
          return;
        }
        return {
          value: attribute,
          writable: true,
          enumerable: true,
          configurable: true
        };
      }
    });
  }
};

// node_modules/happy-dom/lib/nodes/html-element/HTMLElement.js
var HTMLElement = class extends Element {
  static observedAttributes;
  // Internal properties
  [accessKey] = "";
  [offsetHeight] = 0;
  [offsetWidth] = 0;
  [offsetLeft] = 0;
  [offsetTop] = 0;
  [clientHeight] = 0;
  [clientWidth] = 0;
  [clientLeft] = 0;
  [clientTop] = 0;
  [style] = null;
  [dataset] = null;
  // Private properties
  #customElementDefineCallback = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get oncancel() {
    return ElementEventAttributeUtility.getEventListener(this, "oncancel");
  }
  set oncancel(value2) {
    this[propertyEventListeners].set("oncancel", value2);
  }
  get onerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onerror");
  }
  set onerror(value2) {
    this[propertyEventListeners].set("onerror", value2);
  }
  get onscroll() {
    return ElementEventAttributeUtility.getEventListener(this, "onscroll");
  }
  set onscroll(value2) {
    this[propertyEventListeners].set("onscroll", value2);
  }
  get onselect() {
    return ElementEventAttributeUtility.getEventListener(this, "onselect");
  }
  set onselect(value2) {
    this[propertyEventListeners].set("onselect", value2);
  }
  get onwheel() {
    return ElementEventAttributeUtility.getEventListener(this, "onwheel");
  }
  set onwheel(value2) {
    this[propertyEventListeners].set("onwheel", value2);
  }
  get oncopy() {
    return ElementEventAttributeUtility.getEventListener(this, "oncopy");
  }
  set oncopy(value2) {
    this[propertyEventListeners].set("oncopy", value2);
  }
  get oncut() {
    return ElementEventAttributeUtility.getEventListener(this, "oncut");
  }
  set oncut(value2) {
    this[propertyEventListeners].set("oncut", value2);
  }
  get onpaste() {
    return ElementEventAttributeUtility.getEventListener(this, "onpaste");
  }
  set onpaste(value2) {
    this[propertyEventListeners].set("onpaste", value2);
  }
  get oncompositionend() {
    return ElementEventAttributeUtility.getEventListener(this, "oncompositionend");
  }
  set oncompositionend(value2) {
    this[propertyEventListeners].set("oncompositionend", value2);
  }
  get oncompositionstart() {
    return ElementEventAttributeUtility.getEventListener(this, "oncompositionstart");
  }
  set oncompositionstart(value2) {
    this[propertyEventListeners].set("oncompositionstart", value2);
  }
  get oncompositionupdate() {
    return ElementEventAttributeUtility.getEventListener(this, "oncompositionupdate");
  }
  set oncompositionupdate(value2) {
    this[propertyEventListeners].set("oncompositionupdate", value2);
  }
  get onblur() {
    return ElementEventAttributeUtility.getEventListener(this, "onblur");
  }
  set onblur(value2) {
    this[propertyEventListeners].set("onblur", value2);
  }
  get onfocus() {
    return ElementEventAttributeUtility.getEventListener(this, "onfocus");
  }
  set onfocus(value2) {
    this[propertyEventListeners].set("onfocus", value2);
  }
  get onfocusin() {
    return ElementEventAttributeUtility.getEventListener(this, "onfocusin");
  }
  set onfocusin(value2) {
    this[propertyEventListeners].set("onfocusin", value2);
  }
  get onfocusout() {
    return ElementEventAttributeUtility.getEventListener(this, "onfocusout");
  }
  set onfocusout(value2) {
    this[propertyEventListeners].set("onfocusout", value2);
  }
  get onkeydown() {
    return ElementEventAttributeUtility.getEventListener(this, "onkeydown");
  }
  set onkeydown(value2) {
    this[propertyEventListeners].set("onkeydown", value2);
  }
  get onkeyup() {
    return ElementEventAttributeUtility.getEventListener(this, "onkeyup");
  }
  set onkeyup(value2) {
    this[propertyEventListeners].set("onkeyup", value2);
  }
  get onauxclick() {
    return ElementEventAttributeUtility.getEventListener(this, "onauxclick");
  }
  set onauxclick(value2) {
    this[propertyEventListeners].set("onauxclick", value2);
  }
  get onclick() {
    return ElementEventAttributeUtility.getEventListener(this, "onclick");
  }
  set onclick(value2) {
    this[propertyEventListeners].set("onclick", value2);
  }
  get oncontextmenu() {
    return ElementEventAttributeUtility.getEventListener(this, "oncontextmenu");
  }
  set oncontextmenu(value2) {
    this[propertyEventListeners].set("oncontextmenu", value2);
  }
  get ondblclick() {
    return ElementEventAttributeUtility.getEventListener(this, "ondblclick");
  }
  set ondblclick(value2) {
    this[propertyEventListeners].set("ondblclick", value2);
  }
  get onmousedown() {
    return ElementEventAttributeUtility.getEventListener(this, "onmousedown");
  }
  set onmousedown(value2) {
    this[propertyEventListeners].set("onmousedown", value2);
  }
  get onmouseenter() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseenter");
  }
  set onmouseenter(value2) {
    this[propertyEventListeners].set("onmouseenter", value2);
  }
  get onmouseleave() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseleave");
  }
  set onmouseleave(value2) {
    this[propertyEventListeners].set("onmouseleave", value2);
  }
  get onmousemove() {
    return ElementEventAttributeUtility.getEventListener(this, "onmousemove");
  }
  set onmousemove(value2) {
    this[propertyEventListeners].set("onmousemove", value2);
  }
  get onmouseout() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseout");
  }
  set onmouseout(value2) {
    this[propertyEventListeners].set("onmouseout", value2);
  }
  get onmouseover() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseover");
  }
  set onmouseover(value2) {
    this[propertyEventListeners].set("onmouseover", value2);
  }
  get onmouseup() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseup");
  }
  set onmouseup(value2) {
    this[propertyEventListeners].set("onmouseup", value2);
  }
  get ontouchcancel() {
    return ElementEventAttributeUtility.getEventListener(this, "ontouchcancel");
  }
  set ontouchcancel(value2) {
    this[propertyEventListeners].set("ontouchcancel", value2);
  }
  get ontouchend() {
    return ElementEventAttributeUtility.getEventListener(this, "ontouchend");
  }
  set ontouchend(value2) {
    this[propertyEventListeners].set("ontouchend", value2);
  }
  get ontouchmove() {
    return ElementEventAttributeUtility.getEventListener(this, "ontouchmove");
  }
  set ontouchmove(value2) {
    this[propertyEventListeners].set("ontouchmove", value2);
  }
  get ontouchstart() {
    return ElementEventAttributeUtility.getEventListener(this, "ontouchstart");
  }
  set ontouchstart(value2) {
    this[propertyEventListeners].set("ontouchstart", value2);
  }
  get oninvalid() {
    return ElementEventAttributeUtility.getEventListener(this, "oninvalid");
  }
  set oninvalid(value2) {
    this[propertyEventListeners].set("oninvalid", value2);
  }
  get onanimationcancel() {
    return ElementEventAttributeUtility.getEventListener(this, "onanimationcancel");
  }
  set onanimationcancel(value2) {
    this[propertyEventListeners].set("onanimationcancel", value2);
  }
  get onanimationend() {
    return ElementEventAttributeUtility.getEventListener(this, "onanimationend");
  }
  set onanimationend(value2) {
    this[propertyEventListeners].set("onanimationend", value2);
  }
  get onanimationiteration() {
    return ElementEventAttributeUtility.getEventListener(this, "onanimationiteration");
  }
  set onanimationiteration(value2) {
    this[propertyEventListeners].set("onanimationiteration", value2);
  }
  get onanimationstart() {
    return ElementEventAttributeUtility.getEventListener(this, "onanimationstart");
  }
  set onanimationstart(value2) {
    this[propertyEventListeners].set("onanimationstart", value2);
  }
  get onbeforeinput() {
    return ElementEventAttributeUtility.getEventListener(this, "onbeforeinput");
  }
  set onbeforeinput(value2) {
    this[propertyEventListeners].set("onbeforeinput", value2);
  }
  get oninput() {
    return ElementEventAttributeUtility.getEventListener(this, "oninput");
  }
  set oninput(value2) {
    this[propertyEventListeners].set("oninput", value2);
  }
  get onchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onchange");
  }
  set onchange(value2) {
    this[propertyEventListeners].set("onchange", value2);
  }
  get ongotpointercapture() {
    return ElementEventAttributeUtility.getEventListener(this, "ongotpointercapture");
  }
  set ongotpointercapture(value2) {
    this[propertyEventListeners].set("ongotpointercapture", value2);
  }
  get onlostpointercapture() {
    return ElementEventAttributeUtility.getEventListener(this, "onlostpointercapture");
  }
  set onlostpointercapture(value2) {
    this[propertyEventListeners].set("onlostpointercapture", value2);
  }
  get onpointercancel() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointercancel");
  }
  set onpointercancel(value2) {
    this[propertyEventListeners].set("onpointercancel", value2);
  }
  get onpointerdown() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerdown");
  }
  set onpointerdown(value2) {
    this[propertyEventListeners].set("onpointerdown", value2);
  }
  get onpointerenter() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerenter");
  }
  set onpointerenter(value2) {
    this[propertyEventListeners].set("onpointerenter", value2);
  }
  get onpointerleave() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerleave");
  }
  set onpointerleave(value2) {
    this[propertyEventListeners].set("onpointerleave", value2);
  }
  get onpointermove() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointermove");
  }
  set onpointermove(value2) {
    this[propertyEventListeners].set("onpointermove", value2);
  }
  get onpointerout() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerout");
  }
  set onpointerout(value2) {
    this[propertyEventListeners].set("onpointerout", value2);
  }
  get onpointerover() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerover");
  }
  set onpointerover(value2) {
    this[propertyEventListeners].set("onpointerover", value2);
  }
  get onpointerup() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerup");
  }
  set onpointerup(value2) {
    this[propertyEventListeners].set("onpointerup", value2);
  }
  get ontransitioncancel() {
    return ElementEventAttributeUtility.getEventListener(this, "ontransitioncancel");
  }
  set ontransitioncancel(value2) {
    this[propertyEventListeners].set("ontransitioncancel", value2);
  }
  get ontransitionend() {
    return ElementEventAttributeUtility.getEventListener(this, "ontransitionend");
  }
  set ontransitionend(value2) {
    this[propertyEventListeners].set("ontransitionend", value2);
  }
  get ontransitionrun() {
    return ElementEventAttributeUtility.getEventListener(this, "ontransitionrun");
  }
  set ontransitionrun(value2) {
    this[propertyEventListeners].set("ontransitionrun", value2);
  }
  get ontransitionstart() {
    return ElementEventAttributeUtility.getEventListener(this, "ontransitionstart");
  }
  set ontransitionstart(value2) {
    this[propertyEventListeners].set("ontransitionstart", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns access key.
   *
   * @returns Access key.
   */
  get accessKey() {
    return this[accessKey];
  }
  /**
   * Sets access key.
   *
   * @param accessKey Access key.
   */
  set accessKey(accessKey2) {
    this[accessKey] = accessKey2;
  }
  /**
   * Returns content editable.
   *
   * @returns Content editable.
   */
  get contentEditable() {
    const contentEditable = String(this.getAttribute("contentEditable")).toLowerCase();
    switch (contentEditable) {
      case "false":
      case "true":
      case "plaintext-only":
        return contentEditable;
      default:
        return "inherit";
    }
  }
  /**
   * Sets content editable.
   *
   * @param contentEditable Content editable.
   */
  set contentEditable(contentEditable) {
    contentEditable = String(contentEditable).toLowerCase();
    switch (contentEditable) {
      case "false":
      case "true":
      case "plaintext-only":
      case "inherit":
        this.setAttribute("contentEditable", contentEditable);
        break;
      default:
        throw new this[window].SyntaxError(`Failed to set the 'contentEditable' property on 'HTMLElement': The value provided ('${contentEditable}') is not one of 'true', 'false', 'plaintext-only', or 'inherit'.`);
    }
  }
  /**
   * Returns is content editable.
   *
   * @returns Is content editable.
   */
  get isContentEditable() {
    const contentEditable = this.contentEditable;
    if (contentEditable === "true" || contentEditable === "plaintext-only") {
      return true;
    }
    if (contentEditable === "inherit") {
      return this[parentNode]?.isContentEditable ?? false;
    }
    return false;
  }
  /**
   * Returns offset height.
   *
   * @returns Offset height.
   */
  get offsetHeight() {
    return this[offsetHeight];
  }
  /**
   * Returns offset width.
   *
   * @returns Offset width.
   */
  get offsetWidth() {
    return this[offsetWidth];
  }
  /**
   * Returns offset left.
   *
   * @returns Offset left.
   */
  get offsetLeft() {
    return this[offsetLeft];
  }
  /**
   * Returns offset top.
   *
   * @returns Offset top.
   */
  get offsetTop() {
    return this[offsetTop];
  }
  /**
   * Returns client height.
   *
   * @returns Client height.
   */
  get clientHeight() {
    return this[clientHeight];
  }
  /**
   * Returns client width.
   *
   * @returns Client width.
   */
  get clientWidth() {
    return this[clientWidth];
  }
  /**
   * Returns client left.
   *
   * @returns Client left.
   */
  get clientLeft() {
    return this[clientLeft];
  }
  /**
   * Returns client top.
   *
   * @returns Client top.
   */
  get clientTop() {
    return this[clientTop];
  }
  /**
   * Returns tab index.
   *
   * @returns Tab index.
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? -1 : parsed;
    }
    return -1;
  }
  /**
   * Returns tab index.
   *
   * @param tabIndex Tab index.
   */
  set tabIndex(tabIndex) {
    const parsed = Number(tabIndex);
    if (isNaN(parsed)) {
      this.setAttribute("tabindex", "0");
    } else {
      this.setAttribute("tabindex", String(parsed));
    }
  }
  /**
   * Returns inner text, which is the rendered appearance of text.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#the-innertext-idl-attribute
   * @returns Inner text.
   */
  get innerText() {
    if (!this[isConnected]) {
      return this.textContent;
    }
    let result2 = "";
    for (const childNode of this[nodeArray]) {
      if (childNode[nodeType] === NodeTypeEnum_default.elementNode) {
        const childElement = childNode;
        const computedStyle2 = this[window].getComputedStyle(childElement);
        if (childElement[tagName] !== "SCRIPT" && childElement[tagName] !== "STYLE" && childElement[tagName] !== "svg") {
          const display = computedStyle2.display;
          if (display !== "none") {
            const textTransform = computedStyle2.textTransform;
            const innerText = childElement.innerText;
            if ((display === "block" || display === "flex") && result2 && innerText) {
              result2 += "\n";
            }
            let text = innerText;
            switch (textTransform) {
              case "uppercase":
                text = text.toUpperCase();
                break;
              case "lowercase":
                text = text.toLowerCase();
                break;
              case "capitalize":
                text = text.replace(/(^|\s)\S/g, (l) => l.toUpperCase());
                break;
            }
            result2 += text;
          }
        }
      } else if (childNode[nodeType] === NodeTypeEnum_default.textNode) {
        result2 += childNode.textContent.replace(/[\n\r]/, "");
      }
    }
    return result2;
  }
  /**
   * Sets the inner text, which is the rendered appearance of text.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#the-innertext-idl-attribute
   * @param innerText Inner text.
   */
  set innerText(text) {
    const childNodes2 = this[nodeArray];
    while (childNodes2.length) {
      this.removeChild(childNodes2[0]);
    }
    const texts = text.split(/[\n\r]/);
    const ownerDocument2 = this[ownerDocument];
    for (let i = 0, max = texts.length; i < max; i++) {
      if (i !== 0) {
        this.appendChild(ownerDocument2.createElement("br"));
      }
      this.appendChild(ownerDocument2.createTextNode(texts[i]));
    }
  }
  /**
   * Returns outer text.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#the-innertext-idl-attribute
   * @returns HTML.
   */
  get outerText() {
    return this.innerText;
  }
  /**
   * Sets outer text.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#the-innertext-idl-attribute
   * @param text Text.
   */
  set outerText(text) {
    if (!this[parentNode]) {
      throw new this[window].DOMException("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");
    }
    const texts = text.split(/[\n\r]/);
    for (let i = 0, max = texts.length; i < max; i++) {
      if (i !== 0) {
        this[parentNode].insertBefore(this[ownerDocument].createElement("br"), this);
      }
      this[parentNode].insertBefore(this[ownerDocument].createTextNode(texts[i]), this);
    }
    this[parentNode].removeChild(this);
  }
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!this[style]) {
      this[style] = new CSSStyleDeclaration(illegalConstructor, this[window], { element: this });
    }
    return this[style];
  }
  /**
   * Sets style.
   *
   * @param cssText Style as text.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style#setting_styles
   */
  set style(cssText2) {
    this.style.cssText = typeof cssText2 === "string" ? cssText2 : "";
  }
  /**
   * Returns data set.
   *
   * @returns Data set.
   */
  get dataset() {
    return this[dataset] ??= new DOMStringMap(illegalConstructor, this);
  }
  /**
   * Returns direction.
   *
   * @returns Direction.
   */
  get dir() {
    return this.getAttribute("dir") || "";
  }
  /**
   * Returns direction.
   *
   * @param direction Direction.
   */
  set dir(direction) {
    this.setAttribute("dir", direction);
  }
  /**
   * Returns hidden.
   *
   * @returns Hidden.
   */
  get hidden() {
    return this.getAttribute("hidden") !== null;
  }
  /**
   * Returns hidden.
   *
   * @param hidden Hidden.
   */
  set hidden(hidden) {
    if (!hidden) {
      this.removeAttribute("hidden");
    } else {
      this.setAttribute("hidden", "");
    }
  }
  /**
   * Returns inert.
   *
   * @returns Inert.
   */
  get inert() {
    return this.getAttribute("inert") !== null;
  }
  /**
   * Returns inert.
   *
   * @param inert Inert.
   */
  set inert(inert) {
    if (!inert) {
      this.removeAttribute("inert");
    } else {
      this.setAttribute("inert", "");
    }
  }
  /**
   * Returns language.
   *
   * @returns Language.
   */
  get lang() {
    return this.getAttribute("lang") || "";
  }
  /**
   * Returns language.
   *
   * @param language Language.
   */
  set lang(lang) {
    this.setAttribute("lang", lang);
  }
  /**
   * Returns title.
   *
   * @returns Title.
   */
  get title() {
    return this.getAttribute("title") || "";
  }
  /**
   * Returns title.
   *
   * @param title Title.
   */
  set title(title) {
    this.setAttribute("title", title);
  }
  /**
   * Returns popover.
   *
   * @returns Popover.
   */
  get popover() {
    const value2 = this.getAttribute("popover");
    switch (value2) {
      case null:
        return null;
      case "":
      case "auto":
        return "auto";
      case "manual":
        return "manual";
      default:
        return "manual";
    }
  }
  /**
   * Sets popover.
   *
   * @param value Value.
   */
  set popover(value2) {
    if (value2 === null) {
      this.removeAttribute("popover");
      return;
    }
    this.setAttribute("popover", value2);
  }
  /**
   * Triggers a click event.
   */
  click() {
    this.dispatchEvent(new PointerEvent("click", {
      bubbles: true,
      composed: true,
      cancelable: true
    }));
  }
  /**
   * Triggers a blur event.
   */
  blur() {
    HTMLElementUtility.blur(this);
  }
  /**
   * Triggers a focus event.
   */
  focus() {
    HTMLElementUtility.focus(this);
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[accessKey] = this[accessKey];
    return clone2;
  }
  /**
   * @override
   * @see https://html.spec.whatwg.org/multipage/dom.html#htmlelement
   */
  [connectedToNode]() {
    const window2 = this[window];
    const localName2 = this[localName];
    const allCallbacks = window2.customElements[callbacks];
    if (this.constructor === window2.HTMLElement && localName2.includes("-") && allCallbacks) {
      if (!this.#customElementDefineCallback) {
        const callback = this.#onCustomElementConnected.bind(this);
        const callbacks2 = allCallbacks.get(localName2);
        if (callbacks2) {
          callbacks2.unshift(callback);
        } else {
          allCallbacks.set(localName2, [callback]);
        }
        this.#customElementDefineCallback = callback;
      }
    }
    super[connectedToNode]();
  }
  /**
   * @override
   */
  [disconnectedFromNode]() {
    const window2 = this[window];
    const localName2 = this[localName];
    const allCallbacks = window2.customElements[callbacks];
    if (this.constructor === window2.HTMLElement && localName2.includes("-") && allCallbacks) {
      const callbacks2 = allCallbacks.get(localName2);
      if (callbacks2 && this.#customElementDefineCallback) {
        const index = callbacks2.indexOf(this.#customElementDefineCallback);
        if (index !== -1) {
          callbacks2.splice(index, 1);
        }
        if (!callbacks2.length) {
          allCallbacks.delete(localName2);
        }
        this.#customElementDefineCallback = null;
      }
    }
    super[disconnectedFromNode]();
  }
  /**
   * @override
   */
  [onSetAttribute](attribute, replacedAttribute) {
    super[onSetAttribute](attribute, replacedAttribute);
    this[window][customElementReactionStack].enqueueReaction(this, "attributeChangedCallback", [attribute.name, replacedAttribute?.value ?? null, attribute.value]);
  }
  /**
   * @override
   */
  [onRemoveAttribute](removedAttribute) {
    super[onRemoveAttribute](removedAttribute);
    this[window][customElementReactionStack].enqueueReaction(this, "attributeChangedCallback", [removedAttribute.name, removedAttribute.value, null]);
  }
  /**
   * Triggered when a custom element is connected to the DOM.
   */
  #onCustomElementConnected() {
    if (!this[parentNode]) {
      return;
    }
    const window2 = this[window];
    const localName2 = this[localName];
    const newElement = this[ownerDocument].createElement(localName2);
    const newCache = newElement[cache];
    newElement[nodeArray] = this[nodeArray];
    newElement[elementArray] = this[elementArray];
    newElement[childNodes] = null;
    newElement[children] = null;
    newElement[isConnected] = this[isConnected];
    newElement[rootNode] = this[rootNode];
    newElement[formNode] = this[formNode];
    newElement[parentNode] = this[parentNode];
    newElement[selectNode] = this[selectNode];
    newElement[textAreaNode] = this[textAreaNode];
    newElement[mutationListeners] = this[mutationListeners];
    newElement[isValue] = this[isValue];
    newElement[cache] = this[cache];
    newElement[affectsCache] = this[affectsCache];
    newElement[attributes][itemsByNamespaceURI] = this[attributes][itemsByNamespaceURI];
    newElement[attributes][itemsByName] = this[attributes][itemsByName];
    newElement[attributes][items] = this[attributes][items];
    for (const attr of newElement[attributes][items].values()) {
      attr[ownerElement] = newElement;
    }
    this[clearCache]();
    this[nodeArray] = [];
    this[elementArray] = [];
    this[childNodes] = null;
    this[children] = null;
    this[parentNode] = null;
    this[rootNode] = null;
    this[formNode] = null;
    this[selectNode] = null;
    this[textAreaNode] = null;
    this[mutationListeners] = [];
    this[isValue] = null;
    this[cache] = newCache;
    this[affectsCache] = [];
    this[attributes][itemsByNamespaceURI] = /* @__PURE__ */ new Map();
    this[attributes][itemsByName] = /* @__PURE__ */ new Map();
    this[attributes][items] = /* @__PURE__ */ new Map();
    for (const node of newElement[nodeArray]) {
      node[parentNode] = newElement;
    }
    const parentChildNodes = newElement[parentNode][nodeArray];
    const parentChildElements = newElement[parentNode][elementArray];
    parentChildNodes[parentChildNodes.indexOf(this)] = newElement;
    parentChildElements[parentChildElements.indexOf(this)] = newElement;
    const allCallbacks = window2.customElements[callbacks];
    const callbacks2 = allCallbacks.get(localName2);
    if (callbacks2 && this.#customElementDefineCallback) {
      const index = callbacks2.indexOf(this.#customElementDefineCallback);
      if (index !== -1) {
        callbacks2.splice(index, 1);
      }
      if (!callbacks2.length) {
        allCallbacks.delete(localName2);
      }
      this.#customElementDefineCallback = null;
    }
    if (newElement[isConnected]) {
      if (newElement[shadowRoot]) {
        newElement[shadowRoot][isConnected] = true;
      }
      newElement[connectedToDocument]();
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-hyperlink-element/HTMLHyperlinkElementUtility.js
var HTMLHyperlinkElementUtility = class {
  element;
  /**
   * Constructor.
   *
   * @param element Element.
   */
  constructor(element) {
    this.element = element;
  }
  /**
   * Returns the hyperlink's URL's origin.
   *
   * @returns Origin.
   */
  getOrigin() {
    try {
      return new URL(this.getHref()).origin;
    } catch (e) {
      return "";
    }
  }
  /**
   * Returns href.
   *
   * @returns Href.
   */
  getHref() {
    if (!this.element.hasAttribute("href")) {
      return "";
    }
    try {
      return new URL(this.element.getAttribute("href"), this.element[ownerDocument].location.href).href;
    } catch (e) {
      return this.element.getAttribute("href");
    }
  }
  /**
   * Sets href.
   *
   * @param href Href.
   */
  setHref(href2) {
    this.element.setAttribute("href", href2);
  }
  /**
   * Returns protocol.
   *
   * @returns Protocol.
   */
  getProtocol() {
    try {
      return new URL(this.getHref()).protocol;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets protocol.
   *
   * @param protocol Protocol.
   */
  setProtocol(protocol) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.protocol = protocol;
    this.element.setAttribute("href", url2.href);
  }
  /**
   * Returns username.
   *
   * @returns Username.
   */
  getUsername() {
    try {
      return new URL(this.getHref()).username;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets username.
   *
   * @param username Username.
   */
  setUsername(username) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.username = username;
    this.element.setAttribute("href", url2.href);
  }
  /**
   * Returns password.
   *
   * @returns Password.
   */
  getPassword() {
    try {
      return new URL(this.getHref()).password;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets password.
   *
   * @param password Password.
   */
  setPassword(password) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.password = password;
    this.element.setAttribute("href", url2.href);
  }
  /**
   * Returns host.
   *
   * @returns Host.
   */
  getHost() {
    try {
      return new URL(this.getHref()).host;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets host.
   *
   * @param host Host.
   */
  setHost(host2) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.host = host2;
    this.element.setAttribute("href", url2.href);
  }
  /**
   * Returns hostname.
   *
   * @returns Hostname.
   */
  getHostname() {
    try {
      return new URL(this.getHref()).hostname;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets hostname.
   *
   * @param hostname Hostname.
   */
  setHostname(hostname) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.hostname = hostname;
    this.element.setAttribute("href", url2.href);
  }
  /**
   * Returns port.
   *
   * @returns Port.
   */
  getPort() {
    try {
      return new URL(this.getHref()).port;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets port.
   *
   * @param port Port.
   */
  setPort(port) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.port = port;
    this.element.setAttribute("href", url2.href);
  }
  /**
   * Returns pathname.
   *
   * @returns Pathname.
   */
  getPathname() {
    try {
      return new URL(this.getHref()).pathname;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets pathname.
   *
   * @param pathname Pathname.
   */
  setPathname(pathname) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.pathname = pathname;
    this.element.setAttribute("href", url2.href);
  }
  /**
   * Returns search.
   *
   * @returns Search.
   */
  getSearch() {
    try {
      return new URL(this.getHref()).search;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets search.
   *
   * @param search Search.
   */
  setSearch(search) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.search = search;
    this.element.setAttribute("href", url2.href);
  }
  /**
   * Returns hash.
   *
   * @returns Hash.
   */
  getHash() {
    const href2 = this.element.getAttribute("href");
    if (href2[0] === "#") {
      return href2;
    }
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return "";
    }
    return url2.hash;
  }
  /**
   * Sets hash.
   *
   * @param hash Hash.
   */
  setHash(hash) {
    let url2;
    try {
      url2 = new URL(this.getHref());
    } catch (e) {
      return;
    }
    url2.hash = hash;
    this.element.setAttribute("href", url2.href);
  }
};

// node_modules/happy-dom/lib/nodes/html-anchor-element/HTMLAnchorElement.js
var HTMLAnchorElement = class extends HTMLElement {
  [relList] = null;
  #htmlHyperlinkElementUtility = new HTMLHyperlinkElementUtility(this);
  /**
   * Returns download.
   *
   * @returns download.
   */
  get download() {
    return this.getAttribute("download") || "";
  }
  /**
   * Sets download.
   *
   * @param download Download.
   */
  set download(download) {
    this.setAttribute("download", download);
  }
  /**
   * Returns hash.
   *
   * @returns Hash.
   */
  get hash() {
    return this.#htmlHyperlinkElementUtility.getHash();
  }
  /**
   * Sets hash.
   *
   * @param hash Hash.
   */
  set hash(hash) {
    this.#htmlHyperlinkElementUtility.setHash(hash);
  }
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    return this.#htmlHyperlinkElementUtility.getHref();
  }
  /**
   * Sets href.
   *
   * @param href Href.
   */
  set href(href2) {
    this.#htmlHyperlinkElementUtility.setHref(href2);
  }
  /**
   * Returns hreflang.
   *
   * @returns Hreflang.
   */
  get hreflang() {
    return this.getAttribute("hreflang") || "";
  }
  /**
   * Sets hreflang.
   *
   * @param hreflang Hreflang.
   */
  set hreflang(hreflang) {
    this.setAttribute("hreflang", hreflang);
  }
  /**
   * Returns the hyperlink's URL's origin.
   *
   * @returns Origin.
   */
  get origin() {
    return this.#htmlHyperlinkElementUtility.getOrigin();
  }
  /**
   * Returns ping.
   *
   * @returns Ping.
   */
  get ping() {
    return this.getAttribute("ping") || "";
  }
  /**
   * Sets ping.
   *
   * @param ping Ping.
   */
  set ping(ping) {
    this.setAttribute("ping", ping);
  }
  /**
   * Returns protocol.
   *
   * @returns Protocol.
   */
  get protocol() {
    return this.#htmlHyperlinkElementUtility.getProtocol();
  }
  /**
   * Sets protocol.
   *
   * @param protocol Protocol.
   */
  set protocol(protocol) {
    this.#htmlHyperlinkElementUtility.setProtocol(protocol);
  }
  /**
   * Returns username.
   *
   * @returns Username.
   */
  get username() {
    return this.#htmlHyperlinkElementUtility.getUsername();
  }
  /**
   * Sets username.
   *
   * @param username Username.
   */
  set username(username) {
    this.#htmlHyperlinkElementUtility.setUsername(username);
  }
  /**
   * Returns password.
   *
   * @returns Password.
   */
  get password() {
    return this.#htmlHyperlinkElementUtility.getPassword();
  }
  /**
   * Sets password.
   *
   * @param password Password.
   */
  set password(password) {
    this.#htmlHyperlinkElementUtility.setPassword(password);
  }
  /**
   * Returns pathname.
   *
   * @returns Pathname.
   */
  get pathname() {
    return this.#htmlHyperlinkElementUtility.getPathname();
  }
  /**
   * Sets pathname.
   *
   * @param pathname Pathname.
   */
  set pathname(pathname) {
    this.#htmlHyperlinkElementUtility.setPathname(pathname);
  }
  /**
   * Returns port.
   *
   * @returns Port.
   */
  get port() {
    return this.#htmlHyperlinkElementUtility.getPort();
  }
  /**
   * Sets port.
   *
   * @param port Port.
   */
  set port(port) {
    this.#htmlHyperlinkElementUtility.setPort(port);
  }
  /**
   * Returns host.
   *
   * @returns Host.
   */
  get host() {
    return this.#htmlHyperlinkElementUtility.getHost();
  }
  /**
   * Sets host.
   *
   * @param host Host.
   */
  set host(host2) {
    this.#htmlHyperlinkElementUtility.setHost(host2);
  }
  /**
   * Returns hostname.
   *
   * @returns Hostname.
   */
  get hostname() {
    return this.#htmlHyperlinkElementUtility.getHostname();
  }
  /**
   * Sets hostname.
   *
   * @param hostname Hostname.
   */
  set hostname(hostname) {
    this.#htmlHyperlinkElementUtility.setHostname(hostname);
  }
  /**
   * Returns referrerPolicy.
   *
   * @returns Referrer Policy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerPolicy") || "";
  }
  /**
   * Sets referrerPolicy.
   *
   * @param referrerPolicy Referrer Policy.
   */
  set referrerPolicy(referrerPolicy2) {
    this.setAttribute("referrerPolicy", referrerPolicy2);
  }
  /**
   * Returns rel.
   *
   * @returns Rel.
   */
  get rel() {
    return this.getAttribute("rel") || "";
  }
  /**
   * Sets rel.
   *
   * @param rel Rel.
   */
  set rel(rel) {
    this.setAttribute("rel", rel);
  }
  /**
   * Returns rel list.
   *
   * @returns Rel list.
   */
  get relList() {
    if (!this[relList]) {
      this[relList] = new DOMTokenList(illegalConstructor, this, "rel");
    }
    return this[relList];
  }
  /**
   * Sets rel list.
   *
   * @param value Value.
   */
  set relList(value2) {
    this.setAttribute("rel", value2);
  }
  /**
   * Returns search.
   *
   * @returns Search.
   */
  get search() {
    return this.#htmlHyperlinkElementUtility.getSearch();
  }
  /**
   * Sets search.
   *
   * @param search Search.
   */
  set search(search) {
    this.#htmlHyperlinkElementUtility.setSearch(search);
  }
  /**
   * Returns target.
   *
   * @returns target.
   */
  get target() {
    return this.getAttribute("target") || "";
  }
  /**
   * Sets target.
   *
   * @param target Target.
   */
  set target(target2) {
    this.setAttribute("target", target2);
  }
  /**
   * Returns text.
   *
   * @returns text.
   */
  get text() {
    return this.textContent;
  }
  /**
   * Sets text.
   *
   * @param text Text.
   */
  set text(text) {
    this.textContent = text;
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * @override
   */
  toString() {
    return this.href;
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    const returnValue2 = super.dispatchEvent(event);
    if (!event[defaultPrevented] && event.type === "click" && event instanceof MouseEvent && (event.eventPhase === EventPhaseEnum_default.none || event.eventPhase === EventPhaseEnum_default.bubbling)) {
      const href2 = this.href;
      if (href2) {
        const features = [];
        if (this.relList.contains("noreferrer")) {
          features.push("noreferrer");
        }
        if (this.relList.contains("noopener")) {
          features.push("noopener");
        }
        this[window].open(href2, this.target || "_self", features.join(","));
        if (this[window].closed) {
          event.stopImmediatePropagation();
        }
      }
    }
    return returnValue2;
  }
};

// node_modules/happy-dom/lib/nodes/html-area-element/HTMLAreaElement.js
var HTMLAreaElement = class extends HTMLElement {
  [relList] = null;
  #htmlHyperlinkElementUtility = new HTMLHyperlinkElementUtility(this);
  /**
   * Returns alt.
   *
   * @returns Alt.
   */
  get alt() {
    return this.getAttribute("alt") || "";
  }
  /**
   * Sets alt.
   *
   * @param alt Alt.
   */
  set alt(alt) {
    this.setAttribute("alt", alt);
  }
  /**
   * Returns coords.
   *
   * @returns Coords.
   */
  get coords() {
    return this.getAttribute("coords") || "";
  }
  /**
   * Sets coords.
   *
   * @param coords Coords.
   */
  set coords(coords) {
    this.setAttribute("coords", coords);
  }
  /**
   * Returns shape.
   *
   * @returns Shape.
   */
  get shape() {
    return this.getAttribute("shape") || "";
  }
  /**
   * Sets shape.
   *
   * @param shape Shape.
   */
  set shape(shape) {
    this.setAttribute("shape", shape);
  }
  /**
   * Returns download.
   *
   * @returns download.
   */
  get download() {
    return this.getAttribute("download") || "";
  }
  /**
   * Sets download.
   *
   * @param download Download.
   */
  set download(download) {
    this.setAttribute("download", download);
  }
  /**
   * Returns referrerPolicy.
   *
   * @returns Referrer Policy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerPolicy") || "";
  }
  /**
   * Sets referrerPolicy.
   *
   * @param referrerPolicy Referrer Policy.
   */
  set referrerPolicy(referrerPolicy2) {
    this.setAttribute("referrerPolicy", referrerPolicy2);
  }
  /**
   * Returns ping.
   *
   * @returns Ping.
   */
  get ping() {
    return this.getAttribute("ping") || "";
  }
  /**
   * Sets ping.
   *
   * @param ping Ping.
   */
  set ping(ping) {
    this.setAttribute("ping", ping);
  }
  /**
   * Returns rel.
   *
   * @returns Rel.
   */
  get rel() {
    return this.getAttribute("rel") || "";
  }
  /**
   * Sets rel.
   *
   * @param rel Rel.
   */
  set rel(rel) {
    this.setAttribute("rel", rel);
  }
  /**
   * Returns rel list.
   *
   * @returns Rel list.
   */
  get relList() {
    if (!this[relList]) {
      this[relList] = new DOMTokenList(illegalConstructor, this, "rel");
    }
    return this[relList];
  }
  /**
   * Sets rel list.
   *
   * @param value Value.
   */
  set relList(value2) {
    this.setAttribute("rel", value2);
  }
  /**
   * Returns target.
   *
   * @returns target.
   */
  get target() {
    return this.getAttribute("target") || "";
  }
  /**
   * Sets target.
   *
   * @param target Target.
   */
  set target(target2) {
    this.setAttribute("target", target2);
  }
  /**
   * Returns the hyperlink's URL's origin.
   *
   * @returns Origin.
   */
  get origin() {
    return this.#htmlHyperlinkElementUtility.getOrigin();
  }
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    return this.#htmlHyperlinkElementUtility.getHref();
  }
  /**
   * Sets href.
   *
   * @param href Href.
   */
  set href(href2) {
    this.#htmlHyperlinkElementUtility.setHref(href2);
  }
  /**
   * Returns protocol.
   *
   * @returns Protocol.
   */
  get protocol() {
    return this.#htmlHyperlinkElementUtility.getProtocol();
  }
  /**
   * Sets protocol.
   *
   * @param protocol Protocol.
   */
  set protocol(protocol) {
    this.#htmlHyperlinkElementUtility.setProtocol(protocol);
  }
  /**
   * Returns username.
   *
   * @returns Username.
   */
  get username() {
    return this.#htmlHyperlinkElementUtility.getUsername();
  }
  /**
   * Sets username.
   *
   * @param username Username.
   */
  set username(username) {
    this.#htmlHyperlinkElementUtility.setUsername(username);
  }
  /**
   * Returns password.
   *
   * @returns Password.
   */
  get password() {
    return this.#htmlHyperlinkElementUtility.getPassword();
  }
  /**
   * Sets password.
   *
   * @param password Password.
   */
  set password(password) {
    this.#htmlHyperlinkElementUtility.setPassword(password);
  }
  /**
   * Returns host.
   *
   * @returns Host.
   */
  get host() {
    return this.#htmlHyperlinkElementUtility.getHost();
  }
  /**
   * Sets host.
   *
   * @param host Host.
   */
  set host(host2) {
    this.#htmlHyperlinkElementUtility.setHost(host2);
  }
  /**
   * Returns hostname.
   *
   * @returns Hostname.
   */
  get hostname() {
    return this.#htmlHyperlinkElementUtility.getHostname();
  }
  /**
   * Sets hostname.
   *
   * @param hostname Hostname.
   */
  set hostname(hostname) {
    this.#htmlHyperlinkElementUtility.setHostname(hostname);
  }
  /**
   * Returns port.
   *
   * @returns Port.
   */
  get port() {
    return this.#htmlHyperlinkElementUtility.getPort();
  }
  /**
   * Sets port.
   *
   * @param port Port.
   */
  set port(port) {
    this.#htmlHyperlinkElementUtility.setPort(port);
  }
  /**
   * Returns pathname.
   *
   * @returns Pathname.
   */
  get pathname() {
    return this.#htmlHyperlinkElementUtility.getPathname();
  }
  /**
   * Sets pathname.
   *
   * @param pathname Pathname.
   */
  set pathname(pathname) {
    this.#htmlHyperlinkElementUtility.setPathname(pathname);
  }
  /**
   * Returns search.
   *
   * @returns Search.
   */
  get search() {
    return this.#htmlHyperlinkElementUtility.getSearch();
  }
  /**
   * Sets search.
   *
   * @param search Search.
   */
  set search(search) {
    this.#htmlHyperlinkElementUtility.setSearch(search);
  }
  /**
   * Returns hash.
   *
   * @returns Hash.
   */
  get hash() {
    return this.#htmlHyperlinkElementUtility.getHash();
  }
  /**
   * Sets hash.
   *
   * @param hash Hash.
   */
  set hash(hash) {
    this.#htmlHyperlinkElementUtility.setHash(hash);
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * @override
   */
  toString() {
    return this.href;
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    const returnValue2 = super.dispatchEvent(event);
    if (!event[defaultPrevented] && event[type] === "click" && event[eventPhase] === EventPhaseEnum_default.none && event instanceof MouseEvent) {
      const href2 = this.href;
      if (href2) {
        this[window].open(href2, this.target || "_self");
        if (this[window].closed) {
          event.stopImmediatePropagation();
        }
      }
    }
    return returnValue2;
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/TimeRanges.js
var TimeRanges = class {
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   */
  constructor(illegalConstructorSymbol) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
  }
  /**
   * Returns length.
   */
  get length() {
    return 0;
  }
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [Symbol.toStringTag]() {
    return "TimeRanges";
  }
  /**
   * Returns `[object NodeList]`.
   *
   * @returns `[object NodeList]`.
   */
  toLocaleString() {
    return "[object TimeRanges]";
  }
  /**
   * Returns `[object NodeList]`.
   *
   * @returns `[object NodeList]`.
   */
  toString() {
    return "[object TimeRanges]";
  }
  /**
   * Returns start.
   *
   * @param _index Index.
   * @returns Start.
   */
  start(_index) {
    return 0;
  }
  /**
   * Returns end.
   *
   * @param _index Index.
   * @returns End.
   */
  end(_index) {
    return 0;
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/MediaStream.js
import Crypto from "crypto";

// node_modules/happy-dom/lib/event/events/MediaStreamTrackEvent.js
var MediaStreamTrackEvent = class extends Event {
  track;
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type2, eventInit = null) {
    super(type2, eventInit);
    this.track = eventInit?.track ?? null;
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/MediaStream.js
var MediaStream = class _MediaStream extends EventTarget {
  // Public properties
  active = true;
  id = Crypto.randomUUID();
  // Events
  onaddtrack = null;
  onremovetrack = null;
  // Internal properties
  [tracks] = [];
  /**
   * Constructor.
   *
   * @param [streamOrTracks] Stream or tracks.
   */
  constructor(streamOrTracks) {
    super();
    if (!this[window]) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
    if (streamOrTracks !== void 0) {
      this[tracks] = streamOrTracks instanceof _MediaStream ? streamOrTracks[tracks].slice() : streamOrTracks;
    }
  }
  /**
   * Adds a track.
   *
   * @param track Track.
   */
  addTrack(track2) {
    if (this[tracks].includes(track2)) {
      return;
    }
    this[tracks].push(track2);
    this.dispatchEvent(new MediaStreamTrackEvent("addtrack", { track: track2 }));
  }
  /**
   * Returns a clone.
   *
   * @returns Clone.
   */
  clone() {
    return new this.constructor(this);
  }
  /**
   * Returns audio tracks.
   *
   * @returns Audio tracks.
   */
  getAudioTracks() {
    return this[tracks].filter((track2) => track2.kind === "audio");
  }
  /**
   * Returns track by id.
   *
   * @param id Id.
   * @returns Track.
   */
  getTrackById(id2) {
    for (const track2 of this[tracks]) {
      if (track2.id === id2) {
        return track2;
      }
    }
    return null;
  }
  /**
   * Returns video tracks.
   *
   * @returns Video tracks.
   */
  getVideoTracks() {
    return this[tracks].filter((track2) => track2.kind === "video");
  }
  /**
   * Removes a track.
   *
   * @param track Track.
   */
  removeTrack(track2) {
    const index = this[tracks].indexOf(track2);
    if (index === -1) {
      return;
    }
    this[tracks].splice(index, 1);
    this.dispatchEvent(new MediaStreamTrackEvent("removetrack", { track: track2 }));
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/TextTrackKindEnum.js
var TextTrackKindEnum;
(function(TextTrackKindEnum2) {
  TextTrackKindEnum2["subtitles"] = "subtitles";
  TextTrackKindEnum2["captions"] = "captions";
  TextTrackKindEnum2["descriptions"] = "descriptions";
  TextTrackKindEnum2["chapters"] = "chapters";
  TextTrackKindEnum2["metadata"] = "metadata";
})(TextTrackKindEnum || (TextTrackKindEnum = {}));
var TextTrackKindEnum_default = TextTrackKindEnum;

// node_modules/happy-dom/lib/nodes/html-media-element/HTMLMediaElement.js
var HTMLMediaElement = class extends HTMLElement {
  // Internal Properties
  [volume] = 1;
  [paused] = true;
  [currentTime] = 0;
  [playbackRate] = 1;
  [defaultPlaybackRate] = 1;
  [muted] = false;
  [defaultMuted] = false;
  [preservesPitch] = true;
  [buffered] = new TimeRanges(illegalConstructor);
  [duration] = NaN;
  [error] = null;
  [ended] = false;
  [networkState] = 0;
  [readyState] = 0;
  [seeking] = false;
  [seekable] = new TimeRanges(illegalConstructor);
  [sinkId] = "";
  [played] = new TimeRanges(illegalConstructor);
  [remote] = new this[window].RemotePlayback();
  [controlsList] = null;
  [mediaKeys] = null;
  [srcObject] = null;
  [textTracks] = [];
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onabort() {
    return ElementEventAttributeUtility.getEventListener(this, "onabort");
  }
  set onabort(value2) {
    this[propertyEventListeners].set("onabort", value2);
  }
  get oncanplay() {
    return ElementEventAttributeUtility.getEventListener(this, "oncanplay");
  }
  set oncanplay(value2) {
    this[propertyEventListeners].set("oncanplay", value2);
  }
  get oncanplaythrough() {
    return ElementEventAttributeUtility.getEventListener(this, "oncanplaythrough");
  }
  set oncanplaythrough(value2) {
    this[propertyEventListeners].set("oncanplaythrough", value2);
  }
  get ondurationchange() {
    return ElementEventAttributeUtility.getEventListener(this, "ondurationchange");
  }
  set ondurationchange(value2) {
    this[propertyEventListeners].set("ondurationchange", value2);
  }
  get onemptied() {
    return ElementEventAttributeUtility.getEventListener(this, "onemptied");
  }
  set onemptied(value2) {
    this[propertyEventListeners].set("onemptied", value2);
  }
  get onended() {
    return ElementEventAttributeUtility.getEventListener(this, "onended");
  }
  set onended(value2) {
    this[propertyEventListeners].set("onended", value2);
  }
  get onerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onerror");
  }
  set onerror(value2) {
    this[propertyEventListeners].set("onerror", value2);
  }
  get onloadeddata() {
    return ElementEventAttributeUtility.getEventListener(this, "onloadeddata");
  }
  set onloadeddata(value2) {
    this[propertyEventListeners].set("onloadeddata", value2);
  }
  get onloadedmetadata() {
    return ElementEventAttributeUtility.getEventListener(this, "onloadedmetadata");
  }
  set onloadedmetadata(value2) {
    this[propertyEventListeners].set("onloadedmetadata", value2);
  }
  get onloadstart() {
    return ElementEventAttributeUtility.getEventListener(this, "onloadstart");
  }
  set onloadstart(value2) {
    this[propertyEventListeners].set("onloadstart", value2);
  }
  get onpause() {
    return ElementEventAttributeUtility.getEventListener(this, "onpause");
  }
  set onpause(value2) {
    this[propertyEventListeners].set("onpause", value2);
  }
  get onplay() {
    return ElementEventAttributeUtility.getEventListener(this, "onplay");
  }
  set onplay(value2) {
    this[propertyEventListeners].set("onplay", value2);
  }
  get onplaying() {
    return ElementEventAttributeUtility.getEventListener(this, "onplaying");
  }
  set onplaying(value2) {
    this[propertyEventListeners].set("onplaying", value2);
  }
  get onprogress() {
    return ElementEventAttributeUtility.getEventListener(this, "onprogress");
  }
  set onprogress(value2) {
    this[propertyEventListeners].set("onprogress", value2);
  }
  get onratechange() {
    return ElementEventAttributeUtility.getEventListener(this, "onratechange");
  }
  set onratechange(value2) {
    this[propertyEventListeners].set("onratechange", value2);
  }
  get onresize() {
    return ElementEventAttributeUtility.getEventListener(this, "onresize");
  }
  set onresize(value2) {
    this[propertyEventListeners].set("onresize", value2);
  }
  get onseeked() {
    return ElementEventAttributeUtility.getEventListener(this, "onseeked");
  }
  set onseeked(value2) {
    this[propertyEventListeners].set("onseeked", value2);
  }
  get onseeking() {
    return ElementEventAttributeUtility.getEventListener(this, "onseeking");
  }
  set onseeking(value2) {
    this[propertyEventListeners].set("onseeking", value2);
  }
  get onstalled() {
    return ElementEventAttributeUtility.getEventListener(this, "onstalled");
  }
  set onstalled(value2) {
    this[propertyEventListeners].set("onstalled", value2);
  }
  get onsuspend() {
    return ElementEventAttributeUtility.getEventListener(this, "onsuspend");
  }
  set onsuspend(value2) {
    this[propertyEventListeners].set("onsuspend", value2);
  }
  get ontimeupdate() {
    return ElementEventAttributeUtility.getEventListener(this, "ontimeupdate");
  }
  set ontimeupdate(value2) {
    this[propertyEventListeners].set("ontimeupdate", value2);
  }
  get onvolumechange() {
    return ElementEventAttributeUtility.getEventListener(this, "onvolumechange");
  }
  set onvolumechange(value2) {
    this[propertyEventListeners].set("onvolumechange", value2);
  }
  get onwaiting() {
    return ElementEventAttributeUtility.getEventListener(this, "onwaiting");
  }
  set onwaiting(value2) {
    this[propertyEventListeners].set("onwaiting", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns buffered.
   *
   * @returns Buffered.
   */
  get buffered() {
    return this[buffered];
  }
  /**
   * Returns duration.
   *
   * @returns Duration.
   */
  get duration() {
    return this[duration];
  }
  /**
   * Returns error.
   *
   * @returns Error.
   */
  get error() {
    return this[error];
  }
  /**
   * Returns ended.
   *
   * @returns Ended.
   */
  get ended() {
    return this[ended];
  }
  /**
   * Returns networkState.
   *
   * @returns NetworkState.
   */
  get networkState() {
    return this[networkState];
  }
  /**
   * Returns readyState.
   *
   * @returns ReadyState.
   */
  get readyState() {
    return this[readyState];
  }
  /**
   * Return a RemotePlayback object instance associated with the media element.
   *
   * @returns RemotePlayback.
   */
  get remote() {
    return this[remote];
  }
  /**
   * Returns seeking.
   *
   * @returns Seeking.
   */
  get seeking() {
    return this[seeking];
  }
  /**
   * Returns seekable.
   *
   * @returns Seekable.
   */
  get seekable() {
    return this[seekable];
  }
  /**
   * Returns sinkId.
   *
   * @returns SinkId.
   */
  get sinkId() {
    return this[sinkId];
  }
  /**
   * Returns played.
   *
   * @returns Played.
   */
  get played() {
    return this[played];
  }
  /**
   * Returns autoplay.
   *
   * @returns Autoplay.
   */
  get autoplay() {
    return this.getAttribute("autoplay") !== null;
  }
  /**
   * Sets autoplay.
   *
   * @param autoplay Autoplay.
   */
  set autoplay(autoplay) {
    if (!autoplay) {
      this.removeAttribute("autoplay");
    } else {
      this.setAttribute("autoplay", "");
    }
  }
  /**
   * Returns controls.
   *
   * @returns Controls.
   */
  get controls() {
    return this.getAttribute("controls") !== null;
  }
  /**
   * Sets controls.
   *
   * @param controls Controls.
   */
  set controls(controls) {
    if (!controls) {
      this.removeAttribute("controls");
    } else {
      this.setAttribute("controls", "");
    }
  }
  /**
   * Returns loop.
   *
   * @returns Loop.
   */
  get loop() {
    return this.getAttribute("loop") !== null;
  }
  /**
   * Sets loop.
   *
   * @param loop Loop.
   */
  set loop(loop) {
    if (!loop) {
      this.removeAttribute("loop");
    } else {
      this.setAttribute("loop", "");
    }
  }
  /**
   * Returns preload.
   *
   * @returns preload.
   */
  get preload() {
    return this.getAttribute("preload") || "auto";
  }
  /**
   * Sets preload.
   *
   * @param preload preload.
   */
  set preload(preload) {
    this.setAttribute("preload", preload);
  }
  /**
   * Returns src.
   *
   * @returns Src.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets src.
   *
   * @param src Src.
   */
  set src(src) {
    this.setAttribute("src", src);
    if (Boolean(src)) {
      this.dispatchEvent(new Event("canplay", { bubbles: false, cancelable: false }));
      this.dispatchEvent(new Event("durationchange", { bubbles: false, cancelable: false }));
    }
  }
  /**
   * Returns controlsList.
   *
   * @returns ControlsList.
   */
  get controlsList() {
    if (this[controlsList] === null) {
      this[controlsList] = new DOMTokenList(illegalConstructor, this, "controlslist");
    }
    return this[controlsList];
  }
  /**
   * Sets controlsList.
   *
   * @param value Value.
   */
  set controlsList(value2) {
    this.setAttribute("controlslist", value2);
  }
  /**
   * Returns mediaKeys.
   *
   * @returns MediaKeys.
   */
  get mediaKeys() {
    return this[mediaKeys];
  }
  /**
   * Returns muted.
   *
   * @returns Muted.
   */
  get muted() {
    if (this[muted]) {
      return this[muted];
    }
    if (!this[defaultMuted]) {
      return this.getAttribute("muted") !== null;
    }
    return false;
  }
  /**
   * Sets muted.
   *
   * @param muted Muted.
   */
  set muted(muted2) {
    this[muted] = !!muted2;
    if (!muted2 && !this[defaultMuted]) {
      this.removeAttribute("muted");
    } else {
      this.setAttribute("muted", "");
    }
  }
  /**
   * Returns defaultMuted.
   *
   * @returns DefaultMuted.
   */
  get defaultMuted() {
    return this[defaultMuted];
  }
  /**
   * Sets defaultMuted.
   *
   * @param defaultMuted DefaultMuted.
   */
  set defaultMuted(defaultMuted2) {
    this[defaultMuted] = !!defaultMuted2;
    if (!this[defaultMuted] && !this[muted]) {
      this.removeAttribute("muted");
    } else {
      this.setAttribute("muted", "");
    }
  }
  /**
   * Returns disableRemotePlayback.
   *
   * @returns DisableRemotePlayback.
   */
  get disableRemotePlayback() {
    return this.getAttribute("disableremoteplayback") !== null;
  }
  /**
   * Sets disableRemotePlayback.
   *
   * @param disableRemotePlayback DisableRemotePlayback.
   */
  set disableRemotePlayback(disableRemotePlayback) {
    if (!disableRemotePlayback) {
      this.removeAttribute("disableremoteplayback");
    } else {
      this.setAttribute("disableremoteplayback", "");
    }
  }
  /**
   * A MediaStream representing the media to play or that has played in the current HTMLMediaElement, or null if not assigned.
   *
   * @returns MediaStream.
   */
  get srcObject() {
    return this[srcObject];
  }
  /**
   * Sets src object.
   *
   * @param srcObject SrcObject.
   */
  set srcObject(srcObject2) {
    if (srcObject2 !== null && !(srcObject2 instanceof MediaStream)) {
      throw new this[window].TypeError(`Failed to set the 'srcObject' property on 'HTMLMediaElement': The provided value is not of type 'MediaStream'.`);
    }
    this[srcObject] = srcObject2;
  }
  /**
   * Returns text track list.
   *
   * @returns Text track list.
   */
  get textTracks() {
    const items2 = [];
    for (const track2 of this[textTracks]) {
      items2.push(track2);
    }
    for (const track2 of this.querySelectorAll("track")[items]) {
      items2.push(track2.track);
    }
    return new this[window].TextTrackList(illegalConstructor, items2);
  }
  /**
   * Returns currentSrc.
   *
   * @returns CurrentrSrc.
   */
  get currentSrc() {
    const src = this.src;
    if (src) {
      return src;
    }
    const sourceElement = this.querySelector("source");
    return sourceElement ? sourceElement.src : "";
  }
  /**
   * Returns volume.
   *
   * @returns Volume.
   */
  get volume() {
    return this[volume];
  }
  /**
   * Sets volume.
   *
   * @param volume Volume.
   */
  set volume(volume2) {
    const parsedVolume = Number(volume2);
    if (isNaN(parsedVolume)) {
      throw new this[window].TypeError(`Failed to set the 'volume' property on 'HTMLMediaElement': The provided double value is non-finite.`);
    }
    if (parsedVolume < 0 || parsedVolume > 1) {
      throw new this[window].DOMException(`Failed to set the 'volume' property on 'HTMLMediaElement': The volume provided (${parsedVolume}) is outside the range [0, 1].`, DOMExceptionNameEnum_default.indexSizeError);
    }
    this[volume] = parsedVolume;
  }
  /**
   * Returns crossOrigin.
   *
   * @returns CrossOrigin.
   */
  get crossOrigin() {
    const crossOrigin2 = this.getAttribute("crossorigin");
    if (crossOrigin2 === "use-credentials") {
      return "use-credentials";
    }
    if (crossOrigin2 !== null) {
      return "anonymous";
    }
    return null;
  }
  /**
   * Sets crossOrigin.
   *
   * @param crossOrigin CrossOrigin.
   */
  set crossOrigin(crossOrigin2) {
    this.setAttribute("crossorigin", crossOrigin2);
  }
  /**
   * Returns currentTime.
   *
   * @returns CurrentTime.
   */
  get currentTime() {
    return this[currentTime];
  }
  /**
   * Sets currentTime.
   *
   * @param currentTime CurrentTime.
   */
  set currentTime(currentTime2) {
    const parsedCurrentTime = Number(currentTime2);
    if (isNaN(parsedCurrentTime)) {
      throw new this[window].TypeError(`Failed to set the 'currentTime' property on 'HTMLMediaElement': The provided double value is non-finite.`);
    }
    this[currentTime] = parsedCurrentTime;
  }
  /**
   * Returns playbackRate.
   *
   * @returns PlaybackRate.
   */
  get playbackRate() {
    return this[playbackRate];
  }
  /**
   * Sets playbackRate.
   *
   * @param playbackRate PlaybackRate.
   */
  set playbackRate(playbackRate2) {
    const parsedPlaybackRate = Number(playbackRate2);
    if (isNaN(parsedPlaybackRate)) {
      throw new this[window].TypeError(`Failed to set the 'playbackRate' property on 'HTMLMediaElement': The provided double value is non-finite.`);
    }
    this[playbackRate] = parsedPlaybackRate;
  }
  /**
   * Returns defaultPlaybackRate.
   *
   * @returns DefaultPlaybackRate.
   */
  get defaultPlaybackRate() {
    return this[defaultPlaybackRate];
  }
  /**
   * Sets defaultPlaybackRate.
   *
   * @param defaultPlaybackRate DefaultPlaybackRate.
   */
  set defaultPlaybackRate(defaultPlaybackRate2) {
    const parsedDefaultPlaybackRate = Number(defaultPlaybackRate2);
    if (isNaN(parsedDefaultPlaybackRate)) {
      throw new this[window].TypeError(`Failed to set the 'defaultPlaybackRate' property on 'HTMLMediaElement': The provided double value is non-finite.`);
    }
    this[defaultPlaybackRate] = parsedDefaultPlaybackRate;
  }
  /**
   * Returns preservesPitch.
   *
   * @returns PlaybackRate.
   */
  get preservesPitch() {
    return this[preservesPitch];
  }
  /**
   * Sets preservesPitch.
   *
   * @param preservesPitch PreservesPitch.
   */
  set preservesPitch(preservesPitch2) {
    this[preservesPitch] = Boolean(preservesPitch2);
  }
  /**
   * Returns paused.
   *
   * @returns Paused.
   */
  get paused() {
    return this[paused];
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * Adds a new text track to the media element.
   *
   * @param kind The kind of text track.
   * @param label The label of the text track.
   * @param language The language of the text track data.
   */
  addTextTrack(kind2, label2, language2) {
    const window2 = this[window];
    if (arguments.length === 0) {
      throw new window2.TypeError(`Failed to execute 'addTextTrack' on 'HTMLMediaElement': 1 argument required, but only 0 present.`);
    }
    if (!TextTrackKindEnum_default[kind2]) {
      throw new window2.TypeError(`Failed to execute 'addTextTrack' on 'HTMLMediaElement': The provided value '${kind2}' is not a valid enum value of type TextTrackKind.`);
    }
    const track2 = new window2.TextTrack(illegalConstructor);
    track2[kind] = kind2;
    track2[label] = label2 || "";
    track2[language] = language2 || "";
    this[textTracks].push(track2);
    return track2;
  }
  /**
   * Pause played media.
   */
  pause() {
    if (this[paused]) {
      return;
    }
    this[paused] = true;
    this.dispatchEvent(new Event("pause", { bubbles: false, cancelable: false }));
  }
  /**
   * Start playing media.
   */
  async play() {
    if (!this[paused]) {
      return;
    }
    this[paused] = false;
    this.dispatchEvent(new Event("play", { bubbles: false, cancelable: false }));
    this.dispatchEvent(new Event("playing", { bubbles: false, cancelable: false }));
  }
  /**
   * Reports how likely it is that the current browser will be able to play media of a given MIME type.
   *
   * @param _type MIME type.
   * @returns Can play type.
   */
  canPlayType(_type) {
    return "";
  }
  /**
   * Quickly seeks the media to the new time with precision tradeoff.
   *
   * @param _time Time.
   */
  fastSeek(_time) {
  }
  /**
   * Load media.
   */
  load() {
    this.dispatchEvent(new Event("emptied", { bubbles: false, cancelable: false }));
  }
  /**
   * Sets media keys.
   *
   * @param mediaKeys MediaKeys.
   * @returns Promise.
   */
  async setMediaKeys(mediaKeys2) {
    this[mediaKeys] = mediaKeys2;
  }
  /**
   * Sets sink id.
   *
   * @param sinkId SinkId.
   * @returns Promise.
   */
  async setSinkId(sinkId2) {
    this[sinkId] = sinkId2;
  }
  /**
   * Returns MediaStream, captures a stream of the media content.
   *
   * @returns MediaStream.
   */
  captureStream() {
    return new this[window].MediaStream();
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
};

// node_modules/happy-dom/lib/nodes/html-audio-element/HTMLAudioElement.js
var HTMLAudioElement = class extends HTMLMediaElement {
};

// node_modules/happy-dom/lib/nodes/html-base-element/HTMLBaseElement.js
var HTMLBaseElement = class extends HTMLElement {
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this.hasAttribute("href")) {
      return this[ownerDocument].location.href;
    }
    try {
      return new URL(this.getAttribute("href"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("href");
    }
  }
  /**
   * Sets href.
   *
   * @param href Href.
   */
  set href(href2) {
    this.setAttribute("href", href2);
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get target() {
    return this.getAttribute("target") || "";
  }
  /**
   * Sets target.
   *
   * @param target Target.
   */
  set target(target2) {
    this.setAttribute("target", target2);
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
};

// node_modules/happy-dom/lib/nodes/html-body-element/HTMLBodyElement.js
var HTMLBodyElement = class extends HTMLElement {
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onafterprint() {
    return ElementEventAttributeUtility.getEventListener(this, "onafterprint");
  }
  set onafterprint(value2) {
    this[propertyEventListeners].set("onafterprint", value2);
  }
  get onbeforeprint() {
    return ElementEventAttributeUtility.getEventListener(this, "onbeforeprint");
  }
  set onbeforeprint(value2) {
    this[propertyEventListeners].set("onbeforeprint", value2);
  }
  get onbeforeunload() {
    return ElementEventAttributeUtility.getEventListener(this, "onbeforeunload");
  }
  set onbeforeunload(value2) {
    this[propertyEventListeners].set("onbeforeunload", value2);
  }
  get ongamepadconnected() {
    return ElementEventAttributeUtility.getEventListener(this, "ongamepadconnected");
  }
  set ongamepadconnected(value2) {
    this[propertyEventListeners].set("ongamepadconnected", value2);
  }
  get ongamepaddisconnected() {
    return ElementEventAttributeUtility.getEventListener(this, "ongamepaddisconnected");
  }
  set ongamepaddisconnected(value2) {
    this[propertyEventListeners].set("ongamepaddisconnected", value2);
  }
  get onhashchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onhashchange");
  }
  set onhashchange(value2) {
    this[propertyEventListeners].set("onhashchange", value2);
  }
  get onlanguagechange() {
    return ElementEventAttributeUtility.getEventListener(this, "onlanguagechange");
  }
  set onlanguagechange(value2) {
    this[propertyEventListeners].set("onlanguagechange", value2);
  }
  get onmessage() {
    return ElementEventAttributeUtility.getEventListener(this, "onmessage");
  }
  set onmessage(value2) {
    this[propertyEventListeners].set("onmessage", value2);
  }
  get onmessageerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onmessageerror");
  }
  set onmessageerror(value2) {
    this[propertyEventListeners].set("onmessageerror", value2);
  }
  get onoffline() {
    return ElementEventAttributeUtility.getEventListener(this, "onoffline");
  }
  set onoffline(value2) {
    this[propertyEventListeners].set("onoffline", value2);
  }
  get ononline() {
    return ElementEventAttributeUtility.getEventListener(this, "ononline");
  }
  set ononline(value2) {
    this[propertyEventListeners].set("ononline", value2);
  }
  get onpagehide() {
    return ElementEventAttributeUtility.getEventListener(this, "onpagehide");
  }
  set onpagehide(value2) {
    this[propertyEventListeners].set("onpagehide", value2);
  }
  get onpageshow() {
    return ElementEventAttributeUtility.getEventListener(this, "onpageshow");
  }
  set onpageshow(value2) {
    this[propertyEventListeners].set("onpageshow", value2);
  }
  get onpopstate() {
    return ElementEventAttributeUtility.getEventListener(this, "onpopstate");
  }
  set onpopstate(value2) {
    this[propertyEventListeners].set("onpopstate", value2);
  }
  get onrejectionhandled() {
    return ElementEventAttributeUtility.getEventListener(this, "onrejectionhandled");
  }
  set onrejectionhandled(value2) {
    this[propertyEventListeners].set("onrejectionhandled", value2);
  }
  get onstorage() {
    return ElementEventAttributeUtility.getEventListener(this, "onstorage");
  }
  set onstorage(value2) {
    this[propertyEventListeners].set("onstorage", value2);
  }
  get onunhandledrejection() {
    return ElementEventAttributeUtility.getEventListener(this, "onunhandledrejection");
  }
  set onunhandledrejection(value2) {
    this[propertyEventListeners].set("onunhandledrejection", value2);
  }
  get onunload() {
    return ElementEventAttributeUtility.getEventListener(this, "onunload");
  }
  set onunload(value2) {
    this[propertyEventListeners].set("onunload", value2);
  }
};

// node_modules/happy-dom/lib/nodes/html-br-element/HTMLBRElement.js
var HTMLBRElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-input-element/HTMLInputElementValueSanitizer.js
var NEW_LINES_REGEXP = /[\n\r]/gm;
var parseInts = (a) => a.map((v) => parseInt(v, 10));
var HTMLInputElementValueSanitizer = class {
  /**
   * Sanitizes a value.
   *
   * @param input Input.
   * @param value Value.
   */
  static sanitize(input, value2) {
    switch (input.type) {
      case "password":
      case "search":
      case "tel":
      case "text":
        return value2.replace(NEW_LINES_REGEXP, "");
      case "color":
        return /^#[a-fA-F\d]{6}$/.test(value2) ? value2.toLowerCase() : "#000000";
      case "email":
        if (input.multiple) {
          return value2.split(",").map((token) => token.trim()).join(",");
        }
        return value2.trim().replace(NEW_LINES_REGEXP, "");
      case "number":
        return !isNaN(Number.parseFloat(value2)) ? value2 : "";
      case "range": {
        const number = Number.parseFloat(value2);
        const min = parseFloat(input.min) || 0;
        const max = parseFloat(input.max) || 100;
        if (isNaN(number)) {
          return max < min ? String(min) : String((min + max) / 2);
        } else if (number < min) {
          return String(min);
        } else if (number > max) {
          return String(max);
        }
        return value2;
      }
      case "url":
        return value2.trim().replace(NEW_LINES_REGEXP, "");
      case "date":
        value2 = this.sanitizeDate(value2);
        return value2 && this.checkBoundaries(value2, input.min, input.max) ? value2 : "";
      case "datetime-local": {
        const match = value2.match(/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d)(?::(\d\d)(?:\.(\d{1,3}))?)?$/);
        if (!match) {
          return "";
        }
        const dateString = this.sanitizeDate(value2.slice(0, 10));
        let timeString = this.sanitizeTime(value2.slice(11));
        if (!(dateString && timeString)) {
          return "";
        }
        if (match[6] !== void 0) {
          if (timeString.indexOf(".") !== -1) {
            timeString = timeString.replace(/(?:\.0*|(\.\d+?)0+)$/, "$1");
          }
          timeString = timeString.replace(/(\d\d:\d\d)(:00)$/, "$1");
        }
        return dateString + "T" + timeString;
      }
      case "month":
        if (!(value2.match(/^(\d\d\d\d)-(\d\d)$/) && this.parseMonthComponent(value2))) {
          return "";
        }
        return this.checkBoundaries(value2, input.min, input.max) ? value2 : "";
      case "time": {
        value2 = this.sanitizeTime(value2);
        return value2 && this.checkBoundaries(value2, input.min, input.max) ? value2 : "";
      }
      case "week": {
        const match = value2.match(/^(\d\d\d\d)-W(\d\d)$/);
        if (!match) {
          return "";
        }
        const [intY, intW] = parseInts(match.slice(1, 3));
        if (intY <= 0 || intW < 1 || intW > 53) {
          return "";
        }
        const lastWeek = this.lastIsoWeekOfYear(intY);
        if (intW < 1 || intW > 52 + lastWeek) {
          return "";
        }
        if (!this.checkBoundaries(value2, input.min, input.max)) {
          return "";
        }
        return value2;
      }
    }
    return value2;
  }
  /**
   * Checks if a value is within the boundaries of min and max.
   *
   * @param value
   * @param min
   * @param max
   */
  static checkBoundaries(value2, min, max) {
    if (min && min > value2) {
      return false;
    } else if (max && max < value2) {
      return false;
    }
    return true;
  }
  /**
   * Parses the month component of a date string.
   *
   * @param value
   */
  static parseMonthComponent(value2) {
    const [Y, M] = value2.split("-");
    const [intY, intM] = parseInts([Y, M]);
    if (isNaN(intY) || isNaN(intM) || intY <= 0 || intM < 1 || intM > 12) {
      return "";
    }
    return value2;
  }
  /**
   * Returns the last ISO week of a year.
   *
   * @param year
   */
  static lastIsoWeekOfYear = (year) => {
    const date = new Date(+year, 11, 31);
    const day = (date.getDay() + 6) % 7;
    date.setDate(date.getDate() - day + 3);
    const firstThursday = date.getTime();
    date.setMonth(0, 1);
    if (date.getDay() !== 4) {
      date.setMonth(0, 1 + (4 - date.getDay() + 7) % 7);
    }
    return 1 + Math.ceil((firstThursday - date.getTime()) / 6048e5);
  };
  /**
   * Sanitizes a date string.
   *
   * @param value
   */
  static sanitizeDate(value2) {
    const match = value2.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!match) {
      return "";
    }
    const month = this.parseMonthComponent(value2.slice(0, 7));
    if (!month) {
      return "";
    }
    const [intY, intM, intD] = parseInts(match.slice(1, 4));
    if (intD < 1 || intD > 31) {
      return "";
    }
    const lastDayOfMonth = new Date(intY, intM, 0).getDate();
    if (intD > lastDayOfMonth) {
      return "";
    }
    return value2;
  }
  /**
   * Sanitizes a time string.
   *
   * @param value
   */
  static sanitizeTime(value2) {
    const match = value2.match(/^(\d{2}):(\d{2})(?::(\d{2}(?:\.(\d{1,3}))?))?$/);
    if (!match) {
      return "";
    }
    const [intH, intM] = parseInts(match.slice(1, 3));
    const ms = parseFloat(match[3] || "0") * 1e3;
    if (intH > 23 || intM > 59 || ms > 59999) {
      return "";
    }
    if (ms === 0) {
      return `${match[1]}:${match[2]}`;
    } else {
      return `${match[1]}:${match[2]}${ms >= 1e4 ? `:${ms / 1e3}` : `:0${ms / 1e3}`}`;
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-input-element/HTMLInputElementSelectionModeEnum.js
var HTMLInputElementSelectionModeEnum;
(function(HTMLInputElementSelectionModeEnum2) {
  HTMLInputElementSelectionModeEnum2["preserve"] = "preserve";
  HTMLInputElementSelectionModeEnum2["select"] = "select";
  HTMLInputElementSelectionModeEnum2["start"] = "start";
  HTMLInputElementSelectionModeEnum2["end"] = "end";
})(HTMLInputElementSelectionModeEnum || (HTMLInputElementSelectionModeEnum = {}));
var HTMLInputElementSelectionModeEnum_default = HTMLInputElementSelectionModeEnum;

// node_modules/happy-dom/lib/nodes/html-input-element/HTMLInputElementSelectionDirectionEnum.js
var HTMLInputElementSelectionDirectionEnum;
(function(HTMLInputElementSelectionDirectionEnum2) {
  HTMLInputElementSelectionDirectionEnum2["none"] = "none";
  HTMLInputElementSelectionDirectionEnum2["forward"] = "forward";
  HTMLInputElementSelectionDirectionEnum2["backward"] = "backward";
})(HTMLInputElementSelectionDirectionEnum || (HTMLInputElementSelectionDirectionEnum = {}));
var HTMLInputElementSelectionDirectionEnum_default = HTMLInputElementSelectionDirectionEnum;

// node_modules/happy-dom/lib/nodes/html-input-element/HTMLInputElementValueStepping.js
var HTMLInputElementValueStepping = class {
  /**
   * Steps up or down.
   *
   * @param type Type.
   * @param value Value.
   * @param direction Direction.
   * @param [increment] Increment.
   * @returns New value.
   */
  static step(type2, value2, direction, increment) {
    switch (type2) {
      case "number":
        return String(Number(value2) + (increment !== void 0 ? increment * direction : direction));
      case "date":
      case "month":
      case "week":
      case "time":
      case "datetime-local":
      case "range":
        return null;
      default:
        throw new DOMException("This form element is not steppable.");
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-input-element/FileList.js
var FileList = class extends Array {
  /**
   * Constructor.
   */
  constructor() {
    super(0);
  }
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   * @returns Item.
   */
  item(index) {
    return this[index] || null;
  }
};

// node_modules/happy-dom/lib/nodes/html-input-element/HTMLInputElementDateUtility.js
var HTMLInputElementDateUtility = class {
  /**
   * Returns iso week number from given date
   *
   * @see https://stackoverflow.com/a/6117889
   * @param date Date or number.
   * @returns Iso-week string.
   */
  static dateIsoWeek(date) {
    date = typeof date === "number" ? new Date(date) : date;
    date = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    date.setUTCDate(date.getUTCDate() + 4 - (date.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil(((date - yearStart) / 864e5 + 1) / 7);
    return `${date.getUTCFullYear()}-W${weekNo < 10 ? "0" : ""}${weekNo}`;
  }
  /**
   * Returns a date object for monday of given iso week string (\d\d\d\d-W\d\d)
   *
   * @param isoWeek Iso-week string.
   * @returns Date.
   */
  static isoWeekDate(isoWeek) {
    const [, Y, W] = isoWeek.match(/^(\d{4})-W(\d{2})$/) || [];
    if (!Y || !W || Number(W) > 53 || Number(W) < 1) {
      return /* @__PURE__ */ new Date("x");
    }
    const date = /* @__PURE__ */ new Date(`${Y}-01-01T00:00Z`);
    const jan4th = /* @__PURE__ */ new Date(`${Y}-01-04T00:00Z`);
    const jan4thDay = (jan4th.getUTCDay() + 6) % 7;
    const ordinalDate = 1 + (Number(W) - 1) * 7 - jan4thDay + 3;
    date.setUTCDate(ordinalDate);
    if (date.getUTCFullYear() > Number(Y)) {
      return /* @__PURE__ */ new Date("x");
    }
    return date;
  }
};

// node_modules/happy-dom/lib/nodes/html-label-element/HTMLLabelElementUtility.js
var HTMLLabelElementUtility = class {
  /**
   * Returns label elements for a form element.
   *
   * @param element Element to get labels for.
   * @returns Label elements.
   */
  static getAssociatedLabelElements(element) {
    const id2 = element.id;
    let labels;
    if (id2 && element[isConnected]) {
      const rootNode2 = element[rootNode] || element[ownerDocument];
      labels = rootNode2.querySelectorAll(`label[for="${id2}"]`)[items];
    } else {
      labels = [];
    }
    let parent2 = element[parentNode];
    while (parent2) {
      if (parent2["tagName"] === "LABEL") {
        labels.push(parent2);
        break;
      }
      parent2 = parent2[parentNode];
    }
    return new NodeList_default(illegalConstructor, labels);
  }
};

// node_modules/happy-dom/lib/nodes/html-input-element/HTMLInputElement.js
import { URL as URL9 } from "url";
var HTMLInputElement = class extends HTMLElement {
  [value] = null;
  [height] = 0;
  [width] = 0;
  [checked] = null;
  [validationMessage] = "";
  [validity] = new ValidityState(this);
  [files] = new FileList();
  [indeterminate] = false;
  [formNode] = null;
  [popoverTargetElement] = null;
  // Private properties
  #selectionStart = null;
  #selectionEnd = null;
  #selectionDirection = HTMLInputElementSelectionDirectionEnum_default.none;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get oninput() {
    return ElementEventAttributeUtility.getEventListener(this, "oninput");
  }
  set oninput(value2) {
    this[propertyEventListeners].set("oninput", value2);
  }
  get oninvalid() {
    return ElementEventAttributeUtility.getEventListener(this, "oninvalid");
  }
  set oninvalid(value2) {
    this[propertyEventListeners].set("oninvalid", value2);
  }
  get onselectionchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onselectionchange");
  }
  set onselectionchange(value2) {
    this[propertyEventListeners].set("onselectionchange", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns default checked.
   *
   * @returns Default checked.
   */
  get defaultChecked() {
    return this.hasAttribute("checked");
  }
  /**
   * Sets default checked.
   *
   * @param defaultChecked Default checked.
   */
  set defaultChecked(defaultChecked2) {
    if (defaultChecked2) {
      this.setAttribute("checked", "");
    } else {
      this.removeAttribute("checked");
    }
  }
  /**
   * Returns files.
   *
   * @returns Files.
   */
  get files() {
    return this[files];
  }
  /**
   * Sets files.
   *
   * @param files Files.
   */
  set files(files2) {
    this[files] = files2;
  }
  /**
   * Returns form action.
   *
   * @returns Form action.
   */
  get formAction() {
    if (!this.hasAttribute("formaction")) {
      return this[ownerDocument].location.href;
    }
    try {
      return new URL9(this.getAttribute("formaction"), this[ownerDocument].location.href).href;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets form action.
   *
   * @param formAction Form action.
   */
  set formAction(formAction) {
    this.setAttribute("formaction", formAction);
  }
  /**
   * Returns form enctype.
   *
   * @returns Form enctype.
   */
  get formEnctype() {
    return this.getAttribute("formenctype") || "";
  }
  /**
   * Sets form enctype.
   *
   * @param formEnctype Form enctype.
   */
  set formEnctype(formEnctype) {
    this.setAttribute("formenctype", formEnctype);
  }
  /**
   * Returns form method.
   *
   * @returns Form method.
   */
  get formMethod() {
    return this.getAttribute("formmethod") || "";
  }
  /**
   * Sets form method.
   *
   * @param formMethod Form method.
   */
  set formMethod(formMethod) {
    this.setAttribute("formmethod", formMethod);
  }
  /**
   * Returns no validate.
   *
   * @returns No validate.
   */
  get formNoValidate() {
    return this.getAttribute("formnovalidate") !== null;
  }
  /**
   * Sets no validate.
   *
   * @param formNoValidate No validate.
   */
  set formNoValidate(formNoValidate) {
    if (!formNoValidate) {
      this.removeAttribute("formnovalidate");
    } else {
      this.setAttribute("formnovalidate", "");
    }
  }
  /**
   * Returns form target.
   *
   * @returns Form target.
   */
  get formTarget() {
    return this.getAttribute("formtarget") || "";
  }
  /**
   * Sets form target.
   *
   * @param formTarget Form target.
   */
  set formTarget(formTarget) {
    this.setAttribute("formtarget", formTarget);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    const id2 = this.getAttribute("form");
    if (!id2 || !this[isConnected]) {
      return null;
    }
    return this[ownerDocument].getElementById(id2);
  }
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this[height];
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this[height] = height2;
    this.setAttribute("height", String(height2));
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this[width];
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this[width] = width2;
    this.setAttribute("width", String(width2));
  }
  /**
   * Returns size.
   *
   * @returns Size.
   */
  get size() {
    const size = this.getAttribute("size");
    if (size !== null) {
      return parseInt(size);
    }
    return 20;
  }
  /**
   * Sets size.
   *
   * @param size Size.
   */
  set size(size) {
    this.setAttribute("size", String(size));
  }
  /**
   * Returns minlength.
   *
   * @returns Min length.
   */
  get minLength() {
    const minLength = this.getAttribute("minlength");
    if (minLength !== null) {
      return parseInt(minLength);
    }
    return -1;
  }
  /**
   * Sets minlength.
   *
   * @param minLength Min length.
   */
  set minLength(minlength) {
    this.setAttribute("minlength", String(minlength));
  }
  /**
   * Returns maxlength.
   *
   * @returns Max length.
   */
  get maxLength() {
    const maxLength = this.getAttribute("maxlength");
    if (maxLength !== null) {
      return parseInt(maxLength);
    }
    return -1;
  }
  /**
   * Sets maxlength.
   *
   * @param maxlength Max length.
   */
  set maxLength(maxLength) {
    this.setAttribute("maxlength", String(maxLength));
  }
  /**
   * Returns type.
   *
   * @returns Type. Defaults to "text".
   */
  get type() {
    return this.getAttribute("type") || "text";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2.toLowerCase());
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns alt.
   *
   * @returns Alt.
   */
  get alt() {
    return this.getAttribute("alt") || "";
  }
  /**
   * Sets alt.
   *
   * @param alt Alt.
   */
  set alt(alt) {
    this.setAttribute("alt", alt);
  }
  /**
   * Returns min.
   *
   * @returns Min.
   */
  get min() {
    return this.getAttribute("min") || "";
  }
  /**
   * Sets min.
   *
   * @param min Min.
   */
  set min(min) {
    this.setAttribute("min", min);
  }
  /**
   * Returns max.
   *
   * @returns Max.
   */
  get max() {
    return this.getAttribute("max") || "";
  }
  /**
   * Sets max.
   *
   * @param max Max.
   */
  set max(max) {
    this.setAttribute("max", max);
  }
  /**
   * Returns pattern.
   *
   * @returns Pattern.
   */
  get pattern() {
    return this.getAttribute("pattern") || "";
  }
  /**
   * Sets pattern.
   *
   * @param pattern Pattern.
   */
  set pattern(pattern) {
    this.setAttribute("pattern", pattern);
  }
  /**
   * Returns placeholder.
   *
   * @returns Placeholder.
   */
  get placeholder() {
    return this.getAttribute("placeholder") || "";
  }
  /**
   * Sets placeholder.
   *
   * @param placeholder Placeholder.
   */
  set placeholder(placeholder) {
    this.setAttribute("placeholder", placeholder);
  }
  /**
   * Returns step.
   *
   * @returns Step.
   */
  get step() {
    return this.getAttribute("step") || "";
  }
  /**
   * Sets step.
   *
   * @param step Step.
   */
  set step(step) {
    this.setAttribute("step", step);
  }
  /**
   * Returns inputmode.
   *
   * @returns Inputmode.
   */
  get inputMode() {
    return this.getAttribute("inputmode") || "";
  }
  /**
   * Sets inputmode.
   *
   * @param inputmode Inputmode.
   */
  set inputMode(inputmode) {
    this.setAttribute("inputmode", inputmode);
  }
  /**
   * Returns accept.
   *
   * @returns Accept.
   */
  get accept() {
    return this.getAttribute("accept") || "";
  }
  /**
   * Sets accept.
   *
   * @param accept Accept.
   */
  set accept(accept) {
    this.setAttribute("accept", accept);
  }
  /**
   * Returns allowdirs.
   *
   * @returns Allowdirs.
   */
  get allowdirs() {
    return this.getAttribute("allowdirs") || "";
  }
  /**
   * Sets allowdirs.
   *
   * @param allowdirs Allowdirs.
   */
  set allowdirs(allowdirs) {
    this.setAttribute("allowdirs", allowdirs);
  }
  /**
   * Returns autocomplete.
   *
   * @returns Autocomplete.
   */
  get autocomplete() {
    return this.getAttribute("autocomplete") || "";
  }
  /**
   * Sets autocomplete.
   *
   * @param autocomplete Autocomplete.
   */
  set autocomplete(autocomplete) {
    this.setAttribute("autocomplete", autocomplete);
  }
  /**
   * Returns src.
   *
   * @returns Src.
   */
  get src() {
    return this.getAttribute("src") || "";
  }
  /**
   * Sets src.
   *
   * @param src Src.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns defaultValue.
   *
   * @returns Defaultvalue.
   */
  get defaultValue() {
    return this.getAttribute("value") || "";
  }
  /**
   * Sets defaultValue.
   *
   * @param defaultValue Defaultvalue.
   */
  set defaultValue(defaultValue2) {
    this.setAttribute("value", defaultValue2);
  }
  /**
   * Returns read only.
   *
   * @returns Read only.
   */
  get readOnly() {
    return this.getAttribute("readonly") !== null;
  }
  /**
   * Sets read only.
   *
   * @param readOnly Read only.
   */
  set readOnly(readOnly2) {
    if (!readOnly2) {
      this.removeAttribute("readonly");
    } else {
      this.setAttribute("readonly", "");
    }
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    if (!disabled2) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns autofocus.
   *
   * @returns Autofocus.
   */
  get autofocus() {
    return this.getAttribute("autofocus") !== null;
  }
  /**
   * Sets autofocus.
   *
   * @param autofocus Autofocus.
   */
  set autofocus(autofocus) {
    if (!autofocus) {
      this.removeAttribute("autofocus");
    } else {
      this.setAttribute("autofocus", "");
    }
  }
  /**
   * Returns required.
   *
   * @returns Required.
   */
  get required() {
    return this.getAttribute("required") !== null;
  }
  /**
   * Sets required.
   *
   * @param required Required.
   */
  set required(required) {
    if (!required) {
      this.removeAttribute("required");
    } else {
      this.setAttribute("required", "");
    }
  }
  /**
   * Returns indeterminate.
   *
   * @returns Indeterminate.
   */
  get indeterminate() {
    return this[indeterminate];
  }
  /**
   * Sets indeterminate.
   *
   * @param indeterminate Indeterminate.
   */
  set indeterminate(indeterminate2) {
    this[indeterminate] = Boolean(indeterminate2);
  }
  /**
   * Returns multiple.
   *
   * @returns Multiple.
   */
  get multiple() {
    return this.getAttribute("multiple") !== null;
  }
  /**
   * Sets multiple.
   *
   * @param multiple Multiple.
   */
  set multiple(multiple) {
    if (!multiple) {
      this.removeAttribute("multiple");
    } else {
      this.setAttribute("multiple", "");
    }
  }
  /**
   * Returns checked.
   *
   * @returns Checked.
   */
  get checked() {
    if (this[checked] !== null) {
      return this[checked];
    }
    return this.getAttribute("checked") !== null;
  }
  /**
   * Sets checked.
   *
   * @param checked Checked.
   */
  set checked(checked2) {
    this.#setChecked(checked2);
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    switch (this.type) {
      case "hidden":
      case "submit":
      case "image":
      case "reset":
      case "button":
        return this.getAttribute("value") || "";
      case "checkbox":
      case "radio":
        const attritube = this.getAttribute("value");
        return attritube !== null ? attritube : "on";
      case "file":
        return this[files].length > 0 ? "/fake/path/" + this[files][0].name : "";
    }
    if (this[value] === null) {
      return this.getAttribute("value") || "";
    }
    return this[value];
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    value2 = value2 === null ? "" : String(value2);
    switch (this.type) {
      case "hidden":
      case "submit":
      case "image":
      case "reset":
      case "button":
      case "checkbox":
      case "radio":
        this.setAttribute("value", value2);
        break;
      case "file":
        if (value2 !== null && value2 !== "") {
          throw new this[window].DOMException('Input elements of type "file" may only programmatically set the value to empty string.', DOMExceptionNameEnum_default.invalidStateError);
        }
        this[files] = new FileList();
        break;
      default:
        const oldValue = this.value;
        this[value] = HTMLInputElementValueSanitizer.sanitize(this, value2);
        if (oldValue !== this[value]) {
          this.#selectionStart = this[value].length;
          this.#selectionEnd = this[value].length;
          this.#selectionDirection = HTMLInputElementSelectionDirectionEnum_default.none;
        }
        break;
    }
  }
  /**
   * Returns selection start.
   *
   * @returns Selection start.
   */
  get selectionStart() {
    if (!this.#isSelectionSupported()) {
      return null;
    }
    if (this.#selectionStart === null) {
      return this.value.length;
    }
    return this.#selectionStart;
  }
  /**
   * Sets selection start.
   *
   * @param start Start.
   */
  set selectionStart(start2) {
    if (!this.#isSelectionSupported()) {
      throw new this[window].DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    this.setSelectionRange(start2, Math.max(start2, this.selectionEnd), this.#selectionDirection);
  }
  /**
   * Returns selection end.
   *
   * @returns Selection end.
   */
  get selectionEnd() {
    if (!this.#isSelectionSupported()) {
      return null;
    }
    if (this.#selectionEnd === null) {
      return this.value.length;
    }
    return this.#selectionEnd;
  }
  /**
   * Sets selection end.
   *
   * @param end End.
   */
  set selectionEnd(end2) {
    if (!this.#isSelectionSupported()) {
      throw new this[window].DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    this.setSelectionRange(this.selectionStart, end2, this.#selectionDirection);
  }
  /**
   * Returns selection direction.
   *
   * @returns Selection direction.
   */
  get selectionDirection() {
    if (!this.#isSelectionSupported()) {
      return null;
    }
    return this.#selectionDirection;
  }
  /**
   * Sets selection direction.
   *
   * @param direction Direction.
   */
  set selectionDirection(direction) {
    if (!this.#isSelectionSupported()) {
      throw new this[window].DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    this.setSelectionRange(this.#selectionStart, this.#selectionEnd, direction);
  }
  /**
   * Returns "true" if it will validate.
   *
   * @returns "true" if it will validate.
   */
  get willValidate() {
    return this.type !== "hidden" && this.type !== "reset" && this.type !== "button" && !this.disabled && !this["readOnly"];
  }
  /**
   * Returns value as Date.
   *
   * @returns Date.
   */
  get valueAsDate() {
    switch (this.type) {
      case "date":
      case "month":
        return isNaN(new Date(String(this.value)).getTime()) ? null : new Date(this.value);
      case "week": {
        const d = HTMLInputElementDateUtility.isoWeekDate(this.value);
        return isNaN(d.getTime()) ? null : d;
      }
      case "time": {
        const d = /* @__PURE__ */ new Date(`1970-01-01T${this.value}Z`);
        return isNaN(d.getTime()) ? null : d;
      }
      default:
        return null;
    }
  }
  /**
   * Sets value from a Date.
   *
   * @param value Date.
   */
  set valueAsDate(value2) {
    if (!["date", "month", "time", "week"].includes(this.type)) {
      throw new this[window].DOMException("Failed to set the 'valueAsDate' property on 'HTMLInputElement': This input element does not support Date values.", DOMExceptionNameEnum_default.invalidStateError);
    }
    if (typeof value2 !== "object") {
      throw new this[window].TypeError("Failed to set the 'valueAsDate' property on 'HTMLInputElement': Failed to convert value to 'object'.");
    } else if (value2 && !(value2 instanceof Date)) {
      throw new this[window].TypeError("Failed to set the 'valueAsDate' property on 'HTMLInputElement': The provided value is not a Date.");
    } else if (value2 === null || isNaN(value2.getTime())) {
      this.value = "";
      return;
    }
    switch (this.type) {
      case "date":
        this.value = value2.toISOString().split("T")[0];
        break;
      case "month":
        this.value = value2.toISOString().split("T")[0].slice(0, -3);
        break;
      case "time":
        this.value = value2.toISOString().split("T")[1].slice(0, 5);
        break;
      case "week":
        this.value = HTMLInputElementDateUtility.dateIsoWeek(value2);
        break;
    }
  }
  /**
   * Returns value as number.
   *
   * @returns Number.
   */
  get valueAsNumber() {
    const value2 = this.value;
    if (!this.type.match(/^(range|number|date|datetime-local|month|time|week)$/) || !value2) {
      return NaN;
    }
    switch (this.type) {
      case "number":
        return parseFloat(value2);
      case "range": {
        const number = parseFloat(value2);
        const min = parseFloat(this.min) || 0;
        const max = parseFloat(this.max) || 100;
        if (isNaN(number)) {
          return max < min ? min : (min + max) / 2;
        } else if (number < min) {
          return min;
        } else if (number > max) {
          return max;
        }
        return number;
      }
      case "date":
        return new Date(value2).getTime();
      case "datetime-local":
        return new Date(value2).getTime() - new Date(value2).getTimezoneOffset() * 6e4;
      case "month":
        return (new Date(value2).getUTCFullYear() - 1970) * 12 + new Date(value2).getUTCMonth();
      case "time":
        return (/* @__PURE__ */ new Date("1970-01-01T" + value2)).getTime() - (/* @__PURE__ */ new Date("1970-01-01T00:00:00")).getTime();
      case "week": {
        const match = value2.match(/^(\d{4})-W(\d{2})$/);
        if (!match) {
          return NaN;
        }
        const d = new Date(Date.UTC(parseInt(match[1], 10), 0));
        const day = d.getUTCDay();
        const diff = ((day === 0 ? -6 : 1) - day) * 864e5 + parseInt(match[2], 10) * 6048e5;
        return d.getTime() + diff;
      }
    }
  }
  /**
   * Sets value from a number.
   *
   * @param value number.
   */
  set valueAsNumber(value2) {
    switch (this.type) {
      case "number":
      case "range":
        this.value = Number(value2).toString();
        break;
      case "date":
      case "datetime-local": {
        const d = new Date(Number(value2));
        if (isNaN(d.getTime())) {
          this.value = "";
          break;
        }
        if (this.type == "date") {
          this.value = d.toISOString().slice(0, 10);
        } else {
          this.value = d.toISOString().slice(0, -1);
        }
        break;
      }
      case "month":
        if (!Number.isInteger(value2) || value2 < 0) {
          this.value = "";
        } else {
          this.value = new Date(Date.UTC(1970, Number(value2))).toISOString().slice(0, 7);
        }
        break;
      case "time":
        if (!Number.isInteger(value2) || value2 < 0) {
          this.value = "";
        } else {
          this.value = new Date(Number(value2)).toISOString().slice(11, -1);
        }
        break;
      case "week": {
        const d = new Date(Number(value2));
        this.value = isNaN(d.getTime()) ? "" : HTMLInputElementDateUtility.dateIsoWeek(d);
        break;
      }
      default:
        throw new this[window].DOMException("Failed to set the 'valueAsNumber' property on 'HTMLInputElement': This input element does not support Number values.", DOMExceptionNameEnum_default.invalidStateError);
    }
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * Returns associated datalist element.
   *
   * @returns Data list element.
   */
  get list() {
    const id2 = this.getAttribute("list");
    if (!id2) {
      return null;
    }
    const rootNode2 = this[rootNode] || this[ownerDocument];
    return rootNode2.querySelector(`datalist#${id2}`);
  }
  /**
   * Returns popover target element.
   *
   * @returns Popover target element.
   */
  get popoverTargetElement() {
    return this[popoverTargetElement];
  }
  /**
   * Sets popover target element.
   *
   * @param popoverTargetElement Popover target element.
   */
  set popoverTargetElement(popoverTargetElement2) {
    if (popoverTargetElement2 !== null && !(popoverTargetElement2 instanceof HTMLElement)) {
      throw new this[window].TypeError(`Failed to set the 'popoverTargetElement' property on 'HTMLInputElement': Failed to convert value to 'Element'.`);
    }
    this[popoverTargetElement] = popoverTargetElement2;
  }
  /**
   * Returns popover target action.
   *
   * @returns Popover target action.
   */
  get popoverTargetAction() {
    const value2 = this.getAttribute("popovertargetaction");
    if (value2 === null || value2 !== "hide" && value2 !== "show" && value2 !== "toggle") {
      return "toggle";
    }
    return value2;
  }
  /**
   * Sets popover target action.
   *
   * @param value Popover target action.
   */
  set popoverTargetAction(value2) {
    this.setAttribute("popovertargetaction", value2);
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
  /**
   * Selects the text.
   */
  select() {
    if (!this.#isSelectionSupported()) {
      return null;
    }
    this.#selectionStart = 0;
    this.#selectionEnd = this.value.length;
    this.#selectionDirection = HTMLInputElementSelectionDirectionEnum_default.none;
    this.dispatchEvent(new Event("select", { bubbles: true, cancelable: false }));
  }
  /**
   * Set selection range.
   *
   * @param start Start.
   * @param end End.
   * @param [direction="none"] Direction.
   */
  setSelectionRange(start2, end2, direction = "none") {
    if (!this.#isSelectionSupported()) {
      throw new this[window].DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    this.#selectionEnd = Math.min(end2, this.value.length);
    this.#selectionStart = Math.min(start2, this.#selectionEnd);
    this.#selectionDirection = direction === HTMLInputElementSelectionDirectionEnum_default.forward || direction === HTMLInputElementSelectionDirectionEnum_default.backward ? direction : HTMLInputElementSelectionDirectionEnum_default.none;
    this.dispatchEvent(new Event("select", { bubbles: true, cancelable: false }));
  }
  /**
   * Set range text.
   *
   * @param replacement Replacement.
   * @param [start] Start.
   * @param [end] End.
   * @param [direction] Direction.
   * @param selectionMode
   */
  setRangeText(replacement, start2 = null, end2 = null, selectionMode = HTMLInputElementSelectionModeEnum_default.preserve) {
    if (!this.#isSelectionSupported()) {
      throw new this[window].DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    if (start2 === null) {
      start2 = this.#selectionStart;
    }
    if (end2 === null) {
      end2 = this.#selectionEnd;
    }
    if (start2 > end2) {
      throw new this[window].DOMException("The index is not in the allowed range.", DOMExceptionNameEnum_default.invalidStateError);
    }
    start2 = Math.min(start2, this.value.length);
    end2 = Math.min(end2, this.value.length);
    const val = this.value;
    let selectionStart = this.#selectionStart;
    let selectionEnd = this.#selectionEnd;
    this.value = val.slice(0, start2) + replacement + val.slice(end2);
    const newEnd = start2 + this.value.length;
    switch (selectionMode) {
      case HTMLInputElementSelectionModeEnum_default.select:
        this.setSelectionRange(start2, newEnd);
        break;
      case HTMLInputElementSelectionModeEnum_default.start:
        this.setSelectionRange(start2, start2);
        break;
      case HTMLInputElementSelectionModeEnum_default.end:
        this.setSelectionRange(newEnd, newEnd);
        break;
      default:
        const delta = replacement.length - (end2 - start2);
        if (selectionStart > end2) {
          selectionStart += delta;
        } else if (selectionStart > start2) {
          selectionStart = start2;
        }
        if (selectionEnd > end2) {
          selectionEnd += delta;
        } else if (selectionEnd > start2) {
          selectionEnd = newEnd;
        }
        this.setSelectionRange(selectionStart, selectionEnd);
        break;
    }
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    const valid = this.disabled || this.readOnly || this.type === "hidden" || this.type === "reset" || this.type === "button" || this[validity].valid;
    if (!valid) {
      this.dispatchEvent(new Event("invalid", { bubbles: true, cancelable: true }));
    }
    return valid;
  }
  /**
   * Reports validity.
   *
   * @returns "true" if the field is valid.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * Steps up.
   *
   * @param [increment] Increment.
   */
  stepUp(increment) {
    const newValue = HTMLInputElementValueStepping.step(this.type, this.value, 1, increment);
    if (newValue !== null) {
      this.value = newValue;
    }
  }
  /**
   * Steps down.
   *
   * @param [increment] Increment.
   */
  stepDown(increment) {
    const newValue = HTMLInputElementValueStepping.step(this.type, this.value, -1, increment);
    if (newValue !== null) {
      this.value = newValue;
    }
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[value] = this[value];
    clone2[height] = this[height];
    clone2[width] = this[width];
    clone2[files] = this[files].slice();
    clone2.#selectionStart = this.#selectionStart;
    clone2.#selectionEnd = this.#selectionEnd;
    clone2.#selectionDirection = this.#selectionDirection;
    return clone2;
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    if (event[type] !== "click" || event[eventPhase] !== EventPhaseEnum_default.none || !(event instanceof MouseEvent)) {
      return super.dispatchEvent(event);
    }
    if (this.disabled) {
      return false;
    }
    let previousCheckedValue = null;
    let previousIndeterminateValue = this[indeterminate];
    const type2 = this.type;
    if (type2 === "checkbox" || type2 === "radio") {
      previousCheckedValue = this.checked;
      this.#setChecked(type2 === "checkbox" ? !previousCheckedValue : true);
      if (type2 === "checkbox") {
        previousIndeterminateValue = this[indeterminate];
        this[indeterminate] = false;
      }
    }
    const returnValue2 = super.dispatchEvent(event);
    if (event[type] !== "click" || event[eventPhase] !== EventPhaseEnum_default.none || !(event instanceof MouseEvent)) {
      return returnValue2;
    }
    if (event[defaultPrevented]) {
      if (previousCheckedValue !== null) {
        this.#setChecked(previousCheckedValue);
        this[indeterminate] = previousIndeterminateValue;
      }
    } else {
      const type3 = this.type;
      if (type3 === "checkbox" && this[isConnected]) {
        this.dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));
        this.dispatchEvent(new Event("change", { bubbles: true, cancelable: true }));
      } else if (type3 === "radio" && !previousCheckedValue && this[isConnected]) {
        this.dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));
        this.dispatchEvent(new Event("change", { bubbles: true, cancelable: true }));
      } else if (type3 === "submit" || type3 === "reset") {
        const form = this.form;
        if (form) {
          if (type3 === "submit" && this[isConnected]) {
            form.requestSubmit(this);
          } else if (type3 === "reset") {
            form.reset();
          }
        }
      }
    }
    return returnValue2;
  }
  /**
   * Checks is selection is supported.
   *
   * @returns "true" if selection is supported.
   */
  #isSelectionSupported() {
    const inputType = this.type;
    return inputType === "text" || inputType === "search" || inputType === "url" || inputType === "tel" || inputType === "password";
  }
  /**
   * Sets checked value.
   *
   * @param checked Checked.
   */
  #setChecked(checked2) {
    this[checked] = checked2;
    this[clearCache]();
    if (checked2 && this.type === "radio" && this.name) {
      const root2 = this[formNode] || this.getRootNode();
      const radioButtons = root2.querySelectorAll(`input[type="radio"][name="${this.name}"]`);
      for (const radioButton of radioButtons) {
        if (radioButton !== this) {
          radioButton[checked] = false;
        }
      }
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-text-area-element/HTMLTextAreaElement.js
var HTMLTextAreaElement = class extends HTMLElement {
  type = "textarea";
  // Internal properties
  [validationMessage] = "";
  [validity] = new ValidityState(this);
  [value] = null;
  [textAreaNode] = this;
  [formNode] = null;
  // Private properties
  #selectionStart = null;
  #selectionEnd = null;
  #selectionDirection = HTMLInputElementSelectionDirectionEnum_default.none;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get oninput() {
    return ElementEventAttributeUtility.getEventListener(this, "oninput");
  }
  set oninput(value2) {
    this[propertyEventListeners].set("oninput", value2);
  }
  get onselectionchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onselectionchange");
  }
  set onselectionchange(value2) {
    this[propertyEventListeners].set("onselectionchange", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns the default value.
   *
   * @returns Default value.
   */
  get defaultValue() {
    return this.textContent;
  }
  /**
   * Sets the default value.
   *
   * @param defaultValue Default value.
   */
  set defaultValue(defaultValue2) {
    this.textContent = defaultValue2;
  }
  /**
   * Returns minlength.
   *
   * @returns Min length.
   */
  get minLength() {
    const minLength = this.getAttribute("minlength");
    if (minLength !== null) {
      return parseInt(minLength);
    }
    return -1;
  }
  /**
   * Sets minlength.
   *
   * @param minLength Min length.
   */
  set minLength(minlength) {
    this.setAttribute("minlength", String(minlength));
  }
  /**
   * Returns maxlength.
   *
   * @returns Max length.
   */
  get maxLength() {
    const maxLength = this.getAttribute("maxlength");
    if (maxLength !== null) {
      return parseInt(maxLength);
    }
    return -1;
  }
  /**
   * Sets maxlength.
   *
   * @param maxlength Max length.
   */
  set maxLength(maxLength) {
    this.setAttribute("maxlength", String(maxLength));
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns placeholder.
   *
   * @returns Placeholder.
   */
  get placeholder() {
    return this.getAttribute("placeholder") || "";
  }
  /**
   * Sets placeholder.
   *
   * @param placeholder Placeholder.
   */
  set placeholder(placeholder) {
    this.setAttribute("placeholder", placeholder);
  }
  /**
   * Returns inputmode.
   *
   * @returns Inputmode.
   */
  get inputMode() {
    return this.getAttribute("inputmode") || "";
  }
  /**
   * Sets inputmode.
   *
   * @param inputmode Inputmode.
   */
  set inputMode(inputmode) {
    this.setAttribute("inputmode", inputmode);
  }
  /**
   * Returns cols.
   *
   * @returns Cols.
   */
  get cols() {
    return this.getAttribute("cols") || "";
  }
  /**
   * Sets cols.
   *
   * @param cols Cols.
   */
  set cols(cols) {
    this.setAttribute("cols", cols);
  }
  /**
   * Returns rows.
   *
   * @returns Rows.
   */
  get rows() {
    return this.getAttribute("rows") || "";
  }
  /**
   * Sets rows.
   *
   * @param rows Rows.
   */
  set rows(rows2) {
    this.setAttribute("rows", rows2);
  }
  /**
   * Returns autocomplete.
   *
   * @returns Autocomplete.
   */
  get autocomplete() {
    return this.getAttribute("autocomplete") || "";
  }
  /**
   * Sets autocomplete.
   *
   * @param autocomplete Autocomplete.
   */
  set autocomplete(autocomplete) {
    this.setAttribute("autocomplete", autocomplete);
  }
  /**
   * Returns readOnly.
   *
   * @returns ReadOnly.
   */
  get readOnly() {
    return this.getAttribute("readonly") !== null;
  }
  /**
   * Sets readOnly.
   *
   * @param readOnly ReadOnly.
   */
  set readOnly(readOnly2) {
    if (!readOnly2) {
      this.removeAttribute("readonly");
    } else {
      this.setAttribute("readonly", "");
    }
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    if (!disabled2) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns autofocus.
   *
   * @returns Autofocus.
   */
  get autofocus() {
    return this.getAttribute("autofocus") !== null;
  }
  /**
   * Sets autofocus.
   *
   * @param autofocus Autofocus.
   */
  set autofocus(autofocus) {
    if (!autofocus) {
      this.removeAttribute("autofocus");
    } else {
      this.setAttribute("autofocus", "");
    }
  }
  /**
   * Returns required.
   *
   * @returns Required.
   */
  get required() {
    return this.getAttribute("required") !== null;
  }
  /**
   * Sets required.
   *
   * @param required Required.
   */
  set required(required) {
    if (!required) {
      this.removeAttribute("required");
    } else {
      this.setAttribute("required", "");
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    if (this[value] === null) {
      return this.textContent;
    }
    return this[value];
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    const oldValue = this[value];
    this[value] = value2;
    if (oldValue !== this[value]) {
      this.#selectionStart = this[value].length;
      this.#selectionEnd = this[value].length;
      this.#selectionDirection = HTMLInputElementSelectionDirectionEnum_default.none;
    }
  }
  /**
   * Returns selection start.
   *
   * @returns Selection start.
   */
  get selectionStart() {
    if (this.#selectionStart === null) {
      return this.value.length;
    }
    return this.#selectionStart;
  }
  /**
   * Sets selection start.
   *
   * @param start Start.
   */
  set selectionStart(start2) {
    this.setSelectionRange(start2, Math.max(start2, this.selectionEnd), this.#selectionDirection);
  }
  /**
   * Returns selection end.
   *
   * @returns Selection end.
   */
  get selectionEnd() {
    if (this.#selectionEnd === null) {
      return this.value.length;
    }
    return this.#selectionEnd;
  }
  /**
   * Sets selection end.
   *
   * @param end End.
   */
  set selectionEnd(end2) {
    this.setSelectionRange(this.selectionStart, end2, this.#selectionDirection);
  }
  /**
   * Returns selection direction.
   *
   * @returns Selection direction.
   */
  get selectionDirection() {
    return this.#selectionDirection;
  }
  /**
   * Sets selection direction.
   *
   * @param direction Direction.
   */
  set selectionDirection(direction) {
    this.setSelectionRange(this.selectionStart, this.selectionEnd, direction);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    const id2 = this.getAttribute("form");
    if (!id2 || !this[isConnected]) {
      return null;
    }
    return this[ownerDocument].getElementById(id2);
  }
  /**
   * Returns text length.
   *
   * @param Text Length.
   */
  get textLength() {
    return this.value.length;
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * Selects the text.
   */
  select() {
    this.#selectionStart = 0;
    this.#selectionEnd = this.value.length;
    this.#selectionDirection = HTMLInputElementSelectionDirectionEnum_default.none;
    this.dispatchEvent(new Event("select", { bubbles: true, cancelable: false }));
  }
  /**
   * Set selection range.
   *
   * @param start Start.
   * @param end End.
   * @param [direction="none"] Direction.
   */
  setSelectionRange(start2, end2, direction = "none") {
    this.#selectionEnd = Math.min(end2, this.value.length);
    this.#selectionStart = Math.min(start2, this.selectionEnd);
    this.#selectionDirection = direction === HTMLInputElementSelectionDirectionEnum_default.forward || direction === HTMLInputElementSelectionDirectionEnum_default.backward ? direction : HTMLInputElementSelectionDirectionEnum_default.none;
    this.dispatchEvent(new Event("select", { bubbles: true, cancelable: false }));
  }
  /**
   * Set range text.
   *
   * @param replacement Replacement.
   * @param [start] Start.
   * @param [end] End.
   * @param [direction] Direction.
   * @param selectionMode
   */
  setRangeText(replacement, start2 = null, end2 = null, selectionMode = HTMLInputElementSelectionModeEnum_default.preserve) {
    if (start2 === null) {
      start2 = this.#selectionStart;
    }
    if (end2 === null) {
      end2 = this.#selectionEnd;
    }
    if (start2 > end2) {
      throw new this[window].DOMException("The index is not in the allowed range.", DOMExceptionNameEnum_default.invalidStateError);
    }
    start2 = Math.min(start2, this.value.length);
    end2 = Math.min(end2, this.value.length);
    const val = this.value;
    let selectionStart = this.#selectionStart;
    let selectionEnd = this.#selectionEnd;
    this.value = val.slice(0, start2) + replacement + val.slice(end2);
    const newEnd = start2 + this.value.length;
    switch (selectionMode) {
      case HTMLInputElementSelectionModeEnum_default.select:
        this.setSelectionRange(start2, newEnd);
        break;
      case HTMLInputElementSelectionModeEnum_default.start:
        this.setSelectionRange(start2, start2);
        break;
      case HTMLInputElementSelectionModeEnum_default.end:
        this.setSelectionRange(newEnd, newEnd);
        break;
      default:
        const delta = replacement.length - (end2 - start2);
        if (selectionStart > end2) {
          selectionStart += delta;
        } else if (selectionStart > start2) {
          selectionStart = start2;
        }
        if (selectionEnd > end2) {
          selectionEnd += delta;
        } else if (selectionEnd > start2) {
          selectionEnd = newEnd;
        }
        this.setSelectionRange(selectionStart, selectionEnd);
        break;
    }
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    const valid = this.disabled || this.readOnly || this[validity].valid;
    if (!valid) {
      this.dispatchEvent(new Event("invalid", { bubbles: true, cancelable: true }));
    }
    return valid;
  }
  /**
   * Reports validity.
   *
   * @returns "true" if the field is valid.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[value] = this[value];
    clone2.#selectionStart = this.#selectionStart;
    clone2.#selectionEnd = this.#selectionEnd;
    clone2.#selectionDirection = this.#selectionDirection;
    return clone2;
  }
  /**
   * Resets selection.
   */
  [resetSelection]() {
    if (this[value] === null) {
      this.#selectionStart = null;
      this.#selectionEnd = null;
      this.#selectionDirection = HTMLInputElementSelectionDirectionEnum_default.none;
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-object-element/HTMLObjectElement.js
var HTMLObjectElement = class extends HTMLElement {
  [formNode] = null;
  [validationMessage] = "";
  [validity] = new ValidityState(this);
  /**
   * Returns the content document.
   *
   * @returns Document
   */
  get contentDocument() {
    return null;
  }
  /**
   * Returns the content window.
   *
   * @returns Window
   */
  get contentWindow() {
    return null;
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get data() {
    if (!this.hasAttribute("data")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("data"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("data");
    }
  }
  /**
   * Sets source.
   *
   * @param data Source.
   */
  set data(data2) {
    this.setAttribute("data", data2);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    const id2 = this.getAttribute("form");
    if (!id2 || !this[isConnected]) {
      return null;
    }
    return this[ownerDocument].getElementById(id2);
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this.getAttribute("height") || "";
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this.setAttribute("height", height2);
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this.getAttribute("width") || "";
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this.setAttribute("width", width2);
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns "true" if it will validate.
   *
   * @returns "true" if it will validate.
   */
  get willValidate() {
    return false;
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    return true;
  }
  /**
   * Reports validity.
   *
   * @returns Validity.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
};

// node_modules/happy-dom/lib/nodes/html-output-element/HTMLOutputElement.js
var HTMLOutputElement = class extends HTMLElement {
  [formNode] = null;
  [validationMessage] = "";
  [validity] = new ValidityState(this);
  [defaultValue] = "";
  /**
   * Returns default value.
   *
   * @returns Default value.
   */
  get defaultValue() {
    return this[defaultValue];
  }
  /**
   * Sets default value.
   *
   * @param defaultValue Default value.
   */
  set defaultValue(defaultValue2) {
    this[defaultValue] = defaultValue2;
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    const id2 = this.getAttribute("form");
    if (!id2 || !this[isConnected]) {
      return null;
    }
    return this[ownerDocument].getElementById(id2);
  }
  /**
   * Returns a string containing the ID of the labeled control. This reflects the "for" attribute.
   *
   * @returns ID of the labeled control.
   */
  get htmlFor() {
    return this.getAttribute("for") || "";
  }
  /**
   * Sets a string containing the ID of the labeled control. This reflects the "for" attribute.
   *
   * @param htmlFor ID of the labeled control.
   */
  set htmlFor(htmlFor) {
    this.setAttribute("for", htmlFor);
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    return this.textContent || "";
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    this.textContent = value2;
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return "output";
  }
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns "true" if it will validate.
   *
   * @returns "true" if it will validate.
   */
  get willValidate() {
    return false;
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    return true;
  }
  /**
   * Reports validity.
   *
   * @returns Validity.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
};

// node_modules/happy-dom/lib/validity-state/ValidityState.js
var EMAIL_REGEXP = /^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*$/;
var URL_REGEXP2 = /^(?:(?:https?|HTTPS?|ftp|FTP):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-zA-Z\u00a1-\uffff0-9]-*)*[a-zA-Z\u00a1-\uffff0-9]+)(?:\.(?:[a-zA-Z\u00a1-\uffff0-9]-*)*[a-zA-Z\u00a1-\uffff0-9]+)*)(?::\d{2,5})?(?:[\/?#]\S*)?$/;
var ValidityState = class {
  element;
  /**
   * Constructor.
   *
   * @param element Input element.
   */
  constructor(element) {
    this.element = element;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get badInput() {
    return this.element instanceof HTMLInputElement && (this.element.type === "number" || this.element.type === "range") && this.element.value.length > 0 && !/^[-+]?(?:\d+|\d*[.,]\d+)$/.test(this.element.value);
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get customError() {
    return this.element[validationMessage].length > 0;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get patternMismatch() {
    return this.element instanceof HTMLInputElement && this.element.hasAttribute("pattern") && this.element.value.length > 0 && this.element.value.replace(new RegExp(this.element.getAttribute("pattern")), "").length > 0;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get rangeOverflow() {
    return this.element instanceof HTMLInputElement && this.element.hasAttribute("max") && (this.element.type === "number" || this.element.type === "range") && this.element.value.length > 0 && Number(this.element.value) > Number(this.element.getAttribute("max"));
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get rangeUnderflow() {
    return this.element instanceof HTMLInputElement && this.element.hasAttribute("min") && (this.element.type === "number" || this.element.type === "range") && this.element.value.length > 0 && Number(this.element.value) < Number(this.element.getAttribute("min"));
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get stepMismatch() {
    return this.element instanceof HTMLInputElement && (this.element.type === "number" || this.element.type === "range") && (this.element.hasAttribute("step") && this.element.getAttribute("step") !== "any" && Number(this.element.value) % Number(this.element.getAttribute("step")) !== 0 || !this.element.hasAttribute("step") && Number(this.element.value) % 1 !== 0);
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get tooLong() {
    return (this.element instanceof HTMLInputElement || this.element instanceof HTMLTextAreaElement) && this.element.maxLength > 0 && this.element.value.length > this.element.maxLength;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get tooShort() {
    return (this.element instanceof HTMLInputElement || this.element instanceof HTMLTextAreaElement) && this.element.minLength > 0 && this.element.value.length > 0 && this.element.value.length < this.element.minLength;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get typeMismatch() {
    return this.element instanceof HTMLInputElement && this.element.value.length > 0 && (this.element.type === "email" && !EMAIL_REGEXP.test(this.element.value) || this.element.type === "url" && !URL_REGEXP2.test(this.element.value));
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get valueMissing() {
    if (!this.element.required || this.element instanceof HTMLObjectElement || this.element instanceof HTMLOutputElement) {
      return false;
    }
    if (this.element instanceof HTMLInputElement) {
      if (this.element.type === "checkbox") {
        return !this.element.checked;
      } else if (this.element.type === "radio") {
        if (this.element.checked) {
          return false;
        }
        if (!this.element.name) {
          return true;
        }
        const root2 = this.element[formNode] || this.element.getRootNode();
        return !root2 || !root2.querySelector(`input[name="${this.element.name}"]:checked`);
      }
    }
    return this.element.value.length === 0;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get valid() {
    return !this.badInput && !this.customError && !this.patternMismatch && !this.rangeOverflow && !this.rangeUnderflow && !this.stepMismatch && !this.tooLong && !this.tooShort && !this.typeMismatch && !this.valueMissing;
  }
};

// node_modules/happy-dom/lib/nodes/html-button-element/HTMLButtonElement.js
import { URL as URL10 } from "url";
var BUTTON_TYPES = ["submit", "reset", "button", "menu"];
var HTMLButtonElement = class extends HTMLElement {
  [validationMessage] = "";
  [validity] = new ValidityState(this);
  [formNode] = null;
  [popoverTargetElement] = null;
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    return this.getAttribute("value");
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    this.setAttribute("value", value2);
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    if (!disabled2) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns type
   *
   * @returns Type
   */
  get type() {
    const type2 = this.getAttribute("type");
    if (type2 === null || !BUTTON_TYPES.includes(type2)) {
      return "submit";
    }
    return type2;
  }
  /**
   * Sets type
   *
   * @param value Type
   */
  set type(value2) {
    this.setAttribute("type", value2);
  }
  /**
   * Returns form action.
   *
   * @returns Form action.
   */
  get formAction() {
    if (!this.hasAttribute("formaction")) {
      return this[ownerDocument].location.href;
    }
    try {
      return new URL10(this.getAttribute("formaction"), this[ownerDocument].location.href).href;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets form action.
   *
   * @param formAction Form action.
   */
  set formAction(formAction) {
    this.setAttribute("formaction", formAction);
  }
  /**
   * Returns form enctype.
   *
   * @returns Form enctype.
   */
  get formEnctype() {
    return this.getAttribute("formenctype") || "";
  }
  /**
   * Sets form enctype.
   *
   * @param formEnctype Form enctype.
   */
  set formEnctype(formEnctype) {
    this.setAttribute("formenctype", formEnctype);
  }
  /**
   * Returns form method.
   *
   * @returns Form method.
   */
  get formMethod() {
    return this.getAttribute("formmethod") || "";
  }
  /**
   * Sets form method.
   *
   * @param formMethod Form method.
   */
  set formMethod(formMethod) {
    this.setAttribute("formmethod", formMethod);
  }
  /**
   * Returns no validate.
   *
   * @returns No validate.
   */
  get formNoValidate() {
    return this.getAttribute("formnovalidate") !== null;
  }
  /**
   * Sets no validate.
   *
   * @param formNoValidate No validate.
   */
  set formNoValidate(formNoValidate) {
    if (!formNoValidate) {
      this.removeAttribute("formnovalidate");
    } else {
      this.setAttribute("formnovalidate", "");
    }
  }
  /**
   * Returns form target.
   *
   * @returns Form target.
   */
  get formTarget() {
    return this.getAttribute("formtarget") || "";
  }
  /**
   * Sets form target.
   *
   * @param formTarget Form target.
   */
  set formTarget(formTarget) {
    this.setAttribute("formtarget", formTarget);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    const id2 = this.getAttribute("form");
    if (!id2 || !this[isConnected]) {
      return null;
    }
    return this[ownerDocument].getElementById(id2);
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * Returns popover target element.
   *
   * @returns Popover target element.
   */
  get popoverTargetElement() {
    return this[popoverTargetElement];
  }
  /**
   * Sets popover target element.
   *
   * @param popoverTargetElement Popover target element.
   */
  set popoverTargetElement(popoverTargetElement2) {
    if (popoverTargetElement2 !== null && !(popoverTargetElement2 instanceof HTMLElement)) {
      throw new this[window].TypeError(`Failed to set the 'popoverTargetElement' property on 'HTMLInputElement': Failed to convert value to 'Element'.`);
    }
    this[popoverTargetElement] = popoverTargetElement2;
  }
  /**
   * Returns popover target action.
   *
   * @returns Popover target action.
   */
  get popoverTargetAction() {
    const value2 = this.getAttribute("popovertargetaction");
    if (value2 === null || value2 !== "hide" && value2 !== "show" && value2 !== "toggle") {
      return "toggle";
    }
    return value2;
  }
  /**
   * Sets popover target action.
   *
   * @param value Popover target action.
   */
  set popoverTargetAction(value2) {
    this.setAttribute("popovertargetaction", value2);
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    const valid = this.disabled || this.type === "reset" || this.type === "button" || this[validity].valid;
    if (!valid) {
      this.dispatchEvent(new Event("invalid", { bubbles: true, cancelable: true }));
    }
    return valid;
  }
  /**
   * Reports validity.
   *
   * @returns Validity.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    if (event.type === "click" && event instanceof MouseEvent && event.eventPhase === EventPhaseEnum_default.none && this.disabled) {
      return false;
    }
    const returnValue2 = super.dispatchEvent(event);
    if (!event[defaultPrevented] && event.type === "click" && event.eventPhase === EventPhaseEnum_default.none && event instanceof MouseEvent) {
      const type2 = this.type;
      if (type2 === "submit" || type2 === "reset") {
        const form = this.form;
        if (form) {
          if (type2 === "submit" && this[isConnected]) {
            form.requestSubmit(this);
          } else if (type2 === "reset") {
            form.reset();
          }
        }
      }
    }
    return returnValue2;
  }
};

// node_modules/happy-dom/lib/nodes/html-canvas-element/ImageBitmap.js
var ImageBitmap = class {
  height;
  width;
  /**
   * Constructor.
   *
   * @param width Width.
   * @param height Height.
   */
  constructor(width2, height2) {
    this.width = width2;
    this.height = height2;
  }
  /**
   * Disposes of all graphical resources associated with an ImageBitmap.
   */
  close() {
  }
};

// node_modules/happy-dom/lib/nodes/html-canvas-element/OffscreenCanvas.js
var OffscreenCanvas = class {
  width;
  height;
  /**
   * Constructor.
   *
   * @param width Width.
   * @param height Height.
   */
  constructor(width2, height2) {
    this.width = width2;
    this.height = height2;
  }
  /**
   * Returns context.
   *
   * @param _contextType Context type.
   * @param [_contextAttributes] Context attributes.
   * @returns Context.
   */
  getContext(_contextType, _contextAttributes) {
    return null;
  }
  /**
   * Converts the canvas to a Blob.
   *
   * @param [_options] Options.
   * @param [_options.type] Type.
   * @param [_options.quality] Quality.
   * @returns Blob.
   */
  async convertToBlob(_options) {
    return new Blob([]);
  }
  /**
   * Creates an ImageBitmap object from the most recently rendered image of the OffscreenCanvas.
   *
   * @returns ImageBitmap.
   */
  transferToImageBitmap() {
    return new ImageBitmap(this.width, this.height);
  }
};

// node_modules/happy-dom/lib/nodes/html-canvas-element/HTMLCanvasElement.js
var DEVICE_ID = "S3F/aBCdEfGHIjKlMnOpQRStUvWxYz1234567890+1AbC2DEf2GHi3jK34le+ab12C3+1aBCdEf==";
var HTMLCanvasElement = class extends HTMLElement {
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get oncontextlost() {
    return ElementEventAttributeUtility.getEventListener(this, "oncontextlost");
  }
  set oncontextlost(value2) {
    this[propertyEventListeners].set("oncontextlost", value2);
  }
  get oncontextrestored() {
    return ElementEventAttributeUtility.getEventListener(this, "oncontextrestored");
  }
  set oncontextrestored(value2) {
    this[propertyEventListeners].set("oncontextrestored", value2);
  }
  get onwebglcontextcreationerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onwebglcontextcreationerror");
  }
  set onwebglcontextcreationerror(value2) {
    this[propertyEventListeners].set("onwebglcontextcreationerror", value2);
  }
  get onwebglcontextlost() {
    return ElementEventAttributeUtility.getEventListener(this, "onwebglcontextlost");
  }
  set onwebglcontextlost(value2) {
    this[propertyEventListeners].set("onwebglcontextlost", value2);
  }
  get onwebglcontextrestored() {
    return ElementEventAttributeUtility.getEventListener(this, "onwebglcontextrestored");
  }
  set onwebglcontextrestored(value2) {
    this[propertyEventListeners].set("onwebglcontextrestored", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    const width2 = this.getAttribute("width");
    return width2 !== null ? Number(width2) : 300;
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this.setAttribute("width", String(width2));
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    const height2 = this.getAttribute("height");
    return height2 !== null ? Number(height2) : 150;
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this.setAttribute("height", String(height2));
  }
  /**
   * Returns capture stream.
   *
   * @param [frameRate] Frame rate.
   * @returns Capture stream.
   */
  captureStream(frameRate) {
    const stream = new this[window].MediaStream();
    const track2 = new this[window].CanvasCaptureMediaStreamTrack(illegalConstructor, this);
    track2[kind] = "video";
    track2[capabilities].deviceId = DEVICE_ID;
    track2[capabilities].aspectRatio.max = this.width;
    track2[capabilities].height.max = this.height;
    track2[capabilities].width.max = this.width;
    track2[settings].deviceId = DEVICE_ID;
    if (frameRate !== void 0) {
      track2[capabilities].frameRate.max = frameRate;
      track2[settings].frameRate = frameRate;
    }
    stream.addTrack(track2);
    return stream;
  }
  /**
   * Returns context.
   *
   * @param _contextType Context type.
   * @param [_contextAttributes] Context attributes.
   * @returns Context.
   */
  getContext(_contextType, _contextAttributes) {
    return null;
  }
  /**
   * Returns to data URL.
   *
   * @param [_type] Type.
   * @param [_encoderOptions] Quality.
   * @returns Data URL.
   */
  toDataURL(_type, _encoderOptions) {
    return "";
  }
  /**
   * Returns to blob.
   *
   * @param callback Callback.
   * @param [_type] Type.
   * @param [_quality] Quality.
   */
  toBlob(callback, _type, _quality) {
    callback(new Blob([]));
  }
  /**
   * Transfers control to offscreen.
   *
   * @returns Offscreen canvas.
   */
  transferControlToOffscreen() {
    return new OffscreenCanvas(this.width, this.height);
  }
};

// node_modules/happy-dom/lib/nodes/html-d-list-element/HTMLDListElement.js
var HTMLDListElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-data-element/HTMLDataElement.js
var HTMLDataElement = class extends HTMLElement {
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    return this.getAttribute("value") || "";
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    this.setAttribute("value", value2);
  }
};

// node_modules/happy-dom/lib/nodes/html-data-list-element/HTMLDataListElement.js
var HTMLDataListElement = class extends HTMLElement {
  [options] = null;
  /**
   * Returns options.
   *
   * @returns Options.
   */
  get options() {
    if (!this[options]) {
      this[options] = ParentNodeUtility.getElementsByTagName(this, "OPTION");
    }
    return this[options];
  }
};

// node_modules/happy-dom/lib/nodes/html-details-element/HTMLDetailsElement.js
var HTMLDetailsElement = class extends HTMLElement {
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get ontoggle() {
    return ElementEventAttributeUtility.getEventListener(this, "ontoggle");
  }
  set ontoggle(value2) {
    this[propertyEventListeners].set("ontoggle", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns the open attribute.
   */
  get open() {
    return this.getAttribute("open") !== null;
  }
  /**
   * Sets the open attribute.
   *
   * @param open New value.
   */
  set open(open) {
    if (open) {
      this.setAttribute("open", "");
    } else {
      this.removeAttribute("open");
    }
  }
  /**
   * @override
   */
  [onSetAttribute](attribute, replacedAttribute) {
    super[onSetAttribute](attribute, replacedAttribute);
    if (attribute[name] === "open") {
      if (attribute[value] !== replacedAttribute?.[value]) {
        this.dispatchEvent(new Event("toggle"));
      }
    }
  }
  /**
   * @override
   */
  [onRemoveAttribute](removedAttribute) {
    super[onRemoveAttribute](removedAttribute);
    if (removedAttribute && removedAttribute[name] === "open") {
      this.dispatchEvent(new Event("toggle"));
    }
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    const returnValue2 = super.dispatchEvent(event);
    if (!event[defaultPrevented] && event[target]?.[localName] === "summary" && event.type === "click" && event.eventPhase === EventPhaseEnum_default.bubbling && event instanceof MouseEvent) {
      this.open = !this.open;
    }
    return returnValue2;
  }
};

// node_modules/happy-dom/lib/nodes/html-dialog-element/HTMLDialogElement.js
var HTMLDialogElement = class extends HTMLElement {
  // Internal properties
  [returnValue] = "";
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get oncancel() {
    return ElementEventAttributeUtility.getEventListener(this, "oncancel");
  }
  set oncancel(value2) {
    this[propertyEventListeners].set("oncancel", value2);
  }
  get onclose() {
    return ElementEventAttributeUtility.getEventListener(this, "onclose");
  }
  set onclose(value2) {
    this[propertyEventListeners].set("onclose", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns return value.
   *
   * @returns Return value.
   */
  get returnValue() {
    return this[returnValue];
  }
  /**
   * Sets return value.
   *
   * @param value Return value.
   */
  set returnValue(value2) {
    this[returnValue] = String(value2);
  }
  /**
   * Sets the "open" attribute.
   *
   * @param open Open.
   */
  set open(open) {
    if (open) {
      this.setAttribute("open", "");
    } else {
      this.removeAttribute("open");
    }
  }
  /**
   * Returns open.
   *
   * @returns Open.
   */
  get open() {
    return this.getAttribute("open") !== null;
  }
  /**
   * Closes the dialog.
   *
   * @param [returnValue] ReturnValue.
   */
  close(returnValue2) {
    const wasOpen = this.open;
    this.removeAttribute("open");
    this.returnValue = returnValue2 !== void 0 ? String(returnValue2) : "";
    if (wasOpen) {
      this.dispatchEvent(new Event("close"));
    }
  }
  /**
   * Shows the modal.
   */
  showModal() {
    this.setAttribute("open", "");
  }
  /**
   * Shows the dialog.
   */
  show() {
    this.setAttribute("open", "");
  }
};

// node_modules/happy-dom/lib/nodes/html-div-element/HTMLDivElement.js
var HTMLDivElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-embed-element/HTMLEmbedElement.js
var HTMLEmbedElement = class extends HTMLElement {
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this.getAttribute("height") || "";
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this.setAttribute("height", height2);
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this.getAttribute("width") || "";
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this.setAttribute("width", width2);
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
};

// node_modules/happy-dom/lib/nodes/html-field-set-element/HTMLFieldSetElement.js
var HTMLFieldSetElement = class extends HTMLElement {
  // Internal properties
  [elements] = null;
  [formNode] = null;
  /**
   * Returns elements.
   *
   * @returns Elements.
   */
  get elements() {
    if (!this[elements]) {
      this[elements] = new HTMLCollection(illegalConstructor, () => QuerySelector.querySelectorAll(this, "input,button,textarea,select")[items]);
    }
    return this[elements];
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    const id2 = this.getAttribute("form");
    if (!id2 || !this[isConnected]) {
      return null;
    }
    return this[ownerDocument].getElementById(id2);
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns type "fieldset".
   *
   * @returns Type.
   */
  get type() {
    return "fieldset";
  }
  /**
   * Returns empty string as fieldset never candidates for constraint validation.
   */
  get validationMessage() {
    return "";
  }
  /**
   * Returns will validate state.
   *
   * Always returns false as fieldset never candidates for constraint validation.
   *
   * @returns Will validate state.
   */
  get willValidate() {
    return false;
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    if (!disabled2) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Checks validity.
   *
   * Always returns true as fieldset never candidates for constraint validation.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    return true;
  }
  /**
   * Reports validity.
   *
   * Always returns true as fieldset never candidates for constraint validation.
   *
   * @returns Validity.
   */
  reportValidity() {
    return true;
  }
  /**
   * Sets validation message.
   *
   * Does nothing as fieldset never candidates for constraint validation.
   *
   * @param _message Message.
   */
  setCustomValidity(_message) {
  }
};

// node_modules/happy-dom/lib/nodes/html-form-element/HTMLFormControlsCollection.js
var HTMLFormControlsCollection = class extends HTMLCollection {
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param ownerElement Form element.
   */
  constructor(illegalConstructorSymbol, ownerElement2) {
    super(illegalConstructorSymbol, () => ownerElement2[getFormControlItems]());
    this[ownerElement] = ownerElement2;
  }
  /**
   * @override
   */
  namedItem(name2) {
    return this[ownerElement][getFormControlNamedItem](name2);
  }
};

// node_modules/happy-dom/lib/browser/utilities/BrowserFrameFactory.js
var BrowserFrameFactory = class {
  /**
   * Creates a new frame.
   *
   * @param parentFrame Parent frame.
   * @returns Frame.
   */
  static createChildFrame(parentFrame) {
    const frame = new parentFrame.constructor(parentFrame.page);
    frame.parentFrame = parentFrame;
    parentFrame.childFrames.push(frame);
    return frame;
  }
  /**
   * Aborts all ongoing operations and destroys the frame.
   *
   * @param frame Frame.
   */
  static destroyFrame(frame) {
    const exceptionObserver2 = frame.page?.context?.browser?.[exceptionObserver];
    return new Promise((resolve, reject) => {
      if (!frame.window) {
        resolve();
        return;
      }
      if (frame.parentFrame) {
        const index = frame.parentFrame.childFrames.indexOf(frame);
        if (index !== -1) {
          frame.parentFrame.childFrames.splice(index, 1);
        }
      }
      if (!frame.childFrames.length) {
        frame[asyncTaskManager].destroy().then(() => {
          if (exceptionObserver2 && frame.window) {
            exceptionObserver2.disconnect(frame.window);
          }
          frame.page = null;
          frame.window = null;
          frame[openerFrame] = null;
          frame[openerWindow] = null;
          resolve();
        }).catch((error2) => reject(error2));
        if (frame.window) {
          frame.window[destroy]();
        }
        return;
      }
      Promise.all(frame.childFrames.slice().map((childFrame) => this.destroyFrame(childFrame))).then(() => {
        frame[asyncTaskManager].destroy().then(() => {
          if (exceptionObserver2 && frame.window) {
            exceptionObserver2.disconnect(frame.window);
          }
          frame.page = null;
          frame.window = null;
          frame[openerFrame] = null;
          frame[openerWindow] = null;
          resolve();
        }).catch((error2) => reject(error2));
        if (frame.window) {
          frame.window[destroy]();
        }
      }).catch((error2) => reject(error2));
    });
  }
};

// node_modules/happy-dom/lib/browser/enums/BrowserNavigationCrossOriginPolicyEnum.js
var BrowserNavigationCrossOriginPolicyEnum;
(function(BrowserNavigationCrossOriginPolicyEnum2) {
  BrowserNavigationCrossOriginPolicyEnum2["anyOrigin"] = "anyOrigin";
  BrowserNavigationCrossOriginPolicyEnum2["sameOrigin"] = "sameOrigin";
  BrowserNavigationCrossOriginPolicyEnum2["strictOrigin"] = "strictOrigin";
})(BrowserNavigationCrossOriginPolicyEnum || (BrowserNavigationCrossOriginPolicyEnum = {}));
var BrowserNavigationCrossOriginPolicyEnum_default = BrowserNavigationCrossOriginPolicyEnum;

// node_modules/happy-dom/lib/browser/utilities/BrowserFrameScriptEvaluator.js
import { Script } from "vm";
var BrowserFrameScriptEvaluator = class {
  /**
   * Evaluates code or a VM Script in the frame's context.
   *
   * @param frame Frame.
   * @param script Script.
   * @returns Result.
   */
  static evaluate(frame, script) {
    if (!frame.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    script = typeof script === "string" ? new Script(script) : script;
    return script.runInContext(frame.window);
  }
};

// node_modules/happy-dom/lib/browser/detached-browser/DetachedBrowserFrame.js
var DetachedBrowserFrame = class {
  childFrames = [];
  parentFrame = null;
  page;
  // Needs to be injected from the outside when the browser frame is constructed.
  window;
  [asyncTaskManager] = new AsyncTaskManager(this);
  [listeners] = { navigation: [] };
  [openerFrame] = null;
  [openerWindow] = null;
  [popup] = false;
  [history] = [
    {
      title: "",
      href: "about:blank",
      state: null,
      scrollRestoration: HistoryScrollRestorationEnum_default.auto,
      method: "GET",
      formData: null,
      isCurrent: true
    }
  ];
  /**
   * Constructor.
   *
   * @param page Page.
   * @param [window] Window.
   */
  constructor(page) {
    this.page = page;
    if (page.context.browser.contexts[0]?.pages[0]?.mainFrame) {
      this.window = new this.page.context.browser.windowClass(this);
    }
    if (page.context.browser[exceptionObserver]) {
      page.context.browser[exceptionObserver].observe(this.window);
    }
  }
  /**
   * Returns the content.
   *
   * @returns Content.
   */
  get content() {
    if (!this.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    return this.window.document.documentElement.outerHTML;
  }
  /**
   * Sets the content.
   *
   * @param content Content.
   */
  set content(content2) {
    if (!this.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    this.window.document[isFirstWrite] = true;
    this.window.document[isFirstWriteAfterOpen] = false;
    this.window.document.open();
    this.window.document.write(content2);
  }
  /**
   * Returns the URL.
   *
   * @returns URL.
   */
  get url() {
    if (!this.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    return this.window.location.href;
  }
  /**
   * Sets the content.
   *
   * @param url URL.
   */
  set url(url2) {
    if (!this.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    this.window[location][setURL](this, BrowserFrameURL.getRelativeURL(this, url2).href);
  }
  /**
   * Returns document.
   *
   * @returns Document.
   */
  get document() {
    return this.window?.document ?? null;
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   */
  async waitUntilComplete() {
    await Promise.all([
      this[asyncTaskManager].waitUntilComplete(),
      ...this.childFrames.map((frame) => frame.waitUntilComplete())
    ]);
  }
  /**
   * Returns a promise that is resolved when the frame has navigated and the response HTML has been written to the document.
   */
  waitForNavigation() {
    return new Promise((resolve) => this[listeners].navigation.push(resolve));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    if (!this.childFrames.length) {
      return this[asyncTaskManager].abort();
    }
    return new Promise((resolve, reject) => {
      Promise.all(this.childFrames.map((frame) => frame.abort()).concat([this[asyncTaskManager].abort()])).then(() => resolve()).catch(reject);
    });
  }
  /**
   * Evaluates code or a VM Script in the page's context.
   *
   * @param script Script.
   * @returns Result.
   */
  evaluate(script) {
    return BrowserFrameScriptEvaluator.evaluate(this, script);
  }
  /**
   * Go to a page.
   *
   * @param url URL.
   * @param [options] Options.
   * @returns Response.
   */
  goto(url2, options2) {
    return BrowserFrameNavigator.navigate({
      windowClass: this.page.context.browser.windowClass,
      frame: this,
      url: url2,
      goToOptions: options2
    });
  }
  /**
   * Navigates back in history.
   *
   * @param [options] Options.
   */
  goBack(options2) {
    return BrowserFrameNavigator.navigateBack({
      windowClass: this.page.context.browser.windowClass,
      frame: this,
      goToOptions: options2
    });
  }
  /**
   * Navigates forward in history.
   *
   * @param [options] Options.
   */
  goForward(options2) {
    return BrowserFrameNavigator.navigateForward({
      windowClass: this.page.context.browser.windowClass,
      frame: this,
      goToOptions: options2
    });
  }
  /**
   * Navigates a delta in history.
   *
   * @param steps Steps.
   * @param [options] Options.
   */
  goSteps(steps, options2) {
    return BrowserFrameNavigator.navigateSteps({
      windowClass: this.page.context.browser.windowClass,
      frame: this,
      steps,
      goToOptions: options2
    });
  }
  /**
   * Reloads the current frame.
   *
   * @param [options] Options.
   * @returns Response.
   */
  reload(options2) {
    return BrowserFrameNavigator.reload({
      windowClass: this.page.context.browser.windowClass,
      frame: this,
      goToOptions: options2
    });
  }
};

// node_modules/happy-dom/lib/browser/utilities/BrowserFrameValidator.js
var BrowserFrameValidator = class {
  /**
   * Returns true if the frame navigation complies with the cross origin policy.
   *
   * @param frame Frame.
   * @param toURL URL.
   * @returns True if the frame navigation complies with the cross origin policy.
   */
  static validateCrossOriginPolicy(frame, toURL) {
    const settings2 = frame.page.context.browser.settings;
    let fromURL = frame.page.mainFrame.window.location;
    if (frame[openerFrame]) {
      fromURL = frame[openerFrame].window.location;
    } else if (frame.parentFrame) {
      fromURL = frame.parentFrame.window.location;
    }
    if (settings2.navigation.crossOriginPolicy === BrowserNavigationCrossOriginPolicyEnum_default.sameOrigin && fromURL.protocol !== "about:" && toURL.protocol !== "about:" && toURL.protocol !== "javascript:" && fromURL.origin !== toURL.origin) {
      return false;
    }
    if (settings2.navigation.crossOriginPolicy === BrowserNavigationCrossOriginPolicyEnum_default.strictOrigin && fromURL.protocol === "https:" && toURL.protocol === "http:") {
      return false;
    }
    return true;
  }
  /**
   * Returns true if navigation is allowed for the frame.
   *
   * @param frame Frame.
   * @returns True if navigation is allowed for the frame.
   */
  static validateFrameNavigation(frame) {
    const settings2 = frame.page.context.browser.settings;
    if (frame instanceof DetachedBrowserFrame && frame.page.context === frame.page.context.browser.defaultContext && frame.page.context.pages[0] === frame.page && frame.page.mainFrame === frame) {
      return false;
    }
    if (settings2.navigation.disableMainFrameNavigation && frame.page.mainFrame === frame) {
      return false;
    }
    if (settings2.navigation.disableChildFrameNavigation && frame.page.mainFrame !== frame) {
      return false;
    }
    if (settings2.navigation.disableChildPageNavigation && !!frame[openerFrame]) {
      return false;
    }
    return true;
  }
};

// node_modules/happy-dom/lib/browser/utilities/BrowserFrameNavigator.js
var BrowserFrameNavigator = class _BrowserFrameNavigator {
  /**
   * Navigates to a page.
   *
   * @throws Error if the request can't be resolved (because of SSL error or similar). It will not throw if the response is not ok.
   * @param options Options.
   * @param options.windowClass Window class.
   * @param options.frame Frame.
   * @param options.url URL.
   * @param [options.goToOptions] Go to options.
   * @param [options.method] Method.
   * @param [options.formData] Form data.
   * @param [options.disableHistory] Disables adding the navigation to the history.
   * @returns Response.
   */
  static async navigate(options2) {
    const { windowClass, frame, url: url2, formData, method: method2, goToOptions, disableHistory } = options2;
    const exceptionObserver2 = frame.page.context.browser[exceptionObserver];
    const referrer2 = goToOptions?.referrer || frame.window.location.origin;
    const targetURL = BrowserFrameURL.getRelativeURL(frame, url2);
    const resolveNavigationListeners = () => {
      const listeners2 = frame[listeners].navigation;
      frame[listeners].navigation = [];
      for (const listener of listeners2) {
        listener();
      }
    };
    if (!frame.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    if (targetURL.protocol === "javascript:") {
      if (frame && !frame.page.context.browser.settings.disableJavaScriptEvaluation) {
        const readyStateManager3 = frame.window[readyStateManager];
        readyStateManager3.startTask();
        const code = "//# sourceURL=" + frame.url + "\n" + targetURL.href.replace("javascript:", "");
        await new Promise((resolve) => {
          frame.window.requestAnimationFrame(() => {
            frame.window.requestAnimationFrame(resolve);
            frame.window.eval(code);
          });
        });
        readyStateManager3.endTask();
        resolveNavigationListeners();
      }
      return null;
    }
    if (!BrowserFrameValidator.validateCrossOriginPolicy(frame, targetURL)) {
      return null;
    }
    if (!BrowserFrameValidator.validateFrameNavigation(frame)) {
      if (!frame.page.context.browser.settings.navigation.disableFallbackToSetURL) {
        frame.window.location[setURL](frame, targetURL.href);
      }
      return null;
    }
    if (!disableHistory) {
      const history2 = frame[history];
      for (let i = history2.length - 1; i >= 0; i--) {
        if (history2[i].isCurrent) {
          history2[i].isCurrent = false;
          history2.length = i + 1;
          break;
        }
      }
      history2.push({
        title: "",
        href: targetURL.href,
        state: null,
        scrollRestoration: HistoryScrollRestorationEnum_default.auto,
        method: method2 || (formData ? "POST" : "GET"),
        formData: formData || null,
        isCurrent: true
      });
    }
    const previousWindow = frame.window;
    const previousAsyncTaskManager = frame[asyncTaskManager];
    const width2 = previousWindow.innerWidth;
    const height2 = previousWindow.innerHeight;
    const devicePixelRatio = previousWindow.devicePixelRatio;
    const parentWindow = frame.parentFrame ? frame.parentFrame.window : frame.page.mainFrame.window;
    const topWindow = frame.page.mainFrame.window;
    frame[asyncTaskManager] = new AsyncTaskManager(frame);
    frame.window = new windowClass(frame, { url: targetURL.href, width: width2, height: height2 });
    frame.window[parent] = parentWindow;
    frame.window[top] = topWindow;
    frame.window.devicePixelRatio = devicePixelRatio;
    if (exceptionObserver2) {
      exceptionObserver2.observe(frame.window);
    }
    if (referrer2) {
      frame.window.document[referrer] = referrer2;
    }
    const destroyTaskID = frame[asyncTaskManager].startTask();
    const destroyWindowAndAsyncTaskManager = () => {
      previousAsyncTaskManager.destroy().then(() => {
        if (exceptionObserver2) {
          exceptionObserver2.disconnect(previousWindow);
        }
        frame[asyncTaskManager].endTask(destroyTaskID);
      });
      previousWindow[destroy]();
    };
    if (frame.childFrames.length) {
      Promise.all(frame.childFrames.map((childFrame) => BrowserFrameFactory.destroyFrame(childFrame))).then(destroyWindowAndAsyncTaskManager);
    } else {
      destroyWindowAndAsyncTaskManager();
    }
    if (targetURL.protocol === "about:") {
      await new Promise((resolve) => frame.page.mainFrame.window.requestAnimationFrame(resolve));
      resolveNavigationListeners();
      return null;
    }
    const readyStateManager2 = frame.window[readyStateManager];
    const abortController = new frame.window.AbortController();
    const timeout = frame.window.setTimeout(() => abortController.abort(new frame.window.DOMException("The operation was aborted. Request timed out.", DOMExceptionNameEnum_default.timeoutError)), goToOptions?.timeout ?? 3e4);
    const finalize = () => {
      frame.window.clearTimeout(timeout);
      readyStateManager2.endTask();
      resolveNavigationListeners();
    };
    let response;
    let responseText;
    readyStateManager2.startTask();
    try {
      response = await frame.window.fetch(targetURL.href, {
        referrer: referrer2,
        referrerPolicy: goToOptions?.referrerPolicy || "origin",
        signal: abortController.signal,
        method: method2 || (formData ? "POST" : "GET"),
        headers: goToOptions?.hard ? { "Cache-Control": "no-cache" } : void 0,
        body: formData
      });
      if (frame.parentFrame) {
        const originURL = frame.parentFrame.window.location;
        const xFrameOptions = response.headers?.get("X-Frame-Options")?.toLowerCase();
        const isSameOrigin = originURL.origin === targetURL.origin || targetURL.origin === "null";
        if (xFrameOptions === "deny" || xFrameOptions === "sameorigin" && !isSameOrigin) {
          throw new Error(`Refused to display '${url2}' in a frame because it set 'X-Frame-Options' to '${xFrameOptions}'.`);
        }
      }
      responseText = await response.text();
    } catch (error2) {
      finalize();
      throw error2;
    }
    if (response.url) {
      frame.window[location][setURL](frame, response.url);
    }
    if (!response.ok) {
      frame.page.console.error(`GET ${targetURL.href} ${response.status} (${response.statusText})`);
    }
    if (!frame.window) {
      return null;
    }
    await new Promise((resolve) => {
      frame.window.requestAnimationFrame(() => {
        frame.window.requestAnimationFrame(resolve);
        frame.content = responseText;
      });
    });
    finalize();
    return response;
  }
  /**
   * Navigates back in history.
   *
   * @param options Options.
   * @param options.windowClass Window class.
   * @param options.frame Frame.
   * @param [options.goToOptions] Go to options.
   */
  static navigateBack(options2) {
    const { windowClass, frame, goToOptions } = options2;
    const history2 = frame[history];
    let historyItem;
    for (let i = history2.length - 1; i >= 0; i--) {
      if (history2[i].isCurrent) {
        if (i > 0) {
          history2[i].isCurrent = false;
          historyItem = history2[i - 1];
        }
        break;
      }
    }
    if (!historyItem) {
      return new Promise((resolve) => {
        frame.window.requestAnimationFrame(() => {
          const listeners2 = frame[listeners].navigation;
          frame[listeners].navigation = [];
          for (const listener of listeners2) {
            listener();
          }
          resolve(null);
        });
      });
    }
    historyItem.isCurrent = true;
    return _BrowserFrameNavigator.navigate({
      windowClass,
      frame,
      goToOptions: {
        ...goToOptions,
        referrer: frame.url
      },
      url: historyItem.href,
      method: historyItem.method,
      formData: historyItem.formData,
      disableHistory: true
    });
  }
  /**
   * Navigates forward in history.
   *
   * @param options Options.
   * @param options.windowClass Window class.
   * @param options.frame Frame.
   * @param [options.goToOptions] Go to options.
   */
  static navigateForward(options2) {
    const { windowClass, frame, goToOptions } = options2;
    const history2 = frame[history];
    let historyItem;
    for (let i = history2.length - 1; i >= 0; i--) {
      if (history2[i].isCurrent) {
        if (i < history2.length - 1) {
          history2[i].isCurrent = false;
          historyItem = history2[i + 1];
        }
        break;
      }
    }
    if (!historyItem) {
      return new Promise((resolve) => {
        frame.window.requestAnimationFrame(() => {
          const listeners2 = frame[listeners].navigation;
          frame[listeners].navigation = [];
          for (const listener of listeners2) {
            listener();
          }
          resolve(null);
        });
      });
    }
    historyItem.isCurrent = true;
    return _BrowserFrameNavigator.navigate({
      windowClass,
      frame,
      goToOptions: {
        ...goToOptions,
        referrer: frame.url
      },
      url: historyItem.href,
      method: historyItem.method,
      formData: historyItem.formData,
      disableHistory: true
    });
  }
  /**
   * Navigates steps in history.
   *
   * @param options Options.
   * @param options.windowClass Window class.
   * @param options.frame Frame.
   * @param options.goToOptions Go to options.
   * @param options.steps Steps.
   */
  static navigateSteps(options2) {
    if (!options2.steps) {
      return this.reload(options2);
    }
    const { windowClass, frame, goToOptions, steps } = options2;
    const history2 = frame[history];
    let historyItem;
    for (let i = history2.length - 1; i >= 0; i--) {
      if (history2[i].isCurrent) {
        if (history2[i + steps]) {
          history2[i].isCurrent = false;
          historyItem = history2[i + steps];
        }
        break;
      }
    }
    if (!historyItem) {
      return new Promise((resolve) => {
        frame.window.requestAnimationFrame(() => {
          const listeners2 = frame[listeners].navigation;
          frame[listeners].navigation = [];
          for (const listener of listeners2) {
            listener();
          }
          resolve(null);
        });
      });
    }
    historyItem.isCurrent = true;
    return _BrowserFrameNavigator.navigate({
      windowClass,
      frame,
      goToOptions: {
        ...goToOptions,
        referrer: frame.url
      },
      url: historyItem.href,
      method: historyItem.method,
      formData: historyItem.formData,
      disableHistory: true
    });
  }
  /**
   * Reloads the current history item.
   *
   * @param options Options.
   * @param options.windowClass Window class.
   * @param options.frame Frame.
   * @param options.goToOptions Go to options.
   */
  static reload(options2) {
    const { windowClass, frame, goToOptions } = options2;
    const history2 = frame[history];
    let historyItem;
    for (let i = history2.length - 1; i >= 0; i--) {
      if (history2[i].isCurrent) {
        historyItem = history2[i];
        break;
      }
    }
    if (!historyItem) {
      return new Promise((resolve) => {
        frame.window.requestAnimationFrame(() => {
          const listeners2 = frame[listeners].navigation;
          frame[listeners].navigation = [];
          for (const listener of listeners2) {
            listener();
          }
          resolve(null);
        });
      });
    }
    return _BrowserFrameNavigator.navigate({
      windowClass,
      frame,
      goToOptions: {
        ...goToOptions,
        referrer: frame.url
      },
      url: historyItem.href,
      method: historyItem.method,
      formData: historyItem.formData,
      disableHistory: true
    });
  }
};

// node_modules/happy-dom/lib/nodes/html-form-element/RadioNodeList.js
var RadioNodeList = class extends NodeList_default {
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    for (const node of this[items]) {
      if (node.checked) {
        return node.value;
      }
    }
    return null;
  }
};

// node_modules/happy-dom/lib/nodes/html-form-element/HTMLFormElement.js
var HTMLFormElement = class _HTMLFormElement extends HTMLElement {
  // Internal properties.
  [elements] = null;
  [proxy];
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Constructor.
   */
  constructor() {
    super();
    const methodBinder = new ClassMethodBinder(this, [
      _HTMLFormElement,
      HTMLElement,
      Element,
      Node,
      EventTarget
    ]);
    const proxy2 = new Proxy(this, {
      get: (target2, property) => {
        if (property === "length") {
          return target2[getFormControlItems]().length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return target2[getFormControlItems]()[index];
        }
        return target2[getFormControlNamedItem](property) || void 0;
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys(target2) {
        return Object.keys(target2[getFormControlItems]());
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const items2 = target2[getFormControlItems]();
        const index = Number(property);
        if (!isNaN(index) && index >= 0 && index < items2.length) {
          return true;
        }
        property = String(property);
        for (let i = 0; i < items2.length; i++) {
          const item = items2[i];
          const name2 = item.getAttribute("id") || item.getAttribute("name");
          if (name2 && name2 === property) {
            return true;
          }
        }
        return false;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (!descriptor.value) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        const index = Number(descriptor.value);
        if (isNaN(index)) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2) {
          return Object.getOwnPropertyDescriptor(target2, property);
        }
        const items2 = target2[getFormControlItems]();
        const index = Number(property);
        if (!isNaN(index) && index >= 0 && index < items2.length) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
        for (let i = 0; i < items2.length; i++) {
          const item = items2[i];
          const name2 = item.getAttribute("id") || item.getAttribute("name");
          if (name2 && name2 === property) {
            return {
              value: item,
              writable: false,
              enumerable: true,
              configurable: true
            };
          }
        }
      }
    });
    this[proxy] = proxy2;
    this[formNode] = proxy2;
    return proxy2;
  }
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onformdata() {
    return ElementEventAttributeUtility.getEventListener(this, "onformdata");
  }
  set onformdata(value2) {
    this[propertyEventListeners].set("onformdata", value2);
  }
  get onreset() {
    return ElementEventAttributeUtility.getEventListener(this, "onreset");
  }
  set onreset(value2) {
    this[propertyEventListeners].set("onreset", value2);
  }
  get onsubmit() {
    return ElementEventAttributeUtility.getEventListener(this, "onsubmit");
  }
  set onsubmit(value2) {
    this[propertyEventListeners].set("onsubmit", value2);
  }
  /**
   * Returns elements.
   *
   * @returns Elements.
   */
  get elements() {
    if (!this[elements]) {
      this[elements] = new HTMLFormControlsCollection(illegalConstructor, this);
    }
    return this[elements];
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[getFormControlItems]().length;
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns method.
   *
   * @returns Method.
   */
  get method() {
    return this.getAttribute("method") || "get";
  }
  /**
   * Sets method.
   *
   * @param method Method.
   */
  set method(method2) {
    this.setAttribute("method", method2);
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get target() {
    return this.getAttribute("target") || "";
  }
  /**
   * Sets target.
   *
   * @param target Target.
   */
  set target(target2) {
    this.setAttribute("target", target2);
  }
  /**
   * Returns action.
   *
   * @returns Action.
   */
  get action() {
    if (!this.hasAttribute("action")) {
      return this[ownerDocument].location.href;
    }
    try {
      return new URL(this.getAttribute("action"), this[ownerDocument].location.href).href;
    } catch (e) {
      return "";
    }
  }
  /**
   * Sets action.
   *
   * @param action Action.
   */
  set action(action) {
    this.setAttribute("action", action);
  }
  /**
   * Returns encoding.
   *
   * @returns Encoding.
   */
  get encoding() {
    return this.getAttribute("encoding") || "";
  }
  /**
   * Sets encoding.
   *
   * @param encoding Encoding.
   */
  set encoding(encoding) {
    this.setAttribute("encoding", encoding);
  }
  /**
   * Returns enctype.
   *
   * @returns Enctype.
   */
  get enctype() {
    return this.getAttribute("enctype") || "";
  }
  /**
   * Sets enctype.
   *
   * @param enctype Enctype.
   */
  set enctype(enctype) {
    this.setAttribute("enctype", enctype);
  }
  /**
   * Returns autocomplete.
   *
   * @returns Autocomplete.
   */
  get autocomplete() {
    return this.getAttribute("autocomplete") || "";
  }
  /**
   * Sets autocomplete.
   *
   * @param autocomplete Autocomplete.
   */
  set autocomplete(autocomplete) {
    this.setAttribute("autocomplete", autocomplete);
  }
  /**
   * Returns accept charset.
   *
   * @returns Accept charset.
   */
  get acceptCharset() {
    return this.getAttribute("acceptcharset") || "";
  }
  /**
   * Sets accept charset.
   *
   * @param acceptCharset Accept charset.
   */
  set acceptCharset(acceptCharset) {
    this.setAttribute("acceptcharset", acceptCharset);
  }
  /**
   * Returns no validate.
   *
   * @returns No validate.
   */
  get noValidate() {
    return this.getAttribute("novalidate") !== null;
  }
  /**
   * Sets no validate.
   *
   * @param noValidate No validate.
   */
  set noValidate(noValidate) {
    if (!noValidate) {
      this.removeAttribute("novalidate");
    } else {
      this.setAttribute("novalidate", "");
    }
  }
  /**
   * Submits form. No submit event is raised. In particular, the form's "submit" event handler is not run.
   */
  submit() {
    this.#submit();
  }
  /**
   * Submits form, reports validity and raises submit event.
   *
   * @param [submitter] Submitter.
   */
  requestSubmit(submitter) {
    const noValidate = submitter?.formNoValidate || this.noValidate;
    if (noValidate || this.checkValidity()) {
      const event = new SubmitEvent("submit", {
        bubbles: true,
        cancelable: true,
        submitter: submitter || this[proxy]
      });
      this.dispatchEvent(event);
      if (!event.defaultPrevented) {
        this.#submit(submitter);
      }
    }
  }
  /**
   * Resets form.
   */
  reset() {
    for (const element of this[getFormControlItems]()) {
      switch (element[tagName]) {
        case "TEXTAREA":
          element[value] = null;
          break;
        case "INPUT":
          element[value] = null;
          element[checked] = null;
          break;
        case "OUTPUT":
          element.textContent = element[defaultValue];
          break;
        case "SELECT":
          let hasSelectedAttribute = false;
          for (const option of element.options) {
            if (option.hasAttribute("selected")) {
              hasSelectedAttribute = true;
              option.selected = true;
              break;
            }
          }
          if (!hasSelectedAttribute && element.options.length > 0) {
            element.options[0].selected = true;
          }
          break;
      }
    }
    this.dispatchEvent(new Event("reset", { bubbles: true, cancelable: true }));
  }
  /**
   * Checks validity.
   *
   * @returns "true" if validation does'nt fail.
   */
  checkValidity() {
    const radioValidationState = {};
    let isFormValid = true;
    for (const element of this[getFormControlItems]()) {
      if (element[tagName] === "INPUT" && element.type === "radio" && element.name) {
        if (!radioValidationState[element.name]) {
          radioValidationState[element.name] = true;
          if (!element.checkValidity()) {
            isFormValid = false;
          }
        }
      } else if (!element.checkValidity()) {
        isFormValid = false;
      }
    }
    return isFormValid;
  }
  /**
   * Reports validity.
   *
   * @returns "true" if validation does'nt fail.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * Returns form control items.
   *
   * @returns Form control items.
   */
  [getFormControlItems]() {
    const elements2 = QuerySelector.querySelectorAll(this, "input,select,textarea,button,fieldset,object,output")[items].slice();
    if (this[isConnected]) {
      const id2 = this.getAttribute("id");
      if (id2) {
        for (const element of QuerySelector.querySelectorAll(this[ownerDocument], `input[form="${id2}"],select[form="${id2}"],textarea[form="${id2}"],button[form="${id2}"],fieldset[form="${id2}"],object[form="${id2}"],output[form="${id2}"]`)[items]) {
          if (!elements2.includes(element)) {
            elements2.push(element);
          }
        }
      }
    }
    return elements2;
  }
  /**
   * Returns form control named item.
   *
   * @param name
   * @returns Form control named item.
   */
  [getFormControlNamedItem](name2) {
    const items2 = this[getFormControlItems]();
    const namedItems = [];
    name2 = String(name2);
    for (const item of items2) {
      if (item.getAttribute("id") === name2 || item.getAttribute("name") === name2) {
        namedItems.push(item);
      }
    }
    if (!namedItems.length) {
      return null;
    }
    if (namedItems.length === 1) {
      return namedItems[0];
    }
    return new RadioNodeList(illegalConstructor, namedItems);
  }
  /**
   * Submits form.
   *
   * @param browserFrame Browser frame. Injected by the constructor.
   * @param [submitter] Submitter.
   */
  #submit(submitter) {
    const method2 = submitter?.formMethod || this.method;
    if (method2 === "dialog") {
      let dialog = null;
      let parent2 = this;
      while (parent2) {
        if (parent2[tagName] === "DIALOG") {
          dialog = parent2;
          break;
        }
        parent2 = parent2.parentElement;
      }
      if (dialog) {
        dialog.close(submitter?.value);
        return;
      }
    }
    const action = submitter?.hasAttribute("formaction") ? submitter?.formAction || this.action : this.action;
    const browserFrame = new WindowBrowserContext(this[window]).getBrowserFrame();
    if (!browserFrame) {
      return;
    }
    if (!action) {
      this[ownerDocument].location.hash = "#blocked";
      return;
    }
    const formData = new this[window].FormData(this);
    let targetFrame;
    switch (submitter?.formTarget || this.target) {
      default:
      case "_self":
        targetFrame = browserFrame;
        break;
      case "_top":
        targetFrame = browserFrame.page.mainFrame;
        break;
      case "_parent":
        targetFrame = browserFrame.parentFrame ?? browserFrame;
        break;
      case "_blank":
        const newPage = browserFrame.page.context.newPage();
        targetFrame = newPage.mainFrame;
        targetFrame[openerFrame] = browserFrame;
        break;
    }
    if (method2 === "get") {
      const url2 = new URL(action);
      for (const [key, value2] of formData) {
        if (typeof value2 === "string") {
          url2.searchParams.append(key, value2);
        }
      }
      BrowserFrameNavigator.navigate({
        windowClass: this[ownerDocument][defaultView].constructor,
        frame: targetFrame,
        url: url2.href,
        goToOptions: {
          referrer: browserFrame.page.mainFrame.window.location.origin
        }
      });
      return;
    }
    BrowserFrameNavigator.navigate({
      windowClass: this[ownerDocument][defaultView].constructor,
      frame: targetFrame,
      method: method2,
      url: action,
      formData,
      goToOptions: {
        referrer: browserFrame.page.mainFrame.window.location.origin
      }
    });
  }
};

// node_modules/happy-dom/lib/nodes/html-head-element/HTMLHeadElement.js
var HTMLHeadElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-heading-element/HTMLHeadingElement.js
var HTMLHeadingElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-hr-element/HTMLHRElement.js
var HTMLHRElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-html-element/HTMLHtmlElement.js
var HTMLHtmlElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/window/CrossOriginBrowserWindow.js
var CrossOriginBrowserWindow = class extends EventTarget {
  window = this;
  location;
  // Internal properties
  [self] = this;
  // Private properties
  #targetWindow;
  /**
   * Constructor.
   *
   * @param target Target window.
   * @param [parent] Parent window.
   */
  constructor(target2, parent2) {
    super();
    this[parent] = parent2 ?? this;
    this[top] = parent2 ?? this;
    this.location = new Proxy({}, {
      get: () => {
        throw new DOMException(`Blocked a frame with origin "${this.parent.location.origin}" from accessing a cross-origin frame.`, DOMExceptionNameEnum_default.securityError);
      },
      set: () => {
        throw new DOMException(`Blocked a frame with origin "${this.parent.location.origin}" from accessing a cross-origin frame.`, DOMExceptionNameEnum_default.securityError);
      }
    });
    this.#targetWindow = target2;
  }
  /**
   * Returns self.
   *
   * @returns Self.
   */
  get self() {
    return this[self];
  }
  /**
   * Returns self.
   *
   * @param self Self.
   */
  set self(self2) {
    this[self] = self2;
  }
  /**
   * Returns top.
   *
   * @returns Top.
   */
  get top() {
    return this[top];
  }
  /**
   * Returns parent.
   *
   * @returns Parent.
   */
  get parent() {
    return this[parent];
  }
  /**
   * Returns parent.
   *
   * @param parent Parent.
   */
  set parent(parent2) {
    this[parent] = parent2;
  }
  /**
   * Returns the opener.
   *
   * @returns Opener.
   */
  get opener() {
    return this.#targetWindow.opener;
  }
  /**
   * Returns the closed state.
   *
   * @returns Closed state.
   */
  get closed() {
    return this.#targetWindow.closed;
  }
  /**
   * Shifts focus away from the window.
   */
  blur() {
    this.#targetWindow.blur();
  }
  /**
   * Gives focus to the window.
   */
  focus() {
    this.#targetWindow.focus();
  }
  /**
   * Closes the window.
   */
  close() {
    this.#targetWindow.close();
  }
  /**
   * Safely enables cross-origin communication between Window objects; e.g., between a page and a pop-up that it spawned, or between a page and an iframe embedded within it.
   *
   * @param message Message.
   * @param [targetOrigin=*] Target origin.
   * @param transfer Transfer. Not implemented.
   */
  postMessage(message, targetOrigin = "*", transfer) {
    this.#targetWindow.postMessage(message, targetOrigin, transfer);
  }
};

// node_modules/happy-dom/lib/nodes/html-iframe-element/HTMLIFrameElement.js
var SANDBOX_FLAGS = [
  "allow-downloads",
  "allow-forms",
  "allow-modals",
  "allow-orientation-lock",
  "allow-pointer-lock",
  "allow-popups",
  "allow-popups-to-escape-sandbox",
  "allow-presentation",
  "allow-same-origin",
  "allow-scripts",
  "allow-top-navigation",
  "allow-top-navigation-by-user-activation",
  "allow-top-navigation-to-custom-protocols"
];
var HTMLIFrameElement = class extends HTMLElement {
  // Internal properties
  [sandbox] = null;
  // Private properties
  #contentWindowContainer = {
    window: null
  };
  #iframe;
  #loadedSrcdoc = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onload() {
    return ElementEventAttributeUtility.getEventListener(this, "onload");
  }
  set onload(value2) {
    this[propertyEventListeners].set("onload", value2);
  }
  get onerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onerror");
  }
  set onerror(value2) {
    this[propertyEventListeners].set("onerror", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns allow.
   *
   * @returns Allow.
   */
  get allow() {
    return this.getAttribute("allow") || "";
  }
  /**
   * Sets allow.
   *
   * @param allow Allow.
   */
  set allow(allow) {
    this.setAttribute("allow", allow);
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this.getAttribute("height") || "";
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this.setAttribute("height", height2);
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this.getAttribute("width") || "";
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this.setAttribute("width", width2);
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns sandbox.
   *
   * @returns Sandbox.
   */
  get sandbox() {
    if (!this[sandbox]) {
      this[sandbox] = new DOMTokenList(illegalConstructor, this, "sandbox");
    }
    return this[sandbox];
  }
  /**
   * Sets sandbox.
   */
  set sandbox(sandbox2) {
    this.setAttribute("sandbox", sandbox2);
  }
  /**
   * Returns srcdoc.
   *
   * @returns Srcdoc.
   */
  get srcdoc() {
    return this.getAttribute("srcdoc") || "";
  }
  /**
   * Sets srcdoc.
   *
   * @param srcdoc Srcdoc.
   */
  set srcdoc(srcdoc) {
    this.setAttribute("srcdoc", srcdoc);
  }
  /**
   * Returns referrer policy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerpolicy") || "";
  }
  /**
   * Sets referrer policy.
   *
   * @param referrerPolicy Referrer policy.
   */
  set referrerPolicy(referrerPolicy2) {
    this.setAttribute("referrerpolicy", referrerPolicy2);
  }
  /**
   * Returns content document.
   *
   * @returns Content document.
   */
  get contentDocument() {
    return this.#contentWindowContainer.window?.document ?? null;
  }
  /**
   * Returns content window.
   *
   * @returns Content window.
   */
  get contentWindow() {
    return this.#contentWindowContainer.window;
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * @override
   */
  [connectedToDocument]() {
    super[connectedToDocument]();
    this.#loadPage();
  }
  /**
   * Called when disconnected from document.
   * @param e
   */
  [disconnectedFromDocument]() {
    super[disconnectedFromDocument]();
    this.#unloadPage();
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * @override
   */
  [onSetAttribute](attribute, replacedAttribute) {
    super[onSetAttribute](attribute, replacedAttribute);
    if (attribute[name] === "srcdoc") {
      this.#loadPage();
    }
    if (attribute[name] === "src" && attribute[value] && !this.hasAttribute("srcdoc") && attribute[value] !== replacedAttribute?.[value]) {
      this.#loadPage();
    }
    if (attribute[name] === "sandbox") {
      this.#validateSandboxFlags();
    }
  }
  /**
   * @override
   */
  [onRemoveAttribute](removedAttribute) {
    super[onRemoveAttribute](removedAttribute);
    if (removedAttribute[name] === "srcdoc" || removedAttribute[name] === "src") {
      this.#loadPage();
    }
  }
  /**
   *
   * @param tokens
   * @param vconsole
   */
  #validateSandboxFlags() {
    const window2 = this[window];
    const invalidFlags = [];
    for (const token of this.sandbox) {
      if (!SANDBOX_FLAGS.includes(token)) {
        invalidFlags.push(token);
      }
    }
    if (invalidFlags.length === 1) {
      window2.console.error(`Error while parsing the 'sandbox' attribute: '${invalidFlags[0]}' is an invalid sandbox flag.`);
    } else if (invalidFlags.length > 1) {
      window2.console.error(`Error while parsing the 'sandbox' attribute: '${invalidFlags.join(`', '`)}' are invalid sandbox flags.`);
    }
  }
  /**
   * Loads an iframe page.
   */
  #loadPage() {
    if (!this[isConnected]) {
      this.#unloadPage();
      return;
    }
    const srcdoc = this.getAttribute("srcdoc");
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return;
    }
    if (srcdoc !== null) {
      if (this.#loadedSrcdoc === srcdoc) {
        return;
      }
      this.#unloadPage();
      this.#iframe = BrowserFrameFactory.createChildFrame(browserFrame);
      this.#iframe.url = "about:srcdoc";
      this.#contentWindowContainer.window = this.#iframe.window;
      this.#iframe.window[top] = browserFrame.window.top;
      this.#iframe.window[parent] = browserFrame.window;
      this.#iframe.window.document.open();
      this.#iframe.window.document.write(srcdoc);
      this.#loadedSrcdoc = srcdoc;
      this[window].requestAnimationFrame(() => this.dispatchEvent(new Event("load")));
      return;
    }
    if (this.#loadedSrcdoc !== null) {
      this.#unloadPage();
    }
    const originURL = browserFrame.window.location;
    const targetURL = BrowserFrameURL.getRelativeURL(browserFrame, this.src);
    if (this.#iframe && this.#iframe.window.location.href === targetURL.href) {
      return;
    }
    if (browserFrame.page.context.browser.settings.disableIframePageLoading) {
      const error2 = new window2.DOMException(`Failed to load iframe page "${targetURL.href}". Iframe page loading is disabled.`, DOMExceptionNameEnum_default.notSupportedError);
      browserFrame.page?.console.error(error2);
      this.dispatchEvent(new Event("error"));
      return;
    }
    const isSameOrigin = originURL.origin === targetURL.origin || targetURL.origin === "null";
    const parentWindow = isSameOrigin ? window2 : new CrossOriginBrowserWindow(window2);
    this.#iframe = this.#iframe ?? BrowserFrameFactory.createChildFrame(browserFrame);
    this.#iframe.window[top] = parentWindow;
    this.#iframe.window[parent] = parentWindow;
    this.#iframe.goto(targetURL.href, {
      referrer: originURL.origin,
      referrerPolicy: this.referrerPolicy
    }).then(() => this.dispatchEvent(new Event("load"))).catch((error2) => {
      browserFrame.page?.console.error(error2);
      this.dispatchEvent(new Event("error"));
    });
    this.#contentWindowContainer.window = isSameOrigin ? this.#iframe.window : new CrossOriginBrowserWindow(this.#iframe.window, window2);
  }
  /**
   * Unloads an iframe page.
   */
  #unloadPage() {
    if (this.#iframe) {
      BrowserFrameFactory.destroyFrame(this.#iframe);
      this.#iframe = null;
    }
    this.#contentWindowContainer.window = null;
    this.#loadedSrcdoc = null;
  }
};

// node_modules/happy-dom/lib/nodes/html-image-element/HTMLImageElement.js
var HTMLImageElement = class extends HTMLElement {
  [tagName] = "IMG";
  [complete] = false;
  [naturalHeight] = 0;
  [naturalWidth] = 0;
  [loading] = "auto";
  [x] = 0;
  [y] = 0;
  /**
   * Returns complete.
   *
   * @returns Complete.
   */
  get complete() {
    return this[complete];
  }
  /**
   * Returns natural height.
   *
   * @returns Natural height.
   */
  get naturalHeight() {
    return this[naturalHeight];
  }
  /**
   * Returns natural width.
   *
   * @returns Natural width.
   */
  get naturalWidth() {
    return this[naturalWidth];
  }
  /**
   * Returns loading.
   *
   * @returns Loading.
   */
  get loading() {
    const loading2 = this.getAttribute("loading");
    return loading2 === "eager" || loading2 === "lazy" ? loading2 : "auto";
  }
  /**
   * Sets loading.
   *
   * @param loading Loading.
   */
  set loading(loading2) {
    this.setAttribute("loading", loading2);
  }
  /**
   * Returns x.
   */
  get x() {
    return this[x];
  }
  /**
   * Returns y.
   */
  get y() {
    return this[y];
  }
  /**
   * Returns decoding.
   *
   * @returns Decoding.
   */
  get decoding() {
    return this.getAttribute("decoding") || "auto";
  }
  /**
   * Sets decoding.
   *
   * @param decoding Decoding.
   */
  set decoding(decoding) {
    this.setAttribute("decoding", decoding);
  }
  /**
   * Returns cross origin.
   *
   * @returns Cross origin.
   */
  get crossOrigin() {
    return this.getAttribute("crossOrigin");
  }
  /**
   * Sets cross origin.
   *
   * @param crossOrigin Cross origin.
   */
  set crossOrigin(crossOrigin2) {
    if (crossOrigin2 === "anonymous" || crossOrigin2 === "use-credentials") {
      this.setAttribute("crossOrigin", crossOrigin2);
    }
  }
  /**
   * Returns alt.
   *
   * @returns Alt.
   */
  get alt() {
    return this.getAttribute("alt") || "";
  }
  /**
   * Sets alt.
   *
   * @param alt Alt.
   */
  set alt(alt) {
    this.setAttribute("alt", alt);
  }
  /**
   * Returns current src.
   *
   * @returns Current src.
   */
  get currentSrc() {
    return this.src;
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    const width2 = this.getAttribute("width");
    return width2 !== null ? Number(width2) : 0;
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this.setAttribute("width", String(width2));
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    const height2 = this.getAttribute("height");
    return height2 !== null ? Number(height2) : 0;
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this.setAttribute("height", String(height2));
  }
  /**
   * Returns is map.
   *
   * @returns Is map.
   */
  get isMap() {
    return this.getAttribute("ismap") !== null;
  }
  /**
   * Sets is map.
   *
   * @param ismap Is map.
   */
  set isMap(isMap) {
    if (!isMap) {
      this.removeAttribute("ismap");
    } else {
      this.setAttribute("ismap", "");
    }
  }
  /**
   * Returns referrer policy.
   *
   * @returns Referrer policy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerpolicy") || "";
  }
  /**
   * Sets referrer policy.
   *
   * @param referrerPolicy Referrer policy.
   */
  set referrerPolicy(referrerPolicy2) {
    this.setAttribute("referrerpolicy", referrerPolicy2);
  }
  /**
   * Returns sizes.
   *
   * @returns Sizes.
   */
  get sizes() {
    return this.getAttribute("sizes") || "";
  }
  /**
   * Sets sizes.
   *
   * @param sizes Sizes.
   */
  set sizes(sizes) {
    this.setAttribute("sizes", sizes);
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns srcset.
   *
   * @returns Source.
   */
  get srcset() {
    return this.getAttribute("srcset") || "";
  }
  /**
   * Sets src set.
   *
   * @param srcset Src set.
   */
  set srcset(srcset) {
    this.setAttribute("srcset", srcset);
  }
  /**
   * Returns use map.
   *
   * @returns Use map.
   */
  get useMap() {
    return this.getAttribute("usemap") || "";
  }
  /**
   * Sets is map.
   *
   * @param useMap Is map.
   */
  set useMap(useMap) {
    this.setAttribute("usemap", useMap);
  }
  /**
   * The decode() method of the HTMLImageElement interface returns a Promise that resolves when the image is decoded and it is safe to append the image to the DOM.
   *
   * @returns Promise.
   */
  decode() {
    return Promise.resolve();
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
};

// node_modules/happy-dom/lib/nodes/html-label-element/HTMLLabelElement.js
var HTMLLabelElement = class extends HTMLElement {
  /**
   * Returns a string containing the ID of the labeled control. This reflects the "for" attribute.
   *
   * @returns ID of the labeled control.
   */
  get htmlFor() {
    const htmlFor = this.getAttribute("for");
    if (htmlFor !== null) {
      return htmlFor;
    }
    return htmlFor !== null ? htmlFor : "";
  }
  /**
   * Sets a string containing the ID of the labeled control. This reflects the "for" attribute.
   *
   * @param htmlFor ID of the labeled control.
   */
  set htmlFor(htmlFor) {
    this.setAttribute("for", htmlFor);
  }
  /**
   * Returns an HTML element representing the control with which the label is associated.
   *
   * @returns Control element.
   */
  get control() {
    const htmlFor = this.getAttribute("for");
    if (htmlFor !== null) {
      if (!htmlFor || !this[isConnected]) {
        return null;
      }
      const control = this[rootNode].getElementById(htmlFor);
      if (control) {
        switch (control[tagName]) {
          case "INPUT":
            return control.type !== "hidden" ? control : null;
          case "BUTTON":
          case "METER":
          case "OUTPUT":
          case "PROGRESS":
          case "SELECT":
          case "TEXTAREA":
            return control;
          default:
            return null;
        }
      }
    }
    return this.querySelector('button,input:not([type="hidden"]),meter,output,progress,select,textarea');
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    return this.control?.form || null;
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    const returnValue2 = super.dispatchEvent(event);
    if (!event[defaultPrevented] && event.type === "click" && (event.eventPhase === EventPhaseEnum_default.atTarget || event.eventPhase === EventPhaseEnum_default.bubbling) && event instanceof MouseEvent) {
      const control = this.control;
      if (control && event.target !== control) {
        control.dispatchEvent(new MouseEvent("click", { bubbles: true, cancelable: true }));
      }
    }
    return returnValue2;
  }
};

// node_modules/happy-dom/lib/nodes/html-legend-element/HTMLLegendElement.js
var HTMLLegendElement = class extends HTMLElement {
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    let parent2 = this;
    while (parent2) {
      if (parent2 instanceof HTMLFieldSetElement) {
        return parent2.form;
      }
      parent2 = parent2.parentNode;
    }
    return null;
  }
};

// node_modules/happy-dom/lib/nodes/html-li-element/HTMLLIElement.js
var HTMLLIElement = class extends HTMLElement {
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    if (!this.hasAttribute("value")) {
      return 0;
    }
    const parsedValue = Number(this.getAttribute("value"));
    return isNaN(parsedValue) ? 0 : parsedValue;
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    const parsedValue = Number(value2);
    this.setAttribute("value", isNaN(parsedValue) ? "0" : String(parsedValue));
  }
};

// node_modules/happy-dom/lib/fetch/SyncFetch.js
import FS2 from "fs";
import Path3 from "path";
import ChildProcess from "child_process";

// node_modules/happy-dom/lib/fetch/utilities/SyncFetchScriptBuilder.js
var SyncFetchScriptBuilder = class {
  /**
   * Sends a synchronous request.
   *
   * @param request Request.
   * @param request.url
   * @param request.method
   * @param request.headers
   * @param request.body
   * @returns Script.
   */
  static getScript(request) {
    const sortedHeaders = {};
    const headerNames = Object.keys(request.headers).sort();
    for (const name2 of headerNames) {
      sortedHeaders[name2] = request.headers[name2];
    }
    return `
                const sendRequest = require('http${request.url.protocol === "https:" ? "s" : ""}').request;
                const options = ${JSON.stringify({
      method: request.method,
      headers: sortedHeaders,
      agent: false,
      rejectUnauthorized: true,
      key: request.url.protocol === "https:" ? FetchHTTPSCertificate_default.key : void 0,
      cert: request.url.protocol === "https:" ? FetchHTTPSCertificate_default.cert : void 0
    }, null, 4)};
                const request = sendRequest(${JSON.stringify(request.url.href)}, options, (incomingMessage) => {
                    let data = Buffer.alloc(0);
                    incomingMessage.on('data', (chunk) => {
                        data = Buffer.concat([data, Buffer.from(chunk)]);
                    });
                    incomingMessage.on('end', () => {
                        console.log(JSON.stringify({
                            error: null,
                            incomingMessage: {
                                statusCode: incomingMessage.statusCode,
                                statusMessage: incomingMessage.statusMessage,
                                rawHeaders: incomingMessage.rawHeaders,
                                data: data.toString('base64')
                            }
                        }));
                    });
                    incomingMessage.on('error', (error) => {
                        console.log(JSON.stringify({ error: error.message, incomingMessage: null }));
                    });
                });
                request.write(Buffer.from('${request.body ? request.body.toString("base64") : ""}', 'base64'));
                request.end();
            `;
  }
};

// node_modules/happy-dom/lib/fetch/SyncFetch.js
import Zlib2 from "zlib";
var SyncFetch = class _SyncFetch {
  request;
  redirectCount = 0;
  disableCache;
  disableSameOriginPolicy;
  interceptor;
  #browserFrame;
  #window;
  #unfilteredHeaders = null;
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.browserFrame Browser frame.
   * @param options.window Window.
   * @param options.url URL.
   * @param [options.init] Init.
   * @param [options.redirectCount] Redirect count.
   * @param [options.contentType] Content Type.
   * @param [options.disableCache] Disables the use of cached responses. It will still store the response in the cache.
   * @param [options.disableSameOriginPolicy] Disables the Same-Origin policy.
   * @param [options.unfilteredHeaders] Unfiltered headers - necessary for preflight requests.
   */
  constructor(options2) {
    this.#browserFrame = options2.browserFrame;
    this.#window = options2.window;
    this.#unfilteredHeaders = options2.unfilteredHeaders ?? null;
    this.request = typeof options2.url === "string" || options2.url instanceof URL2 ? new options2.window.Request(options2.url, options2.init) : options2.url;
    if (options2.contentType) {
      this.request[contentType] = options2.contentType;
    }
    this.redirectCount = options2.redirectCount ?? 0;
    this.disableCache = options2.disableCache ?? false;
    this.disableSameOriginPolicy = options2.disableSameOriginPolicy ?? this.#browserFrame.page.context.browser.settings.fetch.disableSameOriginPolicy ?? false;
    this.interceptor = this.#browserFrame.page.context.browser.settings.fetch.interceptor;
  }
  /**
   * Sends request.
   *
   * @returns Response.
   */
  send() {
    FetchRequestReferrerUtility.prepareRequest(new URL2(this.#window.location.href), this.request);
    const beforeRequestResponse = this.interceptor?.beforeSyncRequest ? this.interceptor.beforeSyncRequest({
      request: this.request,
      window: this.#window
    }) : void 0;
    if (typeof beforeRequestResponse === "object") {
      return beforeRequestResponse;
    }
    FetchRequestValidationUtility.validateSchema(this.request);
    if (this.request.signal[aborted]) {
      if (this.request.signal[reason] !== void 0) {
        throw this.request.signal[reason];
      }
      throw new this[window].DOMException("signal is aborted without reason", DOMExceptionNameEnum_default.abortError);
    }
    if (this.request[url].protocol === "data:") {
      const result2 = DataURIParser.parse(this.request.url);
      const response = {
        status: 200,
        statusText: "OK",
        ok: true,
        url: this.request.url,
        redirected: false,
        headers: new Headers({ "Content-Type": result2.type }),
        body: result2.buffer
      };
      const interceptedResponse = this.interceptor?.afterSyncResponse ? this.interceptor.afterSyncResponse({
        window: this.#window,
        response,
        request: this.request
      }) : void 0;
      return typeof interceptedResponse === "object" ? interceptedResponse : response;
    }
    if (this.request[url].protocol === "http:" && this.#window.location.protocol === "https:") {
      throw new this.#window.DOMException(`Mixed Content: The page at '${this.#window.location.href}' was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint '${this.request.url}'. This request has been blocked; the content must be served over HTTPS.`, DOMExceptionNameEnum_default.securityError);
    }
    const cachedResponse2 = this.getCachedResponse();
    if (cachedResponse2) {
      return cachedResponse2;
    }
    const virtualServerResponse = this.getVirtualServerResponse();
    if (virtualServerResponse) {
      return virtualServerResponse;
    }
    if (!this.compliesWithCrossOriginPolicy()) {
      this.#window.console.warn(`Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at "${this.request.url}".`);
      throw new this.#window.DOMException(`Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at "${this.request.url}".`, DOMExceptionNameEnum_default.networkError);
    }
    return this.sendRequest();
  }
  /**
   * Returns cached response.
   *
   * @returns Response.
   */
  getCachedResponse() {
    if (this.disableCache) {
      return null;
    }
    let cachedResponse2 = this.#browserFrame.page.context.responseCache.get(this.request);
    if (!cachedResponse2 || cachedResponse2.response.waitingForBody) {
      return null;
    }
    if (cachedResponse2.state === CachedResponseStateEnum_default.stale) {
      const headers2 = new Headers(cachedResponse2.request.headers);
      if (cachedResponse2.etag) {
        headers2.set("If-None-Match", cachedResponse2.etag);
      } else {
        if (!cachedResponse2.lastModified) {
          return null;
        }
        headers2.set("If-Modified-Since", new Date(cachedResponse2.lastModified).toUTCString());
      }
      if (cachedResponse2.etag || !cachedResponse2.staleWhileRevalidate) {
        const fetch = new _SyncFetch({
          browserFrame: this.#browserFrame,
          window: this.#window,
          url: this.request.url,
          init: { headers: headers2, method: cachedResponse2.request.method },
          disableCache: true,
          disableSameOriginPolicy: true
        });
        const validateResponse = fetch.send();
        const body2 = validateResponse.status !== 304 ? validateResponse.body : null;
        cachedResponse2 = this.#browserFrame.page.context.responseCache.add(this.request, {
          ...validateResponse,
          body: body2,
          waitingForBody: false
        });
        if (validateResponse.status !== 304) {
          return validateResponse;
        }
      } else {
        const fetch = new Fetch({
          browserFrame: this.#browserFrame,
          window: this.#window,
          url: this.request.url,
          init: { headers: headers2, method: cachedResponse2.request.method },
          disableCache: true,
          disableSameOriginPolicy: true
        });
        fetch.send().then((response) => {
          response.buffer().then((body2) => {
            this.#browserFrame.page.context.responseCache.add(this.request, {
              ...response,
              body: body2,
              waitingForBody: false
            });
          });
        });
      }
    }
    if (!cachedResponse2 || cachedResponse2.response.waitingForBody) {
      return null;
    }
    return {
      status: cachedResponse2.response.status,
      statusText: cachedResponse2.response.statusText,
      ok: true,
      url: cachedResponse2.response.url,
      // TODO: Do we need to add support for redirected responses to the cache?
      redirected: false,
      headers: cachedResponse2.response.headers,
      body: cachedResponse2.response.body
    };
  }
  /**
   * Returns virtual server response.
   *
   * @returns Response.
   */
  getVirtualServerResponse() {
    const filePath = VirtualServerUtility.getFilepath(this.#window, this.request.url);
    if (!filePath) {
      return null;
    }
    if (this.request.method !== "GET") {
      this.#browserFrame?.page?.console.error(`${this.request.method} ${this.request.url} 404 (Not Found)`);
      const response2 = VirtualServerUtility.getNotFoundSyncResponse(this.#window);
      const interceptedResponse2 = this.interceptor?.afterSyncResponse ? this.interceptor.afterSyncResponse({
        window: this.#window,
        response: response2,
        request: this.request
      }) : void 0;
      return typeof interceptedResponse2 === "object" ? interceptedResponse2 : response2;
    }
    let buffer2;
    try {
      const stat = FS2.statSync(filePath);
      buffer2 = FS2.readFileSync(stat.isDirectory() ? Path3.join(filePath, "index.html") : filePath);
    } catch {
      this.#browserFrame?.page?.console.error(`${this.request.method} ${this.request.url} 404 (Not Found)`);
      const response2 = VirtualServerUtility.getNotFoundSyncResponse(this.#window);
      const interceptedResponse2 = this.interceptor?.afterSyncResponse ? this.interceptor.afterSyncResponse({
        window: this.#window,
        response: response2,
        request: this.request
      }) : void 0;
      return typeof interceptedResponse2 === "object" ? interceptedResponse2 : response2;
    }
    const response = {
      status: 200,
      statusText: "",
      ok: true,
      url: this.request.url,
      redirected: false,
      headers: new this.#window.Headers(),
      body: buffer2
    };
    const interceptedResponse = this.interceptor?.afterSyncResponse ? this.interceptor.afterSyncResponse({
      window: this.#window,
      response,
      request: this.request
    }) : void 0;
    const returnResponse = typeof interceptedResponse === "object" ? interceptedResponse : response;
    this.#browserFrame.page.context.responseCache.add(this.request, {
      ...returnResponse,
      waitingForBody: false
    });
    return returnResponse;
  }
  /**
   * Checks if the request complies with the Cross-Origin policy.
   *
   * @returns True if it complies with the policy.
   */
  compliesWithCrossOriginPolicy() {
    if (this.disableSameOriginPolicy || !FetchCORSUtility.isCORS(this.#window.location.href, this.request[url])) {
      return true;
    }
    const cachedPreflightResponse = this.#browserFrame.page.context.preflightResponseCache.get(this.request);
    if (cachedPreflightResponse) {
      if (cachedPreflightResponse.allowOrigin !== "*" && cachedPreflightResponse.allowOrigin !== this.#window.location.origin) {
        return false;
      }
      if (cachedPreflightResponse.allowMethods.length !== 0 && !cachedPreflightResponse.allowMethods.includes(this.request.method)) {
        return false;
      }
      return true;
    }
    const requestHeaders = [];
    for (const [header] of this.request.headers) {
      requestHeaders.push(header.toLowerCase());
    }
    const corsHeaders = new Headers({
      "Access-Control-Request-Method": this.request.method,
      Origin: this.#window.location.origin
    });
    if (requestHeaders.length > 0) {
      corsHeaders.set("Access-Control-Request-Headers", requestHeaders.slice().sort().join(","));
    }
    const fetch = new _SyncFetch({
      browserFrame: this.#browserFrame,
      window: this.#window,
      url: this.request.url,
      init: { method: "OPTIONS" },
      disableCache: true,
      disableSameOriginPolicy: true,
      unfilteredHeaders: corsHeaders
    });
    const response = fetch.send();
    if (!response.ok) {
      return false;
    }
    const allowOrigin = response.headers.get("Access-Control-Allow-Origin");
    if (!allowOrigin) {
      return false;
    }
    if (allowOrigin !== "*" && allowOrigin !== this.#window.location.origin) {
      return false;
    }
    const allowMethods = [];
    if (response.headers.has("Access-Control-Allow-Methods")) {
      const allowMethodsHeader = response.headers.get("Access-Control-Allow-Methods");
      if (allowMethodsHeader !== "*") {
        for (const method2 of allowMethodsHeader.split(",")) {
          allowMethods.push(method2.trim().toUpperCase());
        }
      }
    }
    if (allowMethods.length !== 0 && !allowMethods.includes(this.request.method)) {
      return false;
    }
    return true;
  }
  /**
   * Sends request.
   *
   * @returns Response.
   */
  sendRequest() {
    if (!this.request[bodyBuffer] && this.request.body) {
      throw new this.#window.DOMException(`Streams are not supported as request body for synchrounous requests.`, DOMExceptionNameEnum_default.notSupportedError);
    }
    const script = SyncFetchScriptBuilder.getScript({
      url: this.request[url],
      method: this.request.method,
      headers: FetchRequestHeaderUtility.getRequestHeaders({
        browserFrame: this.#browserFrame,
        window: this.#window,
        request: this.request,
        baseHeaders: this.#unfilteredHeaders
      }),
      body: this.request[bodyBuffer]
    });
    const content2 = ChildProcess.execFileSync(process.argv[0], ["-e", script], {
      encoding: "buffer",
      maxBuffer: 1024 * 1024 * 1024
      // TODO: Consistent buffer size: 1GB.
    });
    if (!content2.length) {
      throw new this.#window.DOMException(`Synchronous fetch to "${this.request.url}" failed.`, DOMExceptionNameEnum_default.networkError);
    }
    const { error: error2, incomingMessage } = JSON.parse(content2.toString());
    if (error2) {
      throw new this.#window.DOMException(`Synchronous fetch to "${this.request.url}" failed. Error: ${error2}`, DOMExceptionNameEnum_default.networkError);
    }
    const headers2 = FetchResponseHeaderUtility.parseResponseHeaders({
      browserFrame: this.#browserFrame,
      requestURL: this.request[url],
      rawHeaders: incomingMessage.rawHeaders
    });
    const response = {
      status: incomingMessage.statusCode,
      statusText: incomingMessage.statusMessage,
      ok: incomingMessage.statusCode >= 200 && incomingMessage.statusCode < 300,
      url: this.request.url,
      redirected: this.redirectCount > 0,
      headers: headers2,
      body: this.parseIResponseBody({
        headers: headers2,
        status: incomingMessage.statusCode,
        body: Buffer.from(incomingMessage.data, "base64")
      })
    };
    const redirectedResponse = this.handleRedirectResponse(response) || response;
    if (!this.disableCache && !redirectedResponse.redirected) {
      this.#browserFrame.page.context.responseCache.add(this.request, {
        status: redirectedResponse.status,
        statusText: redirectedResponse.statusText,
        url: redirectedResponse.url,
        headers: redirectedResponse.headers,
        body: redirectedResponse.body,
        waitingForBody: false
      });
    }
    const interceptedResponse = this.interceptor?.afterSyncResponse ? this.interceptor.afterSyncResponse({
      window: this.#window,
      response: redirectedResponse,
      request: this.request
    }) : void 0;
    const returnResponse = typeof interceptedResponse === "object" ? interceptedResponse : redirectedResponse;
    if (!returnResponse.ok) {
      this.#browserFrame?.page?.console.error(`${this.request.method} ${this.request.url} ${returnResponse.status} (${returnResponse.statusText})`);
    }
    return returnResponse;
  }
  /**
   * Parses response body.
   *
   * @param options Options.
   * @param options.headers Headers.
   * @param options.status Status.
   * @param options.body Body.
   * @returns Parsed body.
   */
  parseIResponseBody(options2) {
    const contentEncodingHeader = options2.headers.get("Content-Encoding");
    if (this.request.method === "HEAD" || contentEncodingHeader === null || options2.status === 204 || options2.status === 304) {
      return options2.body;
    }
    try {
      if (contentEncodingHeader === "gzip" || contentEncodingHeader === "x-gzip") {
        return Zlib2.gunzipSync(options2.body, {
          flush: Zlib2.constants.Z_SYNC_FLUSH,
          finishFlush: Zlib2.constants.Z_SYNC_FLUSH
        });
      }
      if (contentEncodingHeader === "deflate" || contentEncodingHeader === "x-deflate") {
        return Zlib2.inflateSync(options2.body);
      }
      if (contentEncodingHeader === "br") {
        return Zlib2.brotliDecompressSync(options2.body);
      }
    } catch (error2) {
      throw new this.#window.DOMException(`Failed to read response body. Error: ${error2.message}.`, DOMExceptionNameEnum_default.encodingError);
    }
    return options2.body;
  }
  /**
   * Handles redirect response.
   *
   * @param response Response.
   * @returns Redirected response or null.
   */
  handleRedirectResponse(response) {
    if (!FetchResponseRedirectUtility.isRedirect(response.status)) {
      return null;
    }
    switch (this.request.redirect) {
      case "error":
        throw new this.#window.DOMException(`URI requested responds with a redirect, redirect mode is set to "error": ${this.request.url}`, DOMExceptionNameEnum_default.abortError);
      case "manual":
        return null;
      case "follow":
        const locationHeader = response.headers.get("Location");
        const shouldBecomeGetRequest = response.status === 303 || (response.status === 301 || response.status === 302) && this.request.method === "POST";
        let locationURL = null;
        if (locationHeader !== null) {
          try {
            locationURL = new URL2(locationHeader, this.request.url);
          } catch {
            throw new this.#window.DOMException(`URI requested responds with an invalid redirect URL: ${locationHeader}`, DOMExceptionNameEnum_default.uriMismatchError);
          }
        }
        if (locationURL === null) {
          return null;
        }
        if (FetchResponseRedirectUtility.isMaxRedirectsReached(this.redirectCount)) {
          throw new this.#window.DOMException(`Maximum redirects reached at: ${this.request.url}`, DOMExceptionNameEnum_default.networkError);
        }
        const headers2 = new Headers(this.request.headers);
        const requestInit = {
          method: this.request.method,
          signal: this.request.signal,
          referrer: this.request.referrer,
          referrerPolicy: this.request.referrerPolicy,
          credentials: this.request.credentials,
          headers: headers2,
          body: this.request[bodyBuffer]
        };
        if (this.request.credentials === "omit" || this.request.credentials === "same-origin" && FetchCORSUtility.isCORS(this.#window.location.href, locationURL)) {
          headers2.delete("authorization");
          headers2.delete("www-authenticate");
          headers2.delete("cookie");
          headers2.delete("cookie2");
        }
        if (shouldBecomeGetRequest) {
          requestInit.method = "GET";
          requestInit.body = void 0;
          headers2.delete("Content-Length");
          headers2.delete("Content-Type");
        }
        const responseReferrerPolicy = FetchRequestReferrerUtility.getReferrerPolicyFromHeader(headers2);
        if (responseReferrerPolicy) {
          requestInit.referrerPolicy = responseReferrerPolicy;
        }
        const fetch = new _SyncFetch({
          browserFrame: this.#browserFrame,
          window: this.#window,
          url: locationURL,
          init: requestInit,
          redirectCount: this.redirectCount + 1,
          contentType: !shouldBecomeGetRequest ? this.request[contentType] : void 0
        });
        return fetch.send();
      default:
        throw new this.#window.DOMException(`Redirect option '${this.request.redirect}' is not a valid value of IRequestRedirect`);
    }
  }
};

// node_modules/happy-dom/lib/fetch/ResourceFetch.js
var ResourceFetch = class {
  window;
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    this.window = window2;
  }
  /**
   * Returns resource data asynchronously.
   *
   * @param url URL.
   * @param destination Destination.
   * @param [options]
   * @param [options.credentials] Credentials.
   * @param options.referrerPolicy
   * @returns Response.
   */
  async fetch(url2, destination, options2) {
    const browserFrame = new WindowBrowserContext(this.window).getBrowserFrame();
    if (destination === "script" || destination === "style") {
      const preloadKey = PreloadUtility.getKey({
        url: String(url2),
        destination,
        mode: "cors",
        credentialsMode: options2.credentials || "same-origin"
      });
      const preloadEntry = this.window.document[preloads].get(preloadKey);
      if (preloadEntry) {
        this.window.document[preloads].delete(preloadKey);
        const response2 = preloadEntry.response || await preloadEntry.onResponseAvailable();
        if (!response2.ok) {
          throw new this.window.DOMException(`Failed to perform request to "${new URL2(url2, this.window.location.href).href}". Status ${preloadEntry.response.status} ${preloadEntry.response.statusText}.`);
        }
        return preloadEntry.response[buffer].toString();
      }
    }
    const fetch = new Fetch({
      browserFrame,
      window: this.window,
      url: url2,
      disableSameOriginPolicy: destination === "script" || destination === "style",
      disablePreload: true,
      init: {
        credentials: options2?.credentials,
        referrerPolicy: options2?.referrerPolicy
      }
    });
    const response = await fetch.send();
    if (!response.ok) {
      throw new this.window.DOMException(`Failed to perform request to "${new URL2(url2, this.window.location.href).href}". Status ${response.status} ${response.statusText}.`);
    }
    return await response.text();
  }
  /**
   * Returns resource data synchronously.
   *
   * @param url URL.
   * @param destination Destination.
   * @param [options] Options.
   * @param [options.credentials] Credentials.
   * @param [options.referrerPolicy] Referrer policy.
   * @returns Response.
   */
  fetchSync(url2, destination, options2) {
    const browserFrame = new WindowBrowserContext(this.window).getBrowserFrame();
    if (destination === "script" || destination === "style") {
      const preloadKey = PreloadUtility.getKey({
        url: String(url2),
        destination,
        mode: "cors",
        credentialsMode: options2.credentials || "same-origin"
      });
      const preloadEntry = this.window.document[preloads].get(preloadKey);
      if (preloadEntry && preloadEntry.response) {
        this.window.document[preloads].delete(preloadKey);
        const response2 = preloadEntry.response;
        if (!response2.ok) {
          throw new this.window.DOMException(`Failed to perform request to "${new URL2(url2, this.window.location.href).href}". Status ${preloadEntry.response.status} ${preloadEntry.response.statusText}.`);
        }
        return preloadEntry.response[buffer].toString();
      }
    }
    const fetch = new SyncFetch({
      browserFrame,
      window: this.window,
      url: url2,
      disableSameOriginPolicy: true,
      init: {
        credentials: options2?.credentials,
        referrerPolicy: options2?.referrerPolicy
      }
    });
    const response = fetch.send();
    if (!response.ok) {
      throw new this.window.DOMException(`Failed to perform request to "${new URL2(url2, this.window.location.href).href}". Status ${response.status} ${response.statusText}.`);
    }
    return response.body.toString();
  }
};

// node_modules/happy-dom/lib/module/ModuleFactory.js
import { URL as URL12 } from "url";

// node_modules/happy-dom/lib/module/CSSModule.js
var CSSModule = class {
  url;
  #window;
  #source;
  #exports = null;
  /**
   * Constructor.
   *
   * @param window Window.
   * @param url Module URL.
   * @param source Source code.
   */
  constructor(window2, url2, source) {
    this.#window = window2;
    this.url = url2;
    this.#source = source;
  }
  /**
   * Compiles and evaluates the module.
   *
   * @returns Module exports.
   */
  async evaluate() {
    if (this.#exports) {
      return this.#exports;
    }
    const styleSheet = new this.#window.CSSStyleSheet();
    styleSheet.replaceSync(this.#source);
    this.#exports = { default: styleSheet };
    return this.#exports;
  }
  /**
   * Compiles and preloads the module and its imports.
   *
   * @returns Promise.
   */
  async preload() {
    await this.evaluate();
  }
};

// node_modules/happy-dom/lib/module/JSONModule.js
var JSONModule = class {
  url;
  #window;
  #source;
  #exports = null;
  /**
   * Constructor.
   *
   * @param window Window.
   * @param url Module URL.
   * @param source Source code.
   */
  constructor(window2, url2, source) {
    this.#window = window2;
    this.url = url2;
    this.#source = source;
  }
  /**
   * Compiles and evaluates the module.
   *
   * @returns Module exports.
   */
  async evaluate() {
    if (this.#exports) {
      return this.#exports;
    }
    let result2;
    try {
      result2 = JSON.parse(this.#source);
    } catch (error2) {
      throw new this.#window.TypeError(`Failed to parse module "${this.url.href}": ${error2.message}`);
    }
    this.#exports = { default: result2 };
    return this.#exports;
  }
  /**
   * Compiles and preloads the module and its imports.
   *
   * @returns Promise.
   */
  async preload() {
    await this.evaluate();
  }
};

// node_modules/happy-dom/lib/module/UnresolvedModule.js
var UnresolvedModule = class {
  url;
  #window;
  #hooks = [];
  #error = null;
  /**
   * Constructor.
   *
   * @param window Window.
   * @param url Module URL.
   */
  constructor(window2, url2) {
    this.#window = window2;
    this.url = url2;
  }
  /**
   * Compiles and evaluates the module.
   *
   * @returns Module exports.
   */
  async evaluate() {
    throw new this.#window.TypeError("Unresolved module. We should never end up here.");
  }
  /**
   * Compiles and preloads the module and its imports.
   *
   * @returns Promise.
   */
  async preload() {
    throw new this.#window.TypeError("Unresolved module. We should never end up here.");
  }
  /**
   * Add a hook to be called when the module is resolved.
   *
   * @param resolve Resolve.
   * @param reject Reject.
   */
  addResolveListener(resolve, reject) {
    if (this.#error) {
      reject(this.#error);
      return;
    }
    this.#hooks.push({ resolve, reject });
  }
  /**
   * Resolves the module.
   *
   * @param [error] Error.
   */
  resolve(error2) {
    if (error2) {
      this.#error = error2;
    }
    for (const hook of this.#hooks) {
      if (error2) {
        hook.reject(error2);
      } else {
        hook.resolve(null);
      }
    }
  }
};

// node_modules/happy-dom/lib/module/ModuleURLUtility.js
import { URL as URL11 } from "url";
var ModuleURLUtility = class {
  /**
   * Returns module URL based on parent URL and the import map.
   *
   * @param window Window.
   * @param parentURL Parent URL.
   * @param url Module URL.
   */
  static getURL(window2, parentURL, url2) {
    const parentURLString = typeof parentURL === "string" ? parentURL : parentURL.href;
    const importMap = window2[moduleImportMap];
    if (!importMap) {
      return new URL11(url2, parentURLString);
    }
    if (importMap.scopes.length) {
      for (const scope of importMap.scopes) {
        if (parentURLString.includes(scope.scope)) {
          for (const rule of scope.rules) {
            if (url2.startsWith(rule.from)) {
              return new URL11(rule.to + url2.replace(rule.from, ""), parentURLString);
            }
          }
        }
      }
    }
    if (importMap.imports.length) {
      for (const rule of importMap.imports) {
        if (url2.startsWith(rule.from)) {
          return new URL11(rule.to + url2.replace(rule.from, ""), parentURLString);
        }
      }
    }
    return new URL11(url2, parentURLString);
  }
};

// node_modules/happy-dom/lib/module/ECMAScriptModuleCompiler.js
var CODE_REGEXP = /import\s*["']([^"']+)["'];{0,1}|import\s*\(([^)]+)\)|(import[\s{])|[\s}]from\s*["']([^"']+)["'](\s+with\s*{\s*type\s*:\s*["']([^"']+)["']\s*}){0,1}|export\s([a-zA-Z0-9-_$]+|\*|\*\s+as\s+["'a-zA-Z0-9-_$]+|{[^}]+})\s*from\s["']([^"']+)["']|(export\s*default\s*)|export\s*(function\*{0,1}|class)\s*([^({\s]+)|export\s*{([^}]+)}|export\s+(var|let|const)\s+([^=;]+)(=|;)|(\/)|(\(|\))|({|})|(\[|\])|(\${)|(`)|(')|(")|(\n)/gm;
var IMPORT_REGEXP = /{([^}]+)}|\*\s+as\s+([a-zA-Z0-9-_$]+)|([a-zA-Z0-9-_$]+)/gm;
var PRECEDING_STATEMENT_TOKEN_REGEXP = /['"`(){}\s;=>]/;
var PRECEDING_REGEXP_TOKEN_REGEXP = /[([=\{\},;"'+-]/;
var MULTILINE_COMMENT_REGEXP = /\/\*|\*\//gm;
var ECMAScriptModuleCompiler = class {
  window;
  /**
   * Constructor.
   *
   * @param window Window.
   * @param url Module URL.
   */
  constructor(window2) {
    this.window = window2;
  }
  /**
   * Compiles code and returns imports and compiled code.
   *
   * @param moduleURL Module URL.
   * @param code Code.
   * @returns Result.
   */
  compile(moduleURL, code) {
    const browserSettings = new WindowBrowserContext(this.window).getSettings();
    const regExp = new RegExp(CODE_REGEXP);
    const imports = [];
    const count = {
      comment: 0,
      singleLineComment: 0,
      parantheses: 0,
      curlyBraces: 0,
      squareBrackets: 0,
      regExp: 0,
      regExpSquareBrackets: 0,
      escapeTemplateString: 0,
      simpleString: 0,
      doubleString: 0
    };
    const stack = {
      templateString: { index: null, code: [] }
    };
    const templateString = [];
    const exportSpreadVariables = [];
    let newCode = `(async function anonymous($happy_dom) {
//# sourceURL=${moduleURL}
`;
    let match;
    let precedingToken;
    let isEscaped;
    let lastIndex = 0;
    let importStartIndex = -1;
    let skipMatchedCode = false;
    if (!browserSettings.disableErrorCapturing && browserSettings.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch) {
      newCode += "try {\n";
    }
    while (match = regExp.exec(code)) {
      if (importStartIndex === -1) {
        newCode += code.substring(lastIndex, match.index);
      }
      precedingToken = code[match.index - 1] || " ";
      isEscaped = precedingToken === "\\" && code[match.index - 2] !== "\\";
      if (count.comment === 0 && count.singleLineComment === 0 && count.parantheses === 0 && count.curlyBraces === 0 && count.squareBrackets === 0 && count.regExp === 0 && count.simpleString === 0 && count.doubleString === 0 && templateString.length === 0) {
        if (match[1] && PRECEDING_STATEMENT_TOKEN_REGEXP.test(precedingToken)) {
          imports.push({
            url: ModuleURLUtility.getURL(this.window, moduleURL, match[1]).href,
            type: "esm"
          });
          skipMatchedCode = true;
        } else if (match[3] && PRECEDING_STATEMENT_TOKEN_REGEXP.test(precedingToken)) {
          if (importStartIndex !== -1) {
            throw new this.window.TypeError(`Failed to parse module: Unexpected import statement in "${moduleURL}"`);
          }
          importStartIndex = match.index + match[0].length - 1;
          skipMatchedCode = true;
        } else if (match[4]) {
          if (importStartIndex !== -1) {
            const url2 = ModuleURLUtility.getURL(this.window, moduleURL, match[4]).href;
            const variables = code.substring(importStartIndex, match.index + 1);
            const importRegExp = new RegExp(IMPORT_REGEXP);
            const importCode = [];
            let importMatch;
            while (importMatch = importRegExp.exec(variables)) {
              if (importMatch[1]) {
                importCode.push(`const {${importMatch[1].replace(/\s+as\s+/gm, ": ")}} = $happy_dom.imports.get('${url2}')`);
              } else if (importMatch[2]) {
                importCode.push(`const ${importMatch[2]} = $happy_dom.imports.get('${url2}')`);
              } else if (importMatch[3]) {
                importCode.push(`const ${importMatch[3]} = $happy_dom.imports.get('${url2}').default`);
              }
            }
            newCode += importCode.join(";\n");
            importStartIndex = -1;
            imports.push({ url: url2, type: match[6] || "esm" });
            skipMatchedCode = true;
          }
        } else if (match[7] && match[8] && PRECEDING_STATEMENT_TOKEN_REGEXP.test(precedingToken)) {
          const url2 = ModuleURLUtility.getURL(this.window, moduleURL, match[8]).href;
          const imported = match[7];
          if (imported === "*") {
            newCode += `Object.assign($happy_dom.exports, $happy_dom.imports.get('${url2}'))`;
            imports.push({ url: url2, type: "esm" });
          } else if (imported[0] === "*") {
            const parts = imported.split(/\s+as\s+/);
            if (parts.length === 2) {
              const exportName = parts[1].replace(/["']/g, "");
              newCode += `$happy_dom.exports['${exportName}'] = $happy_dom.imports.get('${url2}')`;
              imports.push({ url: url2, type: "esm" });
            }
          } else if (imported[0] === "{") {
            const parts = this.removeMultilineComments(imported).slice(1, -1).split(/\s*,\s*/);
            const exportCode = [];
            for (const part of parts) {
              const nameParts = part.trim().split(/\s+as\s+/);
              const exportName = (nameParts[1] || nameParts[0]).replace(/["']/g, "");
              const importName = nameParts[0].replace(/["']/g, "");
              if (exportName && importName) {
                exportCode.push(`$happy_dom.exports['${exportName}'] = $happy_dom.imports.get('${url2}')['${importName}']`);
              }
            }
            newCode += exportCode.join(";\n");
            imports.push({ url: url2, type: "esm" });
          }
          skipMatchedCode = true;
        } else if (match[9] && PRECEDING_STATEMENT_TOKEN_REGEXP.test(precedingToken)) {
          newCode += "$happy_dom.exports.default = ";
          skipMatchedCode = true;
        } else if (match[10] && match[11] && PRECEDING_STATEMENT_TOKEN_REGEXP.test(precedingToken)) {
          newCode += `$happy_dom.exports['${match[11]}'] = ${match[10]} ${match[11]}`;
          skipMatchedCode = true;
        } else if (match[12] && PRECEDING_STATEMENT_TOKEN_REGEXP.test(precedingToken)) {
          const parts = this.removeMultilineComments(match[12]).split(/\s*,\s*/);
          const exportCode = [];
          for (const part of parts) {
            const nameParts = part.trim().split(/\s+as\s+/);
            const exportName = (nameParts[1] || nameParts[0]).replace(/["']/g, "");
            const importName = nameParts[0].replace(/["']/g, "");
            if (exportName && importName) {
              exportCode.push(`$happy_dom.exports['${exportName}'] = ${importName}`);
            }
          }
          newCode += exportCode.join(";\n");
          skipMatchedCode = true;
        } else if (match[13] && PRECEDING_STATEMENT_TOKEN_REGEXP.test(precedingToken)) {
          if (match[15] === "=") {
            const exportName = this.removeMultilineComments(match[14]).trim();
            if (exportName[0] === "{" && exportName[exportName.length - 1] === "}" || exportName[0] === "[" && exportName[exportName.length - 1] === "]") {
              const parts = exportName.slice(1, -1).split(/\s*,\s*/);
              const variableObject = /* @__PURE__ */ new Map();
              for (const part of parts) {
                const nameParts = part.trim().split(/\s*:\s*/);
                const exportName2 = (nameParts[1] || nameParts[0]).replace(/["']/g, "");
                const importName = nameParts[0].replace(/["']/g, "");
                if (exportName2 && importName) {
                  variableObject.set(exportName2, importName);
                }
              }
              newCode += `const $happy_dom_export_${exportSpreadVariables.length} =`;
              exportSpreadVariables.push(variableObject);
            } else {
              newCode += `$happy_dom.exports['${exportName}'] =`;
            }
          } else {
            newCode += `/*Unknown export: ${match[0]}*/`;
            this.window.console.warn(`Unknown export in "${moduleURL}": ${match[0]}`);
          }
          skipMatchedCode = true;
        }
      }
      if (match[2]) {
        if (count.simpleString === 0 && count.doubleString === 0 && count.comment === 0 && count.singleLineComment === 0 && count.regExp === 0 && (templateString.length === 0 || templateString[0] > 0) && PRECEDING_STATEMENT_TOKEN_REGEXP.test(precedingToken)) {
          newCode += `$happy_dom.dynamicImport(${match[2]})`;
          skipMatchedCode = true;
        }
      } else if (match[16]) {
        if (count.simpleString === 0 && count.doubleString === 0 && count.singleLineComment === 0 && count.regExpSquareBrackets === 0 && (templateString.length === 0 || templateString[0] > 0)) {
          if (count.comment === 1) {
            if (precedingToken === "*") {
              count.comment = 0;
            }
          } else {
            if (count.regExp === 0) {
              if (code[match.index + 1] === "*") {
                count.comment = 1;
              } else if (code[match.index + 1] === "/") {
                count.singleLineComment = 1;
              } else {
                if (!isEscaped) {
                  let index = match.index - 1;
                  let nonSpacePrecedingToken = code[index];
                  while (nonSpacePrecedingToken === " " || nonSpacePrecedingToken === "\n") {
                    index--;
                    nonSpacePrecedingToken = code[index];
                  }
                  if (PRECEDING_REGEXP_TOKEN_REGEXP.test(nonSpacePrecedingToken)) {
                    count.regExp = 1;
                  }
                }
              }
            } else if (!isEscaped) {
              count.regExp = 0;
            }
          }
        }
      } else if (match[17]) {
        if (count.simpleString === 0 && count.doubleString === 0 && count.regExp === 0 && count.comment === 0 && count.singleLineComment === 0 && (templateString.length === 0 || templateString[0] > 0)) {
          if (match[17] === "(") {
            count.parantheses++;
          } else if (match[17] === ")" && count.parantheses > 0) {
            count.parantheses--;
          }
        }
      } else if (match[18]) {
        if (count.simpleString === 0 && count.doubleString === 0 && count.regExp === 0 && count.comment === 0 && count.singleLineComment === 0 && (templateString.length === 0 || templateString[0] > 0)) {
          if (match[18] === "{") {
            if (templateString.length) {
              templateString[0]++;
            }
            count.curlyBraces++;
          } else if (match[18] === "}") {
            if (templateString.length && templateString[0] > 0) {
              templateString[0]--;
            }
            if (count.curlyBraces > 0) {
              count.curlyBraces--;
            }
          }
        }
      } else if (match[19]) {
        if (count.simpleString === 0 && count.doubleString === 0 && count.comment === 0 && count.singleLineComment === 0 && (templateString.length === 0 || templateString[0] > 0)) {
          if (count.regExp === 1) {
            if (!isEscaped) {
              if (match[19] === "[" && count.regExpSquareBrackets === 0) {
                count.regExpSquareBrackets = 1;
              } else if (match[19] === "]" && count.regExpSquareBrackets === 1) {
                count.regExpSquareBrackets = 0;
              }
            }
          } else {
            if (match[19] === "[") {
              count.squareBrackets++;
            } else if (match[19] === "]" && count.squareBrackets > 0) {
              count.squareBrackets--;
            }
          }
        }
      } else if (match[20]) {
        if (count.simpleString === 0 && count.doubleString === 0 && count.comment === 0 && count.singleLineComment === 0 && count.regExp === 0 && !isEscaped) {
          if (templateString.length > 0) {
            templateString[0]++;
          }
          count.curlyBraces++;
        }
      } else if (match[21]) {
        if (count.simpleString === 0 && count.doubleString === 0 && count.comment === 0 && count.singleLineComment === 0 && count.regExp === 0 && !isEscaped) {
          if (templateString?.[0] == 0) {
            templateString.shift();
            stack.templateString.code.push(code.substring(stack.templateString.index, match.index + 1));
          } else {
            templateString.unshift(0);
            stack.templateString.index = match.index;
          }
        }
      } else if (match[22]) {
        if (count.doubleString === 0 && count.comment === 0 && count.singleLineComment === 0 && count.regExp === 0 && !isEscaped && (templateString.length === 0 || templateString[0] > 0)) {
          if (count.simpleString === 0) {
            count.simpleString = 1;
          } else {
            count.simpleString = 0;
          }
        }
      } else if (match[23]) {
        if (count.simpleString === 0 && count.comment === 0 && count.singleLineComment === 0 && count.regExp === 0 && !isEscaped && (templateString.length === 0 || templateString[0] > 0)) {
          if (count.doubleString === 0) {
            count.doubleString = 1;
          } else {
            count.doubleString = 0;
          }
        }
      } else if (match[24]) {
        count.singleLineComment = 0;
      }
      if (!skipMatchedCode && importStartIndex === -1) {
        newCode += match[0];
      }
      skipMatchedCode = false;
      lastIndex = regExp.lastIndex;
    }
    if (importStartIndex !== -1) {
      throw new this.window.TypeError(`Failed to parse module: Unexpected import statement in "${moduleURL}"`);
    }
    newCode += code.substring(lastIndex);
    if (exportSpreadVariables.length > 0) {
      newCode += "\n\n";
      for (let i = 0; i < exportSpreadVariables.length; i++) {
        for (const [exportName, importName] of exportSpreadVariables[i]) {
          newCode += `$happy_dom.exports['${exportName}'] = $happy_dom_export_${i}['${importName}'];
`;
        }
      }
    }
    if (!browserSettings.disableErrorCapturing && browserSettings.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch) {
      newCode += `
} catch(e) {
   $happy_dom.dispatchError(e);
}`;
    }
    newCode += "\n})";
    try {
      return { imports, execute: this.window.eval(newCode) };
    } catch (e) {
      const error2 = new this.window.SyntaxError(`Failed to parse module '${moduleURL}': ${e.message}`);
      if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum_default.tryAndCatch) {
        throw error2;
      } else {
        this.window[dispatchError](error2);
        return {
          imports,
          execute: () => {
          }
        };
      }
    }
  }
  /**
   * Remove multiline comments.
   *
   * @param code Code.
   * @returns Code without multiline comments.
   */
  removeMultilineComments(code) {
    const regexp = new RegExp(MULTILINE_COMMENT_REGEXP);
    let match;
    let count = 0;
    let lastIndex = 0;
    let newCode = "";
    while (match = regexp.exec(code)) {
      if (count === 0) {
        newCode += code.substring(lastIndex, match.index);
      }
      if (match[0] === "/*") {
        count++;
      } else if (match[0] === "*/" && count > 0) {
        count--;
      }
      lastIndex = regexp.lastIndex;
    }
    newCode += code.substring(lastIndex);
    return newCode;
  }
};

// node_modules/happy-dom/lib/module/ECMAScriptModule.js
var EMPTY_COMPILED_RESULT = { imports: [], execute: () => {
} };
var ECMAScriptModule = class {
  url;
  [window];
  #source;
  #preloaded = false;
  #compiled = null;
  #exports = null;
  /**
   * Constructor.
   *
   * @param window Window.
   * @param url Module URL.
   * @param source Source code.
   */
  constructor(window2, url2, source) {
    this[window] = window2;
    this.url = url2;
    this.#source = source;
  }
  /**
   * Compiles and evaluates the module.
   *
   * @returns Module exports.
   */
  async evaluate() {
    if (this.#exports) {
      return this.#exports;
    }
    const compiled = this.#compile();
    const modulePromises = [];
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return {};
    }
    for (const moduleImport of compiled.imports) {
      modulePromises.push(ModuleFactory.getModule(window2, this.url, moduleImport.url, {
        with: { type: moduleImport.type }
      }));
    }
    const modules2 = await Promise.all(modulePromises);
    const imports = /* @__PURE__ */ new Map();
    for (const module of modules2) {
      imports.set(module.url.href, await module.evaluate());
    }
    const exports = {};
    this.#exports = exports;
    compiled.execute({
      dispatchError: window2[dispatchError].bind(window2),
      dynamicImport: this.#import.bind(this),
      imports,
      exports
    });
    return exports;
  }
  /**
   * Compiles and preloads the module and its imports.
   *
   * @returns Promise.
   */
  async preload() {
    if (this.#preloaded) {
      return;
    }
    this.#preloaded = true;
    const compiled = this.#compile();
    const modulePromises = [];
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return;
    }
    for (const moduleImport of compiled.imports) {
      modulePromises.push(ModuleFactory.getModule(window2, this.url, moduleImport.url, {
        with: { type: moduleImport.type }
      }));
    }
    const modules2 = await Promise.all(modulePromises);
    const promises = [];
    for (const module of modules2) {
      promises.push(module.preload());
    }
    await Promise.all(promises);
  }
  /**
   * Compiles the module.
   */
  #compile() {
    if (this.#compiled) {
      return this.#compiled;
    }
    this.#compiled = EMPTY_COMPILED_RESULT;
    const compiler = new ECMAScriptModuleCompiler(this[window]);
    this.#compiled = compiler.compile(this.url.href, this.#source);
    return this.#compiled;
  }
  /**
   * Imports a module.
   *
   * @param url URL.
   * @param [options] Options.
   * @param [options.with] With.
   * @param [options.with.type] Type.
   */
  async #import(url2, options2) {
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return;
    }
    const asyncTaskManager2 = browserFrame[asyncTaskManager];
    const taskID = asyncTaskManager2?.startTask();
    const module = await ModuleFactory.getModule(window2, this.url, url2, options2);
    const exports = await module.evaluate();
    asyncTaskManager2.endTask(taskID);
    return exports;
  }
};

// node_modules/happy-dom/lib/module/ModuleFactory.js
var ModuleFactory = class {
  /**
   * Fetches the source code of the module from the given URL and creates a new module instance.
   *
   * @param window Window.
   * @param parentURL Parent URL.
   * @param url Module URL.
   * @param [options] Options.
   * @param [options.with] Options.
   * @param [options.with.type] Module type.
   */
  static async getModule(window2, parentURL, url2, options2) {
    const absoluteURL = this.getURL(window2, parentURL, url2);
    const absoluteURLString = absoluteURL.href;
    const type2 = options2?.with?.type || "esm";
    if (type2 !== "esm" && type2 !== "css" && type2 !== "json") {
      throw new window2.TypeError(`Failed to import module "${absoluteURL}" from "${parentURL}": Unkown type "${type2}"`);
    }
    const cached = window2[modules][type2].get(absoluteURLString);
    if (cached) {
      if (cached instanceof UnresolvedModule) {
        await new Promise((resolve, reject) => {
          cached.addResolveListener(resolve, reject);
        });
        return window2[modules][type2].get(absoluteURLString);
      }
      return cached;
    }
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      throw new window2.TypeError(`Failed to import module "${absoluteURL}" from "${parentURL}": Window is closed and is no longer attached to a frame`);
    }
    const unresolvedModule = new UnresolvedModule(window2, absoluteURL);
    window2[modules][type2].set(absoluteURLString, unresolvedModule);
    const resourceFetch = new ResourceFetch(window2);
    let source;
    try {
      source = await resourceFetch.fetch(absoluteURL, "module");
    } catch (error2) {
      unresolvedModule.resolve(error2);
      throw error2;
    }
    let module;
    switch (type2) {
      case "json":
        module = new JSONModule(window2, absoluteURL, source);
        break;
      case "css":
        module = new CSSModule(window2, absoluteURL, source);
        break;
      case "esm":
        module = new ECMAScriptModule(window2, absoluteURL, source);
        break;
    }
    window2[modules][type2].set(absoluteURLString, module);
    unresolvedModule.resolve();
    return module;
  }
  /**
   * Returns module URL based on parent URL and the import map.
   *
   * @param window Window.
   * @param parentURL Parent URL.
   * @param url Module URL.
   */
  static getURL(window2, parentURL, url2) {
    const parentURLString = parentURL.href;
    const absoluteURL = new URL12(url2, parentURLString);
    const absoluteURLString = absoluteURL.href;
    const importMap = window2[moduleImportMap];
    if (!importMap) {
      return absoluteURL;
    }
    if (importMap.scopes) {
      for (const scope of importMap.scopes) {
        if (parentURLString.includes(scope.scope)) {
          for (const rule of scope.rules) {
            if (absoluteURLString.startsWith(rule.from)) {
              return new URL12(rule.to + absoluteURLString.replace(rule.from, ""));
            }
          }
        }
      }
    }
    if (importMap.imports) {
      for (const rule of importMap.imports) {
        if (absoluteURLString.startsWith(rule.from)) {
          return new URL12(rule.to + absoluteURLString.replace(rule.from, ""));
        }
      }
    }
    return absoluteURL;
  }
};

// node_modules/happy-dom/lib/fetch/preload/PreloadEntry.js
var PreloadEntry = class {
  integrityMetadata = null;
  response = null;
  error = null;
  #callback = null;
  /**
   * On response available.
   *
   * @returns Response.
   */
  onResponseAvailable() {
    return new Promise((resolve, reject) => {
      this.#callback = { resolve, reject };
    });
  }
  /**
   * Response available.
   *
   * @param error
   * @param response
   */
  responseAvailable(error2, response) {
    this.response = response;
    this.error = error2;
    if (!this.#callback) {
      return;
    }
    if (error2) {
      this.#callback.reject(error2);
    } else {
      this.#callback.resolve(response);
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-link-element/HTMLLinkElement.js
var HTMLLinkElement = class extends HTMLElement {
  // Internal properties
  [sheet] = null;
  [evaluateCSS] = true;
  [relList] = null;
  #loadedStyleSheetURL = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onerror");
  }
  set onerror(value2) {
    this[propertyEventListeners].set("onerror", value2);
  }
  get onload() {
    return ElementEventAttributeUtility.getEventListener(this, "onload");
  }
  set onload(value2) {
    this[propertyEventListeners].set("onload", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns sheet.
   */
  get sheet() {
    return this[sheet];
  }
  /**
   * Returns rel list.
   *
   * @returns Rel list.
   */
  get relList() {
    if (!this[relList]) {
      this[relList] = new DOMTokenList(illegalConstructor, this, "rel", ["stylesheet", "modulepreload", "preload"]);
    }
    return this[relList];
  }
  /**
   * Sets rel list.
   *
   * @param value Value.
   */
  set relList(value2) {
    this.setAttribute("rel", value2);
  }
  /**
   * Returns as.
   *
   * @returns As.
   */
  get as() {
    return this.getAttribute("as") || "";
  }
  /**
   * Sets as.
   *
   * @param as As.
   */
  set as(as) {
    this.setAttribute("as", as);
  }
  /**
   * Returns crossOrigin.
   *
   * @returns CrossOrigin.
   */
  get crossOrigin() {
    return this.getAttribute("crossorigin") || "";
  }
  /**
   * Sets crossOrigin.
   *
   * @param crossOrigin CrossOrigin.
   */
  set crossOrigin(crossOrigin2) {
    this.setAttribute("crossorigin", crossOrigin2);
  }
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this.hasAttribute("href")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("href"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("href");
    }
  }
  /**
   * Sets href.
   *
   * @param href Href.
   */
  set href(href2) {
    this.setAttribute("href", href2);
  }
  /**
   * Returns hreflang.
   *
   * @returns Hreflang.
   */
  get hreflang() {
    return this.getAttribute("hreflang") || "";
  }
  /**
   * Sets hreflang.
   *
   * @param hreflang Hreflang.
   */
  set hreflang(hreflang) {
    this.setAttribute("hreflang", hreflang);
  }
  /**
   * Returns media.
   *
   * @returns Media.
   */
  get media() {
    return this.getAttribute("media") || "";
  }
  /**
   * Sets media.
   *
   * @param media Media.
   */
  set media(media) {
    this.setAttribute("media", media);
  }
  /**
   * Returns referrerPolicy.
   *
   * @returns ReferrerPolicy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerPolicy") || "";
  }
  /**
   * Sets referrerPolicy.
   *
   * @param referrerPolicy ReferrerPolicy.
   */
  set referrerPolicy(referrerPolicy2) {
    this.setAttribute("referrerPolicy", referrerPolicy2);
  }
  /**
   * Returns rel.
   *
   * @returns Rel.
   */
  get rel() {
    return this.getAttribute("rel") || "";
  }
  /**
   * Sets rel.
   *
   * @param rel Rel.
   */
  set rel(rel) {
    this.setAttribute("rel", rel);
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
  /**
   * @override
   */
  [connectedToDocument]() {
    super[connectedToDocument]();
    const rel = this.getAttribute("rel");
    const href2 = this.getAttribute("href");
    if (rel && href2) {
      switch (rel) {
        case "stylesheet":
          this.#loadStyleSheet(href2);
          break;
        case "modulepreload":
          this.#preloadModule(href2);
          break;
        case "preload":
          this.#preloadResource(href2);
          break;
      }
    }
  }
  /**
   * @override
   */
  [onSetAttribute](attribute, replacedAttribute) {
    super[onSetAttribute](attribute, replacedAttribute);
    if (attribute[name] === "rel" || attribute[name] === "href") {
      const rel = this.getAttribute("rel");
      const href2 = this.getAttribute("href");
      if (rel && href2) {
        switch (rel) {
          case "stylesheet":
            this.#loadStyleSheet(href2);
            break;
          case "modulepreload":
            this.#preloadModule(href2);
            break;
          case "preload":
            this.#preloadResource(href2);
            break;
        }
      }
    }
  }
  /**
   * Preloads a module.
   *
   * @param url URL.
   */
  async #preloadModule(url2) {
    const absoluteURL = new URL(url2, this[ownerDocument].location.href);
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    const browserSettings = new WindowBrowserContext(window2).getSettings();
    if (!browserSettings || !this[isConnected] || browserSettings.disableJavaScriptFileLoading || browserSettings.disableJavaScriptEvaluation) {
      return;
    }
    if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum_default.tryAndCatch) {
      const module = await ModuleFactory.getModule(window2, absoluteURL, url2);
      await module.preload();
    } else {
      try {
        const module = await ModuleFactory.getModule(window2, absoluteURL, url2);
        await module.preload();
      } catch (error2) {
        browserFrame.page?.console.error(error2);
        window2[dispatchError](error2);
        return;
      }
    }
  }
  /**
   * Preloads a resource.
   *
   * @param url URL.
   */
  async #preloadResource(url2) {
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    const browserSettings = browserFrame.page?.context?.browser?.settings;
    const as = this.as;
    if (!browserFrame || !this[isConnected] || as !== "script" && as !== "style" && as !== "fetch") {
      return;
    }
    if (as === "script" && (browserSettings.disableJavaScriptFileLoading || browserSettings.disableJavaScriptEvaluation)) {
      return;
    }
    if (as === "style" && browserSettings.disableCSSFileLoading) {
      return;
    }
    const absoluteURL = new URL(url2, window2.location.href).href;
    const preloadKey = PreloadUtility.getKey({
      url: absoluteURL,
      destination: as,
      mode: "cors",
      credentialsMode: this.crossOrigin === "use-credentials" ? "include" : "same-origin"
    });
    if (window2.document[preloads].has(preloadKey)) {
      return;
    }
    const preloadEntry = new PreloadEntry();
    window2.document[preloads].set(preloadKey, preloadEntry);
    const fetch = new Fetch({
      browserFrame,
      window: window2,
      url: absoluteURL,
      disableSameOriginPolicy: as === "script" || as === "style",
      disablePreload: true,
      init: {
        credentials: this.crossOrigin === "use-credentials" ? "include" : "same-origin"
      }
    });
    try {
      const response = await fetch.send();
      if (!response[buffer]) {
        await response.buffer();
      }
      preloadEntry.responseAvailable(null, response);
    } catch (error2) {
      preloadEntry.responseAvailable(error2, null);
      window2.document[preloads].delete(preloadKey);
      browserFrame.page?.console?.error(`Failed to preload resource "${absoluteURL}": ${error2.message}`);
    }
  }
  /**
   * Returns a URL relative to the given Location object.
   *
   * @param url URL.
   * @param rel Rel.
   */
  async #loadStyleSheet(url2) {
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return;
    }
    const browserSettings = browserFrame.page?.context?.browser?.settings;
    if (!this[evaluateCSS] || !this[isConnected]) {
      return;
    }
    let absoluteURL;
    try {
      absoluteURL = new URL(url2, window2.location.href).href;
    } catch (error3) {
      return;
    }
    if (this.#loadedStyleSheetURL === absoluteURL) {
      return;
    }
    if (browserSettings && browserSettings.disableCSSFileLoading) {
      if (browserSettings.handleDisabledFileLoadingAsSuccess) {
        this.dispatchEvent(new Event("load"));
      } else {
        const error3 = new window2.DOMException(`Failed to load external stylesheet "${absoluteURL}". CSS file loading is disabled.`, DOMExceptionNameEnum_default.notSupportedError);
        browserFrame.page?.console.error(error3);
        this.dispatchEvent(new Event("error"));
      }
      return;
    }
    const resourceFetch = new ResourceFetch(window2);
    const readyStateManager2 = window2[readyStateManager];
    this.#loadedStyleSheetURL = absoluteURL;
    readyStateManager2.startTask();
    let code = null;
    let error2 = null;
    try {
      code = await resourceFetch.fetch(absoluteURL, "style", {
        credentials: this.crossOrigin === "use-credentials" ? "include" : "same-origin"
      });
    } catch (e) {
      error2 = e;
    }
    readyStateManager2.endTask();
    if (error2) {
      browserFrame.page?.console.error(error2);
      this.dispatchEvent(new Event("error"));
    } else {
      const styleSheet = new this[ownerDocument][window].CSSStyleSheet();
      styleSheet.replaceSync(code);
      this[sheet] = styleSheet;
      const document = this[ownerDocument];
      if (document) {
        for (const item of document[affectsComputedStyleCache]) {
          item.result = null;
        }
        document[affectsComputedStyleCache] = [];
      }
      this.dispatchEvent(new Event("load"));
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-map-element/HTMLMapElement.js
var HTMLMapElement = class extends HTMLElement {
  [areas] = null;
  /**
   * Returns areas.
   *
   * @returns Areas.
   */
  get areas() {
    if (!this[areas]) {
      this[areas] = ParentNodeUtility.getElementsByTagName(this, "area");
    }
    return this[areas];
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/TextTrackCueList.js
var TextTrackCueList = class extends Array {
  /**
   * Constructor.
   *
   * @param [illegalConstructorSymbol] Illegal constructor symbol.
   */
  constructor(illegalConstructorSymbol) {
    super();
    if (illegalConstructorSymbol !== 1 && illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
  }
  /**
   * Returns the first TextTrackCue object with the identifier passed to it.
   *
   * @param id Text track cue identifier.
   */
  getCueById(id2) {
    for (const cue of this) {
      if (cue.id === id2) {
        return cue;
      }
    }
    return null;
  }
};

// node_modules/happy-dom/lib/nodes/html-menu-element/HTMLMenuElement.js
var HTMLMenuElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-meta-element/HTMLMetaElement.js
var HTMLMetaElement = class extends HTMLElement {
  /**
   * Returns content.
   *
   * @returns Content.
   */
  get content() {
    return this.getAttribute("content") || "";
  }
  /**
   * Sets content.
   *
   * @param content Content.
   */
  set content(content2) {
    this.setAttribute("content", content2);
  }
  /**
   * Returns httpEquiv.
   *
   * @returns HttpEquiv.
   */
  get httpEquiv() {
    return this.getAttribute("http-equiv") || "";
  }
  /**
   * Sets httpEquiv.
   *
   * @param httpEquiv HttpEquiv.
   */
  set httpEquiv(httpEquiv) {
    this.setAttribute("http-equiv", httpEquiv);
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns scheme.
   *
   * @returns Name.
   */
  get scheme() {
    return this.getAttribute("scheme") || "";
  }
  /**
   * Sets scheme.
   *
   * @param scheme Scheme.
   */
  set scheme(scheme) {
    this.setAttribute("scheme", scheme);
  }
};

// node_modules/happy-dom/lib/nodes/html-meter-element/HTMLMeterElement.js
var HTMLMeterElement = class extends HTMLElement {
  /**
   * Returns high.
   *
   * @returns High.
   */
  get high() {
    if (!this.hasAttribute("high")) {
      return 1;
    }
    const parsedValue = parseFloat(this.getAttribute("high") || "");
    if (isNaN(parsedValue) || parsedValue > 1) {
      return 1;
    }
    return parsedValue < 0 ? 0 : parsedValue;
  }
  /**
   * Sets high.
   *
   * @param high High.
   */
  set high(high) {
    high = typeof high !== "number" ? Number(high) : high;
    if (isNaN(high)) {
      throw new this[window].TypeError("Failed to set the 'high' property on 'HTMLMeterElement': The provided double value is non-finite.");
    }
    this.setAttribute("high", String(high));
  }
  /**
   * Returns low.
   *
   * @returns Low.
   */
  get low() {
    if (!this.hasAttribute("low")) {
      return 0;
    }
    const parsedValue = parseFloat(this.getAttribute("low") || "");
    if (isNaN(parsedValue) || parsedValue < 0) {
      return 0;
    }
    return parsedValue > 1 ? 1 : parsedValue;
  }
  /**
   * Sets low.
   *
   * @param low Low.
   */
  set low(low) {
    low = typeof low !== "number" ? Number(low) : low;
    if (isNaN(low)) {
      throw new this[window].TypeError("Failed to set the 'low' property on 'HTMLMeterElement': The provided double value is non-finite.");
    }
    this.setAttribute("low", String(low));
  }
  /**
   * Returns max.
   *
   * @returns Max.
   */
  get max() {
    if (!this.hasAttribute("max")) {
      return 1;
    }
    const parsedValue = parseFloat(this.getAttribute("max") || "");
    if (isNaN(parsedValue) || parsedValue > 1) {
      return 1;
    }
    return parsedValue < 0 ? 0 : parsedValue;
  }
  /**
   * Sets max.
   *
   * @param max Max.
   */
  set max(max) {
    max = typeof max !== "number" ? Number(max) : max;
    if (isNaN(max)) {
      throw new this[window].TypeError("Failed to set the 'max' property on 'HTMLMeterElement': The provided double value is non-finite.");
    }
    this.setAttribute("max", String(max));
  }
  /**
   * Returns min.
   *
   * @returns Min.
   */
  get min() {
    if (!this.hasAttribute("min")) {
      return 0;
    }
    const parsedValue = parseFloat(this.getAttribute("min") || "");
    if (isNaN(parsedValue) || parsedValue < 0) {
      return 0;
    }
    return parsedValue > 1 ? 1 : parsedValue;
  }
  /**
   * Sets min.
   *
   * @param min Min.
   */
  set min(min) {
    min = typeof min !== "number" ? Number(min) : min;
    if (isNaN(min)) {
      throw new this[window].TypeError("Failed to set the 'min' property on 'HTMLMeterElement': The provided double value is non-finite.");
    }
    this.setAttribute("min", String(min));
  }
  /**
   * Returns optimum.
   *
   * @returns Optimum.
   */
  get optimum() {
    if (!this.hasAttribute("optimum")) {
      return 0.5;
    }
    const parsedValue = parseFloat(this.getAttribute("optimum") || "");
    if (isNaN(parsedValue)) {
      return 0.5;
    }
    if (parsedValue < 0) {
      return 0;
    }
    return parsedValue > 1 ? 1 : parsedValue;
  }
  /**
   * Sets optimum.
   *
   * @param optimum Optimum.
   */
  set optimum(optimum) {
    optimum = typeof optimum !== "number" ? Number(optimum) : optimum;
    if (isNaN(optimum)) {
      throw new this[window].TypeError("Failed to set the 'optimum' property on 'HTMLMeterElement': The provided double value is non-finite.");
    }
    this.setAttribute("optimum", String(optimum));
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    if (!this.hasAttribute("value")) {
      return 0;
    }
    const parsedValue = parseFloat(this.getAttribute("value") || "");
    if (isNaN(parsedValue) || parsedValue < 0) {
      return 0;
    }
    return parsedValue > 1 ? 1 : parsedValue;
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    value2 = typeof value2 !== "number" ? Number(value2) : value2;
    if (isNaN(value2)) {
      throw new this[window].TypeError("Failed to set the 'value' property on 'HTMLMeterElement': The provided double value is non-finite.");
    }
    this.setAttribute("value", String(value2));
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
};

// node_modules/happy-dom/lib/nodes/html-mod-element/HTMLModElement.js
var HTMLModElement = class extends HTMLElement {
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get cite() {
    if (!this.hasAttribute("cite")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("cite"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("cite");
    }
  }
  /**
   * Sets source.
   *
   * @param cite Source.
   */
  set cite(cite) {
    this.setAttribute("cite", cite);
  }
  /**
   * Returns date time.
   *
   * @returns Date time.
   */
  get dateTime() {
    return this.getAttribute("datetime") || "";
  }
  /**
   * Sets date time.
   *
   * @param dateTime Date time.
   */
  set dateTime(dateTime) {
    this.setAttribute("datetime", dateTime);
  }
};

// node_modules/happy-dom/lib/nodes/html-o-list-element/HTMLOListElement.js
var HTMLOListElement = class extends HTMLElement {
  /**
   * Returns reversed.
   *
   * @returns Reversed.
   */
  get reversed() {
    return this.getAttribute("reversed") !== null;
  }
  /**
   * Sets reversed.
   *
   * @param reversed Reversed.
   */
  set reversed(reversed) {
    if (!reversed) {
      this.removeAttribute("reversed");
    } else {
      this.setAttribute("reversed", "");
    }
  }
  /**
   * Returns start.
   *
   * @returns Start.
   */
  get start() {
    if (!this.hasAttribute("start")) {
      return 1;
    }
    const parsedValue = Number(this.getAttribute("start") || "");
    if (isNaN(parsedValue)) {
      return 1;
    }
    return parsedValue;
  }
  /**
   * Sets start.
   *
   * @param start Start.
   */
  set start(start2) {
    if (typeof start2 !== "number") {
      start2 = Number(start2);
    }
    if (isNaN(start2)) {
      start2 = 0;
    }
    this.setAttribute("start", String(start2));
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
};

// node_modules/happy-dom/lib/nodes/html-opt-group-element/HTMLOptGroupElement.js
var HTMLOptGroupElement = class extends HTMLElement {
  /**
   * Returns label.
   *
   * @returns Label.
   */
  get label() {
    return this.getAttribute("label") || "";
  }
  /**
   * Sets label.
   *
   * @param label Label.
   */
  set label(label2) {
    if (!label2) {
      this.removeAttribute("label");
    } else {
      this.setAttribute("label", label2);
    }
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    if (!disabled2) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-option-element/HTMLOptionElement.js
var HTMLOptionElement = class extends HTMLElement {
  [selectedness] = false;
  [dirtyness] = false;
  [selectNode] = null;
  /**
   * Returns inner text, which is the rendered appearance of text.
   *
   * @returns Inner text.
   */
  get text() {
    return this.innerText;
  }
  /**
   * Sets the inner text, which is the rendered appearance of text.
   *
   * @param innerText Inner text.
   */
  set text(text) {
    this.innerText = text;
  }
  /**
   * Returns index.
   *
   * @returns Index.
   */
  get index() {
    if (!this[selectNode]) {
      return 0;
    }
    const options2 = QuerySelector.querySelectorAll(this[selectNode], "option")[elements];
    return options2.indexOf(this);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    return this[selectNode]?.form || null;
  }
  /**
   * Returns selected.
   *
   * @returns Selected.
   */
  get selected() {
    return this[selectedness];
  }
  /**
   * Sets selected.
   *
   * @param selected Selected.
   */
  set selected(selected) {
    const selectNode2 = this[selectNode];
    this[dirtyness] = true;
    this[selectedness] = Boolean(selected);
    if (selectNode2) {
      selectNode2[updateSelectedness](this[selectedness] ? this : null);
    }
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    if (!disabled2) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    return this.getAttribute("value") ?? this.textContent;
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    this.setAttribute("value", value2);
  }
  /**
   * @override
   */
  [onSetAttribute](attribute, replacedAttribute) {
    super[onSetAttribute](attribute, replacedAttribute);
    if (!this[dirtyness] && attribute[name] === "selected" && replacedAttribute?.[value] !== attribute[value]) {
      const selectNode2 = this[selectNode];
      this[selectedness] = true;
      if (selectNode2) {
        selectNode2[updateSelectedness](this);
      }
    }
  }
  /**
   * @override
   */
  [onRemoveAttribute](removedAttribute) {
    super[onRemoveAttribute](removedAttribute);
    if (removedAttribute && !this[dirtyness] && removedAttribute[name] === "selected") {
      const selectNode2 = this[selectNode];
      this[selectedness] = false;
      if (selectNode2) {
        selectNode2[updateSelectedness]();
      }
    }
  }
  /**
   * @override
   */
  [connectedToNode]() {
    super[connectedToNode]();
    if (this[selectNode]) {
      this[selectNode][updateSelectedness]();
    }
  }
  /**
   * @override
   */
  [disconnectedFromNode]() {
    if (this[selectNode]) {
      this[selectNode][updateSelectedness]();
    }
    super[disconnectedFromNode]();
  }
};

// node_modules/happy-dom/lib/nodes/html-paragraph-element/HTMLParagraphElement.js
var HTMLParagraphElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-param-element/HTMLParamElement.js
var HTMLParamElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-picture-element/HTMLPictureElement.js
var HTMLPictureElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-pre-element/HTMLPreElement.js
var HTMLPreElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-progress-element/HTMLProgressElement.js
var HTMLProgressElement = class extends HTMLElement {
  /**
   * Returns max.
   *
   * @returns Max.
   */
  get max() {
    if (!this.hasAttribute("max")) {
      return 1;
    }
    const parsedValue = parseFloat(this.getAttribute("max") || "");
    if (isNaN(parsedValue) || parsedValue < 0) {
      return 1;
    }
    return parsedValue;
  }
  /**
   * Sets max.
   *
   * @param max Max.
   */
  set max(max) {
    max = typeof max !== "number" ? Number(max) : max;
    if (isNaN(max)) {
      throw new this[window].TypeError("Failed to set the 'max' property on 'HTMLProgressElement': The provided double value is non-finite.");
    }
    this.setAttribute("max", max < 0 ? "1" : String(max));
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    if (!this.hasAttribute("value")) {
      return 0;
    }
    const parsedValue = parseFloat(this.getAttribute("value") || "");
    if (isNaN(parsedValue) || parsedValue < 0) {
      return 0;
    }
    return parsedValue;
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    value2 = typeof value2 !== "number" ? Number(value2) : value2;
    if (isNaN(value2)) {
      throw new this[window].TypeError("Failed to set the 'value' property on 'HTMLProgressElement': The provided double value is non-finite.");
    }
    this.setAttribute("value", value2 < 0 ? "0" : String(value2));
  }
  /**
   * Returns position.
   *
   * @returns Position.
   */
  get position() {
    if (!this.hasAttribute("value")) {
      return -1;
    }
    return this.value / this.max;
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
};

// node_modules/happy-dom/lib/nodes/html-quote-element/HTMLQuoteElement.js
var HTMLQuoteElement = class extends HTMLElement {
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get cite() {
    if (!this.hasAttribute("cite")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("cite"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("cite");
    }
  }
  /**
   * Sets source.
   *
   * @param cite Source.
   */
  set cite(cite) {
    this.setAttribute("cite", cite);
  }
};

// node_modules/happy-dom/lib/nodes/html-script-element/HTMLScriptElement.js
var HTMLScriptElement = class extends HTMLElement {
  // Internal properties
  [evaluateScript] = true;
  [blocking] = null;
  // Private properties
  #loadedScriptURL = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onerror");
  }
  set onerror(value2) {
    this[propertyEventListeners].set("onerror", value2);
  }
  get onload() {
    return ElementEventAttributeUtility.getEventListener(this, "onload");
  }
  set onload(value2) {
    this[propertyEventListeners].set("onload", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
  /**
   * Returns blocking.
   */
  get blocking() {
    if (!this[blocking]) {
      this[blocking] = new DOMTokenList(illegalConstructor, this, "blocking");
    }
    return this[blocking];
  }
  /**
   * Sets blocking.
   *
   * @param value Value.
   */
  set blocking(value2) {
    this.setAttribute("blocking", value2);
  }
  /**
   * Returns crossOrigin.
   *
   * @returns CrossOrigin.
   */
  get crossOrigin() {
    return this.getAttribute("crossorigin") || "";
  }
  /**
   * Sets crossOrigin.
   *
   * @param crossOrigin CrossOrigin.
   */
  set crossOrigin(crossOrigin2) {
    this.setAttribute("crossorigin", crossOrigin2);
  }
  /**
   * Returns fetch priority.
   *
   * @returns Fetch priority.
   */
  get fetchPriority() {
    const fetchPriority = this.getAttribute("fetchpriority");
    switch (fetchPriority) {
      case "high":
      case "low":
      case "normal":
        return fetchPriority;
      default:
        return "auto";
    }
  }
  /**
   * Sets fetch priority.
   *
   * @param fetchPriority Fetch priority.
   */
  set fetchPriority(fetchPriority) {
    this.setAttribute("fetchpriority", fetchPriority);
  }
  /**
   * Returns noModule.
   *
   * @returns NoModule.
   */
  get noModule() {
    return this.getAttribute("nomodule") !== null;
  }
  /**
   * Sets noModule.
   *
   * @param noModule NoModule.
   */
  set noModule(noModule) {
    if (noModule) {
      this.setAttribute("nomodule", "");
    } else {
      this.removeAttribute("nomodule");
    }
  }
  /**
   * Returns integrity.
   *
   * @returns Integrity.
   */
  get integrity() {
    return this.getAttribute("integrity") || "";
  }
  /**
   * Sets integrity.
   *
   * @param integrity Integrity.
   */
  set integrity(integrity) {
    this.setAttribute("integrity", integrity);
  }
  /**
   * Returns referrerPolicy.
   *
   * @returns ReferrerPolicy.
   */
  get referrerPolicy() {
    const referrerPolicy2 = this.getAttribute("referrerpolicy");
    switch (referrerPolicy2) {
      case "no-referrer":
      case "no-referrer-when-downgrade":
      case "same-origin":
      case "origin":
      case "strict-origin":
      case "origin-when-cross-origin":
      case "strict-origin-when-cross-origin":
      case "unsafe-url":
        return referrerPolicy2;
      default:
        return "";
    }
  }
  /**
   * Sets referrerPolicy.
   *
   * @param referrerPolicy ReferrerPolicy.
   */
  set referrerPolicy(referrerPolicy2) {
    this.setAttribute("referrerpolicy", referrerPolicy2);
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns charset.
   *
   * @returns Charset.
   */
  get charset() {
    return this.getAttribute("charset") || "";
  }
  /**
   * Sets charset.
   *
   * @param charset Charset.
   */
  set charset(charset) {
    this.setAttribute("charset", charset);
  }
  /**
   * Returns lang.
   *
   * @returns Lang.
   */
  get lang() {
    return this.getAttribute("lang") || "";
  }
  /**
   * Sets lang.
   *
   * @param lang Lang.
   */
  set lang(lang) {
    this.setAttribute("lang", lang);
  }
  /**
   * Returns async.
   *
   * @returns Async.
   */
  get async() {
    return this.getAttribute("async") !== null;
  }
  /**
   * Sets async.
   *
   * @param async Async.
   */
  set async(async) {
    if (!async) {
      this.removeAttribute("async");
    } else {
      this.setAttribute("async", "");
    }
  }
  /**
   * Returns defer.
   *
   * @returns Defer.
   */
  get defer() {
    return this.getAttribute("defer") !== null;
  }
  /**
   * Sets defer.
   *
   * @param defer Defer.
   */
  set defer(defer) {
    if (!defer) {
      this.removeAttribute("defer");
    } else {
      this.setAttribute("defer", "");
    }
  }
  /**
   * Returns text.
   *
   * @returns Text.
   */
  get text() {
    return this.textContent;
  }
  /**
   * Sets text.
   *
   * @param text Text.
   */
  set text(text) {
    this.textContent = text;
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * @override
   */
  [connectedToDocument]() {
    const browserSettings = new WindowBrowserContext(this[window]).getSettings();
    super[connectedToDocument]();
    if (this[evaluateScript]) {
      const src = this.getAttribute("src");
      if (src !== null) {
        if (this.getAttribute("type") === "module") {
          this.#loadModule(src);
        } else {
          this.#loadScript(src);
        }
      } else if (browserSettings && !browserSettings.disableJavaScriptEvaluation) {
        const source = this.textContent;
        const type2 = this.getAttribute("type");
        if (source) {
          if (type2 === "module") {
            this.#evaluateModule(source);
          } else if (type2 === "importmap") {
            this.#evaluateImportMap(source);
          } else if (type2 === null || type2 === "application/x-ecmascript" || type2 === "application/x-javascript" || type2.startsWith("text/javascript")) {
            this.#evaluateScript(source);
          }
        }
      }
    }
  }
  /**
   * @override
   */
  [onSetAttribute](attribute, replacedAttribute) {
    super[onSetAttribute](attribute, replacedAttribute);
    if (attribute[name] === "src" && attribute[value] !== null && this[isConnected]) {
      if (this.getAttribute("type") === "module") {
        this.#loadModule(attribute[value]);
      } else {
        this.#loadScript(attribute[value]);
      }
    }
  }
  /**
   * Evaluates a module.
   *
   * @param source Source.
   */
  async #evaluateModule(source) {
    const url2 = this[ownerDocument].location;
    const window2 = this[window];
    const browserSettings = new WindowBrowserContext(window2).getSettings();
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return;
    }
    const module = new ECMAScriptModule(window2, url2, source);
    const readyStateManager2 = window2[readyStateManager];
    readyStateManager2.startTask();
    if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum_default.tryAndCatch) {
      await module.evaluate();
    } else {
      try {
        await module.evaluate();
      } catch (error2) {
        window2[dispatchError](error2);
        return;
      }
    }
    readyStateManager2.endTask();
    this.dispatchEvent(new Event("load"));
  }
  /**
   * Evaluates an import map.
   *
   * @param source Source.
   */
  async #evaluateImportMap(source) {
    const window2 = this[window];
    const browserSettings = new WindowBrowserContext(window2).getSettings();
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame || window2[moduleImportMap]) {
      return;
    }
    let json;
    if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum_default.tryAndCatch) {
      json = JSON.parse(source);
    } else {
      try {
        json = JSON.parse(source);
      } catch (error2) {
        window2[dispatchError](error2);
        return;
      }
    }
    if (json.imports || json.scopes) {
      const importMap = {
        imports: [],
        scopes: []
      };
      if (json.imports) {
        for (const key of Object.keys(json.imports)) {
          importMap.imports.push({
            from: key,
            to: json.imports[key]
          });
        }
      }
      if (json.scopes) {
        for (const scopeKey of Object.keys(json.scopes)) {
          const scope = {
            scope: scopeKey,
            rules: []
          };
          for (const importKey of Object.keys(json.scopes[scopeKey])) {
            const value2 = json.scopes[scopeKey][importKey];
            scope.rules.push({
              from: importKey,
              to: value2
            });
          }
          importMap.scopes.push(scope);
        }
      }
      window2[moduleImportMap] = importMap;
    }
  }
  /**
   * Evaluates a script.
   *
   * @param source Source.
   */
  #evaluateScript(source) {
    const window2 = this[window];
    const browserSettings = new WindowBrowserContext(window2).getSettings();
    if (!browserSettings) {
      return;
    }
    this[ownerDocument][currentScript] = this;
    const code = `//# sourceURL=${this[ownerDocument].location.href}
` + source;
    if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum_default.tryAndCatch) {
      window2.eval(code);
    } else {
      try {
        window2.eval(code);
      } catch (error2) {
        window2[dispatchError](error2);
      }
    }
    this[ownerDocument][currentScript] = null;
  }
  /**
   * Loads a module.
   *
   * @param url URL.
   */
  async #loadModule(url2) {
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    const browserSettings = new WindowBrowserContext(window2).getSettings();
    if (!browserSettings) {
      return;
    }
    if (!url2 || !this[isConnected] || this.getAttribute("type") !== "module") {
      return;
    }
    if (browserSettings && (browserSettings.disableJavaScriptFileLoading || browserSettings.disableJavaScriptEvaluation)) {
      if (browserSettings.handleDisabledFileLoadingAsSuccess) {
        this.dispatchEvent(new Event("load"));
      } else {
        const error2 = new window2.DOMException(`Failed to load module "${url2}". JavaScript file loading is disabled.`, DOMExceptionNameEnum_default.notSupportedError);
        browserFrame.page?.console.error(error2);
        this.dispatchEvent(new Event("error"));
      }
      return;
    }
    const readyStateManager2 = window2[readyStateManager];
    readyStateManager2.startTask();
    if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum_default.tryAndCatch) {
      const module = await ModuleFactory.getModule(window2, window2.location, url2);
      await module.evaluate();
    } else {
      try {
        const module = await ModuleFactory.getModule(window2, window2.location, url2);
        await module.evaluate();
      } catch (error2) {
        browserFrame.page?.console.error(error2);
        this.dispatchEvent(new Event("error"));
        readyStateManager2.endTask();
        return;
      }
    }
    readyStateManager2.endTask();
    this.dispatchEvent(new Event("load"));
  }
  /**
   * Returns a URL relative to the given Location object.
   *
   * @param url URL.
   */
  async #loadScript(url2) {
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (!browserFrame) {
      return;
    }
    const browserSettings = browserFrame.page?.context?.browser?.settings;
    const type2 = this.getAttribute("type");
    if (!url2 || !this[isConnected] || type2 !== null && type2 !== "application/x-ecmascript" && type2 !== "application/x-javascript" && !type2.startsWith("text/javascript")) {
      return;
    }
    let absoluteURL;
    try {
      absoluteURL = new URL(url2, window2.location.href);
    } catch (error2) {
      return;
    }
    const absoluteURLString = absoluteURL.toString();
    if (this.#loadedScriptURL === absoluteURLString) {
      return;
    }
    if (browserSettings && (browserSettings.disableJavaScriptFileLoading || browserSettings.disableJavaScriptEvaluation)) {
      if (browserSettings.handleDisabledFileLoadingAsSuccess) {
        this.dispatchEvent(new Event("load"));
      } else {
        const error2 = new window2.DOMException(`Failed to load script "${absoluteURL}". JavaScript file loading is disabled.`, DOMExceptionNameEnum_default.notSupportedError);
        browserFrame.page?.console.error(error2);
        this.dispatchEvent(new Event("error"));
      }
      return;
    }
    this.#loadedScriptURL = absoluteURLString;
    const resourceFetch = new ResourceFetch(window2);
    const async = this.getAttribute("async") !== null || this.getAttribute("defer") !== null;
    let code = null;
    if (async) {
      const readyStateManager2 = window2[readyStateManager];
      readyStateManager2.startTask();
      try {
        code = await resourceFetch.fetch(absoluteURLString, "script", {
          credentials: this.crossOrigin === "use-credentials" ? "include" : "same-origin",
          referrerPolicy: this.referrerPolicy
        });
      } catch (error2) {
        browserFrame.page?.console.error(error2);
        this.dispatchEvent(new Event("error"));
        return;
      }
      readyStateManager2.endTask();
    } else {
      try {
        code = resourceFetch.fetchSync(absoluteURLString, "script", {
          credentials: this.crossOrigin === "use-credentials" ? "include" : "same-origin",
          referrerPolicy: this.referrerPolicy
        });
      } catch (error2) {
        browserFrame.page?.console.error(error2);
        this.dispatchEvent(new Event("error"));
        return;
      }
    }
    this[ownerDocument][currentScript] = this;
    code = "//# sourceURL=" + absoluteURL + "\n" + code;
    if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum_default.tryAndCatch) {
      this[window].eval(code);
    } else {
      try {
        this[window].eval(code);
      } catch (error2) {
        this[ownerDocument][currentScript] = null;
        window2[dispatchError](error2);
        return;
      }
    }
    this[ownerDocument][currentScript] = null;
    this.dispatchEvent(new Event("load"));
  }
  /**
   * Returns true if the given type is supported.
   *
   * @param type Type.
   * @returns True if the given type is supported.
   */
  static supports(type2) {
    switch (type2) {
      case "classic":
      case "module":
      case "importmap":
        return true;
      case "speculationrules":
      default:
        return false;
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-select-element/HTMLOptionsCollection.js
var HTMLOptionsCollection = class extends HTMLCollection {
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param ownerElement Select element.
   */
  constructor(illegalConstructorSymbol, ownerElement2) {
    super(illegalConstructorSymbol, () => QuerySelector.querySelectorAll(ownerElement2, "option")[items]);
    this[ownerElement] = ownerElement2;
  }
  /**
   * Returns selectedIndex.
   *
   * @returns SelectedIndex.
   */
  get selectedIndex() {
    return this[ownerElement].selectedIndex;
  }
  /**
   * Sets selectedIndex.
   *
   * @param selectedIndex SelectedIndex.
   */
  set selectedIndex(selectedIndex2) {
    this[ownerElement].selectedIndex = selectedIndex2;
  }
  /**
   *
   * @param element
   * @param before
   */
  add(element, before) {
    this[ownerElement].add(element, before);
  }
  /**
   * Removes indexed element from collection.
   *
   * @param index Index.
   */
  remove(index) {
    this[ownerElement].remove(index);
  }
};

// node_modules/happy-dom/lib/nodes/html-select-element/HTMLSelectElement.js
var HTMLSelectElement = class _HTMLSelectElement extends HTMLElement {
  // Internal properties.
  [validationMessage] = "";
  [validity] = new ValidityState(this);
  [options] = null;
  [selectedOptions] = null;
  [selectedIndex] = -1;
  [proxy];
  /**
   * Constructor.
   */
  constructor() {
    super();
    const methodBinder = new ClassMethodBinder(this, [
      _HTMLSelectElement,
      HTMLElement,
      Element,
      Node,
      EventTarget
    ]);
    const proxy2 = new Proxy(this, {
      get: (target2, property) => {
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return QuerySelector.querySelectorAll(target2, "option")[items][index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
          return true;
        }
        if (!newValue || !(newValue instanceof HTMLOptionElement)) {
          throw new this[window].Error(`TypeError: Failed to set an indexed property [${index}] on 'HTMLSelectElement': parameter 2 is not of type 'HTMLOptionElement'.`);
        }
        const options2 = QuerySelector.querySelectorAll(target2, "option")[items];
        const childNodes2 = target2[nodeArray];
        while (childNodes2.length) {
          target2[removeChild](childNodes2[0]);
        }
        for (let i = 0; i <= index; i++) {
          if (i === index) {
            target2[appendChild](newValue);
          } else if (options2[i]) {
            target2[appendChild](options2[i]);
          } else {
            target2[appendChild](target2[ownerDocument].createElement("option"));
          }
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys(target2) {
        return Object.keys(QuerySelector.querySelectorAll(target2, "option")[items]);
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return !!QuerySelector.querySelectorAll(target2, "option")[items][index];
        }
        return false;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        const index = Number(property);
        if (isNaN(index)) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        if (!descriptor.value || !(descriptor.value instanceof HTMLOptionElement)) {
          throw new this[window].Error(`TypeError: Failed to set an indexed property [${index}] on 'HTMLSelectElement': parameter 2 is not of type 'HTMLOptionElement'.`);
        }
        const options2 = QuerySelector.querySelectorAll(target2, "option")[items];
        const childNodes2 = target2[nodeArray];
        while (childNodes2.length) {
          target2[removeChild](childNodes2[0]);
        }
        for (let i = 0; i <= index; i++) {
          if (i === index) {
            target2[appendChild](descriptor.value);
          } else if (options2[i]) {
            target2[appendChild](options2[i]);
          } else {
            target2[appendChild](target2[ownerDocument].createElement("option"));
          }
        }
        return true;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2) {
          return Object.getOwnPropertyDescriptor(target2, property);
        }
        const index = Number(property);
        if (isNaN(index)) {
          return;
        }
        const options2 = QuerySelector.querySelectorAll(target2, "option")[items];
        if (!options2[index]) {
          return;
        }
        return {
          value: options2[index],
          writable: true,
          enumerable: true,
          configurable: true
        };
      }
    });
    this[proxy] = proxy2;
    this[selectNode] = proxy2;
    return proxy2;
  }
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onchange");
  }
  set onchange(value2) {
    this[propertyEventListeners].set("onchange", value2);
  }
  get oninput() {
    return ElementEventAttributeUtility.getEventListener(this, "oninput");
  }
  set oninput(value2) {
    this[propertyEventListeners].set("oninput", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return QuerySelector.querySelectorAll(this, "option")[items].length;
  }
  /**
   * Returns options.
   *
   * @returns Options.
   */
  get options() {
    if (!this[options]) {
      this[options] = new HTMLOptionsCollection(illegalConstructor, this);
    }
    return this[options];
  }
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    if (!disabled2) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns multiple.
   *
   * @returns Multiple.
   */
  get multiple() {
    return this.getAttribute("multiple") !== null;
  }
  /**
   * Sets multiple.
   *
   * @param multiple Multiple.
   */
  set multiple(multiple) {
    if (!multiple) {
      this.removeAttribute("multiple");
    } else {
      this.setAttribute("multiple", "");
    }
  }
  /**
   * Returns autofocus.
   *
   * @returns Autofocus.
   */
  get autofocus() {
    return this.getAttribute("autofocus") !== null;
  }
  /**
   * Sets autofocus.
   *
   * @param autofocus Autofocus.
   */
  set autofocus(autofocus) {
    if (!autofocus) {
      this.removeAttribute("autofocus");
    } else {
      this.setAttribute("autofocus", "");
    }
  }
  /**
   * Returns required.
   *
   * @returns Required.
   */
  get required() {
    return this.getAttribute("required") !== null;
  }
  /**
   * Sets required.
   *
   * @param required Required.
   */
  set required(required) {
    if (!required) {
      this.removeAttribute("required");
    } else {
      this.setAttribute("required", "");
    }
  }
  /**
   * Returns type.
   *
   * @returns type.
   */
  get type() {
    return this.hasAttributeNS(null, "multiple") ? "select-multiple" : "select-one";
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    const options2 = QuerySelector.querySelectorAll(this, "option")[items];
    for (let i = 0, max = options2.length; i < max; i++) {
      const option = options2[i];
      if (option[selectedness]) {
        return option.value;
      }
    }
    return "";
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    const options2 = QuerySelector.querySelectorAll(this, "option")[items];
    this[selectedIndex] = -1;
    for (let i = 0, max = options2.length; i < max; i++) {
      const option = options2[i];
      if (option.value === value2) {
        option[selectedness] = true;
        option[dirtyness] = true;
        this[selectedIndex] = i;
      } else {
        option[selectedness] = false;
      }
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get selectedIndex() {
    return this[selectedIndex];
  }
  /**
   * Sets value.
   *
   * @param selectedIndex Selected index.
   */
  set selectedIndex(selectedIndex2) {
    selectedIndex2 = Number(selectedIndex2);
    if (isNaN(selectedIndex2)) {
      return;
    }
    const options2 = QuerySelector.querySelectorAll(this, "option")[items];
    this[selectedIndex] = -1;
    if (typeof selectedIndex2 === "number" && !isNaN(selectedIndex2)) {
      for (let i = 0, max = options2.length; i < max; i++) {
        options2[i][selectedness] = false;
      }
      const selectedOption = options2[selectedIndex2];
      if (selectedOption) {
        selectedOption[selectedness] = true;
        selectedOption[dirtyness] = true;
        this[selectedIndex] = selectedIndex2;
      }
    }
  }
  /**
   * Returns selected options.
   *
   * @returns HTMLCollection.
   */
  get selectedOptions() {
    if (!this[selectedOptions]) {
      this[selectedOptions] = new HTMLCollection(illegalConstructor, () => {
        const options2 = QuerySelector.querySelectorAll(this, "option")[items];
        if (options2[selectedOptions]) {
          return options2[selectedOptions];
        }
        const selectedOptions2 = [];
        for (let i = 0, max = options2.length; i < max; i++) {
          const option = options2[i];
          if (option[selectedness]) {
            selectedOptions2.push(option);
          }
        }
        options2[selectedOptions] = selectedOptions2;
        return selectedOptions2;
      });
    }
    return this[selectedOptions];
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    const id2 = this.getAttribute("form");
    if (!id2 || !this[isConnected]) {
      return null;
    }
    return this[ownerDocument].getElementById(id2);
  }
  /**
   * Returns "true" if it will validate.
   *
   * @returns "true" if it will validate.
   */
  get willValidate() {
    return this.type !== "hidden" && this.type !== "reset" && this.type !== "button" && !this.disabled && !this["readOnly"];
  }
  /**
   * @override
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    if (tabIndex !== null) {
      const parsed = Number(tabIndex);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }
  /**
   * @override
   */
  set tabIndex(tabIndex) {
    super.tabIndex = tabIndex;
  }
  /**
   * Returns item from options collection by index.
   *
   * @param index Index.
   */
  item(index) {
    return this[options].item(index);
  }
  /**
   * Adds new option to options collection.
   *
   * @param element HTMLOptionElement to add.
   * @param before HTMLOptionElement or index number.
   */
  add(element, before) {
    const options2 = QuerySelector.querySelectorAll(this, "option")[items];
    if (!before && before !== 0) {
      const childNodes3 = this[nodeArray];
      while (childNodes3.length) {
        this[removeChild](childNodes3[0]);
      }
      for (const option of options2) {
        this[appendChild](option);
      }
      this[appendChild](element);
      return;
    }
    const window2 = this[window];
    if (typeof before !== "number") {
      if (!(before instanceof HTMLOptionElement)) {
        throw new window2.DOMException("Failed to execute 'add' on 'HTMLFormElement': The node before which the new node is to be inserted before is not an 'HTMLOptionElement'.");
      }
      before = options2.indexOf(before);
    }
    const optionsElement = options2[before];
    if (!optionsElement) {
      throw new window2.DOMException("Failed to execute 'add' on 'HTMLFormElement': The node before which the new node is to be inserted before is not a child of this node.");
    }
    const childNodes2 = this[nodeArray];
    while (childNodes2.length) {
      this[removeChild](childNodes2[0]);
    }
    for (let i = 0, max = options2.length; i < max; i++) {
      if (i === before) {
        this[appendChild](element);
      }
      this[appendChild](options2[i]);
    }
  }
  /**
   * Removes indexed element from collection or the select element.
   *
   * @param [index] Index.
   */
  remove(index) {
    if (typeof index === "number") {
      const options2 = QuerySelector.querySelectorAll(this, "option")[items];
      if (!options2[index]) {
        return;
      }
      const childNodes2 = this[nodeArray];
      while (childNodes2.length) {
        this[removeChild](childNodes2[0]);
      }
      for (let i = 0, max = options2.length; i < max; i++) {
        if (i !== index) {
          this[appendChild](options2[i]);
        }
      }
    } else {
      super.remove();
    }
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    const valid = this.disabled || this[validity].valid;
    if (!valid) {
      this.dispatchEvent(new Event("invalid", { bubbles: true, cancelable: true }));
    }
    return valid;
  }
  /**
   * Reports validity.
   *
   * @returns "true" if the field is valid.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * Updates option item.
   *
   * Based on:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/nodes/HTMLSelectElement-impl.js
   *
   * @see https://html.spec.whatwg.org/multipage/form-elements.html#selectedness-setting-algorithm
   * @param [selectedOption] Selected option.
   */
  [updateSelectedness](selectedOption) {
    const isMultiple = this.hasAttribute("multiple");
    const options2 = QuerySelector.querySelectorAll(this, "option")[items];
    const selected = [];
    if (selectedOption) {
      this[selectedIndex] = -1;
    }
    if (!isMultiple) {
      for (let i = 0, max = options2.length; i < max; i++) {
        const option = options2[i];
        if (selectedOption) {
          option[selectedness] = option === selectedOption;
          if (option === selectedOption) {
            this[selectedIndex] = i;
          }
        }
        if (option[selectedness]) {
          selected.push(option);
        }
      }
    }
    const size = this.#getDisplaySize();
    if (size === 1 && !selected.length) {
      this[selectedIndex] = -1;
      for (let i = 0, max = options2.length; i < max; i++) {
        const option = options2[i];
        const parentNode2 = option[parentNode];
        let disabled2 = option.hasAttributeNS(null, "disabled");
        if (parentNode2 && parentNode2[nodeType] === NodeTypeEnum_default.elementNode && parentNode2[tagName] === "OPTGROUP" && parentNode2.hasAttributeNS(null, "disabled")) {
          disabled2 = true;
        }
        if (!disabled2) {
          option[selectedness] = true;
          this[selectedIndex] = i;
          break;
        }
      }
    } else if (selected.length >= 2) {
      this[selectedIndex] = -1;
      for (let i = 0, max = options2.length; i < max; i++) {
        options2[i][selectedness] = i === selected.length - 1;
        if (i === selected.length - 1) {
          this[selectedIndex] = i;
        }
      }
    }
  }
  /**
   * Returns display size.
   *
   * @returns Display size.
   */
  #getDisplaySize() {
    if (this.hasAttributeNS(null, "size")) {
      const size = parseInt(this.getAttribute("size"));
      if (!isNaN(size) && size >= 0) {
        return size;
      }
    }
    return this.hasAttributeNS(null, "multiple") ? 4 : 1;
  }
};

// node_modules/happy-dom/lib/nodes/html-slot-element/HTMLSlotElement.js
var _a;
var HTMLSlotElement = class extends HTMLElement {
  // Internal properties
  [assignedNodes] = [];
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onslotchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onslotchange");
  }
  set onslotchange(value2) {
    this[propertyEventListeners].set("onslotchange", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Sets the slot's manually assigned nodes to an ordered set of slottables.
   *
   * @param nodes Nodes.
   */
  assign(...nodes) {
    const shadowRoot2 = this.getRootNode();
    if (shadowRoot2?.[slotAssignment] !== "manual") {
      return;
    }
    const host2 = shadowRoot2.host;
    for (const node of nodes) {
      if (node instanceof Node) {
        if (host2[nodeArray].includes(node) && node[nodeType] !== NodeTypeEnum_default.commentNode) {
          if (node[assignedToSlot]) {
            const index = node[assignedToSlot][assignedNodes].indexOf(node);
            if (index !== -1) {
              node[assignedToSlot][assignedNodes].splice(index, 1);
            }
          }
          node[assignedToSlot] = this;
          this[assignedNodes].push(node);
        }
      }
    }
  }
  /**
   * Returns assigned nodes.
   *
   * @param [options] Options.
   * @param [options.flatten] A boolean value indicating whether to return the assigned nodes of any available child <slot> elements (true) or not (false). Defaults to false.
   * @returns Nodes.
   */
  assignedNodes(options2) {
    return this.#assignedNodes(this.name, options2);
  }
  /**
   * Returns assigned elements.
   *
   * @param [options] Options.
   * @param [options.flatten] A boolean value indicating whether to return the assigned elements of any available child <slot> elements (true) or not (false). Defaults to false.
   * @returns Nodes.
   */
  assignedElements(options2) {
    return this.#assignedElements(this.name, options2);
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * @override
   */
  [onSetAttribute](attribute, replacedAttribute) {
    super[onSetAttribute](attribute, replacedAttribute);
    if (attribute[name] === "name" && attribute[value] !== replacedAttribute?.[value]) {
      const replacedAssignedNodes = this.#assignedNodes(replacedAttribute?.[value]);
      const assignedNodes2 = this.#assignedNodes(attribute.value);
      if (replacedAssignedNodes.length !== assignedNodes2.length) {
        this.dispatchEvent(new Event("slotchange", { bubbles: true }));
      } else {
        for (let i = 0, max = assignedNodes2.length; i < max; i++) {
          if (replacedAssignedNodes[i] !== assignedNodes2[i]) {
            this.dispatchEvent(new Event("slotchange", { bubbles: true }));
            break;
          }
        }
      }
    }
  }
  /**
   * @override
   */
  [onRemoveAttribute](removedAttribute) {
    super[onRemoveAttribute](removedAttribute);
    if (removedAttribute[name] === "name" && removedAttribute[value] && this.#assignedNodes(removedAttribute.value).length > 0) {
      this.dispatchEvent(new Event("slotchange", { bubbles: true }));
    }
  }
  /**
   * Returns assigned nodes.
   *
   * @param name Name.
   * @param [options] Options.
   * @param [options.flatten] A boolean value indicating whether to return the assigned nodes of any available child <slot> elements (true) or not (false). Defaults to false.
   * @returns Nodes.
   */
  #assignedNodes(name2, options2) {
    const shadowRoot2 = this.getRootNode();
    if (!shadowRoot2?.host) {
      return [];
    }
    if (shadowRoot2[slotAssignment] === "manual") {
      return this[assignedNodes];
    }
    const host2 = shadowRoot2.host;
    const flatten = !!options2?.flatten;
    const assigned = [];
    for (const slotNode of host2[nodeArray]) {
      const slotName = slotNode["slot"];
      if (name2 && slotName && slotName === name2 || !name2 && !slotName) {
        if (flatten && slotNode instanceof _a) {
          for (const slotChild of slotNode.assignedNodes(options2)) {
            assigned.push(slotChild);
          }
        } else {
          assigned.push(slotNode);
        }
      }
    }
    return assigned;
  }
  /**
   * Returns assigned elements.
   *
   * @param name Name.
   * @param [options] Options.
   * @param [options.flatten] A boolean value indicating whether to return the assigned elements of any available child <slot> elements (true) or not (false). Defaults to false.
   * @returns Nodes.
   */
  #assignedElements(name2, options2) {
    const shadowRoot2 = this.getRootNode();
    if (!shadowRoot2?.host) {
      return [];
    }
    if (shadowRoot2[slotAssignment] === "manual") {
      const elements2 = [];
      for (const node of this[assignedNodes]) {
        if (node instanceof Element) {
          elements2.push(node);
        }
      }
      return elements2;
    }
    const host2 = shadowRoot2.host;
    const flatten = !!options2?.flatten;
    const assigned = [];
    for (const slotElement of host2[elementArray]) {
      const slotName = slotElement.slot;
      if (name2 && slotName === name2 || !name2 && !slotName) {
        if (flatten && slotElement instanceof _a) {
          for (const slotChild of slotElement.assignedElements(options2)) {
            assigned.push(slotChild);
          }
        } else {
          assigned.push(slotElement);
        }
      }
    }
    return assigned;
  }
};
_a = HTMLSlotElement;
var HTMLSlotElement_default = HTMLSlotElement;

// node_modules/happy-dom/lib/nodes/html-source-element/HTMLSourceElement.js
var HTMLSourceElement = class extends HTMLElement {
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    const value2 = Number(this.getAttribute("height"));
    return isNaN(value2) || value2 < 0 ? 0 : value2;
  }
  /**
   * Sets height.
   *
   * @param value Height.
   */
  set height(value2) {
    const parsedValue = Number(value2);
    this.setAttribute("height", isNaN(parsedValue) || parsedValue < 0 ? "0" : String(parsedValue));
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    const value2 = Number(this.getAttribute("width"));
    return isNaN(value2) || value2 < 0 ? 0 : value2;
  }
  /**
   * Sets width.
   *
   * @param value Width.
   */
  set width(value2) {
    const parsedValue = Number(value2);
    this.setAttribute("width", isNaN(parsedValue) || parsedValue < 0 ? "0" : String(parsedValue));
  }
  /**
   * Returns media.
   *
   * @returns Media.
   */
  get media() {
    return this.getAttribute("media") || "";
  }
  /**
   * Sets media.
   *
   * @param value Media.
   */
  set media(value2) {
    this.setAttribute("media", value2);
  }
  /**
   * Returns sizes.
   *
   * @returns Sizes.
   */
  get sizes() {
    return this.getAttribute("sizes") || "";
  }
  /**
   * Sets sizes.
   *
   * @param value Sizes.
   */
  set sizes(value2) {
    this.setAttribute("sizes", value2);
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns source set.
   *
   * @returns Source set.
   */
  get srcset() {
    return this.getAttribute("srcset") || "";
  }
  /**
   * Sets source set.
   *
   * @param value Source set.
   */
  set srcset(value2) {
    this.setAttribute("srcset", value2);
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
};

// node_modules/happy-dom/lib/nodes/html-span-element/HTMLSpanElement.js
var HTMLSpanElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-style-element/HTMLStyleElement.js
var HTMLStyleElement = class extends HTMLElement {
  [sheet] = null;
  [styleNode] = this;
  [disabled] = false;
  /**
   * Returns media.
   *
   * @returns Media.
   */
  get media() {
    return this.getAttribute("media") || "";
  }
  /**
   * Sets media.
   *
   * @param media Media.
   */
  set media(media) {
    this.setAttribute("media", media);
  }
  /**
   * Returns type.
   *
   * @deprecated
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @deprecated
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this[disabled];
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    this[disabled] = Boolean(disabled2);
  }
  /**
   * Returns CSS style sheet.
   *
   * @returns CSS style sheet.
   */
  get sheet() {
    if (!this[isConnected]) {
      return null;
    }
    if (!this[sheet]) {
      this[sheet] = new this[ownerDocument][window].CSSStyleSheet();
      this[sheet].replaceSync(this.textContent);
    }
    return this[sheet];
  }
  /**
   * @override
   */
  [disconnectedFromDocument]() {
    super[disconnectedFromDocument]();
    this[sheet] = null;
  }
  /**
   * Updates the CSSStyleSheet with the text content.
   */
  [updateSheet]() {
    if (this[sheet]) {
      this[sheet].replaceSync(this.textContent);
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-table-caption-element/HTMLTableCaptionElement.js
var HTMLTableCaptionElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-table-cell-element/HTMLTableCellElement.js
var HTMLTableCellElement = class extends HTMLElement {
  /**
   * Returns abbr.
   *
   * @returns Abbr.
   */
  get abbr() {
    return this.getAttribute("abbr") || "";
  }
  /**
   * Sets abbr.
   *
   * @param value Abbr.
   */
  set abbr(value2) {
    this.setAttribute("abbr", value2);
  }
  /**
   * A number representing the cell's position in the cells collection of the <tr> the cell is contained within. If the cell doesn't belong to a <tr>, it returns -1.
   *
   * @returns Cell index.
   */
  get cellIndex() {
    let parent2 = this.parentNode;
    while (parent2) {
      if (parent2[tagName] === "TR") {
        const cells2 = QuerySelector.querySelectorAll(parent2, "td,th")[items];
        return cells2.indexOf(this);
      }
      parent2 = parent2.parentNode;
    }
    return -1;
  }
  /**
   * Returns colspan.
   *
   * @returns Colspan.
   */
  get colSpan() {
    const value2 = Number(this.getAttribute("colspan"));
    return isNaN(value2) || value2 < 1 ? 1 : value2;
  }
  /**
   * Sets colspan.
   *
   * @param value Colspan.
   */
  set colSpan(value2) {
    const parsedValue = Number(value2);
    this.setAttribute("colspan", isNaN(parsedValue) || parsedValue < 1 ? "1" : String(parsedValue));
  }
  /**
   * Returns headers.
   *
   * @returns headers.
   */
  get headers() {
    return this.getAttribute("headers") || "";
  }
  /**
   * Sets headers.
   *
   * @param value headers.
   */
  set headers(value2) {
    this.setAttribute("headers", String(value2));
  }
  /**
   * Returns rowspan.
   *
   * @returns Rowspan.
   */
  get rowSpan() {
    const value2 = Number(this.getAttribute("rowspan"));
    return isNaN(value2) || value2 < 1 ? 1 : value2;
  }
  /**
   * Sets rowspan.
   *
   * @param value Rowspan.
   */
  set rowSpan(value2) {
    const parsedValue = Number(value2);
    this.setAttribute("rowspan", isNaN(parsedValue) || parsedValue < 1 ? "1" : String(parsedValue));
  }
  /**
   * Returns scope.
   *
   * @returns Scope.
   */
  get scope() {
    return this.getAttribute("scope") || "";
  }
  /**
   * Sets scope.
   *
   * @param value Scope.
   */
  set scope(value2) {
    this.setAttribute("scope", value2);
  }
};

// node_modules/happy-dom/lib/nodes/html-table-col-element/HTMLTableColElement.js
var HTMLTableColElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-table-section-element/HTMLTableSectionElement.js
var HTMLTableSectionElement = class extends HTMLElement {
  /**
   * Returns an HTMLTableRowElement representing a new row of the table. It inserts it in the rows collection immediately before the <tr> element at the given index position. If the index is -1, the new row is appended to the collection. If the index is smaller than -1 or greater than the number of rows in the collection, a DOMException with the value IndexSizeError is raised.
   *
   * @param [index] Index.
   * @returns Row.
   */
  insertRow(index = -1) {
    if (typeof index !== "number") {
      index = -1;
    }
    const rows2 = QuerySelector.querySelectorAll(this, "tr")[items];
    if (index < -1) {
      throw new this[window].DOMException(`Failed to execute 'insertRow' on 'HTMLTableSectionElement': The index provided (${index}) is less than -1.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index > rows2.length) {
      throw new this[window].DOMException(`Failed to execute 'insertRow' on 'HTMLTableSectionElement': The index provided (${index}) is greater than the number of rows (${rows2.length}).`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const row = this[ownerDocument].createElement("tr");
    if (index === -1 || index === rows2.length) {
      this.appendChild(row);
    } else {
      this.insertBefore(row, rows2[index]);
    }
    return row;
  }
  /**
   * Removes the row corresponding to the index given in parameter. If the index value is -1 the last row is removed; if it is smaller than -1 or greater than the amount of rows in the collection, a DOMException with the value IndexSizeError is raised.
   *
   * @param index Index.
   */
  deleteRow(index) {
    if (arguments.length === 0) {
      throw new this[window].TypeError("Failed to execute 'deleteRow' on 'HTMLTableSectionElement': 1 argument required, but only 0 present.");
    }
    if (typeof index !== "number") {
      index = -1;
    }
    if (index < -1) {
      throw new this[window].DOMException(`Failed to execute 'deleteRow' on 'HTMLTableSectionElement': The index provided (${index}) is less than -1.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const rows2 = QuerySelector.querySelectorAll(this, "tr")[items];
    if (index >= rows2.length) {
      throw new this[window].DOMException(`Failed to execute 'deleteRow' on 'HTMLTableSectionElement': The index provided (${index}) is greater than the number of rows in the table (${rows2.length}).`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index === -1) {
      index = rows2.length - 1;
    }
    rows2[index].remove();
  }
};

// node_modules/happy-dom/lib/nodes/html-table-element/HTMLTableElement.js
var HTMLTableElement = class extends HTMLElement {
  [rows] = null;
  [tBodies] = null;
  /**
   * Returns caption.
   *
   * @returns Caption.
   */
  get caption() {
    return QuerySelector.querySelector(this, "caption");
  }
  /**
   * Sets caption.
   *
   * @param caption Caption.
   */
  set caption(caption) {
    if (caption) {
      if (!(caption instanceof HTMLTableCaptionElement)) {
        throw new this[window].TypeError("Failed to set the 'caption' property on 'HTMLTableElement': Failed to convert value to 'HTMLTableCaptionElement'.");
      }
      this.caption?.remove();
      this.insertBefore(caption, this.firstChild);
    } else {
      this.caption?.remove();
    }
  }
  /**
   * Returns table section element.
   *
   * @returns Table section element.
   */
  get tHead() {
    return QuerySelector.querySelector(this, "thead");
  }
  /**
   * Sets table section element.
   *
   * @param tHead Table section element.
   */
  set tHead(tHead) {
    if (tHead) {
      if (!(tHead instanceof HTMLTableSectionElement)) {
        throw new this[window].TypeError("Failed to set the 'tHead' property on 'HTMLTableElement': Failed to convert value to 'HTMLTableSectionElement'.");
      }
      this.tHead?.remove();
      let found = false;
      for (const child of this[elementArray]) {
        if (child[tagName] !== "CAPTION" && child[tagName] !== "COLGROUP") {
          this.insertBefore(tHead, child);
          found = true;
          break;
        }
      }
      if (!found) {
        this.appendChild(tHead);
      }
    } else {
      this.tHead?.remove();
    }
  }
  /**
   * Returns table section element.
   *
   * @returns Table section element.
   */
  get tFoot() {
    return QuerySelector.querySelector(this, "tfoot");
  }
  /**
   * Sets table section element.
   *
   * @param tFoot Table section element.
   */
  set tFoot(tFoot) {
    if (tFoot) {
      if (!(tFoot instanceof HTMLTableSectionElement)) {
        throw new this[window].TypeError("Failed to set the 'tFoot' property on 'HTMLTableElement': Failed to convert value to 'HTMLTableSectionElement'.");
      }
      this.tFoot?.remove();
      let found = false;
      for (const child of this[elementArray]) {
        if (child[tagName] !== "CAPTION" && child[tagName] !== "COLGROUP" && child[tagName] !== "THEAD") {
          this.insertBefore(tFoot, child);
          found = true;
          break;
        }
      }
      if (!found) {
        this.appendChild(tFoot);
      }
    } else {
      this.tFoot?.remove();
    }
  }
  /**
   * Returns rows.
   *
   * @returns Rows.
   */
  get rows() {
    if (!this[rows]) {
      this[rows] = new HTMLCollection(illegalConstructor, () => QuerySelector.querySelectorAll(this, "tr")[items]);
    }
    return this[rows];
  }
  /**
   * Returns bodies.
   *
   * @returns Bodies.
   */
  get tBodies() {
    if (!this[tBodies]) {
      this[tBodies] = new HTMLCollection(illegalConstructor, () => QuerySelector.querySelectorAll(this, "tbody")[items]);
    }
    return this[tBodies];
  }
  /**
   * Returns an HTMLTableSectionElement representing the first <thead> that is a child of the element. If none is found, a new one is created and inserted in the tree immediately before the first element that is neither a <caption>, nor a <colgroup>, or as the last child if there is no such element.
   *
   * @returns Table section element.
   */
  createTHead() {
    const existingTHead = this.tHead;
    if (existingTHead) {
      return existingTHead;
    }
    const tHead = this[ownerDocument].createElement("thead");
    this.tHead = tHead;
    return tHead;
  }
  /**
   * Removes the first <thead> that is a child of the element.
   */
  deleteTHead() {
    this.tHead = null;
  }
  /**
   * Returns an HTMLTableSectionElement representing the first <tfoot> that is a child of the element. If none is found, a new one is created and inserted in the tree as the last child.
   *
   * @returns Table section element.
   */
  createTFoot() {
    const existingTFoot = this.tFoot;
    if (existingTFoot) {
      return existingTFoot;
    }
    const tFoot = this[ownerDocument].createElement("tfoot");
    this.tFoot = tFoot;
    return tFoot;
  }
  /**
   * Removes the first <tfoot> that is a child of the element.
   */
  deleteTFoot() {
    this.tFoot = null;
  }
  /**
   * Returns a HTMLTableSectionElement representing a new <tbody> that is a child of the element. It is inserted in the tree after the last element that is a <tbody>, or as the last child if there is no such element.
   *
   * @returns Table section element.
   */
  createTBody() {
    const tBodies2 = QuerySelector.querySelectorAll(this, "tbody")[items];
    const tBody = this[ownerDocument].createElement("tbody");
    if (tBodies2.length > 0) {
      const lastTBody = tBodies2[tBodies2.length - 1];
      lastTBody.parentNode.insertBefore(tBody, lastTBody.nextSibling);
      return tBody;
    }
    this.appendChild(tBody);
    return tBody;
  }
  /**
   * Returns an HTMLTableCaptionElement representing the first <caption> that is a child of the element. If none is found, a new one is created and inserted in the tree as the first child of the <table> element.
   */
  createCaption() {
    const existingCaption = this.caption;
    if (existingCaption) {
      return existingCaption;
    }
    const caption = this[ownerDocument].createElement("caption");
    this.caption = caption;
    return caption;
  }
  /**
   * Removes the first <caption> that is a child of the element.
   */
  deleteCaption() {
    this.caption = null;
  }
  /**
   * Returns an HTMLTableRowElement representing a new row of the table. It inserts it in the rows collection immediately before the <tr> element at the given index position. If necessary a <tbody> is created. If the index is -1, the new row is appended to the collection. If the index is smaller than -1 or greater than the number of rows in the collection, a DOMException with the value IndexSizeError is raised.
   *
   * @param [index] Index.
   * @returns Row.
   */
  insertRow(index = -1) {
    if (typeof index !== "number") {
      index = -1;
    }
    const rows2 = QuerySelector.querySelectorAll(this, "tr")[items];
    if (index < -1) {
      throw new this[window].DOMException(`Failed to execute 'insertRow' on 'HTMLTableElement': The index provided (${index}) is less than -1.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index > rows2.length) {
      throw new this[window].DOMException(`Failed to execute 'insertRow' on 'HTMLTableElement': The index provided (${index}) is greater than the number of rows (${rows2.length}).`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const row = this[ownerDocument].createElement("tr");
    if (index === -1 || index === rows2.length) {
      const tbody = QuerySelector.querySelector(this, "tbody");
      if (tbody) {
        tbody.appendChild(row);
      } else {
        const tbody2 = this[ownerDocument].createElement("tbody");
        tbody2.appendChild(row);
        this.appendChild(tbody2);
      }
      return row;
    }
    rows2[index].parentNode.insertBefore(row, rows2[index]);
    return row;
  }
  /**
   * Removes the row corresponding to the index given in parameter. If the index value is -1 the last row is removed; if it is smaller than -1 or greater than the amount of rows in the collection, a DOMException with the value IndexSizeError is raised.
   *
   * @param index Index.
   */
  deleteRow(index) {
    if (arguments.length === 0) {
      throw new this[window].TypeError("Failed to execute 'deleteRow' on 'HTMLTableElement': 1 argument required, but only 0 present.");
    }
    if (typeof index !== "number") {
      index = -1;
    }
    if (index < -1) {
      throw new this[window].DOMException(`Failed to execute 'deleteRow' on 'HTMLTableElement': The index provided (${index}) is less than -1.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const rows2 = QuerySelector.querySelectorAll(this, "tr")[items];
    if (index >= rows2.length) {
      throw new this[window].DOMException(`Failed to execute 'deleteRow' on 'HTMLTableElement': The index provided (${index}) is greater than the number of rows in the table (${rows2.length}).`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index === -1) {
      index = rows2.length - 1;
    }
    rows2[index].remove();
  }
};

// node_modules/happy-dom/lib/nodes/html-table-row-element/HTMLTableRowElement.js
var HTMLTableRowElement = class extends HTMLElement {
  [cells] = null;
  /**
   * Returns cells.
   *
   * @returns Cells.
   */
  get cells() {
    if (!this[cells]) {
      this[cells] = new HTMLCollection(illegalConstructor, () => QuerySelector.querySelectorAll(this, "td,th")[items]);
    }
    return this[cells];
  }
  /**
   * Returns a number that gives the logical position of the row within the entire table. If the row is not part of a table, returns -1.
   *
   * @returns Row index.
   */
  get rowIndex() {
    let parent2 = this.parentNode;
    while (parent2) {
      if (parent2[tagName] === "TABLE") {
        const rows2 = QuerySelector.querySelectorAll(parent2, "tr")[items];
        return rows2.indexOf(this);
      }
      parent2 = parent2.parentNode;
    }
    return -1;
  }
  /**
   * Returns a number that gives the logical position of the row within the table section it belongs to. If the row is not part of a section, returns -1.
   */
  get sectionRowIndex() {
    let parent2 = this.parentNode;
    while (parent2) {
      if (parent2 instanceof HTMLTableSectionElement) {
        const rows2 = QuerySelector.querySelectorAll(parent2, "tr")[items];
        return rows2.indexOf(this);
      }
      parent2 = parent2.parentNode;
    }
    return -1;
  }
  /**
   * Returns an HTMLTableCellElement representing a new cell of the row. The cell is inserted in the collection of cells immediately before the given index position in the row. If index is -1, the new cell is appended to the collection. If index is less than -1 or greater than the number of cells in the collection, a DOMException with the value IndexSizeError is raised.
   *
   * @param [index] Index.
   * @returns Cell.
   */
  insertCell(index = -1) {
    if (typeof index !== "number") {
      index = -1;
    }
    const cells2 = QuerySelector.querySelectorAll(this, "td,th")[items];
    if (index < -1) {
      throw new this[window].DOMException(`Failed to execute 'insertCell' on 'HTMLTableRowElement': The index provided (${index}) is less than -1.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index > cells2.length) {
      throw new this[window].DOMException(`Failed to execute 'insertCell' on 'HTMLTableRowElement': The index provided (${index}) is greater than the number of cells (${cells2.length}).`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const cell = this[ownerDocument].createElement("td");
    if (index === -1 || index === cells2.length) {
      this.appendChild(cell);
      return cell;
    }
    cells2[index].parentNode.insertBefore(cell, cells2[index]);
    return cell;
  }
  /**
   * Removes the cell corresponding to index. If index is -1, the last cell of the row is removed. If index is less than -1 or greater than the amount of cells in the collection, a DOMException with the value IndexSizeError is raised.
   *
   * @param index Index.
   */
  deleteCell(index) {
    if (arguments.length === 0) {
      throw new this[window].TypeError("Failed to execute 'deleteCell' on 'HTMLTableRowElement': 1 argument required, but only 0 present.");
    }
    if (typeof index !== "number") {
      index = -1;
    }
    if (index < -1) {
      throw new this[window].DOMException(`Failed to execute 'deleteCell' on 'HTMLTableRowElement': The index provided (${index}) is less than -1.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const cells2 = QuerySelector.querySelectorAll(this, "td,th")[items];
    if (index >= cells2.length) {
      throw new this[window].DOMException(`Failed to execute 'deleteCell' on 'HTMLTableRowElement': The index provided (${index}) is greater than the number of cells in the row (${cells2.length}).`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index === -1) {
      index = cells2.length - 1;
    }
    cells2[index].remove();
  }
};

// node_modules/happy-dom/lib/nodes/html-template-element/HTMLTemplateElement.js
var HTMLTemplateElement = class extends HTMLElement {
  // Internal properties
  [content] = this[ownerDocument].createDocumentFragment();
  /**
   * Returns content.
   *
   * @returns Content.
   */
  get content() {
    return this[content];
  }
  /**
   * @override
   */
  get innerHTML() {
    return this.getHTML();
  }
  /**
   * @override
   */
  set innerHTML(html) {
    const content2 = this[content];
    const childNodes2 = content2[nodeArray];
    while (childNodes2.length) {
      content2.removeChild(childNodes2[0]);
    }
    new HTMLParser(this[window]).parse(html, this[content]);
  }
  /**
   * @override
   */
  get firstChild() {
    return this[content].firstChild;
  }
  /**
   * @override
   */
  get lastChild() {
    return this[content].lastChild;
  }
  /**
   * @deprecated
   * @override
   */
  getInnerHTML(_options) {
    const serializer = new HTMLSerializer();
    const content2 = this[content];
    let html = "";
    for (const node of content2[nodeArray]) {
      html += serializer.serializeToString(node);
    }
    return html;
  }
  /**
   * @override
   */
  getHTML(_options) {
    const serializer = new HTMLSerializer();
    const content2 = this[content];
    let html = "";
    for (const node of content2[nodeArray]) {
      html += serializer.serializeToString(node);
    }
    return html;
  }
  /**
   * @override
   */
  [appendChild](node, disableValidations = false) {
    return this[content][appendChild](node, disableValidations);
  }
  /**
   * @override
   */
  [removeChild](node) {
    return this[content][removeChild](node);
  }
  /**
   * @override
   */
  [insertBefore](newNode, referenceNode, disableValidations = false) {
    return this[content][insertBefore](newNode, referenceNode, disableValidations);
  }
  /**
   * @override
   */
  [replaceChild](newChild, oldChild) {
    return this[content][replaceChild](newChild, oldChild);
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[content] = this[content].cloneNode(deep);
    return clone2;
  }
};

// node_modules/happy-dom/lib/nodes/html-time-element/HTMLTimeElement.js
var HTMLTimeElement = class extends HTMLElement {
  /**
   * Returns dateTime.
   *
   * @returns dateTime.
   */
  get dateTime() {
    return this.getAttribute("dateTime") || "";
  }
  /**
   * Sets dateTime.
   *
   * @param dateTime dateTime.
   */
  set dateTime(dateTime) {
    this.setAttribute("dateTime", dateTime);
  }
};

// node_modules/happy-dom/lib/nodes/html-title-element/HTMLTitleElement.js
var HTMLTitleElement = class extends HTMLElement {
  /**
   * Returns text.
   *
   * @returns Text.
   */
  get text() {
    let text = "";
    for (const child of this[nodeArray]) {
      if (child[nodeType] === NodeTypeEnum_default.textNode) {
        text += child.textContent;
      }
    }
    return text;
  }
  /**
   * Sets text.
   *
   * @param text Text.
   */
  set text(text) {
    this.textContent = text;
  }
  /**
   * @override
   */
  get innerHTML() {
    return this.getHTML();
  }
  /**
   * @override
   */
  set innerHTML(html) {
    this.textContent = html;
  }
};

// node_modules/happy-dom/lib/nodes/html-track-element/HTMLTrackElement.js
var HTMLTrackElement = class extends HTMLElement {
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get oncuechange() {
    return ElementEventAttributeUtility.getEventListener(this, "oncuechange");
  }
  set oncuechange(value2) {
    this[propertyEventListeners].set("oncuechange", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns kind.
   *
   * @returns Kind.
   */
  get kind() {
    const kind2 = this.getAttribute("kind");
    if (kind2 === null) {
      return TextTrackKindEnum_default.subtitles;
    }
    if (!TextTrackKindEnum_default[kind2]) {
      return TextTrackKindEnum_default.metadata;
    }
    return kind2;
  }
  /**
   * Sets kind.
   *
   * @param value Value.
   */
  set kind(value2) {
    if (!TextTrackKindEnum_default[value2]) {
      value2 = TextTrackKindEnum_default.metadata;
    }
    this.setAttribute("kind", value2);
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns source language.
   *
   * @returns Source language.
   */
  get srclang() {
    return this.getAttribute("srclang") || "";
  }
  /**
   * Sets source language.
   *
   * @param value Value.
   */
  set srclang(value2) {
    this.setAttribute("srclang", value2);
  }
  /**
   * Returns label.
   *
   * @returns Label.
   */
  get label() {
    return this.getAttribute("label") || "";
  }
  /**
   * Sets label.
   *
   * @param value Value.
   */
  set label(value2) {
    this.setAttribute("label", value2);
  }
  /**
   * Returns default.
   *
   * @returns Default.
   */
  get default() {
    return this.hasAttribute("default");
  }
  /**
   * Sets default.
   *
   * @param value Value.
   */
  set default(value2) {
    if (value2) {
      this.setAttribute("default", "");
    } else {
      this.removeAttribute("default");
    }
  }
  /**
   * Returns ready state.
   *
   * @returns Ready state.
   */
  get readyState() {
    return 0;
  }
  /**
   * Returns the TextTrack object corresponding to the track element.
   *
   * @returns TextTrack
   */
  get track() {
    const textTrack = new this[window].TextTrack(illegalConstructor);
    textTrack[kind] = this.kind;
    textTrack[label] = this.label;
    textTrack[language] = this.srclang;
    textTrack[mode] = this.default ? "showing" : "disabled";
    textTrack[id] = this.id;
    return textTrack;
  }
};

// node_modules/happy-dom/lib/nodes/html-u-list-element/HTMLUListElement.js
var HTMLUListElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-unknown-element/HTMLUnknownElement.js
var HTMLUnknownElement = class extends HTMLElement {
};

// node_modules/happy-dom/lib/nodes/html-video-element/HTMLVideoElement.js
var HTMLVideoElement = class extends HTMLMediaElement {
};

// node_modules/happy-dom/lib/nodes/processing-instruction/ProcessingInstruction.js
var ProcessingInstruction = class extends CharacterData {
  [nodeType] = NodeTypeEnum_default.processingInstructionNode;
  [target];
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get target() {
    return this[target];
  }
};

// node_modules/happy-dom/lib/nodes/document-fragment/DocumentFragment.js
var DocumentFragment = class extends Node {
  [children] = null;
  [rootNode] = this;
  [nodeType] = NodeTypeEnum_default.documentFragmentNode;
  /**
   * Returns the document fragment children.
   */
  get children() {
    if (!this[children]) {
      const elements2 = this[elementArray];
      this[children] = new HTMLCollection(illegalConstructor, () => elements2);
    }
    return this[children];
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get childElementCount() {
    return this[elementArray].length;
  }
  /**
   * First element child.
   *
   * @returns Element.
   */
  get firstElementChild() {
    return this[elementArray][0] ?? null;
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get lastElementChild() {
    const children2 = this[elementArray];
    return children2[children2.length - 1] ?? null;
  }
  /**
   * Get text value of children.
   *
   * @returns Text content.
   */
  get textContent() {
    let result2 = "";
    for (const childNode of this[nodeArray]) {
      if (childNode[nodeType] === NodeTypeEnum_default.elementNode || childNode[nodeType] === NodeTypeEnum_default.textNode) {
        result2 += childNode.textContent;
      }
    }
    return result2;
  }
  /**
   * Sets text content.
   *
   * @param textContent Text content.
   */
  set textContent(textContent) {
    const childNodes2 = this[nodeArray];
    while (childNodes2.length) {
      this.removeChild(childNodes2[0]);
    }
    if (textContent) {
      this.appendChild(this[ownerDocument].createTextNode(textContent));
    }
  }
  /**
   * Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  append(...nodes) {
    ParentNodeUtility.append(this, ...nodes);
  }
  /**
   * Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  prepend(...nodes) {
    ParentNodeUtility.prepend(this, ...nodes);
  }
  /**
   * Replaces the existing children of a node with a specified new set of children.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceChildren(...nodes) {
    ParentNodeUtility.replaceChildren(this, ...nodes);
  }
  /**
   * Query CSS selector to find matching elments.
   *
   * @param selector CSS selector.
   * @returns Matching elements.
   */
  querySelectorAll(selector) {
    return QuerySelector.querySelectorAll(this, selector);
  }
  /**
   * Query CSS Selector to find a matching element.
   *
   * @param selector CSS selector.
   * @returns Matching element.
   */
  querySelector(selector) {
    return QuerySelector.querySelector(this, selector);
  }
  /**
   * Returns an element by ID.
   *
   * @param id ID.
   * @returns Matching element.
   */
  getElementById(id2) {
    return ParentNodeUtility.getElementById(this, id2);
  }
};

// node_modules/happy-dom/lib/nodes/shadow-root/ShadowRoot.js
var ShadowRoot = class extends DocumentFragment {
  // Internal properties
  [adoptedStyleSheets] = [];
  [mode] = "open";
  [host] = null;
  [clonable] = false;
  [delegatesFocus] = false;
  [serializable] = false;
  [slotAssignment] = "named";
  [propertyEventListeners] = /* @__PURE__ */ new Map();
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onslotchange() {
    return this[propertyEventListeners].get("onslotchange") ?? null;
  }
  set onslotchange(value2) {
    this[propertyEventListeners].set("onslotchange", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns mode.
   *
   * @returns Mode.
   */
  get mode() {
    return this[mode];
  }
  /**
   * Returns host.
   *
   * @returns Host.
   */
  get host() {
    return this[host];
  }
  /**
   * Returns clonable.
   *
   * @returns Clonable.
   */
  get clonable() {
    return this[clonable];
  }
  /**
   * Returns delegates focus.
   *
   * @returns Delegates focus.
   */
  get delegatesFocus() {
    return this[delegatesFocus];
  }
  /**
   * Returns serializable.
   *
   * @returns Serializable.
   */
  get serializable() {
    return this[serializable];
  }
  /**
   * Returns slot assignment.
   *
   * @returns Slot assignment.
   */
  get slotAssignment() {
    return this[slotAssignment];
  }
  /**
   * The element that's currently in full screen mode for this shadow tree.
   *
   * @returns Fullscreen element.
   */
  get fullscreenElement() {
    return null;
  }
  /**
   * Returns the Element within the shadow tree that is currently being presented in picture-in-picture mode.
   *
   * @returns Picture-in-picture element.
   */
  get pictureInPictureElement() {
    return null;
  }
  /**
   * Returns the Element set as the target for mouse events while the pointer is locked. null if lock is pending, pointer is unlocked, or if the target is in another tree.
   *
   * @returns Pointer lock element.
   */
  get pointerLockElement() {
    return null;
  }
  /**
   * Returns inner HTML.
   *
   * @returns HTML.
   */
  get innerHTML() {
    const serializer = new HTMLSerializer();
    let html = "";
    for (const node of this[nodeArray]) {
      html += serializer.serializeToString(node);
    }
    return html;
  }
  /**
   * Sets inner HTML.
   *
   * @param html HTML.
   */
  set innerHTML(html) {
    const childNodes2 = this[nodeArray];
    while (childNodes2.length) {
      this.removeChild(childNodes2[0]);
    }
    new HTMLParser(this[window]).parse(html, this);
  }
  /**
   * Returns adopted style sheets.
   *
   * @returns Adopted style sheets.
   */
  get adoptedStyleSheets() {
    return this[adoptedStyleSheets];
  }
  /**
   * Sets adopted style sheets.
   *
   * @param value Adopted style sheets.
   */
  set adoptedStyleSheets(value2) {
    this[adoptedStyleSheets] = value2;
  }
  /**
   * Returns active element.
   *
   * @returns Active element.
   */
  get activeElement() {
    let activeElement2 = this[ownerDocument][activeElement];
    let rootNode2 = activeElement2?.getRootNode();
    if (!rootNode2 || rootNode2 === this[ownerDocument]) {
      return null;
    }
    if (rootNode2 === this) {
      return activeElement2;
    }
    while (rootNode2 && rootNode2 !== this) {
      activeElement2 = rootNode2.host;
      rootNode2 = activeElement2.getRootNode();
    }
    return activeElement2;
  }
  /**
   * Returns an array of all Animation objects currently in effect, whose target elements are descendants of the shadow tree.
   *
   * @returns Array of animations.
   */
  getAnimations() {
    return [];
  }
  /**
   * Parses a string of HTML into a document fragment, without sanitization, which then replaces the shadowroot's original subtree. The HTML string may include declarative shadow roots, which would be parsed as template elements the HTML was set using ShadowRoot.innerHTML.
   *
   * @param html HTML.
   */
  setHTMLUnsafe(html) {
    const childNodes2 = this[nodeArray];
    while (childNodes2.length) {
      this.removeChild(childNodes2[0]);
    }
    new HTMLParser(this[window]).parse(html, this);
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return this.innerHTML;
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[mode] = this[mode];
    clone2[clonable] = this[clonable];
    clone2[delegatesFocus] = this[delegatesFocus];
    clone2[serializable] = this[serializable];
    clone2[slotAssignment] = this[slotAssignment];
    return clone2;
  }
};

// node_modules/happy-dom/lib/nodes/svg-element/SVGElement.js
var SVGElement = class extends Element {
  // Internal properties
  [style] = null;
  // Private properties
  #dataset = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onabort() {
    return ElementEventAttributeUtility.getEventListener(this, "onabort");
  }
  set onabort(value2) {
    this[propertyEventListeners].set("onabort", value2);
  }
  get onanimationend() {
    return ElementEventAttributeUtility.getEventListener(this, "onanimationend");
  }
  set onanimationend(value2) {
    this[propertyEventListeners].set("onanimationend", value2);
  }
  get onanimationiteration() {
    return ElementEventAttributeUtility.getEventListener(this, "onanimationiteration");
  }
  set onanimationiteration(value2) {
    this[propertyEventListeners].set("onanimationiteration", value2);
  }
  get onanimationstart() {
    return ElementEventAttributeUtility.getEventListener(this, "onanimationstart");
  }
  set onanimationstart(value2) {
    this[propertyEventListeners].set("onanimationstart", value2);
  }
  get onauxclick() {
    return ElementEventAttributeUtility.getEventListener(this, "onauxclick");
  }
  set onauxclick(value2) {
    this[propertyEventListeners].set("onauxclick", value2);
  }
  get onblur() {
    return ElementEventAttributeUtility.getEventListener(this, "onblur");
  }
  set onblur(value2) {
    this[propertyEventListeners].set("onblur", value2);
  }
  get oncancel() {
    return ElementEventAttributeUtility.getEventListener(this, "oncancel");
  }
  set oncancel(value2) {
    this[propertyEventListeners].set("oncancel", value2);
  }
  get oncanplay() {
    return ElementEventAttributeUtility.getEventListener(this, "oncanplay");
  }
  set oncanplay(value2) {
    this[propertyEventListeners].set("oncanplay", value2);
  }
  get oncanplaythrough() {
    return ElementEventAttributeUtility.getEventListener(this, "oncanplaythrough");
  }
  set oncanplaythrough(value2) {
    this[propertyEventListeners].set("oncanplaythrough", value2);
  }
  get onchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onchange");
  }
  set onchange(value2) {
    this[propertyEventListeners].set("onchange", value2);
  }
  get onclick() {
    return ElementEventAttributeUtility.getEventListener(this, "onclick");
  }
  set onclick(value2) {
    this[propertyEventListeners].set("onclick", value2);
  }
  get onclose() {
    return ElementEventAttributeUtility.getEventListener(this, "onclose");
  }
  set onclose(value2) {
    this[propertyEventListeners].set("onclose", value2);
  }
  get oncontextmenu() {
    return ElementEventAttributeUtility.getEventListener(this, "oncontextmenu");
  }
  set oncontextmenu(value2) {
    this[propertyEventListeners].set("oncontextmenu", value2);
  }
  get oncopy() {
    return ElementEventAttributeUtility.getEventListener(this, "oncopy");
  }
  set oncopy(value2) {
    this[propertyEventListeners].set("oncopy", value2);
  }
  get oncuechange() {
    return ElementEventAttributeUtility.getEventListener(this, "oncuechange");
  }
  set oncuechange(value2) {
    this[propertyEventListeners].set("oncuechange", value2);
  }
  get oncut() {
    return ElementEventAttributeUtility.getEventListener(this, "oncut");
  }
  set oncut(value2) {
    this[propertyEventListeners].set("oncut", value2);
  }
  get ondblclick() {
    return ElementEventAttributeUtility.getEventListener(this, "ondblclick");
  }
  set ondblclick(value2) {
    this[propertyEventListeners].set("ondblclick", value2);
  }
  get ondrag() {
    return ElementEventAttributeUtility.getEventListener(this, "ondrag");
  }
  set ondrag(value2) {
    this[propertyEventListeners].set("ondrag", value2);
  }
  get ondragend() {
    return ElementEventAttributeUtility.getEventListener(this, "ondragend");
  }
  set ondragend(value2) {
    this[propertyEventListeners].set("ondragend", value2);
  }
  get ondragenter() {
    return ElementEventAttributeUtility.getEventListener(this, "ondragenter");
  }
  set ondragenter(value2) {
    this[propertyEventListeners].set("ondragenter", value2);
  }
  get ondragleave() {
    return ElementEventAttributeUtility.getEventListener(this, "ondragleave");
  }
  set ondragleave(value2) {
    this[propertyEventListeners].set("ondragleave", value2);
  }
  get ondragover() {
    return ElementEventAttributeUtility.getEventListener(this, "ondragover");
  }
  set ondragover(value2) {
    this[propertyEventListeners].set("ondragover", value2);
  }
  get ondragstart() {
    return ElementEventAttributeUtility.getEventListener(this, "ondragstart");
  }
  set ondragstart(value2) {
    this[propertyEventListeners].set("ondragstart", value2);
  }
  get ondrop() {
    return ElementEventAttributeUtility.getEventListener(this, "ondrop");
  }
  set ondrop(value2) {
    this[propertyEventListeners].set("ondrop", value2);
  }
  get ondurationchange() {
    return ElementEventAttributeUtility.getEventListener(this, "ondurationchange");
  }
  set ondurationchange(value2) {
    this[propertyEventListeners].set("ondurationchange", value2);
  }
  get onemptied() {
    return ElementEventAttributeUtility.getEventListener(this, "onemptied");
  }
  set onemptied(value2) {
    this[propertyEventListeners].set("onemptied", value2);
  }
  get onended() {
    return ElementEventAttributeUtility.getEventListener(this, "onended");
  }
  set onended(value2) {
    this[propertyEventListeners].set("onended", value2);
  }
  get onerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onerror");
  }
  set onerror(value2) {
    this[propertyEventListeners].set("onerror", value2);
  }
  get onfocus() {
    return ElementEventAttributeUtility.getEventListener(this, "onfocus");
  }
  set onfocus(value2) {
    this[propertyEventListeners].set("onfocus", value2);
  }
  get onformdata() {
    return ElementEventAttributeUtility.getEventListener(this, "onformdata");
  }
  set onformdata(value2) {
    this[propertyEventListeners].set("onformdata", value2);
  }
  get ongotpointercapture() {
    return ElementEventAttributeUtility.getEventListener(this, "ongotpointercapture");
  }
  set ongotpointercapture(value2) {
    this[propertyEventListeners].set("ongotpointercapture", value2);
  }
  get oninput() {
    return ElementEventAttributeUtility.getEventListener(this, "oninput");
  }
  set oninput(value2) {
    this[propertyEventListeners].set("oninput", value2);
  }
  get oninvalid() {
    return ElementEventAttributeUtility.getEventListener(this, "oninvalid");
  }
  set oninvalid(value2) {
    this[propertyEventListeners].set("oninvalid", value2);
  }
  get onkeydown() {
    return ElementEventAttributeUtility.getEventListener(this, "onkeydown");
  }
  set onkeydown(value2) {
    this[propertyEventListeners].set("onkeydown", value2);
  }
  get onkeypress() {
    return ElementEventAttributeUtility.getEventListener(this, "onkeypress");
  }
  set onkeypress(value2) {
    this[propertyEventListeners].set("onkeypress", value2);
  }
  get onkeyup() {
    return ElementEventAttributeUtility.getEventListener(this, "onkeyup");
  }
  set onkeyup(value2) {
    this[propertyEventListeners].set("onkeyup", value2);
  }
  get onload() {
    return ElementEventAttributeUtility.getEventListener(this, "onload");
  }
  set onload(value2) {
    this[propertyEventListeners].set("onload", value2);
  }
  get onloadeddata() {
    return ElementEventAttributeUtility.getEventListener(this, "onloadeddata");
  }
  set onloadeddata(value2) {
    this[propertyEventListeners].set("onloadeddata", value2);
  }
  get onloadedmetadata() {
    return ElementEventAttributeUtility.getEventListener(this, "onloadedmetadata");
  }
  set onloadedmetadata(value2) {
    this[propertyEventListeners].set("onloadedmetadata", value2);
  }
  get onloadstart() {
    return ElementEventAttributeUtility.getEventListener(this, "onloadstart");
  }
  set onloadstart(value2) {
    this[propertyEventListeners].set("onloadstart", value2);
  }
  get onlostpointercapture() {
    return ElementEventAttributeUtility.getEventListener(this, "onlostpointercapture");
  }
  set onlostpointercapture(value2) {
    this[propertyEventListeners].set("onlostpointercapture", value2);
  }
  get onmousedown() {
    return ElementEventAttributeUtility.getEventListener(this, "onmousedown");
  }
  set onmousedown(value2) {
    this[propertyEventListeners].set("onmousedown", value2);
  }
  get onmouseenter() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseenter");
  }
  set onmouseenter(value2) {
    this[propertyEventListeners].set("onmouseenter", value2);
  }
  get onmouseleave() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseleave");
  }
  set onmouseleave(value2) {
    this[propertyEventListeners].set("onmouseleave", value2);
  }
  get onmousemove() {
    return ElementEventAttributeUtility.getEventListener(this, "onmousemove");
  }
  set onmousemove(value2) {
    this[propertyEventListeners].set("onmousemove", value2);
  }
  get onmouseout() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseout");
  }
  set onmouseout(value2) {
    this[propertyEventListeners].set("onmouseout", value2);
  }
  get onmouseover() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseover");
  }
  set onmouseover(value2) {
    this[propertyEventListeners].set("onmouseover", value2);
  }
  get onmouseup() {
    return ElementEventAttributeUtility.getEventListener(this, "onmouseup");
  }
  set onmouseup(value2) {
    this[propertyEventListeners].set("onmouseup", value2);
  }
  get onmousewheel() {
    return ElementEventAttributeUtility.getEventListener(this, "onmousewheel");
  }
  set onmousewheel(value2) {
    this[propertyEventListeners].set("onmousewheel", value2);
  }
  get onpaste() {
    return ElementEventAttributeUtility.getEventListener(this, "onpaste");
  }
  set onpaste(value2) {
    this[propertyEventListeners].set("onpaste", value2);
  }
  get onpause() {
    return ElementEventAttributeUtility.getEventListener(this, "onpause");
  }
  set onpause(value2) {
    this[propertyEventListeners].set("onpause", value2);
  }
  get onplay() {
    return ElementEventAttributeUtility.getEventListener(this, "onplay");
  }
  set onplay(value2) {
    this[propertyEventListeners].set("onplay", value2);
  }
  get onplaying() {
    return ElementEventAttributeUtility.getEventListener(this, "onplaying");
  }
  set onplaying(value2) {
    this[propertyEventListeners].set("onplaying", value2);
  }
  get onpointercancel() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointercancel");
  }
  set onpointercancel(value2) {
    this[propertyEventListeners].set("onpointercancel", value2);
  }
  get onpointerdown() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerdown");
  }
  set onpointerdown(value2) {
    this[propertyEventListeners].set("onpointerdown", value2);
  }
  get onpointerenter() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerenter");
  }
  set onpointerenter(value2) {
    this[propertyEventListeners].set("onpointerenter", value2);
  }
  get onpointerleave() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerleave");
  }
  set onpointerleave(value2) {
    this[propertyEventListeners].set("onpointerleave", value2);
  }
  get onpointermove() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointermove");
  }
  set onpointermove(value2) {
    this[propertyEventListeners].set("onpointermove", value2);
  }
  get onpointerout() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerout");
  }
  set onpointerout(value2) {
    this[propertyEventListeners].set("onpointerout", value2);
  }
  get onpointerover() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerover");
  }
  set onpointerover(value2) {
    this[propertyEventListeners].set("onpointerover", value2);
  }
  get onpointerrawupdate() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerrawupdate");
  }
  set onpointerrawupdate(value2) {
    this[propertyEventListeners].set("onpointerrawupdate", value2);
  }
  get onpointerup() {
    return ElementEventAttributeUtility.getEventListener(this, "onpointerup");
  }
  set onpointerup(value2) {
    this[propertyEventListeners].set("onpointerup", value2);
  }
  get onprogress() {
    return ElementEventAttributeUtility.getEventListener(this, "onprogress");
  }
  set onprogress(value2) {
    this[propertyEventListeners].set("onprogress", value2);
  }
  get onratechange() {
    return ElementEventAttributeUtility.getEventListener(this, "onratechange");
  }
  set onratechange(value2) {
    this[propertyEventListeners].set("onratechange", value2);
  }
  get onreset() {
    return ElementEventAttributeUtility.getEventListener(this, "onreset");
  }
  set onreset(value2) {
    this[propertyEventListeners].set("onreset", value2);
  }
  get onresize() {
    return ElementEventAttributeUtility.getEventListener(this, "onresize");
  }
  set onresize(value2) {
    this[propertyEventListeners].set("onresize", value2);
  }
  get onscroll() {
    return ElementEventAttributeUtility.getEventListener(this, "onscroll");
  }
  set onscroll(value2) {
    this[propertyEventListeners].set("onscroll", value2);
  }
  get onscrollend() {
    return ElementEventAttributeUtility.getEventListener(this, "onscrollend");
  }
  set onscrollend(value2) {
    this[propertyEventListeners].set("onscrollend", value2);
  }
  get onscrollsnapchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onscrollsnapchange");
  }
  set onscrollsnapchange(value2) {
    this[propertyEventListeners].set("onscrollsnapchange", value2);
  }
  get onscrollsnapchanging() {
    return ElementEventAttributeUtility.getEventListener(this, "onscrollsnapchanging");
  }
  set onscrollsnapchanging(value2) {
    this[propertyEventListeners].set("onscrollsnapchanging", value2);
  }
  get onsecuritypolicyviolation() {
    return ElementEventAttributeUtility.getEventListener(this, "onsecuritypolicyviolation");
  }
  set onsecuritypolicyviolation(value2) {
    this[propertyEventListeners].set("onsecuritypolicyviolation", value2);
  }
  get onseeked() {
    return ElementEventAttributeUtility.getEventListener(this, "onseeked");
  }
  set onseeked(value2) {
    this[propertyEventListeners].set("onseeked", value2);
  }
  get onseeking() {
    return ElementEventAttributeUtility.getEventListener(this, "onseeking");
  }
  set onseeking(value2) {
    this[propertyEventListeners].set("onseeking", value2);
  }
  get onselect() {
    return ElementEventAttributeUtility.getEventListener(this, "onselect");
  }
  set onselect(value2) {
    this[propertyEventListeners].set("onselect", value2);
  }
  get onselectionchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onselectionchange");
  }
  set onselectionchange(value2) {
    this[propertyEventListeners].set("onselectionchange", value2);
  }
  get onselectstart() {
    return ElementEventAttributeUtility.getEventListener(this, "onselectstart");
  }
  set onselectstart(value2) {
    this[propertyEventListeners].set("onselectstart", value2);
  }
  get onslotchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onslotchange");
  }
  set onslotchange(value2) {
    this[propertyEventListeners].set("onslotchange", value2);
  }
  get onstalled() {
    return ElementEventAttributeUtility.getEventListener(this, "onstalled");
  }
  set onstalled(value2) {
    this[propertyEventListeners].set("onstalled", value2);
  }
  get onsubmit() {
    return ElementEventAttributeUtility.getEventListener(this, "onsubmit");
  }
  set onsubmit(value2) {
    this[propertyEventListeners].set("onsubmit", value2);
  }
  get onsuspend() {
    return ElementEventAttributeUtility.getEventListener(this, "onsuspend");
  }
  set onsuspend(value2) {
    this[propertyEventListeners].set("onsuspend", value2);
  }
  get ontimeupdate() {
    return ElementEventAttributeUtility.getEventListener(this, "ontimeupdate");
  }
  set ontimeupdate(value2) {
    this[propertyEventListeners].set("ontimeupdate", value2);
  }
  get ontoggle() {
    return ElementEventAttributeUtility.getEventListener(this, "ontoggle");
  }
  set ontoggle(value2) {
    this[propertyEventListeners].set("ontoggle", value2);
  }
  get ontransitioncancel() {
    return ElementEventAttributeUtility.getEventListener(this, "ontransitioncancel");
  }
  set ontransitioncancel(value2) {
    this[propertyEventListeners].set("ontransitioncancel", value2);
  }
  get ontransitionend() {
    return ElementEventAttributeUtility.getEventListener(this, "ontransitionend");
  }
  set ontransitionend(value2) {
    this[propertyEventListeners].set("ontransitionend", value2);
  }
  get ontransitionrun() {
    return ElementEventAttributeUtility.getEventListener(this, "ontransitionrun");
  }
  set ontransitionrun(value2) {
    this[propertyEventListeners].set("ontransitionrun", value2);
  }
  get ontransitionstart() {
    return ElementEventAttributeUtility.getEventListener(this, "ontransitionstart");
  }
  set ontransitionstart(value2) {
    this[propertyEventListeners].set("ontransitionstart", value2);
  }
  get onvolumechange() {
    return ElementEventAttributeUtility.getEventListener(this, "onvolumechange");
  }
  set onvolumechange(value2) {
    this[propertyEventListeners].set("onvolumechange", value2);
  }
  get onwaiting() {
    return ElementEventAttributeUtility.getEventListener(this, "onwaiting");
  }
  set onwaiting(value2) {
    this[propertyEventListeners].set("onwaiting", value2);
  }
  get onwheel() {
    return ElementEventAttributeUtility.getEventListener(this, "onwheel");
  }
  set onwheel(value2) {
    this[propertyEventListeners].set("onwheel", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns current translate.
   *
   * @returns Element.
   */
  get ownerSVGElement() {
    let parent2 = this[parentNode];
    while (parent2) {
      if (parent2[localName] === "svg") {
        return parent2;
      }
      parent2 = parent2[parentNode];
    }
    return null;
  }
  /**
   * Returns the SVGElement which established the current viewport. Often the nearest ancestor <svg> element. null if the given element is the outermost <svg> element.
   *
   * @returns SVG element.
   */
  get viewportElement() {
    return this.ownerSVGElement;
  }
  /**
   * Returns data set.
   *
   * @returns Data set.
   */
  get dataset() {
    return this.#dataset ??= new DOMStringMap(illegalConstructor, this);
  }
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!this[style]) {
      this[style] = new CSSStyleDeclaration(illegalConstructor, this[window], { element: this });
    }
    return this[style];
  }
  /**
   * Returns tab index.
   *
   * @returns Tab index.
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    return tabIndex !== null ? Number(tabIndex) : -1;
  }
  /**
   * Returns tab index.
   *
   * @param tabIndex Tab index.
   */
  set tabIndex(tabIndex) {
    if (tabIndex === -1) {
      this.removeAttribute("tabindex");
    } else {
      this.setAttribute("tabindex", String(tabIndex));
    }
  }
  /**
   * Triggers a blur event.
   */
  blur() {
    HTMLElementUtility.blur(this);
  }
  /**
   * Triggers a focus event.
   */
  focus() {
    HTMLElementUtility.focus(this);
  }
};

// node_modules/happy-dom/lib/resize-observer/ResizeObserver.js
var ResizeObserver = class {
  /**
   * Starts observing.
   *
   * Not implemented.
   */
  observe() {
  }
  /**
   * Stops observing.
   *
   * Not implemented.
   */
  unobserve() {
  }
  /**
   * Disconnects.
   *
   * Not implemented.
   */
  disconnect() {
  }
};

// node_modules/happy-dom/lib/screen/Screen.js
var Screen = class {
  width = 1024;
  height = 768;
  availWidth = 1024;
  availHeight = 768;
  colorDepth = 24;
  pixelDepth = 24;
};

// node_modules/happy-dom/lib/storage/Storage.js
var Storage = class _Storage {
  [data] = {};
  /**
   * Constructor.
   */
  constructor() {
    const data2 = this[data];
    const methodBinder = new ClassMethodBinder(this, [_Storage]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        if (property in data2) {
          return data2[property];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (property in target2 || typeof property === "symbol") {
          return true;
        }
        data2[String(property)] = String(newValue);
        return true;
      },
      deleteProperty(_target, property) {
        if (property in data2) {
          delete data2[String(property)];
          return true;
        }
        return false;
      },
      ownKeys() {
        return Object.keys(data2);
      },
      has(target2, property) {
        if (property in target2 || property in data2) {
          return true;
        }
        return false;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        if (descriptor.value !== void 0) {
          data2[String(property)] = String(descriptor.value);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2) {
          return;
        }
        const value2 = data2[String(property)];
        if (value2 !== void 0) {
          return {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return Object.keys(this[data]).length;
  }
  /**
   * Returns name of the nth key.
   *
   * @param index Index.
   * @returns Name.
   */
  key(index) {
    const name2 = Object.keys(this[data])[index];
    return name2 !== void 0 ? name2 : null;
  }
  /**
   * Sets item.
   *
   * @param name Name.
   * @param item Item.
   */
  setItem(name2, item) {
    this[data][name2] = String(item);
  }
  /**
   * Returns item.
   *
   * @param name Name.
   * @returns Item.
   */
  getItem(name2) {
    return this[data][name2] !== void 0 ? this[data][name2] : null;
  }
  /**
   * Removes item.
   *
   * @param name Name.
   */
  removeItem(name2) {
    delete this[data][name2];
  }
  /**
   * Clears storage.
   */
  clear() {
    const data2 = this[data];
    for (const key of Object.keys(data2)) {
      delete data2[key];
    }
  }
};

// node_modules/happy-dom/lib/window/VMGlobalPropertyScript.js
import { Script as Script2 } from "vm";
var VMGlobalPropertyScript_default = new Script2(`
this.ArrayBuffer = globalThis.ArrayBuffer;
this.Boolean = globalThis.Boolean;
this.DataView = globalThis.DataView;
this.Date = globalThis.Date;
this.Error = globalThis.Error;
this.EvalError = globalThis.EvalError;
this.Float32Array = globalThis.Float32Array;
this.Float64Array = globalThis.Float64Array;
this.GLOBAL = globalThis.GLOBAL;
this.Infinity = globalThis.Infinity;
this.Int16Array = globalThis.Int16Array;
this.Int32Array = globalThis.Int32Array;
this.Int8Array = globalThis.Int8Array;
this.Intl = globalThis.Intl;
this.JSON = globalThis.JSON;
this.Map = globalThis.Map;
this.Math = globalThis.Math;
this.NaN = globalThis.NaN;
this.Number = globalThis.Number;
this.Promise = globalThis.Promise;
this.RangeError = globalThis.RangeError;
this.ReferenceError = globalThis.ReferenceError;
this.RegExp = globalThis.RegExp;
this.Reflect = globalThis.Reflect;
this.Set = globalThis.Set;
this.Symbol = globalThis.Symbol;
this.SyntaxError = globalThis.SyntaxError;
this.String = globalThis.String;
this.TypeError = globalThis.TypeError;
this.URIError = globalThis.URIError;
this.Uint16Array = globalThis.Uint16Array;
this.Uint32Array = globalThis.Uint32Array;
this.Uint8Array = globalThis.Uint8Array;
this.Uint8ClampedArray = globalThis.Uint8ClampedArray;
this.WeakMap = globalThis.WeakMap;
this.WeakSet = globalThis.WeakSet;
this.decodeURI = globalThis.decodeURI;
this.decodeURIComponent = globalThis.decodeURIComponent;
this.encodeURI = globalThis.encodeURI;
this.encodeURIComponent = globalThis.encodeURIComponent;
this.eval = globalThis.eval;
this.escape = globalThis.escape;
this.global = globalThis.global;
this.isFinite = globalThis.isFinite;
this.isNaN = globalThis.isNaN;
this.parseFloat = globalThis.parseFloat;
this.parseInt = globalThis.parseInt;
this.root = globalThis.root;
this.undefined = globalThis.undefined;
this.unescape = globalThis.unescape;
this.gc = globalThis.gc;
this.v8debug = globalThis.v8debug;
this.AbortController = globalThis.AbortController;
this.AbortSignal = globalThis.AbortSignal;
this.Array = globalThis.Array;
this.Object = globalThis.Object;
this.Function = globalThis.Function;
`);

// node_modules/happy-dom/lib/window/WindowPageOpenUtility.js
import { URL as URL13 } from "url";
var WindowPageOpenUtility = class {
  /**
   * Opens a page.
   *
   * @param browserFrame Browser frame.
   * @param [options] Options.
   * @param [options.url] URL.
   * @param [options.target] Target.
   * @param [options.features] Window features.
   */
  static openPage(browserFrame, options2) {
    const features = this.getWindowFeatures(options2?.features || "");
    const target2 = options2?.target !== void 0 ? String(options2.target) : null;
    const originURL = new URL13(browserFrame.window.location.href);
    const targetURL = BrowserFrameURL.getRelativeURL(browserFrame, options2.url);
    const oldWindow = browserFrame.window;
    let targetFrame;
    if (browserFrame.window !== oldWindow) {
      return null;
    }
    switch (target2) {
      case "_self":
        targetFrame = browserFrame;
        break;
      case "_top":
        targetFrame = browserFrame.page.mainFrame;
        break;
      case "_parent":
        targetFrame = browserFrame.parentFrame ?? browserFrame;
        break;
      case "_blank":
      default:
        const newPage = browserFrame.page.context.newPage();
        targetFrame = newPage.mainFrame;
        targetFrame[openerFrame] = browserFrame;
        break;
    }
    targetFrame.goto(targetURL.href, {
      referrer: features.noreferrer ? void 0 : browserFrame.window.location.origin,
      referrerPolicy: features.noreferrer ? "no-referrer" : void 0
    }).catch((error2) => {
      if (targetFrame.page?.console) {
        targetFrame.page.console.error(error2);
      } else {
        throw error2;
      }
    });
    if (targetURL.protocol === "javascript:") {
      return targetFrame.window;
    }
    if (targetFrame === browserFrame && browserFrame.window === oldWindow) {
      return null;
    }
    if (features.popup && target2 !== "_self" && target2 !== "_top" && target2 !== "_parent") {
      targetFrame[popup] = true;
      if (features?.width || features?.height) {
        targetFrame.page.setViewport({
          width: features?.width,
          height: features?.height
        });
      }
      if (features?.left) {
        targetFrame.window.screenLeft = features.left;
        targetFrame.window.screenX = features.left;
      }
      if (features?.top) {
        targetFrame.window.screenTop = features.top;
        targetFrame.window.screenY = features.top;
      }
    }
    if (target2 && target2 !== "_self" && target2 !== "_top" && target2 !== "_parent" && target2 !== "_blank") {
      targetFrame.window.name = target2;
    }
    const isCORS = FetchCORSUtility.isCORS(originURL, targetFrame.url);
    if (!features.noopener && !features.noreferrer && browserFrame.window && targetFrame[openerFrame] && targetFrame.window !== browserFrame.window) {
      targetFrame[openerWindow] = isCORS ? new CrossOriginBrowserWindow(browserFrame.window) : browserFrame.window;
    }
    if (features.noopener || features.noreferrer) {
      return null;
    }
    if (isCORS) {
      return new CrossOriginBrowserWindow(targetFrame.window, browserFrame.window);
    }
    return targetFrame.window;
  }
  /**
   * Returns window features.
   *
   * @param features Window features string.
   * @returns Window features.
   */
  static getWindowFeatures(features) {
    const parts = features.split(",");
    const result2 = {
      popup: false,
      width: 0,
      height: 0,
      left: 0,
      top: 0,
      noopener: false,
      noreferrer: false
    };
    for (const part of parts) {
      const [key, value2] = part.split("=");
      switch (key) {
        case "popup":
          result2.popup = !value2 || value2 === "yes" || value2 === "1" || value2 === "true";
          break;
        case "width":
        case "innerWidth":
          result2.width = parseInt(value2, 10);
          break;
        case "height":
        case "innerHeight":
          result2.height = parseInt(value2, 10);
          break;
        case "left":
        case "screenX":
          result2.left = parseInt(value2, 10);
          break;
        case "top":
        case "screenY":
          result2.top = parseInt(value2, 10);
          break;
        case "noopener":
          result2.noopener = true;
          break;
        case "noreferrer":
          result2.noreferrer = true;
          break;
      }
    }
    return result2;
  }
};

// node_modules/happy-dom/lib/window/BrowserWindow.js
import { PerformanceObserver, PerformanceEntry } from "node:perf_hooks";

// node_modules/happy-dom/lib/nodes/html-document/HTMLDocument.js
var HTMLDocument = class extends Document {
  /**
   * Constructor.
   */
  constructor() {
    super();
    const documentElement = this.createElement("html");
    const bodyElement = this.createElement("body");
    const headElement = this.createElement("head");
    this.appendChild(documentElement);
    documentElement.appendChild(headElement);
    documentElement.appendChild(bodyElement);
  }
  /**
   * @override
   */
  [appendChild](node, disableValidations = false) {
    if (node[nodeType] === NodeTypeEnum_default.textNode) {
      throw new this[window].Error(`Failed to execute 'appendChild' on 'Node': Nodes of type '#text' may not be inserted inside nodes of type '#document'.`);
    }
    if (node[nodeType] === NodeTypeEnum_default.documentFragmentNode) {
      return;
    }
    if (node[nodeType] === NodeTypeEnum_default.elementNode && this[elementArray].length !== 0) {
      throw new this[window].Error(`Failed to execute 'appendChild' on 'Node': Only one element on document allowed.`);
    }
    return super[appendChild](node, disableValidations);
  }
  /**
   * @override
   */
  [insertBefore](newNode, referenceNode, disableValidations = false) {
    if (newNode[nodeType] === NodeTypeEnum_default.textNode) {
      throw new this[window].Error(`Failed to execute 'insertBefore' on 'Node': Nodes of type '#text' may not be inserted inside nodes of type '#document'.`);
    }
    if (newNode[nodeType] === NodeTypeEnum_default.documentFragmentNode) {
      return;
    }
    if (newNode[nodeType] === NodeTypeEnum_default.elementNode && this[elementArray].length !== 0) {
      throw new this[window].Error(`Failed to execute 'insertBefore' on 'Node': Only one element on document allowed.`);
    }
    return super[insertBefore](newNode, referenceNode, disableValidations);
  }
};

// node_modules/happy-dom/lib/nodes/xml-document/XMLDocument.js
var XMLDocument = class extends Document {
  // Internal properties
  [contentType] = "application/xml";
};

// node_modules/happy-dom/lib/nodes/text/Text.js
var Text = class extends CharacterData {
  [nodeType] = NodeTypeEnum_default.textNode;
  [textAreaNode] = null;
  [styleNode] = null;
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return "#text";
  }
  /**
   * @override
   */
  get data() {
    return this[data];
  }
  /**
   * @override
   */
  set data(data2) {
    super.data = data2;
    if (this[textAreaNode]) {
      this[textAreaNode][resetSelection]();
    }
    if (this[styleNode]) {
      this[styleNode][updateSheet]();
    }
  }
  /**
   * Breaks the Text node into two nodes at the specified offset, keeping both nodes in the tree as siblings.
   *
   * @see https://dom.spec.whatwg.org/#dom-text-splittext
   * @param offset Offset.
   * @returns New text node.
   */
  splitText(offset2) {
    const length2 = this[data].length;
    if (offset2 < 0 || offset2 > length2) {
      throw new this[window].DOMException("The index is not in the allowed range.", DOMExceptionNameEnum_default.indexSizeError);
    }
    const count = length2 - offset2;
    const newData = this.substringData(offset2, count);
    const newNode = this[ownerDocument].createTextNode(newData);
    if (this[parentNode] !== null) {
      this[parentNode].insertBefore(newNode, this.nextSibling);
    }
    this.replaceData(offset2, count, "");
    return newNode;
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return "[object Text]";
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * @override
   */
  [connectedToNode]() {
    super[connectedToNode]();
    if (this[textAreaNode]) {
      this[textAreaNode][resetSelection]();
    }
    if (this[styleNode] && this[data]) {
      this[styleNode][updateSheet]();
    }
  }
  /**
   * @override
   */
  [disconnectedFromNode]() {
    if (this[textAreaNode]) {
      this[textAreaNode][resetSelection]();
    }
    if (this[styleNode] && this[data]) {
      this[styleNode][updateSheet]();
    }
    super[disconnectedFromNode]();
  }
};

// node_modules/happy-dom/lib/nodes/comment/Comment.js
var Comment = class extends CharacterData {
  [nodeType] = NodeTypeEnum_default.commentNode;
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return "#comment";
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return "[object Comment]";
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
};

// node_modules/happy-dom/lib/nodes/html-image-element/Image.js
var Image = class extends HTMLImageElement {
  [tagName] = "IMG";
  [localName] = "img";
  [namespaceURI] = NamespaceURI_default.html;
  /**
   * Constructor.
   *
   * @param [width] Width.
   * @param [height] Height.
   */
  constructor(width2 = null, height2 = null) {
    super();
    if (width2 !== null) {
      this.width = width2;
    }
    if (height2 !== null) {
      this.height = height2;
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-audio-element/Audio.js
var Audio = class extends HTMLAudioElement {
  [tagName] = "AUDIO";
  [localName] = "audio";
  [namespaceURI] = NamespaceURI_default.html;
  /**
   * Constructor.
   *
   * @param [url] source URL.
   */
  constructor(url2 = null) {
    super();
    if (url2 !== null) {
      this.src = url2;
    }
  }
};

// node_modules/happy-dom/lib/mutation-observer/MutationObserverListener.js
var MutationObserverListener = class {
  target;
  options;
  mutationListener;
  #window;
  #observer;
  #callback;
  #records = [];
  #timeout = null;
  /**
   * Constructor.
   *
   * @param init Options.
   * @param init.window Window.
   * @param init.options Options.
   * @param init.target Target.
   * @param init.observer Observer.
   * @param init.callback Callback.
   */
  constructor(init) {
    this.options = init.options;
    this.target = init.target;
    this.mutationListener = {
      options: init.options,
      callback: new WeakRef((record) => this.report(record))
    };
    this.#window = init.window;
    this.#observer = init.observer;
    this.#callback = init.callback;
  }
  /**
   * Reports mutations.
   *
   * @param record Record.
   */
  report(record) {
    if (!this.#records) {
      return;
    }
    this.#records.push(record);
    if (this.#timeout) {
      this.#window.clearTimeout(this.#timeout);
    }
    this.#timeout = this.#window.setTimeout(() => {
      const records = this.#records;
      if (records?.length > 0) {
        this.#records = [];
        this.#callback(records, this.#observer);
      }
    });
  }
  /**
   * Destroys the listener.
   */
  takeRecords() {
    if (this.#timeout) {
      this.#window.clearTimeout(this.#timeout);
    }
    const records = this.#records;
    this.#records = [];
    return records;
  }
  /**
   * Destroys the listener.
   */
  destroy() {
    if (this.#timeout) {
      this.#window.clearTimeout(this.#timeout);
    }
    this.options = null;
    this.target = null;
    this.mutationListener = null;
    this.#window = null;
    this.#observer = null;
    this.#callback = null;
    this.#timeout = null;
    this.#records = null;
  }
};

// node_modules/happy-dom/lib/mutation-observer/MutationObserver.js
var MutationObserver = class {
  #callback;
  #listeners = [];
  #destroyed = false;
  /**
   * Constructor.
   *
   * @param callback Callback.
   */
  constructor(callback) {
    if (!this[window]) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
    this.#callback = callback;
  }
  /**
   * Starts observing.
   *
   * @param target Target.
   * @param options Options.
   */
  observe(target2, options2) {
    if (this.#destroyed) {
      return;
    }
    if (!target2) {
      throw new this[window].TypeError(`Failed to execute 'observe' on 'MutationObserver': The first parameter "target" should be of type "Node".`);
    }
    if (options2 && (options2.attributeFilter || options2.attributeOldValue)) {
      if (options2.attributes === void 0) {
        options2 = Object.assign({}, options2, {
          attributes: true,
          attributeFilter: options2.attributeFilter,
          attributeOldValue: options2.attributeOldValue
        });
      }
      if (!options2.attributes && options2.attributeOldValue) {
        throw new this[window].TypeError(`Failed to execute 'observe' on 'MutationObserver': The options object may only set 'attributeOldValue' to true when 'attributes' is true or not present.`);
      }
      if (!options2.attributes && options2.attributeFilter) {
        throw new this[window].TypeError(`Failed to execute 'observe' on 'MutationObserver': The options object may only set 'attributeFilter' when 'attributes' is true or not present.`);
      }
    }
    if (options2 && options2.characterDataOldValue) {
      if (options2.characterData === void 0) {
        options2 = Object.assign({}, options2, {
          characterData: true,
          characterDataOldValue: options2.characterDataOldValue
        });
      }
      if (!options2.characterData && options2.characterDataOldValue) {
        throw new this[window].TypeError(`Failed to execute 'observe' on 'MutationObserver': The options object may only set 'characterDataOldValue' to true when 'characterData' is true or not present.`);
      }
    }
    if (!options2 || !options2.childList && !options2.attributes && !options2.characterData) {
      throw new this[window].TypeError(`Failed to execute 'observe' on 'MutationObserver': The options object must set at least one of 'attributes', 'characterData', or 'childList' to true.`);
    }
    options2 = Object.assign({}, options2, {
      attributeFilter: options2.attributeFilter ? options2.attributeFilter.map((name2) => name2.toLowerCase()) : null
    });
    for (const listener2 of this.#listeners) {
      if (listener2.target === target2) {
        listener2.options = options2;
        return;
      }
    }
    const listener = new MutationObserverListener({
      window: this[window],
      options: options2,
      callback: this.#callback.bind(this),
      observer: this,
      target: target2
    });
    this.#listeners.push(listener);
    if (!this[window][mutationObservers].includes(this)) {
      this[window][mutationObservers].push(this);
    }
    target2[observeMutations](listener.mutationListener);
  }
  /**
   * Disconnects.
   */
  disconnect() {
    if (this.#listeners.length === 0) {
      return;
    }
    for (const listener of this.#listeners) {
      listener.target[unobserveMutations](listener.mutationListener);
      listener.destroy();
    }
    this.#listeners = [];
    const mutationObservers2 = this[window][mutationObservers];
    const index = mutationObservers2.indexOf(this);
    if (index !== -1) {
      mutationObservers2.splice(index, 1);
    }
  }
  /**
   * Returns a list of all matching DOM changes that have been detected but not yet processed by the observer's callback function, leaving the mutation queue empty.
   *
   * @returns Records.
   */
  takeRecords() {
    let records = [];
    for (const listener of this.#listeners) {
      records = records.concat(listener.takeRecords());
    }
    return records;
  }
  /**
   *
   */
  [destroy]() {
    this.#destroyed = true;
    this.disconnect();
  }
};

// node_modules/happy-dom/lib/event/MessagePort.js
var MessagePort = class extends EventTarget {
  /**
   * Sends a message from the port, and optionally, transfers ownership of objects to other browsing contexts.
   *
   * @param _message Message.
   * @param _transerList Transfer list.
   */
  postMessage(_message, _transerList) {
  }
  /**
   * Starts the sending of messages queued on the port.
   */
  start() {
  }
  /**
   * Disconnects the port, so it is no longer active. This stops the flow of messages to that port.
   */
  close() {
  }
};

// node_modules/happy-dom/lib/event/DataTransferItem.js
var DataTransferItem = class {
  kind;
  type;
  #item = null;
  /**
   * Constructor.
   *
   * @param item Item.
   * @param type Type.
   */
  constructor(item, type2 = "") {
    this.kind = typeof item === "string" ? "string" : "file";
    this.type = this.kind === "string" ? type2 : item.type;
    this.#item = item;
  }
  /**
   * Returns file.
   */
  getAsFile() {
    if (this.kind === "string") {
      return null;
    }
    return this.#item;
  }
  /**
   * Returns string.
   *
   * @param callback Callback.
   */
  getAsString(callback) {
    if (this.kind === "file") {
      callback;
    }
    callback(this.#item);
  }
};

// node_modules/happy-dom/lib/event/DataTransferItemList.js
var DataTransferItemList = class extends Array {
  /**
   * Adds an item.
   *
   * @param item Item.
   * @param type Type.
   */
  add(item, type2) {
    if (item instanceof File) {
      this.push(new DataTransferItem(item));
      return;
    }
    if (!type2) {
      throw new TypeError(`Failed to execute 'add' on 'DataTransferItemList': parameter 1 is not of type 'File'.`);
    }
    this.push(new DataTransferItem(item, type2));
  }
  /**
   * Removes an item.
   *
   * @param index Index.
   */
  remove(index) {
    this.splice(index, 1);
  }
  /**
   * Clears list.
   */
  clear() {
    while (this.length) {
      this.pop();
    }
  }
};

// node_modules/happy-dom/lib/event/DataTransfer.js
var DataTransfer = class {
  dropEffect = "none";
  effectAllowed = "none";
  items = new DataTransferItemList();
  /**
   * Returns files.
   *
   * @returns Files.
   */
  get files() {
    const files2 = [];
    for (const item of this.items) {
      if (item.kind === "file") {
        files2.push(item.getAsFile());
      }
    }
    return files2;
  }
  /**
   * Returns types.
   *
   * @returns Types.
   */
  get types() {
    return this.items.map((item) => item.type);
  }
  /**
   * Clears the data.
   */
  clearData() {
    this.items.clear();
  }
  /**
   * Sets the data.
   *
   * @param format Format.
   * @param data Data.
   */
  setData(format, data2) {
    for (let i = 0, max = this.items.length; i < max; i++) {
      if (this.items[i].type === format) {
        this.items[i] = new DataTransferItem(data2, format);
        return;
      }
    }
    this.items.add(data2, format);
  }
  /**
   * Gets the data.
   *
   * @param format Format.
   * @returns Data.
   */
  getData(format) {
    for (let i = 0, max = this.items.length; i < max; i++) {
      if (this.items[i].type === format) {
        let data2 = "";
        this.items[i].getAsString((s) => data2 = s);
        return data2;
      }
    }
    return "";
  }
  /**
   * Sets drag image.
   *
   * TODO: Implement.
   */
  setDragImage() {
    throw new Error("Not implemented.");
  }
};

// node_modules/happy-dom/lib/xml-serializer/XMLSerializer.js
var XMLSerializer = class {
  /**
   * Serializes a node into XML.
   *
   * @param root Root node.
   * @returns Result.
   */
  serializeToString(root2) {
    return this.#serializeToString(root2);
  }
  /**
   * Serializes a node into XML.
   *
   * @param root Root node.
   * @param [inheritedDefaultNamespace] Default namespace.
   * @param [inheritedNamespacePrefixes] Inherited namespace prefixes.
   * @returns Result.
   */
  #serializeToString(root2, inheritedDefaultNamespace = null, inheritedNamespacePrefixes = null) {
    switch (root2[nodeType]) {
      case NodeTypeEnum_default.elementNode:
        const element = root2;
        const localName2 = element[localName];
        let innerHTML = "";
        const namespacePrefixes = this.#getNamespacePrefixes(element, inheritedNamespacePrefixes);
        const elementPrefix = element[namespaceURI] === NamespaceURI_default.html ? element[prefix] : this.#getElementPrefix(element, namespacePrefixes);
        const tagName2 = `${elementPrefix ? elementPrefix + ":" : ""}${localName2}`;
        const defaultNamespace = elementPrefix ? inheritedDefaultNamespace : element[namespaceURI] || inheritedDefaultNamespace;
        const attributes2 = this.#getAttributes(element, elementPrefix, inheritedDefaultNamespace, inheritedNamespacePrefixes);
        const childNodes2 = defaultNamespace === NamespaceURI_default.html && localName2 === "template" ? root2.content[nodeArray] : root2[nodeArray];
        for (const node of childNodes2) {
          innerHTML += this.#serializeToString(node, defaultNamespace, namespacePrefixes);
        }
        if (!innerHTML && defaultNamespace === NamespaceURI_default.html && HTMLElementConfig_default[localName2.toLowerCase()]?.contentModel === HTMLElementConfigContentModelEnum_default.noDescendants) {
          return `<${tagName2}${attributes2} />`;
        }
        if (!innerHTML && defaultNamespace !== NamespaceURI_default.html) {
          return `<${tagName2}${attributes2}/>`;
        }
        return `<${tagName2}${attributes2}>${innerHTML}</${tagName2}>`;
      case Node.DOCUMENT_FRAGMENT_NODE:
      case Node.DOCUMENT_NODE:
        let html = "";
        if (root2[xmlProcessingInstruction]) {
          html += this.#serializeToString(root2[xmlProcessingInstruction], inheritedDefaultNamespace, new Map(inheritedNamespacePrefixes));
        }
        for (const node of root2[nodeArray]) {
          html += this.#serializeToString(node, inheritedDefaultNamespace, new Map(inheritedNamespacePrefixes));
        }
        return html;
      case NodeTypeEnum_default.commentNode:
        return `<!--${root2.textContent}-->`;
      case NodeTypeEnum_default.processingInstructionNode:
        return `<?${root2.target} ${root2.textContent}?>`;
      case NodeTypeEnum_default.textNode:
        const parentElement = root2.parentElement;
        if (parentElement) {
          const parentConfig = HTMLElementConfig_default[parentElement[localName]];
          if (parentConfig?.contentModel === HTMLElementConfigContentModelEnum_default.rawText) {
            return root2.textContent;
          }
        }
        return XMLEncodeUtility.encodeTextContent(root2.textContent);
      case NodeTypeEnum_default.documentTypeNode:
        const doctype = root2;
        const identifier = doctype.publicId ? " PUBLIC" : doctype.systemId ? " SYSTEM" : "";
        const publicId2 = doctype.publicId ? ` "${doctype.publicId}"` : "";
        const systemId2 = doctype.systemId ? ` "${doctype.systemId}"` : "";
        return `<!DOCTYPE ${doctype.name}${identifier}${publicId2}${systemId2}>`;
    }
    return "";
  }
  /**
   * Returns namespace prefixes.
   *
   * @param element Element.
   * @param inheritedNamespacePrefixes Inherited namespace prefixes.
   * @returns Namespace prefixes.
   */
  #getNamespacePrefixes(element, inheritedNamespacePrefixes) {
    const namespacePrefixes = new Map(inheritedNamespacePrefixes);
    for (const attribute of element[attributes][items].values()) {
      if (attribute[namespaceURI] === NamespaceURI_default.xmlns && attribute[prefix]) {
        namespacePrefixes.set(attribute[value], attribute[localName]);
      }
    }
    return namespacePrefixes;
  }
  /**
   * Returns namespace prefixes.
   *
   * @param element Element.
   * @param namespacePrefixes Inherited namespace prefixes.
   * @returns Element prefix.
   */
  #getElementPrefix(element, namespacePrefixes) {
    if (element[prefix] && !element[namespaceURI]) {
      throw new Error("Element has a prefix but no namespace.");
    }
    if (!element[prefix]) {
      return null;
    }
    const elementPrefix = namespacePrefixes.get(element[namespaceURI]);
    if (elementPrefix) {
      return elementPrefix;
    }
    const existingPrefixes = new Set(namespacePrefixes.values());
    if (existingPrefixes.has(element[prefix])) {
      let i = 1;
      while (existingPrefixes.has("n" + i)) {
        i++;
      }
      namespacePrefixes.set(element[namespaceURI], "n" + i);
      return "n" + i;
    }
    namespacePrefixes.set(element[namespaceURI], element[prefix]);
    return element[prefix];
  }
  /**
   * Returns attributes as a string.
   *
   * @param element Element.
   * @param elementPrefix Element prefix.
   * @param inheritedDefaultNamespace Inherited default namespace.
   * @param inheritedNamespacePrefixes Inherited namespace prefixes.
   * @returns Attributes.
   */
  #getAttributes(element, elementPrefix, inheritedDefaultNamespace, inheritedNamespacePrefixes) {
    let attributeString = "";
    let namespaceString = "";
    const handledNamespaces = /* @__PURE__ */ new Set();
    for (const attribute of element[attributes][items].values()) {
      if (attribute[namespaceURI] === NamespaceURI_default.xmlns) {
        if (elementPrefix && attribute[localName] === elementPrefix && element[namespaceURI]) {
          namespaceString += ` xmlns:${elementPrefix}="${XMLEncodeUtility.encodeXMLAttributeValue(element[namespaceURI])}"`;
          handledNamespaces.add(element[namespaceURI]);
        } else if (!elementPrefix && attribute[name] === "xmlns" && element[namespaceURI]) {
          namespaceString += ` xmlns="${XMLEncodeUtility.encodeXMLAttributeValue(element[namespaceURI])}"`;
          handledNamespaces.add(element[namespaceURI]);
        } else {
          namespaceString += ` ${attribute[name]}="${XMLEncodeUtility.encodeXMLAttributeValue(attribute[value])}"`;
          handledNamespaces.add(attribute[value]);
        }
      } else {
        attributeString += ` ${attribute[name]}="${XMLEncodeUtility.encodeXMLAttributeValue(attribute[value])}"`;
      }
    }
    if (element[namespaceURI] && inheritedDefaultNamespace !== element[namespaceURI] && !handledNamespaces.has(element[namespaceURI])) {
      if (elementPrefix && !inheritedNamespacePrefixes.has(element[namespaceURI])) {
        namespaceString += ` xmlns:${elementPrefix}="${XMLEncodeUtility.encodeXMLAttributeValue(element[namespaceURI])}"`;
      } else if (!elementPrefix && inheritedDefaultNamespace !== element[namespaceURI]) {
        namespaceString += ` xmlns="${XMLEncodeUtility.encodeXMLAttributeValue(element[namespaceURI])}"`;
      }
    }
    return namespaceString + attributeString;
  }
};

// node_modules/happy-dom/lib/css/utilities/CSSParser.js
var COMMENT_REGEXP = /\/\*[\s\S]*?\*\//gm;
var CSSParser = class {
  /**
   * Parses HTML and returns a root element.
   *
   * @param parentStyleSheet Parent style sheet.
   * @param cssText CSS code.
   * @returns Root element.
   */
  static parseFromString(parentStyleSheet, cssText2) {
    const window2 = parentStyleSheet[window];
    const css = cssText2.replace(COMMENT_REGEXP, "");
    const cssRules = [];
    const regExp = /{|}/gm;
    const stack = [];
    let parentRule = null;
    let lastIndex = 0;
    let match;
    while (match = regExp.exec(css)) {
      if (match[0] === "{") {
        const selectorText = css.substring(lastIndex, match.index).trim();
        if (selectorText[0] === "@") {
          const ruleParts = selectorText.split(" ");
          const ruleType = ruleParts[0];
          const ruleParameters = ruleParts.slice(1).join(" ").trim();
          switch (ruleType) {
            case "@keyframes":
            case "@-webkit-keyframes":
              const keyframesRule = new CSSKeyframesRule(illegalConstructor, window2);
              keyframesRule.name = ruleParameters;
              keyframesRule.parentStyleSheet = parentStyleSheet;
              if (parentRule) {
                if (parentRule.type === CSSRuleTypeEnum_default.mediaRule || parentRule.type === CSSRuleTypeEnum_default.containerRule || parentRule.type === CSSRuleTypeEnum_default.supportsRule) {
                  parentRule.cssRules.push(keyframesRule);
                }
              } else {
                cssRules.push(keyframesRule);
              }
              parentRule = keyframesRule;
              break;
            case "@media":
              const mediums = ruleParameters.split(",");
              const mediaRule = new CSSMediaRule(illegalConstructor, window2);
              for (const medium of mediums) {
                mediaRule.media.appendMedium(medium.trim());
              }
              mediaRule.parentStyleSheet = parentStyleSheet;
              if (parentRule) {
                if (parentRule.type === CSSRuleTypeEnum_default.mediaRule || parentRule.type === CSSRuleTypeEnum_default.containerRule || parentRule.type === CSSRuleTypeEnum_default.supportsRule) {
                  parentRule.cssRules.push(mediaRule);
                }
              } else {
                cssRules.push(mediaRule);
              }
              parentRule = mediaRule;
              break;
            case "@container":
            case "@-webkit-container":
              const containerRule = new CSSContainerRule(illegalConstructor, window2);
              containerRule.conditionText = ruleParameters;
              containerRule.parentStyleSheet = parentStyleSheet;
              if (parentRule) {
                if (parentRule.type === CSSRuleTypeEnum_default.mediaRule || parentRule.type === CSSRuleTypeEnum_default.containerRule || parentRule.type === CSSRuleTypeEnum_default.supportsRule) {
                  parentRule.cssRules.push(containerRule);
                }
              } else {
                cssRules.push(containerRule);
              }
              parentRule = containerRule;
              break;
            case "@supports":
            case "@-webkit-supports":
              const supportsRule = new CSSSupportsRule(illegalConstructor, window2);
              supportsRule.conditionText = ruleParameters;
              supportsRule.parentStyleSheet = parentStyleSheet;
              if (parentRule) {
                if (parentRule.type === CSSRuleTypeEnum_default.mediaRule || parentRule.type === CSSRuleTypeEnum_default.containerRule || parentRule.type === CSSRuleTypeEnum_default.supportsRule) {
                  parentRule.cssRules.push(supportsRule);
                }
              } else {
                cssRules.push(supportsRule);
              }
              parentRule = supportsRule;
              break;
            case "@font-face":
              const fontFaceRule = new CSSFontFaceRule(illegalConstructor, window2);
              fontFaceRule[cssText] = ruleParameters;
              fontFaceRule.parentStyleSheet = parentStyleSheet;
              if (parentRule) {
                if (parentRule.type === CSSRuleTypeEnum_default.mediaRule || parentRule.type === CSSRuleTypeEnum_default.containerRule || parentRule.type === CSSRuleTypeEnum_default.supportsRule) {
                  parentRule.cssRules.push(fontFaceRule);
                }
              } else {
                cssRules.push(fontFaceRule);
              }
              parentRule = fontFaceRule;
              break;
            default:
              const newRule = new CSSRule(illegalConstructor, window2);
              newRule.parentStyleSheet = parentStyleSheet;
              parentRule = newRule;
              break;
          }
        } else if (parentRule && parentRule.type === CSSRuleTypeEnum_default.keyframesRule) {
          const newRule = new CSSKeyframeRule(illegalConstructor, window2);
          newRule.keyText = selectorText.trim();
          newRule.parentStyleSheet = parentStyleSheet;
          newRule.parentRule = parentRule;
          parentRule.cssRules.push(newRule);
          parentRule = newRule;
        } else if (parentRule && (parentRule.type === CSSRuleTypeEnum_default.mediaRule || parentRule.type === CSSRuleTypeEnum_default.containerRule || parentRule.type === CSSRuleTypeEnum_default.supportsRule)) {
          if (this.validateSelectorText(selectorText)) {
            const newRule = new CSSStyleRule(illegalConstructor, window2);
            newRule.selectorText = selectorText;
            newRule.parentStyleSheet = parentStyleSheet;
            newRule.parentRule = parentRule;
            parentRule.cssRules.push(newRule);
            parentRule = newRule;
          }
        } else {
          if (this.validateSelectorText(selectorText)) {
            const newRule = new CSSStyleRule(illegalConstructor, window2);
            newRule.selectorText = selectorText;
            newRule.parentStyleSheet = parentStyleSheet;
            newRule.parentRule = parentRule;
            if (!parentRule) {
              cssRules.push(newRule);
            }
            parentRule = newRule;
          }
        }
        stack.push(parentRule);
      } else {
        if (parentRule) {
          const cssText3 = css.substring(lastIndex, match.index).trim().replace(/([^;])$/, "$1;");
          switch (parentRule.type) {
            case CSSRuleTypeEnum_default.fontFaceRule:
            case CSSRuleTypeEnum_default.keyframeRule:
            case CSSRuleTypeEnum_default.styleRule:
              parentRule[cssText] = cssText3;
              break;
          }
        }
        stack.pop();
        parentRule = stack[stack.length - 1] || null;
      }
      lastIndex = match.index + 1;
    }
    return cssRules;
  }
  /**
   * Validates a selector text.
   *
   * @see https://www.w3.org/TR/CSS21/syndata.html#rule-sets
   * @param selectorText Selector text.
   * @returns True if valid, false otherwise.
   */
  static validateSelectorText(selectorText) {
    try {
      SelectorParser.getSelectorGroups(selectorText);
    } catch (e) {
      return false;
    }
    return true;
  }
};

// node_modules/happy-dom/lib/css/CSSStyleSheet.js
var CSSStyleSheet = class {
  value = null;
  name = null;
  namespaceURI = null;
  cssRules = [];
  // TODO: MediaList is not fully implemented.
  media;
  title;
  alternate;
  disabled;
  #currentText = null;
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.media] Media.
   * @param [options.title] Title.
   * @param [options.alternate] Alternate.
   * @param [options.disabled] Disabled.
   */
  constructor(options2) {
    this.media = options2 && options2.media ? options2.media : "";
    this.title = options2 && options2.title ? options2.title : "";
    this.alternate = options2 && options2.alternate ? options2.alternate : false;
    this.disabled = options2 && options2.disabled ? options2.disabled : false;
  }
  /**
   * Inserts a rule.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule
   * @param rule Rule.
   * @param [index] Index.
   * @returns The newly inserterted rule's index.
   */
  insertRule(rule, index) {
    if (arguments.length === 0) {
      throw new this[window].TypeError(`Failed to execute 'insertRule' on 'CSSStyleSheet': 1 argument required, but only 0 present.`);
    }
    const rules = CSSParser.parseFromString(this, rule);
    if (rules.length === 0 || rules.length > 1) {
      throw new this[window].DOMException(`Failed to execute 'insertRule' on 'CSSStyleSheet': Failed to parse the rule '${rule}'.`, DOMExceptionNameEnum_default.syntaxError);
    }
    if (index !== void 0) {
      if (index > this.cssRules.length) {
        throw new this[window].DOMException(`Failed to execute 'insertRule' on 'CSSStyleSheet': The index provided (${index}) is larger than the maximum index (${this.cssRules.length - 1}).`, DOMExceptionNameEnum_default.indexSizeError);
      }
      this.cssRules.splice(index, 0, rules[0]);
      return index;
    }
    const newIndex = this.cssRules.length;
    this.cssRules.push(rules[0]);
    return newIndex;
  }
  /**
   * Removes a rule.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/deleteRule
   * @param index Index.
   */
  deleteRule(index) {
    if (arguments.length === 0) {
      throw new this[window].TypeError(`Failed to execute 'deleteRule' on 'CSSStyleSheet': 1 argument required, but only 0 present.`);
    }
    this.cssRules.splice(index, 1);
  }
  /**
   * Replaces all CSS rules.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/replace
   * @param text CSS text.
   * @returns Promise.
   */
  async replace(text) {
    if (arguments.length === 0) {
      throw new this[window].TypeError(`Failed to execute 'replace' on 'CSSStyleSheet': 1 argument required, but only 0 present.`);
    }
    this.replaceSync(text);
  }
  /**
   * Replaces all CSS rules.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/replaceSync
   * @param text CSS text.
   */
  replaceSync(text) {
    if (arguments.length === 0) {
      throw new this[window].TypeError(`Failed to execute 'replaceSync' on 'CSSStyleSheet': 1 argument required, but only 0 present.`);
    }
    if (this.#currentText !== text) {
      this.#currentText = text;
      this.cssRules = CSSParser.parseFromString(this, text);
    }
  }
};

// node_modules/happy-dom/lib/fetch/Request.js
import { URL as URL14 } from "url";
var Request = class _Request {
  // Public properties
  [method];
  [body];
  [mode] = "cors";
  [headers];
  [redirect];
  [referrerPolicy];
  [signal];
  [bodyUsed] = false;
  [credentials];
  // Internal properties
  [aborted] = false;
  [contentLength] = null;
  [contentType] = null;
  [referrer] = "client";
  [url];
  [bodyBuffer];
  /**
   * Constructor.
   *
   * @param input Input.
   * @param [init] Init.
   */
  constructor(input, init) {
    const window2 = this[window];
    if (!window2) {
      throw new TypeError(`Failed to construct 'Request': 'Request' was constructed outside a Window context.`);
    }
    if (typeof input !== `string` && !input) {
      throw new window2.TypeError(`Failed to contruct 'Request': 1 argument required, only 0 present.`);
    }
    this[method] = (init?.method || input.method || "GET").toUpperCase();
    if (init?.mode) {
      switch (init.mode) {
        case "navigate":
        case "websocket":
          throw new window2.DOMException(`Failed to construct 'Request': Cannot construct a Request with a RequestInit whose mode member is set as '${init.mode}'.`, DOMExceptionNameEnum_default.securityError);
        case "same-origin":
        case "no-cors":
        case "cors":
          this[mode] = init.mode;
          break;
        default:
          throw new window2.DOMException(`Failed to construct 'Request': The provided value '${init.mode}' is not a valid enum value of type RequestMode.`, DOMExceptionNameEnum_default.syntaxError);
      }
    } else if (input instanceof _Request) {
      this[mode] = input.mode;
    }
    const { stream, buffer: buffer2, contentType: contentType2, contentLength: contentLength2 } = FetchBodyUtility.getBodyStream(input instanceof _Request && (input[bodyBuffer] || input.body) ? input[bodyBuffer] || FetchBodyUtility.cloneBodyStream(window2, input) : init?.body);
    this[bodyBuffer] = buffer2;
    this[body] = stream;
    this[credentials] = init?.credentials || input.credentials || "same-origin";
    this[headers] = new Headers(init?.headers || input.headers || {});
    FetchRequestHeaderUtility.removeForbiddenHeaders(this.headers);
    if (contentLength2) {
      this[contentLength] = contentLength2;
    } else if (!this.body && (this.method === "POST" || this.method === "PUT")) {
      this[contentLength] = 0;
    }
    if (contentType2) {
      if (!this.headers.has("Content-Type")) {
        this.headers.set("Content-Type", contentType2);
      }
      this[contentType] = contentType2;
    } else if (input instanceof _Request && input[contentType]) {
      this[contentType] = input[contentType];
    }
    this[redirect] = init?.redirect || input.redirect || "follow";
    this[referrerPolicy] = (init?.referrerPolicy || input.referrerPolicy || "").toLowerCase();
    this[signal] = init?.signal || input.signal || new window2.AbortSignal();
    this[referrer] = FetchRequestReferrerUtility.getInitialReferrer(window2, init?.referrer !== null && init?.referrer !== void 0 ? init?.referrer : input.referrer);
    if (input instanceof URL14) {
      this[url] = input;
    } else {
      try {
        if (input instanceof _Request && input.url) {
          this[url] = new URL14(input.url, window2.location.href);
        } else {
          this[url] = new URL14(input, window2.location.href);
        }
      } catch (error2) {
        throw new window2.DOMException(`Failed to construct 'Request': Invalid URL "${input}" on document location '${window2.location}'.${window2.location.origin === "null" ? " Relative URLs are not permitted on current document location." : ""}`, DOMExceptionNameEnum_default.notSupportedError);
      }
    }
    FetchRequestValidationUtility.validateMethod(this);
    FetchRequestValidationUtility.validateBody(this);
    FetchRequestValidationUtility.validateURL(this[url]);
    FetchRequestValidationUtility.validateReferrerPolicy(this.referrerPolicy);
    FetchRequestValidationUtility.validateRedirect(this.redirect);
  }
  /**
   * Returns method.
   *
   * @returns Method.
   */
  get method() {
    return this[method];
  }
  /**
   * Returns body.
   *
   * @returns Body.
   */
  get body() {
    return this[body];
  }
  /**
   * Returns mode.
   *
   * @returns Mode.
   */
  get mode() {
    return this[mode];
  }
  /**
   * Returns headers.
   *
   * @returns Headers.
   */
  get headers() {
    return this[headers];
  }
  /**
   * Returns redirect.
   *
   * @returns Redirect.
   */
  get redirect() {
    return this[redirect];
  }
  /**
   * Returns referrer policy.
   *
   * @returns Referrer policy.
   */
  get referrerPolicy() {
    return this[referrerPolicy];
  }
  /**
   * Returns signal.
   *
   * @returns Signal.
   */
  get signal() {
    return this[signal];
  }
  /**
   * Returns body used.
   *
   * @returns Body used.
   */
  get bodyUsed() {
    return this[bodyUsed];
  }
  /**
   * Returns credentials.
   *
   * @returns Credentials.
   */
  get credentials() {
    return this[credentials];
  }
  /**
   * Returns referrer.
   *
   * @returns Referrer.
   */
  get referrer() {
    if (!this[referrer] || this[referrer] === "no-referrer") {
      return "";
    }
    if (this[referrer] === "client") {
      return "about:client";
    }
    return this[referrer].toString();
  }
  /**
   * Returns URL.
   *
   * @returns URL.
   */
  get url() {
    return this[url].href;
  }
  /**
   * Returns string tag.
   *
   * @returns String tag.
   */
  get [Symbol.toStringTag]() {
    return "Request";
  }
  /**
   * Returns array buffer.
   *
   * @returns Array buffer.
   */
  async arrayBuffer() {
    const window2 = this[window];
    if (this[bodyUsed]) {
      throw new window2.DOMException(`Body has already been used for "${this.url}".`, DOMExceptionNameEnum_default.invalidStateError);
    }
    const asyncTaskManager2 = new WindowBrowserContext(window2).getAsyncTaskManager();
    this[bodyUsed] = true;
    const taskID = asyncTaskManager2.startTask(() => {
      if (this.body) {
        this.body[aborted] = true;
      }
      this.signal[abort]();
    });
    let buffer2;
    try {
      buffer2 = await FetchBodyUtility.consumeBodyStream(window2, this.body);
    } catch (error2) {
      asyncTaskManager2.endTask(taskID);
      throw error2;
    }
    asyncTaskManager2.endTask(taskID);
    return buffer2.buffer.slice(buffer2.byteOffset, buffer2.byteOffset + buffer2.byteLength);
  }
  /**
   * Returns blob.
   *
   * @returns Blob.
   */
  async blob() {
    const type2 = this.headers.get("Content-Type") || "";
    const buffer2 = await this.arrayBuffer();
    return new Blob([buffer2], { type: type2 });
  }
  /**
   * Returns buffer.
   *
   * @returns Buffer.
   */
  async buffer() {
    const window2 = this[window];
    if (this[bodyUsed]) {
      throw new window2.DOMException(`Body has already been used for "${this.url}".`, DOMExceptionNameEnum_default.invalidStateError);
    }
    const asyncTaskManager2 = new WindowBrowserContext(window2).getAsyncTaskManager();
    this[bodyUsed] = true;
    const taskID = asyncTaskManager2.startTask(() => {
      if (this.body) {
        this.body[aborted] = true;
      }
      this.signal[abort]();
    });
    let buffer2;
    try {
      buffer2 = await FetchBodyUtility.consumeBodyStream(window2, this.body);
    } catch (error2) {
      asyncTaskManager2.endTask(taskID);
      throw error2;
    }
    asyncTaskManager2.endTask(taskID);
    return buffer2;
  }
  /**
   * Returns text.
   *
   * @returns Text.
   */
  async text() {
    const window2 = this[window];
    if (this[bodyUsed]) {
      throw new window2.DOMException(`Body has already been used for "${this.url}".`, DOMExceptionNameEnum_default.invalidStateError);
    }
    const asyncTaskManager2 = new WindowBrowserContext(window2).getAsyncTaskManager();
    this[bodyUsed] = true;
    const taskID = asyncTaskManager2.startTask(() => {
      if (this.body) {
        this.body[aborted] = true;
      }
      this.signal[abort]();
    });
    let buffer2;
    try {
      buffer2 = await FetchBodyUtility.consumeBodyStream(window2, this.body);
    } catch (error2) {
      asyncTaskManager2.endTask(taskID);
      throw error2;
    }
    asyncTaskManager2.endTask(taskID);
    return new TextDecoder().decode(buffer2);
  }
  /**
   * Returns json.
   *
   * @returns JSON.
   */
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  /**
   * Returns FormData.
   *
   * @returns FormData.
   */
  async formData() {
    const window2 = this[window];
    const asyncTaskManager2 = new WindowBrowserContext(window2).getAsyncTaskManager();
    const contentType2 = this[contentType];
    if (/multipart/i.test(contentType2)) {
      if (this[bodyUsed]) {
        throw new window2.DOMException(`Body has already been used for "${this.url}".`, DOMExceptionNameEnum_default.invalidStateError);
      }
      this[bodyUsed] = true;
      const taskID = asyncTaskManager2.startTask(() => {
        if (this.body) {
          this.body[aborted] = true;
        }
        this.signal[abort]();
      });
      let formData;
      try {
        const result2 = await MultipartFormDataParser.streamToFormData(window2, this.body, contentType2);
        formData = result2.formData;
      } catch (error2) {
        asyncTaskManager2.endTask(taskID);
        throw error2;
      }
      asyncTaskManager2.endTask(taskID);
      return formData;
    }
    if (contentType2?.startsWith("application/x-www-form-urlencoded")) {
      const parameters = new URLSearchParams(await this.text());
      const formData = new window2.FormData();
      for (const [key, value2] of parameters) {
        formData.append(key, value2);
      }
      return formData;
    }
    throw new window2.DOMException(`Failed to construct FormData object: The "content-type" header is neither "application/x-www-form-urlencoded" nor "multipart/form-data".`, DOMExceptionNameEnum_default.invalidStateError);
  }
  /**
   * Clones request.
   *
   * @returns Clone.
   */
  clone() {
    return new this[window].Request(this);
  }
};

// node_modules/happy-dom/lib/xml-http-request/XMLHttpRequestEventTarget.js
var XMLHttpRequestEventTarget = class extends EventTarget {
  onloadstart = null;
  onprogress = null;
  onabort = null;
  onerror = null;
  onload = null;
  ontimeout = null;
  onloadend = null;
};

// node_modules/happy-dom/lib/xml-http-request/XMLHttpRequestUpload.js
var XMLHttpRequestUpload = class extends XMLHttpRequestEventTarget {
};

// node_modules/happy-dom/lib/fetch/AbortController.js
var AbortController = class {
  // Public properties
  signal = new this[window].AbortSignal();
  /**
   * Aborts the signal.
   *
   * @param [reason] Reason.
   */
  abort(reason2) {
    this.signal[abort](reason2);
  }
};

// node_modules/happy-dom/lib/fetch/AbortSignal.js
var AbortSignal = class extends EventTarget {
  // Internal properties
  [aborted] = false;
  [reason] = void 0;
  // Events
  onabort = null;
  /**
   * Constructor.
   */
  constructor() {
    super();
    if (!this[window]) {
      throw new TypeError(`Failed to construct 'AbortSignal': Illegal constructor`);
    }
  }
  /**
   * Return a default description for the AbortSignal class.
   */
  get [Symbol.toStringTag]() {
    return "AbortSignal";
  }
  /**
   * Returns true if the signal has been aborted.
   *
   * @returns True if the signal has been aborted.
   */
  get aborted() {
    return this[aborted];
  }
  /**
   * Setter for aborted. Value will be ignored as the property is read-only.
   *
   * @param _value Aborted.
   */
  set aborted(_value) {
  }
  /**
   * Returns the reason the signal was aborted.
   *
   * @returns Reason.
   */
  get reason() {
    return this[reason];
  }
  /**
   * Setter for reason. Value will be ignored as the property is read-only.
   *
   * @param _value Reason.
   */
  set reason(_value) {
  }
  /**
   * Aborts the signal.
   *
   * @param [reason] Reason.
   */
  [abort](reason2) {
    if (this.aborted) {
      return;
    }
    this[reason] = reason2 !== void 0 ? reason2 : new this[window].DOMException("signal is aborted without reason", DOMExceptionNameEnum_default.abortError);
    this[aborted] = true;
    this.dispatchEvent(new Event("abort"));
  }
  /**
   * Throws an "AbortError" if the signal has been aborted.
   */
  throwIfAborted() {
    if (this.aborted) {
      throw this.reason;
    }
  }
  /**
   * Returns an AbortSignal instance that has been set as aborted.
   *
   * @param [reason] Reason.
   * @returns AbortSignal instance.
   */
  static abort(reason2) {
    const signal2 = new this();
    signal2[reason] = reason2 !== void 0 ? reason2 : new this[window].DOMException("signal is aborted without reason", DOMExceptionNameEnum_default.abortError);
    signal2[aborted] = true;
    return signal2;
  }
  /**
   * Returns an AbortSignal that will automatically abort after a specified
   * time.
   *
   * @param [time] Time in milliseconds.
   * @returns AbortSignal instance.
   */
  static timeout(time) {
    const window2 = this[window];
    const signal2 = new this();
    window2.setTimeout(() => {
      signal2[abort](new window2.DOMException("signal timed out", DOMExceptionNameEnum_default.timeoutError));
    }, time);
    return signal2;
  }
  /**
   * Takes an iterable of abort signals and returns an AbortSignal that is
   * aborted when any of the input iterable abort signals are aborted.
   *
   * The abort reason will be set to the reason of the first signal that is
   * aborted. If any of the given abort signals are already aborted then so will
   * be the returned AbortSignal.
   *
   * @param [signals] Iterable of abort signals.
   * @returns AbortSignal instance.
   */
  static any(signals) {
    for (const signal2 of signals) {
      if (signal2[aborted]) {
        return this.abort(signal2[reason]);
      }
    }
    const anySignal = new this();
    const handlers = /* @__PURE__ */ new Map();
    const stopListening = () => {
      for (const signal2 of signals) {
        signal2.removeEventListener("abort", handlers.get(signal2));
      }
    };
    for (const signal2 of signals) {
      const handler = () => {
        stopListening();
        anySignal[abort](signal2[reason]);
      };
      handlers.set(signal2, handler);
      signal2.addEventListener("abort", handler);
    }
    return anySignal;
  }
};

// node_modules/happy-dom/lib/permissions/PermissionStatus.js
var PermissionStatus = class extends EventTarget {
  state;
  onchange = null;
  /**
   * Constructor.
   *
   * @param [state] State.
   */
  constructor(state2 = "granted") {
    super();
    this.state = state2;
  }
};

// node_modules/happy-dom/lib/clipboard/ClipboardItem.js
var ClipboardItem = class {
  presentationStyle = "unspecified";
  #data;
  /**
   * Constructor.
   *
   * @param data Data.
   * @param [options] Options.
   * @param [options.presentationStyle] Presentation style.
   */
  constructor(data2, options2) {
    this.#data = data2;
    if (options2?.presentationStyle) {
      this.presentationStyle = options2.presentationStyle;
    }
  }
  /**
   * Returns types.
   *
   * @returns Types.
   */
  get types() {
    return Object.keys(this.#data);
  }
  /**
   * Returns data by type.
   *
   * @param type Type.
   * @returns Data.
   */
  async getType(type2) {
    if (!this.#data[type2]) {
      throw new DOMException(`Failed to execute 'getType' on 'ClipboardItem': The type '${type2}' was not found`);
    }
    if (this.#data[type2] instanceof Blob) {
      return this.#data[type2];
    }
    return new Blob([await this.#data[type2]], { type: type2 });
  }
};

// node_modules/happy-dom/lib/xml-http-request/XMLHttpRequestReadyStateEnum.js
var XMLHttpRequestReadyStateEnum;
(function(XMLHttpRequestReadyStateEnum2) {
  XMLHttpRequestReadyStateEnum2[XMLHttpRequestReadyStateEnum2["unsent"] = 0] = "unsent";
  XMLHttpRequestReadyStateEnum2[XMLHttpRequestReadyStateEnum2["opened"] = 1] = "opened";
  XMLHttpRequestReadyStateEnum2[XMLHttpRequestReadyStateEnum2["headersRecieved"] = 2] = "headersRecieved";
  XMLHttpRequestReadyStateEnum2[XMLHttpRequestReadyStateEnum2["loading"] = 3] = "loading";
  XMLHttpRequestReadyStateEnum2[XMLHttpRequestReadyStateEnum2["done"] = 4] = "done";
})(XMLHttpRequestReadyStateEnum || (XMLHttpRequestReadyStateEnum = {}));
var XMLHttpRequestReadyStateEnum_default = XMLHttpRequestReadyStateEnum;

// node_modules/happy-dom/lib/xml-http-request/XMLHttpResponseTypeEnum.js
var XMLHttpResponseTypeEnum;
(function(XMLHttpResponseTypeEnum2) {
  XMLHttpResponseTypeEnum2["arraybuffer"] = "arraybuffer";
  XMLHttpResponseTypeEnum2["blob"] = "blob";
  XMLHttpResponseTypeEnum2["document"] = "document";
  XMLHttpResponseTypeEnum2["json"] = "json";
  XMLHttpResponseTypeEnum2["text"] = "text";
})(XMLHttpResponseTypeEnum || (XMLHttpResponseTypeEnum = {}));
var XMLHttpResponseTypeEnum_default = XMLHttpResponseTypeEnum;

// node_modules/happy-dom/lib/xml-http-request/XMLHttpRequestResponseDataParser.js
var XMLHttpRequestResponseDataParser = class {
  /**
   * Parses response.
   *
   * @param options Options.
   * @param options.window Window.
   * @param [options.responseType] Response type.
   * @param [options.data] Data.
   * @param [options.contentType] Content type.
   * @returns Parsed response.
   **/
  static parse(options2) {
    if (!options2.data) {
      return "";
    }
    switch (options2.responseType) {
      case XMLHttpResponseTypeEnum_default.arraybuffer:
        const newAB = new ArrayBuffer(options2.data.length);
        const view = new Uint8Array(newAB);
        view.set(options2.data);
        return view;
      case XMLHttpResponseTypeEnum_default.blob:
        try {
          return new options2.window.Blob([new Uint8Array(options2.data)], {
            type: options2.contentType || ""
          });
        } catch (e) {
        }
        return null;
      case XMLHttpResponseTypeEnum_default.document:
        const window2 = options2.window;
        const domParser = new window2.DOMParser();
        try {
          return domParser.parseFromString(options2.data.toString(), "application/xml");
        } catch (e) {
        }
        return null;
      case XMLHttpResponseTypeEnum_default.json:
        try {
          return JSON.parse(options2.data.toString());
        } catch (e) {
        }
        return null;
      case XMLHttpResponseTypeEnum_default.text:
      case "":
      default:
        return options2.data.toString();
    }
  }
};

// node_modules/happy-dom/lib/xml-http-request/XMLHttpRequest.js
var XMLHttpRequest = class extends XMLHttpRequestEventTarget {
  // Constants
  static UNSENT = XMLHttpRequestReadyStateEnum_default.unsent;
  static OPENED = XMLHttpRequestReadyStateEnum_default.opened;
  static HEADERS_RECEIVED = XMLHttpRequestReadyStateEnum_default.headersRecieved;
  static LOADING = XMLHttpRequestReadyStateEnum_default.loading;
  static DONE = XMLHttpRequestReadyStateEnum_default.done;
  // Public properties
  upload = new this[window].XMLHttpRequestUpload();
  withCredentials = false;
  // Private properties
  #async = true;
  #abortController = null;
  #aborted = false;
  #request = null;
  #response = null;
  #responseType = "";
  #responseBody = null;
  #readyState = XMLHttpRequestReadyStateEnum_default.unsent;
  /**
   * Constructor.
   */
  constructor() {
    super();
    if (!this[window]) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
  }
  /**
   * Returns the status.
   *
   * @returns Status.
   */
  get status() {
    return this.#response?.status || 0;
  }
  /**
   * Returns the status text.
   *
   * @returns Status text.
   */
  get statusText() {
    return this.#response?.statusText || "";
  }
  /**
   * Returns the response.
   *
   * @returns Response.
   */
  get response() {
    if (!this.#response) {
      return "";
    }
    return this.#responseBody;
  }
  /**
   * Get the response text.
   *
   * @throws {DOMException} If the response type is not text or empty.
   * @returns The response text.
   */
  get responseText() {
    if (this.responseType !== XMLHttpResponseTypeEnum_default.text && this.responseType !== "") {
      throw new this[window].DOMException(`Failed to read the 'responseText' property from 'XMLHttpRequest': The value is only accessible if the object's 'responseType' is '' or 'text' (was '${this.responseType}').`, DOMExceptionNameEnum_default.invalidStateError);
    }
    return this.#responseBody ?? "";
  }
  /**
   * Get the responseXML.
   *
   * @throws {DOMException} If the response type is not text or empty.
   * @returns Response XML.
   */
  get responseXML() {
    if (this.responseType !== XMLHttpResponseTypeEnum_default.document && this.responseType !== "") {
      throw new this[window].DOMException(`Failed to read the 'responseXML' property from 'XMLHttpRequest': The value is only accessible if the object's 'responseType' is '' or 'document' (was '${this.responseType}').`, DOMExceptionNameEnum_default.invalidStateError);
    }
    return this.responseType === "" ? null : this.#responseBody;
  }
  /**
   * Returns the response URL.
   *
   * @returns Response URL.
   */
  get responseURL() {
    return this.#response?.url || "";
  }
  /**
   * Returns the ready state.
   *
   * @returns Ready state.
   */
  get readyState() {
    return this.#readyState;
  }
  /**
   * Set response type.
   *
   * @param type Response type.
   * @throws {DOMException} If the state is not unsent or opened.
   * @throws {DOMException} If the request is synchronous.
   */
  set responseType(type2) {
    if (this.readyState !== XMLHttpRequestReadyStateEnum_default.opened && this.readyState !== XMLHttpRequestReadyStateEnum_default.unsent) {
      throw new this[window].DOMException(`Failed to set the 'responseType' property on 'XMLHttpRequest': The object's state must be OPENED or UNSENT.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    if (!this.#async) {
      throw new this[window].DOMException(`Failed to set the 'responseType' property on 'XMLHttpRequest': The response type cannot be changed for synchronous requests made from a document.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    this.#responseType = type2;
  }
  /**
   * Get response Type.
   *
   * @returns Response type.
   */
  get responseType() {
    return this.#responseType;
  }
  /**
   * Opens the connection.
   *
   * @param method Connection method (eg GET, POST).
   * @param url URL for the connection.
   * @param [async=true] Asynchronous connection.
   * @param [user] Username for basic authentication (optional).
   * @param [password] Password for basic authentication (optional).
   */
  open(method2, url2, async = true, user, password) {
    const window2 = this[window];
    if (!async && !!this.responseType && this.responseType !== XMLHttpResponseTypeEnum_default.text) {
      throw new window2.DOMException(`Failed to execute 'open' on 'XMLHttpRequest': Synchronous requests from a document must not set a response type.`, DOMExceptionNameEnum_default.invalidAccessError);
    }
    const headers2 = new Headers();
    if (user) {
      const authBuffer = Buffer.from(`${user}:${password || ""}`);
      headers2.set("Authorization", "Basic " + authBuffer.toString("base64"));
    }
    this.#async = async;
    this.#aborted = false;
    this.#response = null;
    this.#responseBody = null;
    this.#abortController = new window2.AbortController();
    this.#request = new window2.Request(url2, {
      method: method2,
      headers: headers2,
      signal: this.#abortController.signal,
      credentials: this.withCredentials ? "include" : "same-origin"
    });
    this.#readyState = XMLHttpRequestReadyStateEnum_default.opened;
  }
  /**
   * Sets a header for the request.
   *
   * @param name Header name.
   * @param value Header value.
   * @returns Header added.
   */
  setRequestHeader(name2, value2) {
    if (this.readyState !== XMLHttpRequestReadyStateEnum_default.opened) {
      throw new this[window].DOMException(`Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    if (FetchRequestHeaderUtility.isHeaderForbidden(name2)) {
      return false;
    }
    this.#request.headers.set(name2, value2);
    return true;
  }
  /**
   * Gets a header from the server response.
   *
   * @param header header Name of header to get.
   * @returns string Text of the header or null if it doesn't exist.
   */
  getResponseHeader(header) {
    return this.#response?.headers.get(header) ?? null;
  }
  /**
   * Gets all the response headers.
   *
   * @returns A string with all response headers separated by CR+LF.
   */
  getAllResponseHeaders() {
    if (!this.#response) {
      return "";
    }
    const result2 = [];
    for (const [name2, value2] of this.#response?.headers) {
      const lowerName = name2.toLowerCase();
      if (lowerName !== "set-cookie" && lowerName !== "set-cookie2") {
        result2.push(`${name2}: ${value2}`);
      }
    }
    return result2.join("\r\n");
  }
  /**
   * Sends the request to the server.
   *
   * @param body Optional data to send as request body.
   */
  send(body2) {
    const window2 = this[window];
    if (this.readyState != XMLHttpRequestReadyStateEnum_default.opened) {
      throw new this[window].DOMException(`Failed to execute 'send' on 'XMLHttpRequest': Connection must be opened before send() is called.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    if (typeof body2 === "object" && body2 !== null && body2[nodeType] === NodeTypeEnum_default.documentNode) {
      body2 = new window2.XMLSerializer().serializeToString(body2);
    }
    if (this.#async) {
      this.#sendAsync(body2).catch((error2) => {
        throw error2;
      });
    } else {
      this.#sendSync(body2);
    }
  }
  /**
   * Aborts a request.
   */
  abort() {
    if (this.#aborted) {
      return;
    }
    this.#aborted = true;
    this.#abortController.abort();
  }
  /**
   * Sends the request to the server asynchronously.
   *
   * @param body Optional data to send as request body.
   */
  async #sendAsync(body2) {
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    const asyncTaskManager2 = browserFrame[asyncTaskManager];
    const taskID = asyncTaskManager2.startTask(() => this.abort());
    this.#readyState = XMLHttpRequestReadyStateEnum_default.loading;
    this.dispatchEvent(new Event("readystatechange"));
    this.dispatchEvent(new Event("loadstart"));
    if (body2) {
      this.#request = new window2.Request(this.#request.url, {
        method: this.#request.method,
        headers: this.#request.headers,
        signal: this.#abortController.signal,
        credentials: this.#request.credentials,
        body: body2
      });
    }
    this.#abortController.signal.addEventListener("abort", () => {
      this.#aborted = true;
      this.#readyState = XMLHttpRequestReadyStateEnum_default.unsent;
      this.dispatchEvent(new Event("abort"));
      this.dispatchEvent(new Event("loadend"));
      this.dispatchEvent(new Event("readystatechange"));
      asyncTaskManager2.endTask(taskID);
    });
    const onError = (error2) => {
      if (error2 instanceof DOMException && error2.name === DOMExceptionNameEnum_default.abortError) {
        if (this.#aborted) {
          return;
        }
        this.#readyState = XMLHttpRequestReadyStateEnum_default.unsent;
        this.dispatchEvent(new Event("abort"));
      } else {
        this.#readyState = XMLHttpRequestReadyStateEnum_default.done;
        this.dispatchEvent(new ErrorEvent("error", { error: error2, message: error2.message }));
      }
      this.dispatchEvent(new Event("loadend"));
      this.dispatchEvent(new Event("readystatechange"));
      asyncTaskManager2.endTask(taskID);
    };
    const fetch = new Fetch({
      browserFrame,
      window: window2,
      url: this.#request.url,
      init: this.#request
    });
    try {
      this.#response = await fetch.send();
    } catch (error2) {
      onError(error2);
      return;
    }
    this.#readyState = XMLHttpRequestReadyStateEnum_default.headersRecieved;
    this.dispatchEvent(new Event("readystatechange"));
    const contentLength2 = this.#response.headers.get("Content-Length");
    const contentLengthNumber = contentLength2 !== null && !isNaN(Number(contentLength2)) ? Number(contentLength2) : null;
    let loaded = 0;
    let data2 = Buffer.from([]);
    if (this.#response.body) {
      let eventError;
      try {
        for await (const chunk of this.#response.body) {
          data2 = Buffer.concat([data2, typeof chunk === "string" ? Buffer.from(chunk) : chunk]);
          loaded += chunk.length;
          try {
            this.dispatchEvent(new ProgressEvent("progress", {
              lengthComputable: contentLengthNumber !== null,
              loaded,
              total: contentLengthNumber !== null ? contentLengthNumber : 0
            }));
          } catch (error2) {
            eventError = error2;
            throw error2;
          }
        }
      } catch (error2) {
        if (error2 === eventError) {
          throw error2;
        }
        onError(error2);
        return;
      }
    }
    this.#responseBody = XMLHttpRequestResponseDataParser.parse({
      window: window2,
      responseType: this.#responseType,
      data: data2,
      contentType: this.#response.headers.get("Content-Type") || this.#request.headers.get("Content-Type")
    });
    this.#readyState = XMLHttpRequestReadyStateEnum_default.done;
    asyncTaskManager2.endTask(taskID);
    this.dispatchEvent(new Event("readystatechange"));
    this.dispatchEvent(new Event("load"));
    this.dispatchEvent(new Event("loadend"));
  }
  /**
   * Sends the request to the server synchronously.
   *
   * @param body Optional data to send as request body.
   */
  #sendSync(body2) {
    const window2 = this[window];
    const browserFrame = new WindowBrowserContext(window2).getBrowserFrame();
    if (body2) {
      this.#request = new window2.Request(this.#request.url, {
        method: this.#request.method,
        headers: this.#request.headers,
        signal: this.#abortController.signal,
        credentials: this.#request.credentials,
        body: body2
      });
    }
    this.#readyState = XMLHttpRequestReadyStateEnum_default.loading;
    const fetch = new SyncFetch({
      browserFrame,
      window: window2,
      url: this.#request.url,
      init: this.#request
    });
    try {
      this.#response = fetch.send();
    } catch (error2) {
      this.#readyState = XMLHttpRequestReadyStateEnum_default.done;
      this.dispatchEvent(new ErrorEvent("error", { error: error2, message: error2.message }));
      this.dispatchEvent(new Event("loadend"));
      this.dispatchEvent(new Event("readystatechange"));
      return;
    }
    this.#readyState = XMLHttpRequestReadyStateEnum_default.headersRecieved;
    this.#responseBody = XMLHttpRequestResponseDataParser.parse({
      window: window2,
      responseType: this.#responseType,
      data: this.#response.body,
      contentType: this.#response.headers.get("Content-Type") || this.#request.headers.get("Content-Type")
    });
    this.#readyState = XMLHttpRequestReadyStateEnum_default.done;
    this.dispatchEvent(new Event("readystatechange"));
    this.dispatchEvent(new Event("load"));
    this.dispatchEvent(new Event("loadend"));
  }
};

// node_modules/happy-dom/lib/xml-parser/XMLParser.js
var MARKUP_REGEXP2 = /<([^\s/!>?]+)|<\/([^\s/!>?]+)\s*>|(<!--)|(-->)|(<!)|(<\?)|(\/>)|(>)/gm;
var ATTRIBUTE_REGEXP2 = /\s*([a-zA-Z0-9-_:]+)\s*=\s*"([^"]*)("{0,1})|\s*([a-zA-Z0-9-_:]+)\s*=\s*'([^']*)('{0,1})/gm;
var ATTRIBUTE_WITHOUT_VALUE_REGEXP = /^\s*([a-zA-Z0-9-_:]+)$/;
var XML_PROCESSING_INSTRUCTION_VERSION_REGEXP = /version="[^"]+"/;
var DOCUMENT_TYPE_ATTRIBUTE_REGEXP2 = /"([^"]+)"/gm;
var SPACE_REGEXP4 = /\s+/;
var NEW_LINE_REGEXP = /\n/g;
var MarkupReadStateEnum2;
(function(MarkupReadStateEnum3) {
  MarkupReadStateEnum3["any"] = "any";
  MarkupReadStateEnum3["startTag"] = "startTag";
  MarkupReadStateEnum3["comment"] = "comment";
  MarkupReadStateEnum3["documentType"] = "documentType";
  MarkupReadStateEnum3["processingInstruction"] = "processingInstruction";
  MarkupReadStateEnum3["error"] = "error";
})(MarkupReadStateEnum2 || (MarkupReadStateEnum2 = {}));
var NAMESPACE_URIS = Object.values(NamespaceURI_default);
var XMLParser = class {
  window;
  rootNode = null;
  nodeStack = [];
  tagNameStack = [];
  defaultNamespaceStack = null;
  namespacePrefixStack = null;
  startTagIndex = 0;
  markupRegExp = null;
  lastIndex = 0;
  errorIndex = 0;
  nextElement = null;
  nextTagName = null;
  currentNode = null;
  readState = MarkupReadStateEnum2.any;
  errorMessage = null;
  /**
   * Constructor.
   *
   * @param window Window.
   * @param [options] Options.
   * @param [options.mode] Mode. Defaults to "htmlFragment".
   * @param [options.evaluateScripts] Set to "true" to enable script execution
   */
  constructor(window2) {
    this.window = window2;
  }
  /**
   * Parses XML and returns an XML document containing nodes found.
   *
   * @param xml XML string.
   * @returns XML document.
   */
  parse(xml) {
    this.rootNode = new this.window.XMLDocument();
    this.nodeStack = [this.rootNode];
    this.tagNameStack = [null];
    this.currentNode = this.rootNode;
    this.readState = MarkupReadStateEnum2.any;
    this.defaultNamespaceStack = [null];
    this.namespacePrefixStack = [null];
    this.startTagIndex = 0;
    this.errorIndex = 0;
    this.errorMessage = null;
    this.markupRegExp = new RegExp(MARKUP_REGEXP2, "gm");
    this.lastIndex = 0;
    let match;
    this.rootNode[defaultView] = this.window;
    xml = String(xml);
    while (match = this.markupRegExp.exec(xml)) {
      switch (this.readState) {
        case MarkupReadStateEnum2.any:
          if (match.index !== this.lastIndex && (match[1] || match[2] || match[3] || match[4] || match[5] !== void 0 || match[6])) {
            this.parsePlainText(xml.substring(this.lastIndex, match.index));
          }
          if (match[1]) {
            this.parseStartTag(match[1]);
          } else if (match[2]) {
            if (!this.parseEndTag(match[2])) {
              this.errorMessage = `Opening and ending tag mismatch: ${this.tagNameStack[this.tagNameStack.length - 1]} line ${xml.substring(0, this.startTagIndex).split("\n").length} and ${match[2]}
`;
              this.errorIndex = this.markupRegExp.lastIndex;
              this.readState = MarkupReadStateEnum2.error;
              this.removeOverflowingTextNodes();
            }
          } else if (match[3]) {
            this.startTagIndex = this.markupRegExp.lastIndex;
            this.readState = MarkupReadStateEnum2.comment;
          } else if (match[5] !== void 0) {
            this.startTagIndex = this.markupRegExp.lastIndex;
            this.readState = MarkupReadStateEnum2.documentType;
          } else if (match[6]) {
            this.startTagIndex = this.markupRegExp.lastIndex;
            this.readState = MarkupReadStateEnum2.processingInstruction;
          } else {
            this.parsePlainText(xml.substring(this.lastIndex, this.markupRegExp.lastIndex));
          }
          break;
        case MarkupReadStateEnum2.startTag:
          if (match[7] || match[8]) {
            const attributeString = xml.substring(this.startTagIndex, match[2] ? this.markupRegExp.lastIndex - 1 : match.index);
            const isSelfClosed = !!match[7];
            this.parseEndOfStartTag(attributeString, isSelfClosed);
          } else {
            this.errorMessage = match[2] && this.lastIndex !== this.startTagIndex ? `Unescaped '&lt;' not allowed in attributes values
` : "error parsing attribute name\n";
            this.errorIndex = match.index;
            this.readState = MarkupReadStateEnum2.error;
            this.removeOverflowingTextNodes();
          }
          break;
        case MarkupReadStateEnum2.comment:
          if (match[4]) {
            this.parseComment(xml.substring(this.startTagIndex, match.index));
          }
          break;
        case MarkupReadStateEnum2.documentType:
          if (match[7] || match[8]) {
            this.parseDocumentType(xml.substring(this.startTagIndex, match.index));
          }
          break;
        case MarkupReadStateEnum2.processingInstruction:
          if (match[7] || match[8]) {
            this.parseProcessingInstruction(xml.substring(this.startTagIndex, match.index));
          }
          break;
        case MarkupReadStateEnum2.error:
          this.parseError(xml.slice(0, this.errorIndex), this.errorMessage);
          return this.rootNode;
      }
      this.lastIndex = this.markupRegExp.lastIndex;
    }
    if (this.readState === MarkupReadStateEnum2.error) {
      this.parseError(xml.slice(0, this.errorIndex), this.errorMessage);
      return this.rootNode;
    }
    if (this.readState === MarkupReadStateEnum2.comment) {
      this.parseError(xml, "Comment not terminated\n");
      this.removeOverflowingTextNodes();
      return this.rootNode;
    }
    if (this.rootNode[elementArray].length === 0) {
      this.parseError("", `Start tag expected, '&lt;' not found`);
      return this.rootNode;
    }
    if (this.lastIndex !== xml.length && this.currentNode) {
      this.parsePlainText(xml.substring(this.lastIndex));
    }
    if (this.nodeStack.length !== 1) {
      this.parseError(xml, this.nextElement ? "attributes construct error\n" : "Premature end of data in tag article line 1\n");
      return this.rootNode;
    }
    return this.rootNode;
  }
  /**
   * Parses plain text.
   *
   * @param text Text.
   */
  parsePlainText(text) {
    if (this.currentNode === this.rootNode) {
      const xmlText = text.replace(SPACE_REGEXP4, "");
      if (xmlText) {
        this.errorMessage = "Extra content at the end of the document\n";
        this.errorIndex = this.lastIndex;
        this.readState = MarkupReadStateEnum2.error;
      }
    } else if (text.includes("&nbsp;")) {
      this.errorMessage = `Entity 'nbsp' not defined
`;
      this.errorIndex = this.lastIndex + text.indexOf("&nbsp;") + 6;
      this.readState = MarkupReadStateEnum2.error;
    } else {
      this.currentNode[appendChild](this.rootNode.createTextNode(XMLEncodeUtility.decodeXMLEntities(text)), true);
    }
  }
  /**
   * Parses processing instruction.
   *
   * @param text Text.
   */
  parseProcessingInstruction(text) {
    const parts = text.split(SPACE_REGEXP4);
    const endsWithQuestionMark = text[text.length - 1] === "?";
    if (parts[0] === "xml") {
      if (this.currentNode !== this.rootNode || this.rootNode[nodeArray].length !== 0 || parts.length === 1) {
        this.errorMessage = "XML declaration allowed only at the start of the document\n";
        this.errorIndex = this.markupRegExp.lastIndex - text.length + 2;
        this.readState = MarkupReadStateEnum2.error;
        this.removeOverflowingTextNodes();
      } else if (!XML_PROCESSING_INSTRUCTION_VERSION_REGEXP.test(parts[1])) {
        this.errorMessage = "Malformed declaration expecting version\n";
        this.errorIndex = this.markupRegExp.lastIndex - text.length + 3;
        this.readState = MarkupReadStateEnum2.error;
      } else if (!endsWithQuestionMark) {
        this.errorMessage = "Blank needed here\n";
        this.errorIndex = this.markupRegExp.lastIndex - 1;
        this.readState = MarkupReadStateEnum2.error;
      } else {
        const name2 = parts[0];
        const content2 = parts.slice(1).join(" ").slice(0, -1);
        this.rootNode[xmlProcessingInstruction] = this.rootNode.createProcessingInstruction(name2, content2);
        this.readState = MarkupReadStateEnum2.any;
      }
    } else {
      if (parts.length === 1 && !endsWithQuestionMark) {
        this.errorMessage = "ParsePI: PI processing-instruction space expected\n";
        this.errorIndex = this.markupRegExp.lastIndex - 1;
        this.readState = MarkupReadStateEnum2.error;
      } else if (parts.length > 1 && !endsWithQuestionMark) {
        this.errorMessage = "ParsePI: PI processing-instruction never end ...\n";
        this.errorIndex = this.markupRegExp.lastIndex - 1;
        this.readState = MarkupReadStateEnum2.error;
      } else {
        const name2 = parts[0];
        const content2 = parts.slice(1).join(" ").slice(0, -1);
        this.currentNode[appendChild](this.rootNode.createProcessingInstruction(name2, content2), true);
        this.readState = MarkupReadStateEnum2.any;
      }
    }
  }
  /**
   * Parses comment.
   *
   * @param comment Comment.
   */
  parseComment(comment) {
    if (this.currentNode !== this.rootNode) {
      this.currentNode[appendChild](this.rootNode.createComment(XMLEncodeUtility.decodeXMLEntities(comment)), true);
    }
    this.readState = MarkupReadStateEnum2.any;
  }
  /**
   * Parses document type.
   *
   * @param text Text.
   */
  parseDocumentType(text) {
    if (this.currentNode === this.rootNode && this.rootNode[nodeArray].length === 0) {
      const documentType = this.getDocumentType(XMLEncodeUtility.decodeXMLEntities(text));
      if (documentType?.name) {
        this.rootNode[appendChild](this.window.document.implementation.createDocumentType(documentType.name, documentType.publicId, documentType.systemId), true);
        this.readState = MarkupReadStateEnum2.any;
      } else if (documentType) {
        this.errorMessage = "xmlParseDocTypeDecl : no DOCTYPE name\n";
        this.errorIndex = this.markupRegExp.lastIndex - text.length - 2;
        this.readState = MarkupReadStateEnum2.error;
      } else {
        this.errorMessage = "StartTag: invalid element name\n";
        this.errorIndex = this.markupRegExp.lastIndex - text.length - 2;
        this.readState = MarkupReadStateEnum2.error;
      }
    } else if (this.currentNode === this.rootNode && this.rootNode[elementArray].length === 1) {
      this.errorMessage = "Extra content at the end of the document\n";
      this.errorIndex = this.markupRegExp.lastIndex - text.length - 2;
      this.readState = MarkupReadStateEnum2.error;
    } else {
      this.errorMessage = "StartTag: invalid element name\n";
      this.errorIndex = this.markupRegExp.lastIndex - text.length - 2;
      this.readState = MarkupReadStateEnum2.error;
    }
  }
  /**
   * Parses start tag.
   *
   * @param tagName Tag name.
   */
  parseStartTag(tagName2) {
    const parts = tagName2.split(":");
    if (parts.length > 1) {
      this.nextElement = this.rootNode.createElementNS(this.namespacePrefixStack[this.namespacePrefixStack.length - 1]?.get(parts[0]) || null, tagName2);
    } else {
      this.nextElement = this.rootNode.createElementNS(this.defaultNamespaceStack[this.defaultNamespaceStack.length - 1] || null, tagName2);
    }
    this.namespacePrefixStack.push(new Map(this.namespacePrefixStack[this.namespacePrefixStack.length - 1]));
    this.nextTagName = tagName2;
    this.startTagIndex = this.markupRegExp.lastIndex;
    this.readState = MarkupReadStateEnum2.startTag;
  }
  /**
   * Parses end of start tag.
   *
   * @param attributeString Attribute string.
   * @param isSelfClosed Is self closed.
   */
  parseEndOfStartTag(attributeString, isSelfClosed) {
    const namespacePrefix = this.namespacePrefixStack[this.namespacePrefixStack.length - 1];
    if (attributeString) {
      const attributeRegexp = new RegExp(ATTRIBUTE_REGEXP2, "gm");
      let attributeMatch;
      let lastIndex = 0;
      while (attributeMatch = attributeRegexp.exec(attributeString)) {
        const textBetweenAttributes = attributeString.substring(lastIndex, attributeMatch.index).replace(SPACE_REGEXP4, "");
        if (textBetweenAttributes.length) {
          const match = textBetweenAttributes.match(ATTRIBUTE_WITHOUT_VALUE_REGEXP);
          this.errorMessage = match ? `Specification mandates value for attribute ${match[1]}
` : "attributes construct error\n";
          this.errorIndex = this.startTagIndex;
          this.readState = MarkupReadStateEnum2.error;
          this.removeOverflowingTextNodes();
          return;
        }
        if (attributeMatch[1] && attributeMatch[3] === '"' || attributeMatch[4] && attributeMatch[6] === "'") {
          const name2 = attributeMatch[1] ?? attributeMatch[4];
          const rawValue = attributeMatch[2] ?? attributeMatch[5];
          const value2 = rawValue ? XMLEncodeUtility.decodeXMLAttributeValue(rawValue.replace(NEW_LINE_REGEXP, " ")) : "";
          const attributes2 = this.nextElement[attributes];
          const nameParts = name2.split(":");
          if (nameParts.length > 2 || nameParts.length === 2 && (!nameParts[0] || !nameParts[1])) {
            this.errorMessage = `Failed to parse QName '${name2}'
`;
            this.errorIndex = this.startTagIndex + attributeMatch.index + attributeMatch[0].split("=")[0].length;
            this.readState = MarkupReadStateEnum2.error;
            return;
          }
          let namespaceURI2 = null;
          switch (nameParts[0]) {
            case "xmlns":
              namespaceURI2 = NamespaceURI_default.xmlns;
              break;
            case "xlink":
              namespaceURI2 = NamespaceURI_default.xlink;
              break;
          }
          if (!attributes2.getNamedItemNS(namespaceURI2, nameParts[1] ?? name2)) {
            const attribute = NodeFactory.createNode(this.rootNode, this.window.Attr);
            attribute[namespaceURI] = namespaceURI2;
            attribute[name] = name2;
            attribute[localName] = namespaceURI2 && nameParts[1] ? nameParts[1] : name2;
            attribute[prefix] = namespaceURI2 && nameParts[1] ? nameParts[0] : null;
            attribute[value] = value2;
            attributes2[setNamedItem](attribute);
            if (attribute[prefix] === "xmlns") {
              namespacePrefix.set(attribute[localName], value2);
              if (this.nextElement[prefix] === attribute[localName]) {
                this.nextElement[namespaceURI] = value2;
              }
            } else if (name2 === "xmlns" && !this.nextElement[prefix]) {
              if (NAMESPACE_URIS.includes(value2)) {
                this.nextElement = this.rootNode.createElementNS(value2, this.nextElement[tagName]);
                this.nextElement[attributes] = attributes2;
                attributes2[ownerElement] = this.nextElement;
                for (const item of attributes2[items].values()) {
                  item[ownerElement] = this.nextElement;
                }
              } else {
                this.nextElement[namespaceURI] = value2;
              }
            }
          } else {
            this.errorMessage = `Attribute ${name2} redefined
`;
            this.errorIndex = this.startTagIndex;
            this.readState = MarkupReadStateEnum2.error;
          }
          this.startTagIndex += attributeMatch[0].length;
        } else if (attributeMatch[1] && attributeMatch[3] !== '"' || attributeMatch[4] && attributeMatch[6] !== "'") {
          return;
        }
        lastIndex = attributeRegexp.lastIndex;
      }
      const attributeStringEnd = attributeString.substring(lastIndex).replace(SPACE_REGEXP4, "");
      if (attributeStringEnd.length) {
        const match = attributeStringEnd.match(ATTRIBUTE_WITHOUT_VALUE_REGEXP);
        if (match) {
          this.errorMessage = `Specification mandates value for attribute ${match[1]}
`;
          this.errorIndex = this.markupRegExp.lastIndex - 2;
        } else {
          this.errorMessage = "attributes construct error\n";
          this.errorIndex = this.startTagIndex;
        }
        this.readState = MarkupReadStateEnum2.error;
        this.removeOverflowingTextNodes();
        return;
      }
    }
    if (this.nextElement[prefix] && !this.nextElement[namespaceURI]) {
      this.errorMessage = `Namespace prefix ${this.nextElement[prefix]} on name is not defined
`;
      this.errorIndex = this.lastIndex;
      this.readState = MarkupReadStateEnum2.error;
      return;
    }
    if (this.currentNode === this.rootNode && this.rootNode[elementArray].length !== 0) {
      this.errorMessage = "Extra content at the end of the document\n";
      this.errorIndex = this.lastIndex - this.nextElement[tagName].length - 1;
      this.readState = MarkupReadStateEnum2.error;
      return;
    }
    this.currentNode[appendChild](this.nextElement, true);
    if (!isSelfClosed) {
      this.currentNode = this.nextElement;
      this.nodeStack.push(this.currentNode);
      this.tagNameStack.push(this.nextTagName);
      if (this.currentNode[namespaceURI] && !this.currentNode[prefix]) {
        this.defaultNamespaceStack.push(this.currentNode[namespaceURI]);
      } else {
        this.defaultNamespaceStack.push(this.defaultNamespaceStack[this.defaultNamespaceStack.length - 1]);
      }
    }
    this.nextElement = null;
    this.nextTagName = null;
    this.readState = MarkupReadStateEnum2.any;
    this.startTagIndex = this.markupRegExp.lastIndex;
  }
  /**
   * Parses end tag.
   *
   * @param tagName Tag name.
   * @returns True if the end tag was parsed, false otherwise.
   */
  parseEndTag(tagName2) {
    if (this.tagNameStack[this.tagNameStack.length - 1] === tagName2) {
      this.nodeStack.pop();
      this.tagNameStack.pop();
      this.namespacePrefixStack.pop();
      this.defaultNamespaceStack.pop();
      this.currentNode = this.nodeStack[this.nodeStack.length - 1] || this.rootNode;
      return true;
    }
    return false;
  }
  /**
   * Parses XML document error.
   *
   * @param readXML XML that has been read.
   * @param errorMessage Error message.
   */
  parseError(readXML, errorMessage) {
    let errorRoot = this.rootNode.documentElement;
    if (!errorRoot) {
      const documentElement = this.rootNode.createElementNS(NamespaceURI_default.html, "html");
      const body2 = this.rootNode.createElementNS(NamespaceURI_default.html, "body");
      documentElement.appendChild(body2);
      errorRoot = body2;
      this.rootNode[appendChild](documentElement, true);
    }
    const rows2 = readXML.split("\n");
    const column = rows2[rows2.length - 1].length + 1;
    const error2 = `error on line ${rows2.length} at column ${column}: ${errorMessage}`;
    const errorElement = this.rootNode.createElementNS(NamespaceURI_default.html, "parsererror");
    errorElement.setAttribute("style", "display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black");
    errorElement.innerHTML = `<h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">${error2}</div><h3>Below is a rendering of the page up to the first error.</h3>`;
    errorRoot.insertBefore(errorElement, errorRoot.firstChild);
  }
  /**
   * Removes overflowing text nodes in the current node.
   *
   * This needs to be done for some errors.
   */
  removeOverflowingTextNodes() {
    if (this.currentNode && this.currentNode !== this.rootNode) {
      while (this.currentNode.lastChild?.[nodeType] === Node.TEXT_NODE) {
        this.currentNode.removeChild(this.currentNode.lastChild);
      }
    }
  }
  /**
   * Returns document type.
   *
   * @param value Value.
   * @returns Document type.
   */
  getDocumentType(value2) {
    if (!value2.toUpperCase().startsWith("DOCTYPE")) {
      return null;
    }
    const docTypeSplit = value2.split(SPACE_REGEXP4);
    if (docTypeSplit.length <= 1) {
      return null;
    }
    const docTypeString = docTypeSplit.slice(1).join(" ");
    const attributes2 = [];
    const attributeRegExp = new RegExp(DOCUMENT_TYPE_ATTRIBUTE_REGEXP2, "gm");
    const isPublic = docTypeString.toUpperCase().includes("PUBLIC");
    let attributeMatch;
    while (attributeMatch = attributeRegExp.exec(docTypeString)) {
      attributes2.push(attributeMatch[1]);
    }
    const publicId2 = isPublic ? attributes2[0] || "" : "";
    const systemId2 = isPublic ? attributes2[1] || "" : attributes2[0] || "";
    return {
      name: docTypeSplit[1].toLowerCase(),
      publicId: publicId2,
      systemId: systemId2
    };
  }
};

// node_modules/happy-dom/lib/dom-parser/DOMParser.js
var DOMParser = class {
  /**
   * Parses HTML and returns a root element.
   *
   * @param string HTML data.
   * @param mimeType Mime type.
   * @returns Root element.
   */
  parseFromString(string, mimeType) {
    if (!mimeType) {
      throw new this[window].DOMException('Second parameter "mimeType" is mandatory.');
    }
    const window2 = this[window];
    switch (mimeType) {
      case "text/html":
        const newDocument = new window2.HTMLDocument();
        newDocument[defaultView] = window2;
        return new HTMLParser(this[window]).parse(string, newDocument);
      case "image/svg+xml":
      case "text/xml":
      case "application/xml":
      case "application/xhtml+xml":
        return new XMLParser(this[window]).parse(string);
      default:
        throw new window2.DOMException(`Unknown mime type "${mimeType}".`);
    }
  }
};

// node_modules/happy-dom/lib/range/RangeHowEnum.js
var RangeHowEnum;
(function(RangeHowEnum2) {
  RangeHowEnum2[RangeHowEnum2["endToEnd"] = 2] = "endToEnd";
  RangeHowEnum2[RangeHowEnum2["endToStart"] = 3] = "endToStart";
  RangeHowEnum2[RangeHowEnum2["startToEnd"] = 1] = "startToEnd";
  RangeHowEnum2[RangeHowEnum2["startToStart"] = 0] = "startToStart";
})(RangeHowEnum || (RangeHowEnum = {}));
var RangeHowEnum_default = RangeHowEnum;

// node_modules/happy-dom/lib/range/Range.js
var Range = class {
  static END_TO_END = RangeHowEnum_default.endToEnd;
  static END_TO_START = RangeHowEnum_default.endToStart;
  static START_TO_END = RangeHowEnum_default.startToEnd;
  static START_TO_START = RangeHowEnum_default.startToStart;
  END_TO_END = RangeHowEnum_default.endToEnd;
  END_TO_START = RangeHowEnum_default.endToStart;
  START_TO_END = RangeHowEnum_default.startToEnd;
  START_TO_START = RangeHowEnum_default.startToStart;
  [start] = null;
  [end] = null;
  [ownerDocument];
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor() {
    const window2 = this[window];
    if (!window2) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
    this[ownerDocument] = window2.document;
    this[start] = { node: window2.document, offset: 0 };
    this[end] = { node: window2.document, offset: 0 };
  }
  /**
   * Returns start container.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-startcontainer
   * @returns Start container.
   */
  get startContainer() {
    return this[start].node;
  }
  /**
   * Returns end container.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-endcontainer
   * @returns End container.
   */
  get endContainer() {
    return this[end].node;
  }
  /**
   * Returns start offset.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-startoffset
   * @returns Start offset.
   */
  get startOffset() {
    if (this[start].offset > 0) {
      const length2 = NodeUtility.getNodeLength(this[start].node);
      if (this[start].offset > length2) {
        this[start].offset = length2;
      }
    }
    return this[start].offset;
  }
  /**
   * Returns end offset.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-endoffset
   * @returns End offset.
   */
  get endOffset() {
    if (this[end].offset > 0) {
      const length2 = NodeUtility.getNodeLength(this[end].node);
      if (this[end].offset > length2) {
        this[end].offset = length2;
      }
    }
    return this[end].offset;
  }
  /**
   * Returns a boolean value indicating whether the range's start and end points are at the same position.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-collapsed
   * @returns Collapsed.
   */
  get collapsed() {
    return this[start].node === this[end].node && this.startOffset === this.endOffset;
  }
  /**
   * Returns the deepest Node that contains the startContainer and endContainer nodes.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer
   * @returns Node.
   */
  get commonAncestorContainer() {
    let container = this[start].node;
    while (container) {
      if (NodeUtility.isInclusiveAncestor(container, this[end].node)) {
        return container;
      }
      container = container[parentNode];
    }
    return null;
  }
  /**
   * Returns -1, 0, or 1 depending on whether the referenceNode is before, the same as, or after the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-collapse
   * @param toStart A boolean value: true collapses the Range to its start, false to its end. If omitted, it defaults to false.
   */
  collapse(toStart = false) {
    if (toStart) {
      this[end] = Object.assign({}, this[start]);
    } else {
      this[start] = Object.assign({}, this[end]);
    }
  }
  /**
   * Compares the boundary points of the Range with those of another range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-compareboundarypoints
   * @param how How.
   * @param sourceRange Range.
   * @returns A number, -1, 0, or 1, indicating whether the corresponding boundary-point of the Range is respectively before, equal to, or after the corresponding boundary-point of sourceRange.
   */
  compareBoundaryPoints(how, sourceRange) {
    if (how !== RangeHowEnum_default.startToStart && how !== RangeHowEnum_default.startToEnd && how !== RangeHowEnum_default.endToEnd && how !== RangeHowEnum_default.endToStart) {
      throw new this[window].DOMException(`The comparison method provided must be one of '${RangeHowEnum_default.startToStart}', '${RangeHowEnum_default.startToEnd}', '${RangeHowEnum_default.endToEnd}' or '${RangeHowEnum_default.endToStart}'.`, DOMExceptionNameEnum_default.notSupportedError);
    }
    if (this[ownerDocument] !== sourceRange[ownerDocument]) {
      throw new this[window].DOMException(`The two Ranges are not in the same tree.`, DOMExceptionNameEnum_default.wrongDocumentError);
    }
    const thisPoint = {
      node: null,
      offset: 0
    };
    const sourcePoint = {
      node: null,
      offset: 0
    };
    switch (how) {
      case RangeHowEnum_default.startToStart:
        thisPoint.node = this[start].node;
        thisPoint.offset = this.startOffset;
        sourcePoint.node = sourceRange[start].node;
        sourcePoint.offset = sourceRange.startOffset;
        break;
      case RangeHowEnum_default.startToEnd:
        thisPoint.node = this[end].node;
        thisPoint.offset = this.endOffset;
        sourcePoint.node = sourceRange[start].node;
        sourcePoint.offset = sourceRange.startOffset;
        break;
      case RangeHowEnum_default.endToEnd:
        thisPoint.node = this[end].node;
        thisPoint.offset = this.endOffset;
        sourcePoint.node = sourceRange[end].node;
        sourcePoint.offset = sourceRange.endOffset;
        break;
      case RangeHowEnum_default.endToStart:
        thisPoint.node = this[start].node;
        thisPoint.offset = this.startOffset;
        sourcePoint.node = sourceRange[end].node;
        sourcePoint.offset = sourceRange.endOffset;
        break;
    }
    return RangeUtility.compareBoundaryPointsPosition(thisPoint, sourcePoint);
  }
  /**
   * Returns -1, 0, or 1 depending on whether the referenceNode is before, the same as, or after the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-comparepoint
   * @param node Reference node.
   * @param offset Offset.
   * @returns -1,0, or 1.
   */
  comparePoint(node, offset2) {
    if (node[ownerDocument] !== this[ownerDocument]) {
      throw new this[window].DOMException(`The two Ranges are not in the same tree.`, DOMExceptionNameEnum_default.wrongDocumentError);
    }
    RangeUtility.validateBoundaryPoint({ node, offset: offset2 });
    const boundaryPoint = { node, offset: offset2 };
    if (RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[start].node,
      offset: this.startOffset
    }) === -1) {
      return -1;
    } else if (RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[end].node,
      offset: this.endOffset
    }) === 1) {
      return 1;
    }
    return 0;
  }
  /**
   * Returns a DocumentFragment copying the objects of type Node included in the Range.
   *
   * @see https://dom.spec.whatwg.org/#concept-range-clone
   * @returns Document fragment.
   */
  cloneContents() {
    const window2 = this[window];
    const fragment = this[ownerDocument].createDocumentFragment();
    const startOffset2 = this.startOffset;
    const endOffset = this.endOffset;
    if (this.collapsed) {
      return fragment;
    }
    if (this[start].node === this[end].node && (this[start].node[nodeType] === NodeTypeEnum_default.textNode || this[start].node[nodeType] === NodeTypeEnum_default.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum_default.commentNode)) {
      const clone2 = this[start].node.cloneNode(false);
      clone2[data] = clone2.substringData(startOffset2, endOffset - startOffset2);
      fragment.appendChild(clone2);
      return fragment;
    }
    let commonAncestor = this[start].node;
    while (!NodeUtility.isInclusiveAncestor(commonAncestor, this[end].node)) {
      commonAncestor = commonAncestor[parentNode];
    }
    let firstPartialContainedChild = null;
    if (!NodeUtility.isInclusiveAncestor(this[start].node, this[end].node)) {
      let candidate = commonAncestor.firstChild;
      while (!firstPartialContainedChild) {
        if (RangeUtility.isPartiallyContained(candidate, this)) {
          firstPartialContainedChild = candidate;
        }
        candidate = candidate.nextSibling;
      }
    }
    let lastPartiallyContainedChild = null;
    if (!NodeUtility.isInclusiveAncestor(this[end].node, this[start].node)) {
      let candidate = commonAncestor.lastChild;
      while (!lastPartiallyContainedChild) {
        if (RangeUtility.isPartiallyContained(candidate, this)) {
          lastPartiallyContainedChild = candidate;
        }
        candidate = candidate.previousSibling;
      }
    }
    const containedChildren = [];
    for (const node of commonAncestor[nodeArray]) {
      if (RangeUtility.isContained(node, this)) {
        if (node[nodeType] === NodeTypeEnum_default.documentTypeNode) {
          throw new window2.DOMException("Invalid document type element.", DOMExceptionNameEnum_default.hierarchyRequestError);
        }
        containedChildren.push(node);
      }
    }
    if (firstPartialContainedChild !== null && (firstPartialContainedChild[nodeType] === NodeTypeEnum_default.textNode || firstPartialContainedChild[nodeType] === NodeTypeEnum_default.processingInstructionNode || firstPartialContainedChild[nodeType] === NodeTypeEnum_default.commentNode)) {
      const clone2 = this[start].node.cloneNode(false);
      clone2[data] = clone2.substringData(startOffset2, NodeUtility.getNodeLength(this[start].node) - startOffset2);
      fragment.appendChild(clone2);
    } else if (firstPartialContainedChild !== null) {
      const clone2 = firstPartialContainedChild.cloneNode();
      fragment.appendChild(clone2);
      const subRange = new window2.Range();
      subRange[start].node = this[start].node;
      subRange[start].offset = startOffset2;
      subRange[end].node = firstPartialContainedChild;
      subRange[end].offset = NodeUtility.getNodeLength(firstPartialContainedChild);
      const subDocumentFragment = subRange.cloneContents();
      clone2.appendChild(subDocumentFragment);
    }
    for (const containedChild of containedChildren) {
      const clone2 = containedChild.cloneNode(true);
      fragment.appendChild(clone2);
    }
    if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild[nodeType] === NodeTypeEnum_default.textNode || lastPartiallyContainedChild[nodeType] === NodeTypeEnum_default.processingInstructionNode || lastPartiallyContainedChild[nodeType] === NodeTypeEnum_default.commentNode)) {
      const clone2 = this[end].node.cloneNode(false);
      clone2[data] = clone2.substringData(0, endOffset);
      fragment.appendChild(clone2);
    } else if (lastPartiallyContainedChild !== null) {
      const clone2 = lastPartiallyContainedChild.cloneNode(false);
      fragment.appendChild(clone2);
      const subRange = new window2.Range();
      subRange[start].node = lastPartiallyContainedChild;
      subRange[start].offset = 0;
      subRange[end].node = this[end].node;
      subRange[end].offset = endOffset;
      const subFragment = subRange.cloneContents();
      clone2.appendChild(subFragment);
    }
    return fragment;
  }
  /**
   * Returns a Range object with boundary points identical to the cloned Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-clonerange
   * @returns Range.
   */
  cloneRange() {
    const clone2 = new this[window].Range();
    clone2[start].node = this[start].node;
    clone2[start].offset = this[start].offset;
    clone2[end].node = this[end].node;
    clone2[end].offset = this[end].offset;
    return clone2;
  }
  /**
   * Returns a DocumentFragment by invoking the HTML fragment parsing algorithm or the XML fragment parsing algorithm with the start of the range (the parent of the selected node) as the context node. The HTML fragment parsing algorithm is used if the range belongs to a Document whose HTMLness bit is set. In the HTML case, if the context node would be html, for historical reasons the fragment parsing algorithm is invoked with body as the context instead.
   *
   * @see https://w3c.github.io/DOM-Parsing/#dfn-fragment-parsing-algorithm
   * @param tagString Tag string.
   * @returns Document fragment.
   */
  createContextualFragment(tagString) {
    return new HTMLParser(this[window]).parse(tagString);
  }
  /**
   * Removes the contents of the Range from the Document.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-deletecontents
   */
  deleteContents() {
    const startOffset2 = this.startOffset;
    const endOffset = this.endOffset;
    if (this.collapsed) {
      return;
    }
    if (this[start].node === this[end].node && (this[start].node[nodeType] === NodeTypeEnum_default.textNode || this[start].node[nodeType] === NodeTypeEnum_default.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum_default.commentNode)) {
      this[start].node.replaceData(startOffset2, endOffset - startOffset2, "");
      return;
    }
    const nodesToRemove = [];
    let currentNode = this[start].node;
    const endNode = NodeUtility.nextDescendantNode(this[end].node);
    while (currentNode && currentNode !== endNode) {
      if (RangeUtility.isContained(currentNode, this) && !RangeUtility.isContained(currentNode[parentNode], this)) {
        nodesToRemove.push(currentNode);
      }
      currentNode = NodeUtility.following(currentNode);
    }
    let newNode;
    let newOffset;
    if (NodeUtility.isInclusiveAncestor(this[start].node, this[end].node)) {
      newNode = this[start].node;
      newOffset = startOffset2;
    } else {
      let referenceNode = this[start].node;
      while (referenceNode && !NodeUtility.isInclusiveAncestor(referenceNode[parentNode], this[end].node)) {
        referenceNode = referenceNode[parentNode];
      }
      newNode = referenceNode[parentNode];
      newOffset = referenceNode[parentNode][nodeArray].indexOf(referenceNode) + 1;
    }
    if (this[start].node[nodeType] === NodeTypeEnum_default.textNode || this[start].node[nodeType] === NodeTypeEnum_default.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum_default.commentNode) {
      this[start].node.replaceData(this.startOffset, NodeUtility.getNodeLength(this[start].node) - this.startOffset, "");
    }
    for (const node of nodesToRemove) {
      const parent2 = node[parentNode];
      parent2.removeChild(node);
    }
    if (this[end].node[nodeType] === NodeTypeEnum_default.textNode || this[end].node[nodeType] === NodeTypeEnum_default.processingInstructionNode || this[end].node[nodeType] === NodeTypeEnum_default.commentNode) {
      this[end].node.replaceData(0, endOffset, "");
    }
    this[start].node = newNode;
    this[start].offset = newOffset;
    this[end].node = newNode;
    this[end].offset = newOffset;
  }
  /**
   * Does nothing. It used to disable the Range object and enable the browser to release associated resources. The method has been kept for compatibility.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-detach
   */
  detach() {
  }
  /**
   * Moves contents of the Range from the document tree into a DocumentFragment.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-extractcontents
   * @returns Document fragment.
   */
  extractContents() {
    const window2 = this[window];
    const fragment = this[ownerDocument].createDocumentFragment();
    const startOffset2 = this.startOffset;
    const endOffset = this.endOffset;
    if (this.collapsed) {
      return fragment;
    }
    if (this[start].node === this[end].node && (this[start].node[nodeType] === NodeTypeEnum_default.textNode || this[start].node[nodeType] === NodeTypeEnum_default.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum_default.commentNode)) {
      const clone2 = this[start].node.cloneNode(false);
      clone2[data] = clone2.substringData(startOffset2, endOffset - startOffset2);
      fragment.appendChild(clone2);
      this[start].node.replaceData(startOffset2, endOffset - startOffset2, "");
      return fragment;
    }
    let commonAncestor = this[start].node;
    while (!NodeUtility.isInclusiveAncestor(commonAncestor, this[end].node)) {
      commonAncestor = commonAncestor[parentNode];
    }
    let firstPartialContainedChild = null;
    if (!NodeUtility.isInclusiveAncestor(this[start].node, this[end].node)) {
      let candidate = commonAncestor.firstChild;
      while (!firstPartialContainedChild) {
        if (RangeUtility.isPartiallyContained(candidate, this)) {
          firstPartialContainedChild = candidate;
        }
        candidate = candidate.nextSibling;
      }
    }
    let lastPartiallyContainedChild = null;
    if (!NodeUtility.isInclusiveAncestor(this[end].node, this[start].node)) {
      let candidate = commonAncestor.lastChild;
      while (!lastPartiallyContainedChild) {
        if (RangeUtility.isPartiallyContained(candidate, this)) {
          lastPartiallyContainedChild = candidate;
        }
        candidate = candidate.previousSibling;
      }
    }
    const containedChildren = [];
    for (const node of commonAncestor[nodeArray]) {
      if (RangeUtility.isContained(node, this)) {
        if (node[nodeType] === NodeTypeEnum_default.documentTypeNode) {
          throw new this[window].DOMException("Invalid document type element.", DOMExceptionNameEnum_default.hierarchyRequestError);
        }
        containedChildren.push(node);
      }
    }
    let newNode;
    let newOffset;
    if (NodeUtility.isInclusiveAncestor(this[start].node, this[end].node)) {
      newNode = this[start].node;
      newOffset = startOffset2;
    } else {
      let referenceNode = this[start].node;
      while (referenceNode && !NodeUtility.isInclusiveAncestor(referenceNode[parentNode], this[end].node)) {
        referenceNode = referenceNode[parentNode];
      }
      newNode = referenceNode[parentNode];
      newOffset = referenceNode[parentNode][nodeArray].indexOf(referenceNode) + 1;
    }
    if (firstPartialContainedChild !== null && (firstPartialContainedChild[nodeType] === NodeTypeEnum_default.textNode || firstPartialContainedChild[nodeType] === NodeTypeEnum_default.processingInstructionNode || firstPartialContainedChild[nodeType] === NodeTypeEnum_default.commentNode)) {
      const clone2 = this[start].node.cloneNode(false);
      clone2[data] = clone2.substringData(startOffset2, NodeUtility.getNodeLength(this[start].node) - startOffset2);
      fragment.appendChild(clone2);
      this[start].node.replaceData(startOffset2, NodeUtility.getNodeLength(this[start].node) - startOffset2, "");
    } else if (firstPartialContainedChild !== null) {
      const clone2 = firstPartialContainedChild.cloneNode(false);
      fragment.appendChild(clone2);
      const subRange = new window2.Range();
      subRange[start].node = this[start].node;
      subRange[start].offset = startOffset2;
      subRange[end].node = firstPartialContainedChild;
      subRange[end].offset = NodeUtility.getNodeLength(firstPartialContainedChild);
      const subFragment = subRange.extractContents();
      clone2.appendChild(subFragment);
    }
    for (const containedChild of containedChildren) {
      fragment.appendChild(containedChild);
    }
    if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild[nodeType] === NodeTypeEnum_default.textNode || lastPartiallyContainedChild[nodeType] === NodeTypeEnum_default.processingInstructionNode || lastPartiallyContainedChild[nodeType] === NodeTypeEnum_default.commentNode)) {
      const clone2 = this[end].node.cloneNode(false);
      clone2[data] = clone2.substringData(0, endOffset);
      fragment.appendChild(clone2);
      this[end].node.replaceData(0, endOffset, "");
    } else if (lastPartiallyContainedChild !== null) {
      const clone2 = lastPartiallyContainedChild.cloneNode(false);
      fragment.appendChild(clone2);
      const subRange = new window2.Range();
      subRange[start].node = lastPartiallyContainedChild;
      subRange[start].offset = 0;
      subRange[end].node = this[end].node;
      subRange[end].offset = endOffset;
      const subFragment = subRange.extractContents();
      clone2.appendChild(subFragment);
    }
    this[start].node = newNode;
    this[start].offset = newOffset;
    this[end].node = newNode;
    this[end].offset = newOffset;
    return fragment;
  }
  /**
   * Returns a DOMRect object that bounds the contents of the range; this is a rectangle enclosing the union of the bounding rectangles for all the elements in the range.
   *
   * @returns DOMRect object.
   */
  getBoundingClientRect() {
    return new DOMRect();
  }
  /**
   * The Range.getClientRects() method returns a list of DOMRect objects representing the area of the screen occupied by the range. This is created by aggregating the results of calls to Element.getClientRects() for all the elements in the range.
   *
   * @returns DOMRect objects.
   */
  getClientRects() {
    return new DOMRectList(illegalConstructor);
  }
  /**
   * Returns a boolean indicating whether the given point is in the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-ispointinrange
   * @param node Reference node.
   * @param offset Offset.
   * @returns "true" if in range.
   */
  isPointInRange(node, offset2 = 0) {
    if (node[ownerDocument] !== this[ownerDocument]) {
      return false;
    }
    const boundaryPoint = { node, offset: offset2 };
    RangeUtility.validateBoundaryPoint(boundaryPoint);
    if (RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[start].node,
      offset: this.startOffset
    }) === -1 || RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[end].node,
      offset: this.endOffset
    }) === 1) {
      return false;
    }
    return true;
  }
  /**
   * Inserts a node at the start of the Range.
   *
   * @see https://dom.spec.whatwg.org/#concept-range-insert
   * @param newNode New node.
   */
  insertNode(newNode) {
    if (this[start].node[nodeType] === NodeTypeEnum_default.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum_default.commentNode || this[start].node[nodeType] === NodeTypeEnum_default.textNode && !this[start].node[parentNode] || newNode === this[start].node) {
      throw new this[window].DOMException("Invalid start node.", DOMExceptionNameEnum_default.hierarchyRequestError);
    }
    let referenceNode = this[start].node[nodeType] === NodeTypeEnum_default.textNode ? this[start].node : this[start].node[nodeArray][this.startOffset] || null;
    const parent2 = !referenceNode ? this[start].node : referenceNode[parentNode];
    if (this[start].node[nodeType] === NodeTypeEnum_default.textNode) {
      referenceNode = this[start].node.splitText(this.startOffset);
    }
    if (newNode === referenceNode) {
      referenceNode = referenceNode.nextSibling;
    }
    const nodeParent = newNode[parentNode];
    if (nodeParent) {
      nodeParent.removeChild(newNode);
    }
    let newOffset = !referenceNode ? NodeUtility.getNodeLength(parent2) : referenceNode[parentNode][nodeArray].indexOf(referenceNode);
    newOffset += newNode[nodeType] === NodeTypeEnum_default.documentFragmentNode ? NodeUtility.getNodeLength(newNode) : 1;
    parent2.insertBefore(newNode, referenceNode);
    if (this.collapsed) {
      this[end].node = parent2;
      this[end].offset = newOffset;
    }
  }
  /**
   * Returns a boolean indicating whether the given Node intersects the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-intersectsnode
   * @param node Reference node.
   * @returns "true" if it intersects.
   */
  intersectsNode(node) {
    if (node[ownerDocument] !== this[ownerDocument]) {
      return false;
    }
    const parent2 = node[parentNode];
    if (!parent2) {
      return true;
    }
    const offset2 = parent2[nodeArray].indexOf(node);
    return RangeUtility.compareBoundaryPointsPosition({ node: parent2, offset: offset2 }, { node: this[end].node, offset: this.endOffset }) === -1 && RangeUtility.compareBoundaryPointsPosition({ node: parent2, offset: offset2 + 1 }, { node: this[start].node, offset: this.startOffset }) === 1;
  }
  /**
   * Sets the Range to contain the Node and its contents.
   *
   * @see https://dom.spec.whatwg.org/#concept-range-select
   * @param node Reference node.
   */
  selectNode(node) {
    if (!node[parentNode]) {
      throw new this[window].DOMException(`The given Node has no parent.`, DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    const index = node[parentNode][nodeArray].indexOf(node);
    this[start].node = node[parentNode];
    this[start].offset = index;
    this[end].node = node[parentNode];
    this[end].offset = index + 1;
  }
  /**
   * Sets the Range to contain the contents of a Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-selectnodecontents
   * @param node Reference node.
   */
  selectNodeContents(node) {
    if (node[nodeType] === NodeTypeEnum_default.documentTypeNode) {
      throw new this[window].DOMException("DocumentType Node can't be used as boundary point.", DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    this[start].node = node;
    this[start].offset = 0;
    this[end].node = node;
    this[end].offset = NodeUtility.getNodeLength(node);
  }
  /**
   * Sets the end position of a Range to be located at the given offset into the specified node x.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setend
   * @param node End node.
   * @param offset End offset.
   */
  setEnd(node, offset2 = 0) {
    RangeUtility.validateBoundaryPoint({ node, offset: offset2 });
    const boundaryPoint = { node, offset: offset2 };
    if (node[ownerDocument] !== this[ownerDocument] || RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[start].node,
      offset: this.startOffset
    }) === -1) {
      this[start].node = node;
      this[start].offset = offset2;
    }
    this[end].node = node;
    this[end].offset = offset2;
  }
  /**
   * Sets the start position of a Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setstart
   * @param node Start node.
   * @param offset Start offset.
   */
  setStart(node, offset2 = 0) {
    RangeUtility.validateBoundaryPoint({ node, offset: offset2 });
    const boundaryPoint = { node, offset: offset2 };
    if (node[ownerDocument] !== this[ownerDocument] || RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[end].node,
      offset: this.endOffset
    }) === 1) {
      this[end].node = node;
      this[end].offset = offset2;
    }
    this[start].node = node;
    this[start].offset = offset2;
  }
  /**
   * Sets the end position of a Range relative to another Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setendafter
   * @param node Reference node.
   */
  setEndAfter(node) {
    if (!node[parentNode]) {
      throw new this[window].DOMException("The given Node has no parent.", DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    this.setEnd(node[parentNode], node[parentNode][nodeArray].indexOf(node) + 1);
  }
  /**
   * Sets the end position of a Range relative to another Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setendbefore
   * @param node Reference node.
   */
  setEndBefore(node) {
    if (!node[parentNode]) {
      throw new this[window].DOMException("The given Node has no parent.", DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    this.setEnd(node[parentNode], node[parentNode][nodeArray].indexOf(node));
  }
  /**
   * Sets the start position of a Range relative to a Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setstartafter
   * @param node Reference node.
   */
  setStartAfter(node) {
    if (!node[parentNode]) {
      throw new this[window].DOMException("The given Node has no parent.", DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    this.setStart(node[parentNode], node[parentNode][nodeArray].indexOf(node) + 1);
  }
  /**
   * Sets the start position of a Range relative to another Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setstartbefore
   * @param node Reference node.
   */
  setStartBefore(node) {
    if (!node[parentNode]) {
      throw new this[window].DOMException("The given Node has no parent.", DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    this.setStart(node[parentNode], node[parentNode][nodeArray].indexOf(node));
  }
  /**
   * Moves content of the Range into a new node, placing the new node at the start of the specified range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-surroundcontents
   * @param newParent New parent.
   */
  surroundContents(newParent) {
    let node = this.commonAncestorContainer;
    const endNode = NodeUtility.nextDescendantNode(node);
    while (node !== endNode) {
      if (node[nodeType] !== NodeTypeEnum_default.textNode && RangeUtility.isPartiallyContained(node, this)) {
        throw new this[window].DOMException("The Range has partially contains a non-Text node.", DOMExceptionNameEnum_default.invalidStateError);
      }
      node = NodeUtility.following(node);
    }
    if (newParent[nodeType] === NodeTypeEnum_default.documentNode || newParent[nodeType] === NodeTypeEnum_default.documentTypeNode || newParent[nodeType] === NodeTypeEnum_default.documentFragmentNode) {
      throw new this[window].DOMException("Invalid element type.", DOMExceptionNameEnum_default.invalidNodeTypeError);
    }
    const fragment = this.extractContents();
    while (newParent.firstChild) {
      newParent.removeChild(newParent.firstChild);
    }
    this.insertNode(newParent);
    newParent.appendChild(fragment);
    this.selectNode(newParent);
  }
  /**
   * Returns the text of the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-stringifier
   */
  toString() {
    const startOffset2 = this.startOffset;
    const endOffset = this.endOffset;
    let string = "";
    if (this[start].node === this[end].node && this[start].node[nodeType] === NodeTypeEnum_default.textNode) {
      return this[start].node.data.slice(startOffset2, endOffset);
    }
    if (this[start].node[nodeType] === NodeTypeEnum_default.textNode) {
      string += this[start].node.data.slice(startOffset2);
    }
    const endNode = NodeUtility.nextDescendantNode(this[end].node);
    let currentNode = this[start].node;
    while (currentNode && currentNode !== endNode) {
      if (currentNode[nodeType] === NodeTypeEnum_default.textNode && RangeUtility.isContained(currentNode, this)) {
        string += currentNode.data;
      }
      currentNode = NodeUtility.following(currentNode);
    }
    if (this[end].node[nodeType] === NodeTypeEnum_default.textNode) {
      string += this[end].node.data.slice(0, endOffset);
    }
    return string;
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/TextTrackCue.js
var TextTrackCue = class extends EventTarget {
  // Public properties
  id = "";
  startTime = 0;
  endTime = 0;
  pauseOnExit = false;
  // Internal properties
  [track] = null;
  // Events
  onenter = null;
  onexit = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   */
  constructor(illegalConstructorSymbol) {
    super();
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    if (!this[window]) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
  }
  /**
   * Returns the owner track.
   *
   * @returns TextTrack.
   */
  get track() {
    return this[track];
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/VTTCue.js
var VTTCue = class extends TextTrackCue {
  region = null;
  vertical = "";
  snapToLines = true;
  line = 0;
  lineAlign = "";
  position = "auto";
  positionAlign = "auto";
  size = 100;
  align = "";
  text = "";
  /**
   * Constructor.
   *
   * @param startTime The start time for the cue.
   * @param endTime The end time for the cue.
   * @param text The text of the cue.
   */
  constructor(startTime, endTime, text) {
    super(illegalConstructor);
    const window2 = this[window];
    let argumentCount = 0;
    if (startTime !== void 0) {
      argumentCount++;
    }
    if (endTime !== void 0) {
      argumentCount++;
    }
    if (text !== void 0) {
      argumentCount++;
    }
    if (argumentCount < 3) {
      throw new window2.TypeError(`Failed to construct 'VTTCue': 3 arguments required, but only ${argumentCount} present.`);
    }
    startTime = Number(startTime);
    endTime = Number(endTime);
    if (isNaN(startTime) || isNaN(endTime)) {
      throw new window2.TypeError(`Failed to construct 'VTTCue': The provided double value is non-finite.`);
    }
    this.startTime = startTime;
    this.endTime = endTime;
    this.text = String(text);
  }
  /**
   * Returns the cue as HTML.
   *
   * @returns DocumentFragment
   */
  getCueAsHTML() {
    const window2 = this[window];
    const fragment = window2.document.createDocumentFragment();
    fragment.appendChild(window2.document.createTextNode(this.text));
    return fragment;
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/TextTrack.js
var TextTrack = class extends EventTarget {
  // Internal properties
  [kind] = TextTrackKindEnum_default.subtitles;
  [label] = "";
  [language] = "";
  [id] = "";
  [mode] = "disabled";
  [cues] = new TextTrackCueList(illegalConstructor);
  [activeCues] = new TextTrackCueList(illegalConstructor);
  // Events
  oncuechange = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   */
  constructor(illegalConstructorSymbol) {
    super();
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    if (!this[window]) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
  }
  /**
   * Returns the kind of the text track.
   *
   * @returns Kind.
   */
  get kind() {
    return this[kind];
  }
  /**
   * Returns the label of the text track.
   *
   * @returns Label.
   */
  get label() {
    return this[label];
  }
  /**
   * Returns the language of the text track.
   *
   * @returns Language.
   */
  get language() {
    return this[language];
  }
  /**
   * Returns the id of the text track.
   *
   * @returns Id.
   */
  get id() {
    return this[id];
  }
  /**
   * Returns the mode of the text track.
   *
   * @returns Mode.
   */
  get mode() {
    return this[mode];
  }
  /**
   * Sets the mode of the text track.
   *
   * @param mode Mode.
   */
  set mode(mode2) {
    if (mode2 !== "disabled" && mode2 !== "showing") {
      return;
    }
    this[mode] = mode2;
  }
  /**
   * Returns the list of cues in the track list.
   *
   * @returns List of cues.
   */
  get cues() {
    if (this[mode] === "disabled") {
      return null;
    }
    return this[cues];
  }
  /**
   * Returns the list of active cues in the track list.
   *
   * @returns List of active cues.
   */
  get activeCues() {
    if (this[mode] === "disabled") {
      return null;
    }
    return this[activeCues];
  }
  /**
   * Adds a cue to the track list.
   *
   * @param cue Text track cue.
   */
  addCue(cue) {
    if (this[cues].includes(cue)) {
      return;
    }
    cue[track] = this;
    this[cues].push(cue);
  }
  /**
   * Removes a cue from the track list.
   *
   * @param cue Text track cue.
   */
  removeCue(cue) {
    const index = this[cues].indexOf(cue);
    if (index !== -1) {
      cue[track] = null;
      this[cues].splice(index, 1);
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/TextTrackList.js
var TextTrackList = class _TextTrackList extends EventTarget {
  // Internal properties
  [items] = [];
  // Events
  onaddtrack = null;
  onchange = null;
  onremovetrack = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param items Items.
   */
  constructor(illegalConstructorSymbol, items2) {
    super();
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[items] = items2;
    const methodBinder = new ClassMethodBinder(this, [_TextTrackList, EventTarget]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property === "length") {
          return items2.length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return items2[index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys() {
        return Object.keys(items2);
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        return !isNaN(index) && index >= 0 && index < items2.length;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        if (!isNaN(index) && items2[index]) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
  /**
   * Returns the number of TextTrack objects in the TextTrackList.
   *
   * @returns Number of TextTrack objects.
   */
  get length() {
    return this[items].length;
  }
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [Symbol.toStringTag]() {
    return "TextTrackList";
  }
  /**
   * Returns `[object NodeList]`.
   *
   * @returns `[object NodeList]`.
   */
  toLocaleString() {
    return "[object TextTrackList]";
  }
  /**
   * Returns `[object NodeList]`.
   *
   * @returns `[object NodeList]`.
   */
  toString() {
    return "[object TextTrackList]";
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  [Symbol.iterator]() {
    const items2 = this[items];
    return items2[Symbol.iterator]();
  }
  /**
   * Returns the TextTrack found within the TextTrackList whose id matches the specified string. If no match is found, null is returned.
   *
   * @param id Text track cue identifier.
   * @returns TextTrack.
   */
  getTrackById(id2) {
    for (const cue of this[items]) {
      if (cue.id === id2) {
        return cue;
      }
    }
    return null;
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/RemotePlayback.js
var RemotePlayback = class extends EventTarget {
  // Internal properties
  [state] = "disconnected";
  // Events
  onconnecting = null;
  onconnect = null;
  ondisconnect = null;
  /**
   * Returns the state of the remote playback.
   */
  get state() {
    return this[state];
  }
  /**
   * Watches the list of available remote playback devices and returns a Promise that resolves with a callbackId of an available remote playback device.
   *
   * @returns Promise.
   */
  async watchAvailability() {
  }
  /**
   * Cancels the request to monitor the availability of remote playback devices.
   */
  cancelWatchAvailability() {
  }
  /**
   * Prompts the user to select and give permission to connect to a remote playback device.
   */
  prompt() {
  }
};

// node_modules/happy-dom/lib/file/FileReader.js
var import_whatwg_mimetype = __toESM(require_mime_type(), 1);

// node_modules/happy-dom/lib/file/FileReaderReadyStateEnum.js
var FileReaderReadyStateEnum;
(function(FileReaderReadyStateEnum2) {
  FileReaderReadyStateEnum2[FileReaderReadyStateEnum2["empty"] = 0] = "empty";
  FileReaderReadyStateEnum2[FileReaderReadyStateEnum2["loading"] = 1] = "loading";
  FileReaderReadyStateEnum2[FileReaderReadyStateEnum2["done"] = 2] = "done";
})(FileReaderReadyStateEnum || (FileReaderReadyStateEnum = {}));
var FileReaderReadyStateEnum_default = FileReaderReadyStateEnum;

// node_modules/happy-dom/lib/file/FileReaderFormatEnum.js
var FileReaderFormatEnum;
(function(FileReaderFormatEnum2) {
  FileReaderFormatEnum2["buffer"] = "buffer";
  FileReaderFormatEnum2["binaryString"] = "binaryString";
  FileReaderFormatEnum2["dataURL"] = "dataURL";
  FileReaderFormatEnum2["text"] = "text";
})(FileReaderFormatEnum || (FileReaderFormatEnum = {}));
var FileReaderFormatEnum_default = FileReaderFormatEnum;

// node_modules/happy-dom/lib/file/FileReaderEventTypeEnum.js
var FileReaderEventTypeEnum;
(function(FileReaderEventTypeEnum2) {
  FileReaderEventTypeEnum2["abort"] = "abort";
  FileReaderEventTypeEnum2["error"] = "error";
  FileReaderEventTypeEnum2["load"] = "load";
  FileReaderEventTypeEnum2["loadstart"] = "loadstart";
  FileReaderEventTypeEnum2["loadend"] = "loadend";
  FileReaderEventTypeEnum2["progress"] = "progress";
})(FileReaderEventTypeEnum || (FileReaderEventTypeEnum = {}));
var FileReaderEventTypeEnum_default = FileReaderEventTypeEnum;

// node_modules/happy-dom/lib/file/FileReader.js
import { Buffer as Buffer7 } from "buffer";
var FileReader = class extends EventTarget {
  error = null;
  result = null;
  readyState = FileReaderReadyStateEnum_default.empty;
  onabort = null;
  onerror = null;
  onload = null;
  onloadstart = null;
  onloadend = null;
  onprogress = null;
  #isTerminated = false;
  #loadTimeout = null;
  #parseTimeout = null;
  /**
   * Constructor.
   */
  constructor() {
    super();
    if (!this[window]) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
  }
  /**
   * Reads as ArrayBuffer.
   *
   * @param blob Blob.
   */
  readAsArrayBuffer(blob) {
    if (!(blob instanceof Blob)) {
      throw new this[window].TypeError(`Failed to execute 'readAsArrayBuffer' on 'FileReader': parameter 1 is not of type 'Blob'.`);
    }
    this.#readFile(blob, FileReaderFormatEnum_default.buffer);
  }
  /**
   * Reads as binary string.
   *
   * @param blob Blob.
   */
  readAsBinaryString(blob) {
    if (!(blob instanceof Blob)) {
      throw new this[window].TypeError(`Failed to execute 'readAsBinaryString' on 'FileReader': parameter 1 is not of type 'Blob'.`);
    }
    this.#readFile(blob, FileReaderFormatEnum_default.binaryString);
  }
  /**
   * Reads as data URL.
   *
   * @param blob Blob.
   */
  readAsDataURL(blob) {
    if (!(blob instanceof Blob)) {
      throw new this[window].TypeError(`Failed to execute 'readAsDataURL' on 'FileReader': parameter 1 is not of type 'Blob'.`);
    }
    this.#readFile(blob, FileReaderFormatEnum_default.dataURL);
  }
  /**
   * Reads as text.
   *
   * @param blob Blob.
   * @param [encoding] Encoding.
   */
  readAsText(blob, encoding = null) {
    if (!(blob instanceof Blob)) {
      throw new this[window].TypeError(`Failed to execute 'readAsText' on 'FileReader': parameter 1 is not of type 'Blob'.`);
    }
    this.#readFile(blob, FileReaderFormatEnum_default.text, encoding || "UTF-8");
  }
  /**
   * Aborts the file reader.
   */
  abort() {
    const window2 = this[window];
    window2.clearTimeout(this.#loadTimeout);
    window2.clearTimeout(this.#parseTimeout);
    if (this.readyState === FileReaderReadyStateEnum_default.empty || this.readyState === FileReaderReadyStateEnum_default.done) {
      this.result = null;
      return;
    }
    if (this.readyState === FileReaderReadyStateEnum_default.loading) {
      this.readyState = FileReaderReadyStateEnum_default.done;
      this.result = null;
    }
    this.#isTerminated = true;
    this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum_default.abort));
    this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum_default.loadend));
  }
  /**
   * Reads a file.
   *
   * @param blob Blob.
   * @param format Format.
   * @param [encoding] Encoding.
   */
  #readFile(blob, format, encoding = null) {
    const window2 = this[window];
    if (this.readyState === FileReaderReadyStateEnum_default.loading) {
      throw new window2.DOMException("The object is in an invalid state.", DOMExceptionNameEnum_default.invalidStateError);
    }
    this.readyState = FileReaderReadyStateEnum_default.loading;
    this.#loadTimeout = window2.setTimeout(() => {
      if (this.#isTerminated) {
        this.#isTerminated = false;
        return;
      }
      this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum_default.loadstart));
      let data2 = blob[buffer];
      if (!data2) {
        data2 = Buffer7.alloc(0);
      }
      this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum_default.loadstart, {
        lengthComputable: !isNaN(blob.size),
        total: blob.size,
        loaded: data2.length
      }));
      this.#parseTimeout = window2.setTimeout(() => {
        if (this.#isTerminated) {
          this.#isTerminated = false;
          return;
        }
        switch (format) {
          default:
          case FileReaderFormatEnum_default.buffer: {
            this.result = new Uint8Array(data2).buffer;
            break;
          }
          case FileReaderFormatEnum_default.binaryString: {
            this.result = data2.toString("binary");
            break;
          }
          case FileReaderFormatEnum_default.dataURL: {
            const contentType2 = import_whatwg_mimetype.default.parse(blob.type) || "application/octet-stream";
            this.result = `data:${contentType2};base64,${data2.toString("base64")}`;
            break;
          }
          case FileReaderFormatEnum_default.text: {
            this.result = new TextDecoder(encoding || "UTF-8").decode(data2);
            break;
          }
        }
        this.readyState = FileReaderReadyStateEnum_default.done;
        this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum_default.load));
        this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum_default.loadend));
      });
    });
  }
};

// node_modules/happy-dom/lib/nodes/html-media-element/MediaStreamTrack.js
import Crypto2 from "crypto";
var CAPABILITIES = {
  aspectRatio: {
    max: 300,
    min: 0.006666666666666667
  },
  deviceId: "",
  facingMode: [],
  frameRate: {
    max: 60,
    min: 0
  },
  height: {
    max: 150,
    min: 1
  },
  resizeMode: ["none", "crop-and-scale"],
  width: {
    max: 300,
    min: 1
  }
};
var SETTINGS = {
  deviceId: "",
  frameRate: 60,
  resizeMode: "none"
};
var MediaStreamTrack = class extends EventTarget {
  contentHint = "";
  enabled = true;
  id = Crypto2.randomUUID();
  muted = false;
  readyState = "live";
  label = "";
  [label] = "";
  [kind] = "video";
  [constraints] = {};
  [capabilities] = JSON.parse(JSON.stringify(CAPABILITIES));
  [settings] = JSON.parse(JSON.stringify(SETTINGS));
  // Events
  onended = null;
  onmute = null;
  onunmute = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   */
  constructor(illegalConstructorSymbol) {
    super();
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    if (!this[window]) {
      throw new TypeError(`Failed to construct '${this.constructor.name}': '${this.constructor.name}' was constructed outside a Window context.`);
    }
  }
  /**
   * Returns the kind of the track.
   *
   * @returns Kind.
   */
  get kind() {
    return this[kind];
  }
  /**
   * Applies constraints.
   *
   * @param _constraints Constraints.
   * @param constraints
   */
  async applyConstraints(constraints2) {
    this.#mergeObjects(this[constraints], constraints2);
  }
  /**
   * Returns constraints.
   *
   * @returns Constraints.
   */
  getConstraints() {
    return this[constraints];
  }
  /**
   * Returns capabilities.
   *
   * @returns Capabilities.
   */
  getCapabilities() {
    return this[capabilities];
  }
  /**
   * Returns settings.
   *
   * @returns Settings.
   */
  getSettings() {
    return this[settings];
  }
  /**
   * Clones the track.
   *
   * @returns Clone.
   */
  clone() {
    const clone2 = new this.constructor(illegalConstructor);
    clone2[kind] = this[kind];
    clone2[constraints] = this[constraints];
    clone2[capabilities] = this[capabilities];
    clone2[settings] = this[settings];
    clone2.contentHint = this.contentHint;
    clone2.enabled = this.enabled;
    clone2.label = this.label;
    clone2.muted = this.muted;
    clone2.readyState = this.readyState;
    return clone2;
  }
  /**
   * Stops the track.
   */
  stop() {
    this.readyState = "ended";
  }
  /**
   * Merges two objects.
   *
   * @param source Target.
   * @param target Source.
   */
  #mergeObjects(source, target2) {
    for (const key in target2) {
      if (target2[key] !== null && typeof target2[key] === "object" && !Array.isArray(target2[key])) {
        if (typeof source[key] !== "object") {
          source[key] = {};
        }
        this.#mergeObjects(source[key], target2[key]);
      } else {
        source[key] = target2[key];
      }
    }
  }
};

// node_modules/happy-dom/lib/nodes/html-canvas-element/CanvasCaptureMediaStreamTrack.js
var CanvasCaptureMediaStreamTrack = class extends MediaStreamTrack {
  [canvas];
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param canvas Canvas.
   */
  constructor(illegalConstructorSymbol, canvas2) {
    super(illegalConstructorSymbol);
    this[canvas] = canvas2;
  }
  /**
   * Returns the canvas.
   *
   * @returns Canvas.
   */
  get canvas() {
    return this[canvas];
  }
  /**
   * Requests a frame.
   */
  requestFrame() {
  }
  /**
   * Clones the track.
   *
   * @returns Clone.
   */
  clone() {
    const clone2 = super.clone();
    clone2[canvas] = this.canvas;
    return clone2;
  }
};

// node_modules/happy-dom/lib/window/WindowContextClassExtender.js
var WindowContextClassExtender = class {
  /**
   * Extends classes with a "window" property.
   *
   * @param window Window.
   */
  static extendClasses(window2) {
    class Document2 extends Document {
    }
    Document2.prototype[window] = window2;
    window2.Document = Document2;
    class HTMLDocument2 extends HTMLDocument {
    }
    HTMLDocument2.prototype[window] = window2;
    window2.HTMLDocument = HTMLDocument2;
    class XMLDocument2 extends XMLDocument {
    }
    XMLDocument2.prototype[window] = window2;
    window2.XMLDocument = XMLDocument2;
    class DocumentFragment2 extends DocumentFragment {
    }
    DocumentFragment2.prototype[window] = window2;
    window2.DocumentFragment = DocumentFragment2;
    class Text2 extends Text {
    }
    Text2.prototype[window] = window2;
    window2.Text = Text2;
    class Comment2 extends Comment {
    }
    Comment2.prototype[window] = window2;
    window2.Comment = Comment2;
    class Image2 extends Image {
    }
    Image2.prototype[window] = window2;
    window2.Image = Image2;
    class Audio2 extends Audio {
    }
    Audio2.prototype[window] = window2;
    window2.Audio = Audio2;
    class NodeIterator2 extends NodeIterator {
    }
    NodeIterator2.prototype[window] = window2;
    window2.NodeIterator = NodeIterator2;
    class TreeWalker2 extends TreeWalker {
    }
    TreeWalker2.prototype[window] = window2;
    window2.TreeWalker = TreeWalker2;
    class MutationObserver2 extends MutationObserver {
    }
    MutationObserver2.prototype[window] = window2;
    window2.MutationObserver = MutationObserver2;
    class MessagePort2 extends MessagePort {
    }
    MessagePort2.prototype[window] = window2;
    window2.MessagePort = MessagePort2;
    class DataTransfer2 extends DataTransfer {
    }
    DataTransfer2.prototype[window] = window2;
    window2.DataTransfer = DataTransfer2;
    class DataTransferItem2 extends DataTransferItem {
    }
    DataTransferItem2.prototype[window] = window2;
    window2.DataTransferItem = DataTransferItem2;
    class DataTransferItemList2 extends DataTransferItemList {
    }
    DataTransferItemList2.prototype[window] = window2;
    window2.DataTransferItemList = DataTransferItemList2;
    class XMLSerializer2 extends XMLSerializer {
    }
    XMLSerializer2.prototype[window] = window2;
    window2.XMLSerializer = XMLSerializer2;
    class CSSStyleSheet2 extends CSSStyleSheet {
    }
    CSSStyleSheet2.prototype[window] = window2;
    window2.CSSStyleSheet = CSSStyleSheet2;
    class DOMException2 extends DOMException {
    }
    window2.DOMException = DOMException2;
    class CSSUnitValue2 extends CSSUnitValue {
    }
    CSSUnitValue2.prototype[window] = window2;
    window2.CSSUnitValue = CSSUnitValue2;
    class Selection2 extends Selection {
    }
    Selection2.prototype[window] = window2;
    window2.Selection = Selection2;
    class Headers2 extends Headers {
    }
    Headers2.prototype[window] = window2;
    window2.Headers = Headers2;
    class Request2 extends Request {
    }
    Request2.prototype[window] = window2;
    window2.Request = Request2;
    class Response2 extends Response {
    }
    Response2.prototype[window] = window2;
    Response2[window] = window2;
    window2.Response = Response2;
    class EventTarget2 extends EventTarget {
    }
    EventTarget2.prototype[window] = window2;
    window2.EventTarget = EventTarget2;
    class XMLHttpRequestUpload2 extends XMLHttpRequestUpload {
    }
    XMLHttpRequestUpload2.prototype[window] = window2;
    window2.XMLHttpRequestUpload = XMLHttpRequestUpload2;
    class XMLHttpRequestEventTarget2 extends XMLHttpRequestEventTarget {
    }
    XMLHttpRequestEventTarget2.prototype[window] = window2;
    window2.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget2;
    class AbortController2 extends AbortController {
    }
    AbortController2.prototype[window] = window2;
    window2.AbortController = AbortController2;
    class AbortSignal2 extends AbortSignal {
    }
    AbortSignal2.prototype[window] = window2;
    AbortSignal2[window] = window2;
    window2.AbortSignal = AbortSignal2;
    class FormData2 extends FormData {
    }
    FormData2.prototype[window] = window2;
    window2.FormData = FormData2;
    class Permissions2 extends Permissions {
    }
    Permissions2.prototype[window] = window2;
    window2.Permissions = Permissions2;
    class PermissionStatus2 extends PermissionStatus {
    }
    PermissionStatus2.prototype[window] = window2;
    window2.PermissionStatus = PermissionStatus2;
    class ClipboardItem2 extends ClipboardItem {
    }
    ClipboardItem2.prototype[window] = window2;
    window2.ClipboardItem = ClipboardItem2;
    class XMLHttpRequest2 extends XMLHttpRequest {
    }
    XMLHttpRequest2.prototype[window] = window2;
    window2.XMLHttpRequest = XMLHttpRequest2;
    class DOMParser2 extends DOMParser {
    }
    DOMParser2.prototype[window] = window2;
    window2.DOMParser = DOMParser2;
    class Range2 extends Range {
    }
    Range2.prototype[window] = window2;
    window2.Range = Range2;
    class VTTCue2 extends VTTCue {
    }
    VTTCue2.prototype[window] = window2;
    window2.VTTCue = VTTCue2;
    class TextTrack2 extends TextTrack {
    }
    TextTrack2.prototype[window] = window2;
    window2.TextTrack = TextTrack2;
    class TextTrackList2 extends TextTrackList {
    }
    TextTrackList2.prototype[window] = window2;
    window2.TextTrackList = TextTrackList2;
    class TextTrackCue2 extends TextTrackCue {
    }
    TextTrackCue2.prototype[window] = window2;
    window2.TextTrackCue = TextTrackCue2;
    class RemotePlayback2 extends RemotePlayback {
    }
    RemotePlayback2.prototype[window] = window2;
    window2.RemotePlayback = RemotePlayback2;
    class FileReader2 extends FileReader {
    }
    FileReader2.prototype[window] = window2;
    window2.FileReader = FileReader2;
    class MediaStream2 extends MediaStream {
    }
    MediaStream2.prototype[window] = window2;
    window2.MediaStream = MediaStream2;
    class MediaStreamTrack2 extends MediaStreamTrack {
    }
    MediaStreamTrack2.prototype[window] = window2;
    window2.MediaStreamTrack = MediaStreamTrack2;
    class CanvasCaptureMediaStreamTrack2 extends CanvasCaptureMediaStreamTrack {
    }
    CanvasCaptureMediaStreamTrack2.prototype[window] = window2;
    window2.CanvasCaptureMediaStreamTrack = CanvasCaptureMediaStreamTrack2;
    class NamedNodeMap2 extends NamedNodeMap {
    }
    NamedNodeMap2.prototype[window] = window2;
    window2.NamedNodeMap = NamedNodeMap2;
  }
};

// node_modules/happy-dom/lib/dom/DOMPointReadOnly.js
var DOMPointReadOnly = class {
  [x] = 0;
  [y] = 0;
  [z] = 0;
  [w] = 1;
  /**
   * Constructor.
   *
   * @param [x] X position.
   * @param [y] Y position.
   * @param [z] Width.
   * @param [w] Height.
   */
  constructor(x3, y3, z2, w2) {
    this[x] = x3 !== void 0 && x3 !== null ? Number(x3) : 0;
    this[y] = y3 !== void 0 && y3 !== null ? Number(y3) : 0;
    this[z] = z2 !== void 0 && z2 !== null ? Number(z2) : 0;
    this[w] = w2 !== void 0 && w2 !== null ? Number(w2) : 1;
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    return this[y];
  }
  /**
   * Returns z.
   *
   * @returns Z.
   */
  get z() {
    return this[z];
  }
  /**
   * Returns w.
   *
   * @returns W.
   */
  get w() {
    return this[w];
  }
  /**
   * Returns the JSON representation of the object.
   *
   * @returns JSON representation.
   */
  toJSON() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
  /**
   * Returns a new DOMPointReadOnly object.
   *
   * @param [otherPoint] Other point.
   * @returns Cloned object.
   */
  static fromPoint(otherPoint) {
    if (!otherPoint) {
      return new this();
    }
    return new this(otherPoint.x ?? null, otherPoint.y ?? null, otherPoint.z ?? null, otherPoint.w ?? null);
  }
};

// node_modules/happy-dom/lib/dom/DOMPoint.js
var DOMPoint = class extends DOMPointReadOnly {
  /**
   * Sets x.
   *
   * @param value X.
   */
  set x(value2) {
    this[x] = value2;
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    return this[x];
  }
  /**
   * Sets y.
   *
   * @param value Y.
   */
  set y(value2) {
    this[y] = value2;
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    return this[y];
  }
  /**
   * Sets z.
   *
   * @param value Z.
   */
  set z(value2) {
    this[z] = value2;
  }
  /**
   * Returns z.
   *
   * @returns Z.
   */
  get z() {
    return this[z];
  }
  /**
   * Sets w.
   *
   * @param value W.
   */
  set w(value2) {
    this[w] = value2;
  }
  /**
   * Returns w.
   *
   * @returns W.
   */
  get w() {
    return this[w];
  }
};

// node_modules/happy-dom/lib/dom/dom-matrix/DOMMatrixReadOnly.js
var DEFAULT_MATRIX_JSON = {
  a: 1,
  b: 0,
  c: 0,
  d: 1,
  e: 0,
  f: 0,
  m11: 1,
  m12: 0,
  m13: 0,
  m14: 0,
  m21: 0,
  m22: 1,
  m23: 0,
  m24: 0,
  m31: 0,
  m32: 0,
  m33: 1,
  m34: 0,
  m41: 0,
  m42: 0,
  m43: 0,
  m44: 1,
  is2D: true,
  isIdentity: true
};
var TRANSFORM_REGEXP = /([a-zA-Z0-9]+)\(([^)]+)\)/gm;
var TRANSFORM_PARAMETER_SPLIT_REGEXP = /[\s,]+/;
var DOMMatrixReadOnly = class _DOMMatrixReadOnly {
  [m11] = 1;
  [m12] = 0;
  [m13] = 0;
  [m14] = 0;
  [m21] = 0;
  [m22] = 1;
  [m23] = 0;
  [m24] = 0;
  [m31] = 0;
  [m32] = 0;
  [m33] = 1;
  [m34] = 0;
  [m41] = 0;
  [m42] = 0;
  [m43] = 0;
  [m44] = 1;
  /**
   * Constructor.
   *
   * @param init Init parameter.
   */
  constructor(init) {
    if (init) {
      this[setMatrixValue](init);
    }
  }
  /**
   * Returns the `a` value of the matrix.
   */
  get a() {
    return this[m11];
  }
  /**
   * Returns the `b` value of the matrix.
   */
  get b() {
    return this[m12];
  }
  /**
   * Returns the `c` value of the matrix.
   */
  get c() {
    return this[m21];
  }
  /**
   * Returns the `d` value of the matrix.
   */
  get d() {
    return this[m22];
  }
  /**
   * Returns the `e` value of the matrix.
   */
  get e() {
    return this[m41];
  }
  /**
   * Returns the `f` value of the matrix.
   */
  get f() {
    return this[m42];
  }
  /**
   * Returns the `m11` value of the matrix.
   */
  get m11() {
    return this[m11];
  }
  /**
   * Returns the `m12` value of the matrix.
   */
  get m12() {
    return this[m12];
  }
  /**
   * Returns the `m13` value of the matrix.
   */
  get m13() {
    return this[m13];
  }
  /**
   * Returns the `m14` value of the matrix.
   */
  get m14() {
    return this[m14];
  }
  /**
   * Returns the `m21` value of the matrix.
   */
  get m21() {
    return this[m21];
  }
  /**
   * Returns the `m22` value of the matrix.
   */
  get m22() {
    return this[m22];
  }
  /**
   * Returns the `m23` value of the matrix.
   */
  get m23() {
    return this[m23];
  }
  /**
   * Returns the `m24` value of the matrix.
   */
  get m24() {
    return this[m24];
  }
  /**
   * Returns the `m31` value of the matrix.
   */
  get m31() {
    return this[m31];
  }
  /**
   * Returns the `m32` value of the matrix.
   */
  get m32() {
    return this[m32];
  }
  /**
   * Returns the `m33` value of the matrix.
   */
  get m33() {
    return this[m33];
  }
  /**
   * Returns the `m34` value of the matrix.
   */
  get m34() {
    return this[m34];
  }
  /**
   * Returns the `m41` value of the matrix.
   */
  get m41() {
    return this[m41];
  }
  /**
   * Returns the `m42` value of the matrix.
   */
  get m42() {
    return this[m42];
  }
  /**
   * Returns the `m43` value of the matrix.
   */
  get m43() {
    return this[m43];
  }
  /**
   * Returns the `m44` value of the matrix.
   */
  get m44() {
    return this[m44];
  }
  /**
   * A `Boolean` whose value is `true` if the matrix is the identity matrix.
   *
   * The identity matrix is one in which every value is 0 except those on the main diagonal from top-left to bottom-right corner (in other words, where the offsets in each direction are equal).
   *
   * @returns "true" if the matrix is the identity matrix.
   */
  get isIdentity() {
    return this[m11] === 1 && this[m12] === 0 && this[m13] === 0 && this[m14] === 0 && this[m21] === 0 && this[m22] === 1 && this[m23] === 0 && this[m24] === 0 && this[m31] === 0 && this[m32] === 0 && this[m33] === 1 && this[m34] === 0 && this[m41] === 0 && this[m42] === 0 && this[m43] === 0 && this[m44] === 1;
  }
  /**
   * A `Boolean` flag whose value is `true` if the matrix is a 2D matrix and `false` if the matrix is 3D.
   *
   * @returns "true" if the matrix is a 2D matrix.
   */
  get is2D() {
    return this[m31] === 0 && this[m32] === 0 && this[m33] === 1 && this[m34] === 0 && this[m43] === 0 && this[m44] === 1;
  }
  /**
   * Returns a *Float32Array* containing elements which comprise the matrix.
   *
   * The method can return either the 16 elements or the 6 elements depending on the value of the `is2D` parameter.
   *
   * @param [is2D] Set to `true` to return a 2D matrix.
   * @returns An *Array* representation of the matrix.
   */
  toFloat32Array(is2D) {
    return Float32Array.from(this[toArray](is2D));
  }
  /**
   * Returns a *Float64Array* containing elements which comprise the matrix.
   *
   * The method can return either the 16 elements or the 6 elements depending on the value of the `is2D` parameter.
   *
   * @param [is2D] Set to `true` to return a 2D matrix.
   * @returns An *Array* representation of the matrix
   */
  toFloat64Array(is2D) {
    return Float64Array.from(this[toArray](is2D));
  }
  /**
   * Returns a string representation of the matrix in `CSS` matrix syntax, using the appropriate `CSS` matrix notation.
   *
   * Examples:
   * - `matrix3d(m11, m12, m13, m14, m21, ...)`
   * - `matrix(a, b, c, d, e, f)`
   *
   * @returns A string representation of the matrix.
   */
  toString() {
    const is2D = this.is2D;
    const values2 = this[toArray](is2D).join(", ");
    const type2 = is2D ? "matrix" : "matrix3d";
    return `${type2}(${values2})`;
  }
  /**
   * Returns an Object that can be serialized to a JSON string.
   *
   * The result can be used as a second parameter for the `fromMatrix` static method to load values into another matrix instance.
   *
   * @returns An *Object* with matrix values.
   */
  toJSON() {
    const { is2D, isIdentity } = this;
    return {
      m11: this[m11],
      m12: this[m12],
      m13: this[m13],
      m14: this[m14],
      m21: this[m21],
      m22: this[m22],
      m23: this[m23],
      m24: this[m24],
      m31: this[m31],
      m32: this[m32],
      m33: this[m33],
      m34: this[m34],
      m41: this[m41],
      m42: this[m42],
      m43: this[m43],
      m44: this[m44],
      a: this[m11],
      b: this[m12],
      c: this[m21],
      d: this[m22],
      e: this[m41],
      f: this[m42],
      is2D,
      isIdentity
    };
  }
  /**
   * Returns a new DOMMatrix instance which is the result of this matrix multiplied by the passed matrix.
   *
   * @param secondMatrix DOMMatrix
   * @returns A new DOMMatrix object.
   */
  multiply(secondMatrix) {
    const matrix2 = new this.constructor(this);
    matrix2[multiplySelf](secondMatrix);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix post multiplied by a translation matrix containing the passed values.
   *
   * @param [x=0] X component of the translation value.
   * @param [y=0] Y component of the translation value.
   * @param [z=0] Z component of the translation value.
   * @returns The resulted matrix
   */
  translate(x3 = 0, y3 = 0, z2 = 0) {
    const matrix2 = new this.constructor(this);
    matrix2[translateSelf](x3, y3, z2);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix post multiplied by a scale 2D matrix containing the passed values.
   *
   * @param [scaleX] X-Axis scale.
   * @param [scaleY] Y-Axis scale.
   * @param [scaleZ] Z-Axis scale.
   * @param [originX] X-Axis scale.
   * @param [originY] Y-Axis scale.
   * @param [originZ] Z-Axis scale.
   * @returns The resulted matrix
   */
  scale(scaleX, scaleY, scaleZ = 1, originX = 0, originY = 0, originZ = 0) {
    const matrix2 = new this.constructor(this);
    matrix2[scaleSelf](scaleX, scaleY, scaleZ, originX, originY, originZ);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix post multiplied by a scale 3D matrix containing the passed values.
   *
   * @param [scale] The scale factor.
   * @param [originX] X-Axis scale.
   * @param [originY] Y-Axis scale.
   * @param [originZ] Z-Axis scale.
   * @returns The resulted matrix
   */
  scale3d(scale2 = 1, originX = 0, originY = 0, originZ = 0) {
    const matrix2 = new this.constructor(this);
    matrix2[scale3dSelf](scale2, originX, originY, originZ);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix post multiplied by a scale 3D matrix containing the passed values.
   *
   * @param [scaleX] X-Axis scale.
   * @param [scaleY] Y-Axis scale.
   * @returns The resulted matrix
   */
  scaleNonUniform(scaleX = 1, scaleY = 1) {
    const matrix2 = new this.constructor(this);
    matrix2[scaleNonUniformSelf](scaleX, scaleY);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix post multiplied by a rotation matrix with the given axis and `angle`.
   *
   * @param [x] The X component of the axis vector.
   * @param [y] The Y component of the axis vector.
   * @param [z] The Z component of the axis vector.
   * @param [angle] Angle of rotation about the axis vector, in degrees.
   * @returns The resulted matrix
   */
  rotateAxisAngle(x3 = 0, y3 = 0, z2 = 0, angle2 = 0) {
    const matrix2 = new this.constructor(this);
    matrix2[rotateAxisAngleSelf](x3, y3, z2, angle2);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix post multiplied by each of 3 rotation matrices about the major axes, first X, then Y, then Z.
   *
   * @param [x] X component of the rotation, or Z if Y and Z are null.
   * @param [y] Y component of the rotation value.
   * @param [z] Z component of the rotation value.
   * @returns The resulted matrix
   */
  rotate(x3 = 0, y3, z2) {
    const matrix2 = new this.constructor(this);
    matrix2[rotateSelf](x3, y3, z2);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix post multiplied by a rotation matrix with the angle between the specified vector and (1, 0).
   *
   * @param [x] X-Axis skew.
   * @param [y] Y-Axis skew.
   */
  rotateFromVector(x3 = 0, y3 = 0) {
    const matrix2 = new this.constructor(this);
    matrix2[rotateFromVectorSelf](x3, y3);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance that specifies a skew transformation along X-Axis by the given angle.
   *
   * @param angle Angle amount in degrees to skew.
   * @returns The resulted matrix
   */
  skewX(angle2) {
    const matrix2 = new this.constructor(this);
    matrix2[skewXSelf](angle2);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance that specifies a skew transformation along Y-Axis by the given angle.
   *
   * @param angle Angle amount in degrees to skew.
   * @returns The resulted matrix
   */
  skewY(angle2) {
    const matrix2 = new this.constructor(this);
    matrix2[skewYSelf](angle2);
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix flipped on X-axis.
   */
  flipX() {
    const matrix2 = new this.constructor(this);
    matrix2[flipXSelf]();
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix flipped on Y-axis.
   */
  flipY() {
    const matrix2 = new this.constructor(this);
    matrix2[flipYSelf]();
    return matrix2;
  }
  /**
   * Returns a new DOMMatrix instance which is this matrix inversed.
   */
  inverse() {
    const matrix2 = new this.constructor(this);
    matrix2[invertSelf]();
    return matrix2;
  }
  /**
   * Returns a new DOMPoint instance with the vector transformed using the matrix.
   *
   * @param domPoint DOM point compatible object.
   * @returns A new DOMPoint object.
   */
  transformPoint(domPoint) {
    const xPoint = domPoint.x ?? 0;
    const yPoint = domPoint.y ?? 0;
    const zPoint = domPoint.z ?? 0;
    const wPoint = domPoint.w ?? 1;
    const x3 = this[m11] * xPoint + this[m21] * yPoint + this[m31] * zPoint + this[m41] * wPoint;
    const y3 = this[m12] * xPoint + this[m22] * yPoint + this[m32] * zPoint + this[m42] * wPoint;
    const z2 = this[m13] * xPoint + this[m23] * yPoint + this[m33] * zPoint + this[m43] * wPoint;
    const w2 = this[m14] * xPoint + this[m24] * yPoint + this[m34] * zPoint + this[m44] * wPoint;
    return new DOMPoint(x3, y3, z2, w2);
  }
  /**
   * The `setMatrixValue` method replaces the existing matrix with one computed in the browser (e.g.`matrix(1,0.25,-0.25,1,0,0)`).
   *
   * @param source A `DOMMatrix`, `Float32Array`, `Float64Array`, `Array`, or DOMMatrix compatible object to set the matrix values from.
   */
  [setMatrixValue](source) {
    let matrix2;
    if (typeof source === "string" && source.length && source !== "none") {
      matrix2 = this.constructor[fromString](source);
    } else if (Array.isArray(source) || source instanceof Float64Array || source instanceof Float32Array) {
      matrix2 = this.constructor[fromArray](source);
    } else if (typeof source === "object") {
      matrix2 = this.constructor.fromMatrix(source);
    }
    this[m11] = matrix2[m11];
    this[m12] = matrix2[m12];
    this[m13] = matrix2[m13];
    this[m14] = matrix2[m14];
    this[m21] = matrix2[m21];
    this[m22] = matrix2[m22];
    this[m23] = matrix2[m23];
    this[m24] = matrix2[m24];
    this[m31] = matrix2[m31];
    this[m32] = matrix2[m32];
    this[m33] = matrix2[m33];
    this[m34] = matrix2[m34];
    this[m41] = matrix2[m41];
    this[m42] = matrix2[m42];
    this[m43] = matrix2[m43];
    this[m44] = matrix2[m44];
  }
  /**
   * Applies a multiply operation to the current matrix.
   *
   * @param matrix Second matrix.
   */
  [multiplySelf](matrix2) {
    if (!(matrix2 instanceof _DOMMatrixReadOnly)) {
      if (matrix2?.m11 === void 0 && matrix2?.a !== void 0) {
        matrix2 = Object.assign({}, DEFAULT_MATRIX_JSON, matrix2);
        matrix2.m11 = matrix2.a;
        matrix2.m12 = matrix2.b;
        matrix2.m21 = matrix2.c;
        matrix2.m22 = matrix2.d;
        matrix2.m41 = matrix2.e;
        matrix2.m42 = matrix2.f;
      } else {
        matrix2 = Object.assign({}, DEFAULT_MATRIX_JSON, matrix2);
      }
    }
    const m112 = this[m11] * matrix2.m11 + this[m21] * matrix2.m12 + this[m31] * matrix2.m13 + this[m41] * matrix2.m14;
    const m212 = this[m11] * matrix2.m21 + this[m21] * matrix2.m22 + this[m31] * matrix2.m23 + this[m41] * matrix2.m24;
    const m312 = this[m11] * matrix2.m31 + this[m21] * matrix2.m32 + this[m31] * matrix2.m33 + this[m41] * matrix2.m34;
    const m412 = this[m11] * matrix2.m41 + this[m21] * matrix2.m42 + this[m31] * matrix2.m43 + this[m41] * matrix2.m44;
    const m122 = this[m12] * matrix2.m11 + this[m22] * matrix2.m12 + this[m32] * matrix2.m13 + this[m42] * matrix2.m14;
    const m222 = this[m12] * matrix2.m21 + this[m22] * matrix2.m22 + this[m32] * matrix2.m23 + this[m42] * matrix2.m24;
    const m322 = this[m12] * matrix2.m31 + this[m22] * matrix2.m32 + this[m32] * matrix2.m33 + this[m42] * matrix2.m34;
    const m422 = this[m12] * matrix2.m41 + this[m22] * matrix2.m42 + this[m32] * matrix2.m43 + this[m42] * matrix2.m44;
    const m132 = this[m13] * matrix2.m11 + this[m23] * matrix2.m12 + this[m33] * matrix2.m13 + this[m43] * matrix2.m14;
    const m232 = this[m13] * matrix2.m21 + this[m23] * matrix2.m22 + this[m33] * matrix2.m23 + this[m43] * matrix2.m24;
    const m332 = this[m13] * matrix2.m31 + this[m23] * matrix2.m32 + this[m33] * matrix2.m33 + this[m43] * matrix2.m34;
    const m432 = this[m13] * matrix2.m41 + this[m23] * matrix2.m42 + this[m33] * matrix2.m43 + this[m43] * matrix2.m44;
    const m142 = this[m14] * matrix2.m11 + this[m24] * matrix2.m12 + this[m34] * matrix2.m13 + this[m44] * matrix2.m14;
    const m242 = this[m14] * matrix2.m21 + this[m24] * matrix2.m22 + this[m34] * matrix2.m23 + this[m44] * matrix2.m24;
    const m342 = this[m14] * matrix2.m31 + this[m24] * matrix2.m32 + this[m34] * matrix2.m33 + this[m44] * matrix2.m34;
    const m442 = this[m14] * matrix2.m41 + this[m24] * matrix2.m42 + this[m34] * matrix2.m43 + this[m44] * matrix2.m44;
    this[m11] = m112;
    this[m12] = m122;
    this[m13] = m132;
    this[m14] = m142;
    this[m21] = m212;
    this[m22] = m222;
    this[m23] = m232;
    this[m24] = m242;
    this[m31] = m312;
    this[m32] = m322;
    this[m33] = m332;
    this[m34] = m342;
    this[m41] = m412;
    this[m42] = m422;
    this[m43] = m432;
    this[m44] = m442;
  }
  /**
   * Applies translate to the matrix.
   *
   * This method is equivalent to the CSS `translate3d()` function.
   *
   * @see https://drafts.csswg.org/css-transforms-1/#TranslateDefined
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d
   * @see https://www.w3.org/TR/css-transforms-1/#transform-functions
   * @param [x] X-Axis position.
   * @param [y] Y-Axis position.
   * @param [z] Z-Axis position.
   */
  [translateSelf](x3 = 0, y3 = 0, z2 = 0) {
    const translationMatrix = this.constructor[fromArray]([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      x3,
      y3,
      z2,
      1
    ]);
    this[multiplySelf](translationMatrix);
  }
  /**
   * Applies a scale to the matrix.
   *
   * This method is equivalent to the CSS `scale()` function.
   *
   * @see https://drafts.csswg.org/css-transforms-1/#ScaleDefined
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale
   * @see https://www.w3.org/TR/css-transforms-1/#transform-functions
   * @param [scaleX] X-Axis scale.
   * @param [scaleY] Y-Axis scale.
   * @param [scaleZ] Z-Axis scale.
   * @param [originX] X-Axis scale.
   * @param [originY] Y-Axis scale.
   * @param [originZ] Z-Axis scale.
   */
  [scaleSelf](scaleX, scaleY, scaleZ = 1, originX = 0, originY = 0, originZ = 0) {
    scaleX = scaleX === void 0 ? 1 : Number(scaleX);
    scaleY = scaleY === void 0 ? scaleX : Number(scaleY);
    if (originX !== 0 || originY !== 0 || originZ !== 0) {
      this[translateSelf](originX, originY, originZ);
    }
    if (scaleX !== 1 || scaleY !== 1 || scaleZ !== 1) {
      this[multiplySelf](this.constructor[fromArray]([
        scaleX,
        0,
        0,
        0,
        0,
        scaleY,
        0,
        0,
        0,
        0,
        scaleZ,
        0,
        0,
        0,
        0,
        1
      ]));
    }
    if (originX !== 0 || originY !== 0 || originZ !== 0) {
      this[translateSelf](-originX, -originY, -originZ);
    }
  }
  /**
   * Applies a scale to the matrix.
   *
   * This method is equivalent to the CSS `scale()` function.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale3d
   * @see https://www.w3.org/TR/css-transforms-1/#transform-functions
   * @param [scale] The scale factor.
   * @param [originX] X-Axis scale.
   * @param [originY] Y-Axis scale.
   * @param [originZ] Z-Axis scale.
   */
  [scale3dSelf](scale2 = 1, originX = 0, originY = 0, originZ = 0) {
    if (originX !== 0 || originY !== 0 || originZ !== 0) {
      this[translateSelf](originX, originY, originZ);
    }
    if (scale2 !== 1) {
      this[multiplySelf](this.constructor[fromArray]([
        scale2,
        0,
        0,
        0,
        0,
        scale2,
        0,
        0,
        0,
        0,
        scale2,
        0,
        0,
        0,
        0,
        1
      ]));
    }
    if (originX !== 0 || originY !== 0 || originZ !== 0) {
      this[translateSelf](-originX, -originY, -originZ);
    }
  }
  /**
   * Applies a scale to the matrix.
   *
   * @see https://www.w3.org/TR/css-transforms-1/#transform-functions
   * @param [scaleX] X-Axis scale.
   * @param [scaleY] Y-Axis scale.
   */
  [scaleNonUniformSelf](scaleX = 1, scaleY = 1) {
    if (scaleX === 1 && scaleY === 1) {
      return;
    }
    this[multiplySelf](this.constructor[fromArray]([
      scaleX,
      0,
      0,
      0,
      0,
      scaleY,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]));
  }
  /**
   * Applies a rotation to the matrix.
   *
   * This method is equivalent to the CSS `rotate3d()` function.
   *
   * @see https://drafts.fxtf.org/geometry/#dom-dommatrixreadonly-rotateaxisangleself
   * @see https://www.w3.org/TR/css-transforms-1/#transform-functions
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d
   * @param [x] X-Axis vector.
   * @param [y] Y-Axis vector.
   * @param [z] Z-Axis vector.
   * @param [angle] Angle in degrees of the rotation.
   */
  [rotateAxisAngleSelf](x3 = 0, y3 = 0, z2 = 0, angle2 = 0) {
    x3 = Number(x3);
    y3 = Number(y3);
    z2 = Number(z2);
    angle2 = Number(angle2);
    if (isNaN(x3) || isNaN(y3) || isNaN(z2) || isNaN(angle2)) {
      throw new TypeError(`Failed to execute 'rotateAxisAngleSelf' on 'DOMMatrix': The arguments must be numbers.`);
    }
    const length2 = Math.hypot(x3, y3, z2);
    if (length2 === 0) {
      return;
    }
    if (length2 !== 1) {
      x3 /= length2;
      y3 /= length2;
      z2 /= length2;
    }
    const alpha = -(angle2 * Math.PI / 360);
    const round = this.#round;
    const sc = Math.sin(alpha) * Math.cos(alpha);
    const sq = Math.sin(alpha) * Math.sin(alpha);
    const m112 = round(1 - 2 * (y3 * y3 + z2 * z2) * sq);
    const m122 = round(2 * (x3 * y3 * sq + z2 * sc));
    const m132 = round(2 * (x3 * z2 * sq - y3 * sc));
    const m212 = round(2 * (x3 * y3 * sq - z2 * sc));
    const m222 = round(1 - 2 * (x3 * x3 + z2 * z2) * sq);
    const m232 = round(2 * (y3 * z2 * sq + x3 * sc));
    const m312 = round(2 * (x3 * z2 * sq + y3 * sc));
    const m322 = round(2 * (y3 * z2 * sq - x3 * sc));
    const m332 = round(1 - 2 * (x3 * x3 + y3 * y3) * sq);
    const matrix2 = this.constructor[fromArray]([
      m112,
      m212,
      m312,
      0,
      m122,
      m222,
      m322,
      0,
      m132,
      m232,
      m332,
      0,
      0,
      0,
      0,
      1
    ]);
    this[multiplySelf](matrix2);
  }
  /**
   * Applies a rotation to the matrix.
   *
   * @see http://en.wikipedia.org/wiki/Rotation_matrix
   * @see https://www.w3.org/TR/css-transforms-1/#transform-functions
   * @param [x] X-Axis rotation in degrees.
   * @param [y] Y-Axis rotation in degrees.
   * @param [z] Z-Axis rotation in degrees.
   */
  [rotateSelf](x3 = 0, y3, z2) {
    if (y3 === void 0 && z2 === void 0) {
      z2 = x3;
      x3 = 0;
      y3 = 0;
    }
    if (y3 === void 0) {
      y3 = 0;
    }
    if (z2 === void 0) {
      z2 = 0;
    }
    x3 = Number(x3);
    y3 = Number(y3);
    z2 = Number(z2);
    if (isNaN(x3) || isNaN(y3) || isNaN(z2)) {
      throw new TypeError(`Failed to execute 'rotateSelf' on 'DOMMatrix': The arguments must be numbers.`);
    }
    if (z2 !== 0) {
      this[rotateAxisAngleSelf](0, 0, 1, z2);
    }
    if (y3 !== 0) {
      this[rotateAxisAngleSelf](0, 1, 0, y3);
    }
    if (x3 !== 0) {
      this[rotateAxisAngleSelf](1, 0, 0, x3);
    }
  }
  /**
   * Modifies the matrix by rotating it by the angle between the specified vector and (1, 0).
   *
   * @param x The X component of the axis vector.
   * @param y The Y component of the axis vector.
   */
  [rotateFromVectorSelf](x3 = 0, y3 = 0) {
    if (x3 === 0 && y3 === 0) {
      return;
    }
    this[rotateSelf](Math.atan2(y3, x3) * 180 / Math.PI);
  }
  /**
   * Applies a skew operation to the matrix on the X axis.
   *
   * This method is equivalent to the CSS `skewX()` function.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skewX
   * @see https://www.w3.org/TR/css-transforms-1/#transform-functions
   * @param angle Angle in degrees.
   */
  [skewXSelf](angle2) {
    const matrix2 = Object.assign({}, DEFAULT_MATRIX_JSON);
    const value2 = Math.tan(angle2 * Math.PI / 180);
    matrix2.m21 = value2;
    matrix2.c = value2;
    this[multiplySelf](matrix2);
  }
  /**
   * Applies a skew operation to the matrix on the Y axis.
   *
   * This method is equivalent to the CSS `skewY()` function.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skewY
   * @see https://www.w3.org/TR/css-transforms-1/#transform-functions
   * @param angle Angle in degrees.
   */
  [skewYSelf](angle2) {
    const matrix2 = Object.assign({}, DEFAULT_MATRIX_JSON);
    const value2 = Math.tan(angle2 * Math.PI / 180);
    matrix2.m12 = value2;
    matrix2.b = value2;
    this[multiplySelf](matrix2);
  }
  /**
   * Applies a flip operation to the matrix on the X axis.
   */
  [flipXSelf]() {
    const matrix2 = this.constructor[fromArray]([
      -1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    this[multiplySelf](matrix2);
  }
  /**
   * Applies a flip operation to the matrix on the Y axis.
   */
  [flipYSelf]() {
    const matrix2 = this.constructor[fromArray]([
      1,
      0,
      0,
      0,
      0,
      -1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    this[multiplySelf](matrix2);
  }
  /**
   * Applies an inversion operation to the matrix.
   */
  [invertSelf]() {
    const m112 = this[m22] * this[m33] * this[m44] - this[m22] * this[m34] * this[m43] - this[m32] * this[m23] * this[m44] + this[m32] * this[m24] * this[m43] + this[m42] * this[m23] * this[m34] - this[m42] * this[m24] * this[m33];
    const m122 = -this[m12] * this[m33] * this[m44] + this[m12] * this[m34] * this[m43] + this[m32] * this[m13] * this[m44] - this[m32] * this[m14] * this[m43] - this[m42] * this[m13] * this[m34] + this[m42] * this[m14] * this[m33];
    const m132 = this[m12] * this[m23] * this[m44] - this[m12] * this[m24] * this[m43] - this[m22] * this[m13] * this[m44] + this[m22] * this[m14] * this[m43] + this[m42] * this[m13] * this[m24] - this[m42] * this[m14] * this[m23];
    const m142 = -this[m12] * this[m23] * this[m34] + this[m12] * this[m24] * this[m33] + this[m22] * this[m13] * this[m34] - this[m22] * this[m14] * this[m33] - this[m32] * this[m13] * this[m24] + this[m32] * this[m14] * this[m23];
    const det = this[m11] * m112 + this[m21] * m122 + this[m31] * m132 + this[m41] * m142;
    if (det === 0) {
      this[m11] = NaN;
      this[m12] = NaN;
      this[m13] = NaN;
      this[m14] = NaN;
      this[m21] = NaN;
      this[m22] = NaN;
      this[m23] = NaN;
      this[m24] = NaN;
      this[m31] = NaN;
      this[m32] = NaN;
      this[m33] = NaN;
      this[m34] = NaN;
      this[m41] = NaN;
      this[m42] = NaN;
      this[m43] = NaN;
      this[m44] = NaN;
      return;
    }
    const m212 = -this[m21] * this[m33] * this[m44] + this[m21] * this[m34] * this[m43] + this[m31] * this[m23] * this[m44] - this[m31] * this[m24] * this[m43] - this[m41] * this[m23] * this[m34] + this[m41] * this[m24] * this[m33];
    const m222 = this[m11] * this[m33] * this[m44] - this[m11] * this[m34] * this[m43] - this[m31] * this[m13] * this[m44] + this[m31] * this[m14] * this[m43] + this[m41] * this[m13] * this[m34] - this[m41] * this[m14] * this[m33];
    const m232 = -this[m11] * this[m23] * this[m44] + this[m11] * this[m24] * this[m43] + this[m21] * this[m13] * this[m44] - this[m21] * this[m14] * this[m43] - this[m41] * this[m13] * this[m24] + this[m41] * this[m14] * this[m23];
    const m242 = this[m11] * this[m23] * this[m34] - this[m11] * this[m24] * this[m33] - this[m21] * this[m13] * this[m34] + this[m21] * this[m14] * this[m33] + this[m31] * this[m13] * this[m24] - this[m31] * this[m14] * this[m23];
    const m312 = this[m21] * this[m32] * this[m44] - this[m21] * this[m34] * this[m42] - this[m31] * this[m22] * this[m44] + this[m31] * this[m24] * this[m42] + this[m41] * this[m22] * this[m34] - this[m41] * this[m24] * this[m32];
    const m322 = -this[m11] * this[m32] * this[m44] + this[m11] * this[m34] * this[m42] + this[m31] * this[m12] * this[m44] - this[m31] * this[m14] * this[m42] - this[m41] * this[m12] * this[m34] + this[m41] * this[m14] * this[m32];
    const m332 = this[m11] * this[m22] * this[m44] - this[m11] * this[m24] * this[m42] - this[m21] * this[m12] * this[m44] + this[m21] * this[m14] * this[m42] + this[m41] * this[m12] * this[m24] - this[m41] * this[m14] * this[m22];
    const m342 = -this[m11] * this[m22] * this[m34] + this[m11] * this[m24] * this[m32] + this[m21] * this[m12] * this[m34] - this[m21] * this[m14] * this[m32] - this[m31] * this[m12] * this[m24] + this[m31] * this[m14] * this[m22];
    const m412 = -this[m21] * this[m32] * this[m43] + this[m21] * this[m33] * this[m42] + this[m31] * this[m22] * this[m43] - this[m31] * this[m23] * this[m42] - this[m41] * this[m22] * this[m33] + this[m41] * this[m23] * this[m32];
    const m422 = this[m11] * this[m32] * this[m43] - this[m11] * this[m33] * this[m42] - this[m31] * this[m12] * this[m43] + this[m31] * this[m13] * this[m42] + this[m41] * this[m12] * this[m33] - this[m41] * this[m13] * this[m32];
    const m432 = -this[m11] * this[m22] * this[m43] + this[m11] * this[m23] * this[m42] + this[m21] * this[m12] * this[m43] - this[m21] * this[m13] * this[m42] - this[m41] * this[m12] * this[m23] + this[m41] * this[m13] * this[m22];
    const m442 = this[m11] * this[m22] * this[m33] - this[m11] * this[m23] * this[m32] - this[m21] * this[m12] * this[m33] + this[m21] * this[m13] * this[m32] + this[m31] * this[m12] * this[m23] - this[m31] * this[m13] * this[m22];
    this[m11] = m112 / det || 0;
    this[m12] = m122 / det || 0;
    this[m13] = m132 / det || 0;
    this[m14] = m142 / det || 0;
    this[m21] = m212 / det || 0;
    this[m22] = m222 / det || 0;
    this[m23] = m232 / det || 0;
    this[m24] = m242 / det || 0;
    this[m31] = m312 / det || 0;
    this[m32] = m322 / det || 0;
    this[m33] = m332 / det || 0;
    this[m34] = m342 / det || 0;
    this[m41] = m412 / det || 0;
    this[m42] = m422 / det || 0;
    this[m43] = m432 / det || 0;
    this[m44] = m442 / det || 0;
  }
  /**
   * Returns an *Array* containing elements which comprise the matrix.
   *
   * @param matrix Matrix to convert.
   * @param [is2D] If the matrix is 2D.
   * @returns Array representation of the matrix.
   */
  [toArray](is2D = false) {
    if (is2D) {
      return [
        this[m11],
        this[m12],
        this[m21],
        this[m22],
        this[m41],
        this[m42]
      ];
    }
    return [
      this[m11],
      this[m12],
      this[m13],
      this[m14],
      this[m21],
      this[m22],
      this[m23],
      this[m24],
      this[m31],
      this[m32],
      this[m33],
      this[m34],
      this[m41],
      this[m42],
      this[m43],
      this[m44]
    ];
  }
  /**
   * Rounds the value to the given number of decimals.
   *
   * @param value The value to round.
   * @param [decimals] The number of decimals to round to.
   */
  #round(value2, decimals = 1e15) {
    return Math.round(value2 * decimals) / decimals;
  }
  /**
   * Returns a new `DOMMatrix` instance given an existing matrix.
   *
   * @param matrix Matrix.
   */
  static fromMatrix(matrix2) {
    if (!(matrix2 instanceof _DOMMatrixReadOnly)) {
      if (matrix2?.m11 === void 0 && matrix2?.a !== void 0) {
        matrix2 = Object.assign({}, DEFAULT_MATRIX_JSON, matrix2);
        matrix2.m11 = matrix2.a;
        matrix2.m12 = matrix2.b;
        matrix2.m21 = matrix2.c;
        matrix2.m22 = matrix2.d;
        matrix2.m41 = matrix2.e;
        matrix2.m42 = matrix2.f;
      } else {
        matrix2 = Object.assign({}, DEFAULT_MATRIX_JSON, matrix2);
      }
    }
    return this[fromArray]([
      matrix2.m11,
      matrix2.m12,
      matrix2.m13,
      matrix2.m14,
      matrix2.m21,
      matrix2.m22,
      matrix2.m23,
      matrix2.m24,
      matrix2.m31,
      matrix2.m32,
      matrix2.m33,
      matrix2.m34,
      matrix2.m41,
      matrix2.m42,
      matrix2.m43,
      matrix2.m44
    ]);
  }
  /**
   * Returns a new `DOMMatrix` instance given an array of 16/6 floating point values.
   *
   * @param array An `Array` to feed values from.
   * @returns DOMMatrix instance.
   */
  static fromFloat32Array(array) {
    return this[fromArray](array);
  }
  /**
   * Returns a new `DOMMatrix` instance given an array of 16/6 floating point values.
   *
   * @param array An `Array` to feed values from.
   * @returns DOMMatrix instance.
   */
  static fromFloat64Array(array) {
    return this[fromArray](array);
  }
  /**
   * Returns a new `DOMMatrix` instance given an array of 16/6 floating point values.
   *
   * Conditions:
   * - If the array has six values, the result is a 2D matrix.
   * - If the array has 16 values, the result is a 3D matrix.
   * - Otherwise, a TypeError exception is thrown.
   *
   * @param array An `Array` to feed values from.
   * @returns DOMMatrix instance.
   */
  static [fromArray](array) {
    if (!(array instanceof Float64Array || array instanceof Float32Array || Array.isArray(array)) || array.length !== 6 && array.length !== 16) {
      throw TypeError(`Failed to execute 'fromArray' on '${this.name}': '${String(array)}' is not a compatible array.`);
    }
    const matrix2 = new this();
    if (array.length === 16) {
      const [m112, m122, m132, m142, m212, m222, m232, m242, m312, m322, m332, m342, m412, m422, m432, m442] = array;
      matrix2[m11] = m112;
      matrix2[m12] = m122;
      matrix2[m13] = m132;
      matrix2[m14] = m142;
      matrix2[m21] = m212;
      matrix2[m22] = m222;
      matrix2[m23] = m232;
      matrix2[m24] = m242;
      matrix2[m31] = m312;
      matrix2[m32] = m322;
      matrix2[m33] = m332;
      matrix2[m34] = m342;
      matrix2[m41] = m412;
      matrix2[m42] = m422;
      matrix2[m43] = m432;
      matrix2[m44] = m442;
    } else if (array.length === 6) {
      const [m112, m122, m212, m222, m412, m422] = array;
      matrix2[m11] = m112;
      matrix2[m12] = m122;
      matrix2[m21] = m212;
      matrix2[m22] = m222;
      matrix2[m41] = m412;
      matrix2[m42] = m422;
    }
    return matrix2;
  }
  /**
   * Returns a new `DOMMatrix` instance from a DOM transform string.
   *
   * @param source valid CSS transform string syntax.
   * @returns DOMMatrix instance.
   */
  static [fromString](source) {
    if (typeof source !== "string") {
      throw TypeError(`Failed to execute 'setMatrixValue' on '${this.name}': Expected '${String(source)}' to be a string.`);
    }
    const domMatrix2 = new this();
    const regexp = new RegExp(TRANSFORM_REGEXP);
    let match;
    while (match = regexp.exec(source)) {
      const name2 = match[1];
      const parameters = match[2].split(TRANSFORM_PARAMETER_SPLIT_REGEXP);
      for (let i = 0, max = parameters.length; i < max; i++) {
        parameters[i] = this[getLength](parameters[i]);
      }
      const [x3, y3, z2, a] = parameters;
      switch (name2) {
        case "perspective":
          if (!isNaN(x3) && x3 !== 0 && y3 === void 0 && z2 === void 0) {
            domMatrix2[m34] = -1 / x3;
          }
          break;
        case "translate":
          if (!isNaN(x3) && z2 === void 0) {
            domMatrix2[translateSelf](x3, y3 || 0, 0);
          }
          break;
        case "translate3d":
          if (!isNaN(x3) && !isNaN(y3) && !isNaN(z2)) {
            domMatrix2[translateSelf](x3, y3, z2);
          }
          break;
        case "translateX":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[translateSelf](x3);
          }
          break;
        case "translateY":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[translateSelf](0, x3);
          }
          break;
        case "translateZ":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[translateSelf](0, 0, x3);
          }
          break;
        case "matrix":
        case "matrix3d":
          if (parameters.length === 6 || parameters.length === 16) {
            domMatrix2[setMatrixValue](this[fromArray](parameters));
          }
          break;
        case "rotate":
        case "rotateZ":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[rotateSelf](0, 0, x3);
          }
          break;
        case "rotateX":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[rotateSelf](x3, 0, 0);
          }
          break;
        case "rotateY":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[rotateSelf](0, x3, 0);
          }
        case "rotate3d":
          if (!isNaN(x3) && !isNaN(y3) && !isNaN(z2) && !isNaN(a)) {
            domMatrix2[rotateAxisAngleSelf](x3, y3, z2, a);
          }
          break;
        case "scale":
          if (!isNaN(x3) && x3 !== 1 && z2 === void 0) {
            domMatrix2[scaleSelf](x3, isNaN(y3) ? x3 : y3);
          }
          break;
        case "scale3d":
          if (!isNaN(x3) && !isNaN(y3) && !isNaN(z2)) {
            domMatrix2[scaleSelf](x3, y3, z2);
          }
          break;
        case "scaleX":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[scaleSelf](x3, 1, 1);
          }
          break;
        case "scaleY":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[scaleSelf](1, x3, 1);
          }
          break;
        case "scaleZ":
          if (!isNaN(x3) && y3 === void 0 && z2 === void 0) {
            domMatrix2[scaleSelf](1, 1, x3);
          }
          break;
        case "skew":
          if (!isNaN(x3)) {
            domMatrix2[skewXSelf](x3);
          }
          if (!isNaN(y3)) {
            domMatrix2[skewYSelf](y3);
          }
          break;
        case "skewX":
          if (!isNaN(x3) && y3 === void 0) {
            domMatrix2[skewXSelf](x3);
          }
          break;
        case "skewY":
          if (!isNaN(x3) && y3 === void 0) {
            domMatrix2[skewYSelf](x3);
          }
          break;
        default:
          throw TypeError(`Failed to execute 'setMatrixValue' on '${this.name}': Unknown transform function '${match[1]}'.`);
      }
    }
    return domMatrix2;
  }
  /**
   * Returns length.
   *
   * @param length Length to convert.
   * @returns Length.
   */
  static [getLength](length2) {
    const value2 = parseFloat(length2);
    const unit = length2.replace(value2.toString(), "");
    switch (unit) {
      case "rem":
      case "em":
      case "vw":
      case "vh":
      case "%":
      case "vmin":
      case "vmax":
        throw new SyntaxError(`Failed to construct '${this.name}': Lengths must be absolute, not relative`);
      case "rad":
        return value2 * (180 / Math.PI);
      case "turn":
        return value2 * 360;
      case "px":
        return value2;
      case "cm":
        return value2 * 37.7812;
      case "mm":
        return value2 * 3.7781;
      case "in":
        return value2 * 96;
      case "pt":
        return value2 * 1.3281;
      case "pc":
        return value2 * 16;
      case "Q":
        return value2 * 0.945;
      default:
        return value2;
    }
  }
};

// node_modules/happy-dom/lib/dom/dom-matrix/DOMMatrix.js
var DOMMatrix = class extends DOMMatrixReadOnly {
  /**
   * Returns the `a` value of the matrix.
   */
  get a() {
    return this[m11];
  }
  /**
   * Sets the `a` value of the matrix.
   */
  set a(value2) {
    this[m11] = value2;
  }
  /**
   * Returns the `b` value of the matrix.
   */
  get b() {
    return this[m12];
  }
  /**
   * Sets the `b` value of the matrix.
   */
  set b(value2) {
    this[m12] = value2;
  }
  /**
   * Returns the `c` value of the matrix.
   */
  get c() {
    return this[m21];
  }
  /**
   * Sets the `c` value of the matrix.
   */
  set c(value2) {
    this[m21] = value2;
  }
  /**
   * Returns the `d` value of the matrix.
   */
  get d() {
    return this[m22];
  }
  /**
   * Sets the `d` value of the matrix.
   */
  set d(value2) {
    this[m22] = value2;
  }
  /**
   * Returns the `e` value of the matrix.
   */
  get e() {
    return this[m41];
  }
  /**
   * Sets the `e` value of the matrix.
   */
  set e(value2) {
    this[m41] = value2;
  }
  /**
   * Returns the `f` value of the matrix.
   */
  get f() {
    return this[m42];
  }
  /**
   * Sets the `f` value of the matrix.
   */
  set f(value2) {
    this[m42] = value2;
  }
  /**
   * Returns the `m11` value of the matrix.
   */
  get m11() {
    return this[m11];
  }
  /**
   * Sets the `m11` value of the matrix.
   */
  set m11(value2) {
    this[m11] = value2;
  }
  /**
   * Returns the `m12` value of the matrix.
   */
  get m12() {
    return this[m12];
  }
  /**
   * Sets the `m12` value of the matrix.
   */
  set m12(value2) {
    this[m12] = value2;
  }
  /**
   * Returns the `m13` value of the matrix.
   */
  get m13() {
    return this[m13];
  }
  /**
   * Sets the `m13` value of the matrix.
   */
  set m13(value2) {
    this[m13] = value2;
  }
  /**
   * Returns the `m14` value of the matrix.
   */
  get m14() {
    return this[m14];
  }
  /**
   * Sets the `m14` value of the matrix.
   */
  set m14(value2) {
    this[m14] = value2;
  }
  /**
   * Returns the `m21` value of the matrix.
   */
  get m21() {
    return this[m21];
  }
  /**
   * Sets the `m21` value of the matrix.
   */
  set m21(value2) {
    this[m21] = value2;
  }
  /**
   * Returns the `m22` value of the matrix.
   */
  get m22() {
    return this[m22];
  }
  /**
   * Sets the `m22` value of the matrix.
   */
  set m22(value2) {
    this[m22] = value2;
  }
  /**
   * Returns the `m23` value of the matrix.
   */
  get m23() {
    return this[m23];
  }
  /**
   * Sets the `m23` value of the matrix.
   */
  set m23(value2) {
    this[m23] = value2;
  }
  /**
   * Returns the `m24` value of the matrix.
   */
  get m24() {
    return this[m24];
  }
  /**
   * Sets the `m24` value of the matrix.
   */
  set m24(value2) {
    this[m24] = value2;
  }
  /**
   * Returns the `m31` value of the matrix.
   */
  get m31() {
    return this[m31];
  }
  /**
   * Sets the `m31` value of the matrix.
   */
  set m31(value2) {
    this[m31] = value2;
  }
  /**
   * Returns the `m32` value of the matrix.
   */
  get m32() {
    return this[m32];
  }
  /**
   * Sets the `m32` value of the matrix.
   */
  set m32(value2) {
    this[m32] = value2;
  }
  /**
   * Returns the `m33` value of the matrix.
   */
  get m33() {
    return this[m33];
  }
  /**
   * Sets the `m33` value of the matrix.
   */
  set m33(value2) {
    this[m33] = value2;
  }
  /**
   * Returns the `m34` value of the matrix.
   */
  get m34() {
    return this[m34];
  }
  /**
   * Sets the `m34` value of the matrix.
   */
  set m34(value2) {
    this[m34] = value2;
  }
  /**
   * Returns the `m41` value of the matrix.
   */
  get m41() {
    return this[m41];
  }
  /**
   * Sets the `m41` value of the matrix.
   */
  set m41(value2) {
    this[m41] = value2;
  }
  /**
   * Returns the `m42` value of the matrix.
   */
  get m42() {
    return this[m42];
  }
  /**
   * Sets the `m42` value of the matrix.
   */
  set m42(value2) {
    this[m42] = value2;
  }
  /**
   * Returns the `m43` value of the matrix.
   */
  get m43() {
    return this[m43];
  }
  /**
   * Sets the `m43` value of the matrix.
   */
  set m43(value2) {
    this[m43] = value2;
  }
  /**
   * Returns the `m44` value of the matrix.
   */
  get m44() {
    return this[m44];
  }
  /**
   * Sets the `m44` value of the matrix.
   */
  set m44(value2) {
    this[m44] = value2;
  }
  /**
   * The `setMatrixValue` method replaces the existing matrix with one computed in the browser (e.g.`matrix(1,0.25,-0.25,1,0,0)`).
   *
   * @param source A `DOMMatrix`, `Float32Array`, `Float64Array`, `Array`, or DOMMatrix compatible object to set the matrix values from.
   * @returns Self.
   */
  setMatrixValue(source) {
    this[setMatrixValue](source);
    return this;
  }
  /**
   * Sets self to be multiplied by the passed matrix.
   *
   * @param secondMatrix DOMMatrix
   * @returns Self.
   */
  multiplySelf(secondMatrix) {
    this[multiplySelf](secondMatrix);
    return this;
  }
  /**
   * Sets self to multiplied by a translation matrix containing the passed values.
   *
   * @param [x=0] X component of the translation value.
   * @param [y=0] Y component of the translation value.
   * @param [z=0] Z component of the translation value.
   * @returns Self.
   */
  translateSelf(x3 = 0, y3 = 0, z2 = 0) {
    this[translateSelf](x3, y3, z2);
    return this;
  }
  /**
   * Sets self to be multiplied by a scale matrix containing the passed values.
   *
   * @param [scaleX] X-Axis scale.
   * @param [scaleY] Y-Axis scale.
   * @param [scaleZ] Z-Axis scale.
   * @param [originX] X-Axis scale.
   * @param [originY] Y-Axis scale.
   * @param [originZ] Z-Axis scale.
   * @returns Self.
   */
  scaleSelf(scaleX, scaleY, scaleZ = 1, originX = 0, originY = 0, originZ = 0) {
    this[scaleSelf](scaleX, scaleY, scaleZ, originX, originY, originZ);
    return this;
  }
  /**
   * Sets self to be multiplied by a scale matrix containing the passed values.
   *
   * @param [scale] The scale factor.
   * @param [originX] X-Axis scale.
   * @param [originY] Y-Axis scale.
   * @param [originZ] Z-Axis scale.
   * @returns Self.
   */
  scale3dSelf(scale2 = 1, originX = 0, originY = 0, originZ = 0) {
    this[scale3dSelf](scale2, originX, originY, originZ);
    return this;
  }
  /**
   * Sets self to be multiplied by a scale matrix containing the passed values.
   *
   * @param [scaleX] X-Axis scale.
   * @param [scaleY] Y-Axis scale.
   * @returns Self.
   */
  scaleNonUniformSelf(scaleX = 1, scaleY = 1) {
    this[scaleNonUniformSelf](scaleX, scaleY);
    return this;
  }
  /**
   * Sets self to be multiplied by a rotation matrix with the given axis and `angle`.
   *
   * @param [x] The X component of the axis vector.
   * @param [y] The Y component of the axis vector.
   * @param [z] The Z component of the axis vector.
   * @param [angle] Angle of rotation about the axis vector, in degrees.
   * @returns Self.
   */
  rotateAxisAngleSelf(x3 = 0, y3 = 0, z2 = 0, angle2 = 0) {
    this[rotateAxisAngleSelf](x3, y3, z2, angle2);
    return this;
  }
  /**
   * Set self to be multiplied by each of 3 rotation matrices about the major axes, first X, then Y, then Z.
   *
   * @param [x] X component of the rotation, or Z if Y and Z are null.
   * @param [y] Y component of the rotation value.
   * @param [z] Z component of the rotation value.
   * @returns Self.
   */
  rotateSelf(x3 = 0, y3, z2) {
    this[rotateSelf](x3, y3, z2);
    return this;
  }
  /**
   * Sets self to be multiplied by a skew matrix along the X axis by the given angle.
   *
   * @param [x] X-Axis skew.
   * @param [y] Y-Axis skew.
   */
  rotateFromVectorSelf(x3 = 0, y3 = 0) {
    this[rotateFromVectorSelf](x3, y3);
    return this;
  }
  /**
   * Set self to be specified as a skew transformation along X-Axis by the given angle.
   *
   * @param angle Angle amount in degrees to skew.
   * @returns Self.
   */
  skewXSelf(angle2) {
    this[skewXSelf](angle2);
    return this;
  }
  /**
   * Set self to be specified as a skew transformation along Y-Axis by the given angle.
   *
   * @param angle Angle amount in degrees to skew.
   * @returns Self.
   */
  skewYSelf(angle2) {
    this[skewYSelf](angle2);
    return this;
  }
  /**
   * Set self to be specified as matrix flipped on X-axis.
   */
  flipXSelf() {
    this[flipXSelf]();
    return this;
  }
  /**
   * Set self to be specified as matrix flipped on Y-axis.
   */
  flipYSelf() {
    this[flipYSelf]();
    return this;
  }
  /**
   * Set self to be specified as matrix inverted.
   */
  invertSelf() {
    this[invertSelf]();
    return this;
  }
};

// node_modules/happy-dom/lib/svg/SVGStringList.js
var ATTRIBUTE_SPLIT_REGEXP2 = /[\t\f\n\r ,]+/;
var SVGStringList = class _SVGStringList {
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [readOnly] = false;
  [cache] = {
    items: [],
    attributeValue: ""
  };
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param [options.readOnly] Read only.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[readOnly] = !!options2.readOnly;
    this[getAttribute] = options2.getAttribute || null;
    this[setAttribute] = options2.setAttribute || null;
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    const methodBinder = new ClassMethodBinder(this, [_SVGStringList]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property === "length" || property === "numberOfItems") {
          return target2[getItemList]().length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return target2[getItemList]()[index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys(target2) {
        return Object.keys(target2[getItemList]());
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        return !isNaN(index) && index >= 0 && index < target2[getItemList]().length;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        const items2 = target2[getItemList]();
        if (!isNaN(index) && items2[index]) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[getItemList]().length;
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get numberOfItems() {
    return this[getItemList]().length;
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  [Symbol.iterator]() {
    return this[getItemList]().values();
  }
  /**
   * Clears all items from the list.
   */
  clear() {
    this[cache].attributeValue = "";
    this[cache].items = [];
    this[setAttribute]("");
  }
  /**
   * Replace Token.
   *
   * @param newItem New item.
   * @returns The item being replaced.
   */
  initialize(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGStringList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGStringList': 1 arguments required, but only ${arguments.length} present.`);
    }
    newItem = String(newItem);
    if (!newItem) {
      this.clear();
      return;
    }
    this[setAttribute](newItem);
    return newItem;
  }
  /**
   * Returns item at index.
   *
   * @param index Index.
   * @returns The item at the index.
   **/
  getItem(index) {
    const items2 = this[getItemList]();
    if (typeof index === "number") {
      return items2[index] ? items2[index] : null;
    }
    index = Number(index);
    index = isNaN(index) ? 0 : index;
    return items2[index] ? items2[index] : null;
  }
  /**
   * Inserts a new item into the list at the specified position. The first item is number 0. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to insert before is before the removal of the item. If the index is equal to 0, then the new item is inserted at the front of the list. If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being inserted.
   */
  insertItemBefore(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGStringList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGStringList': 2 arguments required, but only ${arguments.length} present.`);
    }
    newItem = String(newItem);
    if (!newItem) {
      return newItem;
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index > items2.length) {
      index = items2.length;
    }
    items2.splice(index, 0, newItem);
    this[setAttribute](items2.join(" "));
    return newItem;
  }
  /**
   * Replaces an existing item in the list with a new item. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to replace is before the removal of the item.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being replaced.
   */
  replaceItem(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGStringList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGStringList': 2 arguments required, but only ${arguments.length} present.`);
    }
    newItem = String(newItem);
    if (!newItem) {
      return this.removeItem(index);
    }
    const items2 = this[getItemList]();
    if (index < 0) {
      index = 0;
    } else if (index >= items2.length) {
      index = items2.length - 1;
    }
    const replacedItem = items2[index];
    items2[index] = newItem;
    this[setAttribute](items2.join(" "));
    return replacedItem;
  }
  /**
   * Removes an existing item from the list.
   *
   * @param index Index.
   * @returns The removed item.
   */
  removeItem(index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGStringList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGStringList': 1 argument required, but only ${arguments.length} present.`);
    }
    const items2 = this[getItemList]();
    index = Number(index);
    if (isNaN(index)) {
      index = 0;
    }
    if (index >= items2.length) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGStringList':  The index provided (${index}) is greater than the maximum bound.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index < 0) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGStringList':  The index provided (${index}) is negative.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const removedItem = items2[index];
    items2.splice(index, 1);
    this[setAttribute](items2.join(" "));
    return removedItem;
  }
  /**
   * Appends an item to the end of the list.
   *
   * @param newItem The item to add to the list.
   * @returns The item being appended.
   */
  appendItem(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGStringList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGStringList': 1 argument required, but only ${arguments.length} present.`);
    }
    newItem = String(newItem);
    if (!newItem) {
      return newItem;
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    items2.push(newItem);
    this[setAttribute](items2.join(" "));
    return newItem;
  }
  /**
   * Returns item list from attribute value.
   *
   * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
   */
  [getItemList]() {
    const attributeValue2 = this[getAttribute]() ?? "";
    const cache2 = this[cache];
    if (cache2.attributeValue === attributeValue2) {
      return cache2.items;
    }
    const items2 = [];
    const trimmed = attributeValue2.trim();
    if (trimmed) {
      for (const item of trimmed.split(ATTRIBUTE_SPLIT_REGEXP2)) {
        if (!items2.includes(item)) {
          items2.push(item);
        }
      }
    }
    cache2.attributeValue = attributeValue2;
    cache2.items = items2;
    return items2;
  }
};

// node_modules/happy-dom/lib/svg/SVGMatrix.js
var TRANSFORM_REGEXP2 = /([a-zA-Z0-9]+)\(([^)]+)\)/;
var TRANSFORM_PARAMETER_SPLIT_REGEXP2 = /[\s,]+/;
var SVGMatrix = class _SVGMatrix {
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [attributeValue] = null;
  [readOnly] = false;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.readOnly] Read only.
   * @param [options.getAttribute] Get attribute.
   * @param [options.setAttribute] Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    if (options2) {
      this[readOnly] = !!options2.readOnly;
      this[getAttribute] = options2.getAttribute || null;
      this[setAttribute] = options2.setAttribute || null;
    }
  }
  /**
   * Returns the `a` value of the matrix.
   */
  get a() {
    return this[getDOMMatrix]().a;
  }
  /**
   * Sets the `a` value of the matrix.
   */
  set a(value2) {
    if (this[readOnly]) {
      return;
    }
    const domMatrix2 = this[getDOMMatrix]();
    domMatrix2.a = value2;
    this[setDOMMatrix](domMatrix2);
  }
  /**
   * Returns the `b` value of the matrix.
   */
  get b() {
    return this[getDOMMatrix]().b;
  }
  /**
   * Sets the `b` value of the matrix.
   */
  set b(value2) {
    if (this[readOnly]) {
      return;
    }
    const domMatrix2 = this[getDOMMatrix]();
    domMatrix2.b = value2;
    this[setDOMMatrix](domMatrix2);
  }
  /**
   * Returns the `c` value of the matrix.
   */
  get c() {
    return this[getDOMMatrix]().c;
  }
  /**
   * Sets the `c` value of the matrix.
   */
  set c(value2) {
    if (this[readOnly]) {
      return;
    }
    const domMatrix2 = this[getDOMMatrix]();
    domMatrix2.c = value2;
    this[setDOMMatrix](domMatrix2);
  }
  /**
   * Returns the `d` value of the matrix.
   */
  get d() {
    return this[getDOMMatrix]().d;
  }
  /**
   * Sets the `d` value of the matrix.
   */
  set d(value2) {
    if (this[readOnly]) {
      return;
    }
    const domMatrix2 = this[getDOMMatrix]();
    domMatrix2.d = value2;
    this[setDOMMatrix](domMatrix2);
  }
  /**
   * Returns the `e` value of the matrix.
   */
  get e() {
    return this[getDOMMatrix]().e;
  }
  /**
   * Sets the `e` value of the matrix.
   */
  set e(value2) {
    if (this[readOnly]) {
      return;
    }
    const domMatrix2 = this[getDOMMatrix]();
    domMatrix2.e = value2;
    this[setDOMMatrix](domMatrix2);
  }
  /**
   * Returns the `f` value of the matrix.
   */
  get f() {
    return this[getDOMMatrix]().f;
  }
  /**
   * Sets the `f` value of the matrix.
   */
  set f(value2) {
    if (this[readOnly]) {
      return;
    }
    const domMatrix2 = this[getDOMMatrix]();
    domMatrix2.f = value2;
    this[setDOMMatrix](domMatrix2);
  }
  /**
   * Returns a new SVGMatrix instance which is the result of this matrix multiplied by the passed matrix.
   *
   * @param secondMatrix Matrix object.
   * @returns A new SVGMatrix object.
   */
  multiply(secondMatrix) {
    if (!(secondMatrix instanceof _SVGMatrix)) {
      throw new this[window].TypeError("Failed to execute 'multiply' on 'SVGMatrix': parameter 1 is not of type 'SVGMatrix'.");
    }
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.multiplySelf(secondMatrix[getDOMMatrix]());
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance which is this matrix post multiplied by a translation matrix containing the passed values.
   *
   * @param [x=0] X component of the translation value.
   * @param [y=0] Y component of the translation value.
   * @returns The resulted matrix
   */
  translate(x3 = 0, y3 = 0) {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.translateSelf(x3, y3);
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance which is this matrix post multiplied by a scale 2D matrix containing the passed values.
   *
   * @param scale The scale factor.
   * @returns The resulted matrix
   */
  scale(scale2) {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.scaleSelf(scale2);
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance which is this matrix post multiplied by a scale 3D matrix containing the passed values.
   *
   * @param [scaleX] X-Axis scale.
   * @param [scaleY] Y-Axis scale.
   * @returns The resulted matrix
   */
  scaleNonUniform(scaleX = 1, scaleY = 1) {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.scaleNonUniformSelf(scaleX, scaleY);
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance which is this matrix post multiplied by each of 3 rotation matrices about the major axes, first X, then Y, then Z.
   *
   * @param angle Angle of rotation in degrees.
   * @returns The resulted matrix
   */
  rotate(angle2) {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.rotateSelf(angle2);
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance which is this matrix post multiplied by a skew matrix along the X axis by the given angle.
   *
   * Not implemented in Happy DOM yet.
   *
   * @param [x] X-Axis skew.
   * @param [y] Y-Axis skew.
   */
  rotateFromVector(x3 = 0, y3 = 0) {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.rotateFromVectorSelf(x3, y3);
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance that specifies a skew transformation along X-Axis by the given angle.
   *
   * @param angle Angle amount in degrees to skew.
   * @returns The resulted matrix
   */
  skewX(angle2) {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.skewXSelf(angle2);
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance that specifies a skew transformation along Y-Axis by the given angle.
   *
   * @param angle Angle amount in degrees to skew.
   * @returns The resulted matrix
   */
  skewY(angle2) {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.skewYSelf(angle2);
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance which is this matrix flipped on X-axis.
   */
  flipX() {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.flipXSelf();
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance which is this matrix flipped on Y-axis.
   */
  flipY() {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.flipYSelf();
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns a new SVGMatrix instance which is this matrix inverted.
   */
  inverse() {
    const domMatrix2 = this[getDOMMatrix]();
    const svgMatrix = new _SVGMatrix(illegalConstructor, this[window]);
    domMatrix2.invertSelf();
    svgMatrix[setDOMMatrix](domMatrix2);
    return svgMatrix;
  }
  /**
   * Returns DOM matrix.
   *
   * @returns DOM matrix.
   */
  [getDOMMatrix]() {
    const attribute = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    if (!attribute) {
      return new DOMMatrix();
    }
    const match = attribute.match(TRANSFORM_REGEXP2);
    if (!match) {
      return new DOMMatrix();
    }
    const parameters = [];
    for (const parameter of match[2].trim().split(TRANSFORM_PARAMETER_SPLIT_REGEXP2)) {
      const value2 = Number(parameter);
      if (isNaN(value2)) {
        throw new this[window].TypeError(`Failed to parse transform attribute: Expected number, but got "${parameter}" in "${attribute}".`);
      }
      parameters.push(value2);
    }
    switch (match[1]) {
      case "matrix":
        if (parameters.length !== 6) {
          throw new this[window].TypeError(`Failed to parse transform attribute: Expected 6 parameters in "${attribute}".`);
        }
        return DOMMatrix[fromString](attribute);
      case "scale":
      case "translate":
        if (parameters.length !== 1 && parameters.length !== 2) {
          throw new this[window].TypeError(`Failed to parse transform attribute: Expected 1 or 2 parameters in "${attribute}".`);
        }
        return DOMMatrix[fromString](attribute);
      case "skewY":
      case "skewX":
        if (parameters.length !== 1) {
          throw new this[window].TypeError(`Failed to parse transform attribute: Expected 1 parameter in "${attribute}".`);
        }
        return DOMMatrix[fromString](attribute);
      case "rotate":
        const domMatrix2 = new DOMMatrix();
        if (parameters.length !== 1 && parameters.length !== 3) {
          throw new this[window].TypeError(`Failed to parse transform attribute: Expected 1 or 3 parameters in "${attribute}".`);
        }
        const [angle2, x3, y3] = parameters;
        if (x3 || y3) {
          domMatrix2.translateSelf(x3, y3);
        }
        const radian = angle2 * Math.PI / 180;
        domMatrix2.multiplySelf(
          // prettier-ignore
          new DOMMatrix([
            Math.cos(radian),
            Math.sin(radian),
            -Math.sin(radian),
            Math.cos(radian),
            0,
            0
          ])
        );
        if (x3 || y3) {
          domMatrix2.translateSelf(-x3, -y3);
        }
        return domMatrix2;
      default:
        throw new this[window].TypeError(`Failed to parse transform attribute: Unknown transformation "${attribute}".`);
    }
  }
  /**
   * Sets DOM matrix.
   *
   * @param domMatrix DOM matrix.
   */
  [setDOMMatrix](domMatrix2) {
    this[attributeValue] = domMatrix2.toString().replace(/, /g, " ");
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
};

// node_modules/happy-dom/lib/svg/SVGTransformTypeEnum.js
var SVGTransformTypeEnum;
(function(SVGTransformTypeEnum2) {
  SVGTransformTypeEnum2[SVGTransformTypeEnum2["unknown"] = 0] = "unknown";
  SVGTransformTypeEnum2[SVGTransformTypeEnum2["matrix"] = 1] = "matrix";
  SVGTransformTypeEnum2[SVGTransformTypeEnum2["translate"] = 2] = "translate";
  SVGTransformTypeEnum2[SVGTransformTypeEnum2["scale"] = 3] = "scale";
  SVGTransformTypeEnum2[SVGTransformTypeEnum2["rotate"] = 4] = "rotate";
  SVGTransformTypeEnum2[SVGTransformTypeEnum2["skewX"] = 5] = "skewX";
  SVGTransformTypeEnum2[SVGTransformTypeEnum2["skewY"] = 6] = "skewY";
})(SVGTransformTypeEnum || (SVGTransformTypeEnum = {}));
var SVGTransformTypeEnum_default = SVGTransformTypeEnum;

// node_modules/happy-dom/lib/svg/SVGTransform.js
var TRANSFORM_REGEXP3 = /([a-zA-Z0-9]+)\(([^)]+)\)/;
var TRANSFORM_PARAMETER_SPLIT_REGEXP3 = /[\s,]+/;
var SVGTransform = class {
  static SVG_TRANSFORM_UNKNOWN = SVGTransformTypeEnum_default.unknown;
  static SVG_TRANSFORM_MATRIX = SVGTransformTypeEnum_default.matrix;
  static SVG_TRANSFORM_TRANSLATE = SVGTransformTypeEnum_default.translate;
  static SVG_TRANSFORM_SCALE = SVGTransformTypeEnum_default.scale;
  static SVG_TRANSFORM_ROTATE = SVGTransformTypeEnum_default.rotate;
  static SVG_TRANSFORM_SKEWX = SVGTransformTypeEnum_default.skewX;
  static SVG_TRANSFORM_SKEWY = SVGTransformTypeEnum_default.skewY;
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [attributeValue] = null;
  [readOnly] = false;
  [matrix] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.readOnly] Read only.
   * @param [options.getAttribute] Get attribute.
   * @param [options.setAttribute] Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    if (options2) {
      this[readOnly] = !!options2.readOnly;
      this[getAttribute] = options2.getAttribute || null;
      this[setAttribute] = options2.setAttribute || null;
    }
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    const match = attributeValue2?.match(TRANSFORM_REGEXP3);
    if (!match) {
      return SVGTransformTypeEnum_default.unknown;
    }
    switch (match[1]) {
      case "matrix":
        return SVGTransformTypeEnum_default.matrix;
      case "translate":
        return SVGTransformTypeEnum_default.translate;
      case "rotate":
        return SVGTransformTypeEnum_default.rotate;
      case "scale":
        return SVGTransformTypeEnum_default.scale;
      case "skewX":
        return SVGTransformTypeEnum_default.skewX;
      case "skewY":
        return SVGTransformTypeEnum_default.skewY;
    }
    return 0;
  }
  /**
   * Returns angle.
   *
   * @returns Angle.
   */
  get angle() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    const match = attributeValue2?.match(TRANSFORM_REGEXP3);
    if (!match) {
      return 0;
    }
    const angle2 = parseFloat(match[2].trim().split(TRANSFORM_PARAMETER_SPLIT_REGEXP3)[0]);
    if (isNaN(angle2)) {
      return 0;
    }
    switch (match[1]) {
      case "rotate":
      case "skewX":
      case "skewY":
        return angle2;
    }
    return 0;
  }
  /**
   * Returns matrix.
   *
   * @returns Matrix.
   */
  get matrix() {
    if (!this[matrix]) {
      this[matrix] = new SVGMatrix(illegalConstructor, this[window], {
        readOnly: this[readOnly],
        getAttribute: () => {
          if (this[getAttribute]) {
            return this[getAttribute]();
          }
          return this[attributeValue];
        },
        setAttribute: (value2) => {
          this[attributeValue] = value2;
          if (this[setAttribute]) {
            this[setAttribute](value2);
            return;
          }
        }
      });
    }
    return this[matrix];
  }
  /**
   * Set matrix.
   *
   * @param matrix Matrix.
   */
  setMatrix(matrix2) {
    if (!(matrix2 instanceof SVGMatrix)) {
      throw new TypeError('Failed to set the "matrix" property on "SVGTransform": The provided value is not of type "SVGMatrix".');
    }
    if (this[readOnly]) {
      return;
    }
    if (this[matrix]) {
      this[matrix][getAttribute] = null;
      this[matrix][setAttribute] = null;
    }
    matrix2[getAttribute] = () => {
      if (this[getAttribute]) {
        return this[getAttribute]();
      }
      return this[attributeValue];
    };
    matrix2[setAttribute] = (value2) => {
      this[attributeValue] = value2;
      if (this[setAttribute]) {
        this[setAttribute](value2);
        return;
      }
    };
    this[matrix] = matrix2;
    if (matrix2[attributeValue] !== this[attributeValue]) {
      this[attributeValue] = matrix2[attributeValue];
      if (this[setAttribute]) {
        this[setAttribute](this[attributeValue]);
      }
    }
  }
  /**
   * Set translate.
   *
   * @param x X.
   * @param y Y.
   */
  setTranslate(x3, y3) {
    if (arguments.length < 2) {
      throw new TypeError(`Failed to execute 'setTranslate' on 'SVGTransform': 2 arguments required, but only ${arguments.length} present.`);
    }
    x3 = Number(x3);
    y3 = Number(y3);
    if (isNaN(x3) || isNaN(y3)) {
      throw new TypeError(`Failed to execute 'setTranslate' on 'SVGTransform':  The provided float value is non-finite.`);
    }
    if (this[readOnly]) {
      return;
    }
    this[attributeValue] = `translate(${x3} ${y3})`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Set scale.
   *
   * @param x X.
   * @param y Y.
   */
  setScale(x3, y3) {
    if (arguments.length < 2) {
      throw new TypeError(`Failed to execute 'setScale' on 'SVGTransform': 2 arguments required, but only ${arguments.length} present.`);
    }
    x3 = Number(x3);
    y3 = Number(y3);
    if (isNaN(x3) || isNaN(y3)) {
      throw new TypeError(`Failed to execute 'setScale' on 'SVGTransform':  The provided float value is non-finite.`);
    }
    if (this[readOnly]) {
      return;
    }
    this[attributeValue] = `scale(${x3} ${y3})`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Set rotate.
   *
   * @param angle Angle.
   * @param x X.
   * @param y Y.
   */
  setRotate(angle2, x3, y3) {
    if (arguments.length < 3) {
      throw new TypeError(`Failed to execute 'setRotate' on 'SVGTransform': 3 arguments required, but only ${arguments.length} present.`);
    }
    angle2 = Number(angle2);
    x3 = Number(x3);
    y3 = Number(y3);
    if (isNaN(angle2) || isNaN(x3) || isNaN(y3)) {
      throw new TypeError(`Failed to execute 'setRotate' on 'SVGTransform':  The provided float value is non-finite.`);
    }
    if (this[readOnly]) {
      return;
    }
    this[attributeValue] = `rotate(${angle2} ${x3} ${y3})`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Set skew x.
   *
   * @param angle Angle.
   */
  setSkewX(angle2) {
    if (arguments.length < 1) {
      throw new TypeError(`Failed to execute 'setSkewX' on 'SVGTransform': 1 arguments required, but only ${arguments.length} present.`);
    }
    angle2 = Number(angle2);
    if (isNaN(angle2)) {
      throw new TypeError(`Failed to execute 'setSkewX' on 'SVGTransform':  The provided float value is non-finite.`);
    }
    if (this[readOnly]) {
      return;
    }
    this[attributeValue] = `skewX(${angle2})`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Set skew y.
   *
   * @param angle Angle.
   */
  setSkewY(angle2) {
    if (arguments.length < 1) {
      throw new TypeError(`Failed to execute 'setSkewY' on 'SVGTransform': 1 arguments required, but only ${arguments.length} present.`);
    }
    angle2 = Number(angle2);
    if (isNaN(angle2)) {
      throw new TypeError(`Failed to execute 'setSkewY' on 'SVGTransform':  The provided float value is non-finite.`);
    }
    if (this[readOnly]) {
      return;
    }
    this[attributeValue] = `skewY(${angle2})`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
};

// node_modules/happy-dom/lib/svg/SVGTransformList.js
var TRANSFORM_REGEXP4 = /([a-zA-Z0-9]+)\(([^)]+)\)/gm;
var EMPTY_MATRIX = "matrix(1 0 0 1 0 0)";
var SVGTransformList = class _SVGTransformList {
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [readOnly] = false;
  [cache] = {
    items: [],
    attributeValue: ""
  };
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   * @param [options.readOnly] Read only.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[readOnly] = !!options2.readOnly;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
    const methodBinder = new ClassMethodBinder(this, [_SVGTransformList]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property === "length" || property === "numberOfItems") {
          return target2[getItemList]().length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return target2[getItemList]()[index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys(target2) {
        return Object.keys(target2[getItemList]());
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        return !isNaN(index) && index >= 0 && index < target2[getItemList]().length;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        const items2 = target2[getItemList]();
        if (!isNaN(index) && items2[index]) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[getItemList]().length;
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get numberOfItems() {
    return this[getItemList]().length;
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  [Symbol.iterator]() {
    return this[getItemList]().values();
  }
  /**
   * Clears all items from the list.
   */
  clear() {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'clear' on 'SVGTransformList': The object is read-only.`);
    }
    for (const item of this[cache].items) {
      item[getAttribute] = null;
      item[setAttribute] = null;
    }
    this[cache].items = [];
    this[cache].attributeValue = "";
    this[setAttribute]("");
  }
  /**
   * Replace Token.
   *
   * @param newItem New item.
   * @returns The item being replaced.
   */
  initialize(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGTransformList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGTransformList': 1 arguments required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGTransform)) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGTransformList': parameter 1 is not of type 'SVGTransform'.`);
    }
    for (const item of this[cache].items) {
      item[getAttribute] = null;
      item[setAttribute] = null;
    }
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || EMPTY_MATRIX).join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].items = [newItem];
    this[cache].attributeValue = newItem[attributeValue];
    this[setAttribute](newItem[attributeValue]);
    return newItem;
  }
  /**
   * Returns item at index.
   *
   * @param index Index.
   * @returns The item at the index.
   **/
  getItem(index) {
    const items2 = this[getItemList]();
    if (typeof index === "number") {
      return items2[index] ? items2[index] : null;
    }
    index = Number(index);
    index = isNaN(index) ? 0 : index;
    return items2[index] ? items2[index] : null;
  }
  /**
   * Inserts a new item into the list at the specified position. The first item is number 0. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to insert before is before the removal of the item. If the index is equal to 0, then the new item is inserted at the front of the list. If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being inserted.
   */
  insertItemBefore(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGTransformList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGTransformList': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGTransform)) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGTransformList': parameter 1 is not of type 'SVGTransform'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index > items2.length) {
      index = items2.length;
    }
    items2.splice(index, 0, newItem);
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || EMPTY_MATRIX).join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || EMPTY_MATRIX).join(" ");
    this[setAttribute](this[cache].attributeValue);
    return newItem;
  }
  /**
   * Replaces an existing item in the list with a new item. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to replace is before the removal of the item.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being replaced.
   */
  replaceItem(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGTransformList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGTransformList': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGTransform)) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGTransformList': parameter 1 is not of type 'SVGTransform'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex === index) {
      return newItem;
    }
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index >= items2.length) {
      index = items2.length - 1;
    }
    if (items2[index]) {
      items2[index][getAttribute] = null;
      items2[index][setAttribute] = null;
    }
    const replacedItem = items2[index];
    items2[index] = newItem;
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || EMPTY_MATRIX).join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || EMPTY_MATRIX).join(" ");
    this[setAttribute](this[cache].attributeValue);
    return replacedItem;
  }
  /**
   * Removes an existing item from the list.
   *
   * @param index Index.
   * @returns The removed item.
   */
  removeItem(index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGTransformList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGTransformList': 1 argument required, but only ${arguments.length} present.`);
    }
    const items2 = this[getItemList]();
    index = Number(index);
    if (isNaN(index)) {
      index = 0;
    }
    if (index >= items2.length) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGTransformList':  The index provided (${index}) is greater than the maximum bound.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index < 0) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGTransformList':  The index provided (${index}) is negative.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const removedItem = items2[index];
    if (removedItem) {
      removedItem[getAttribute] = null;
      removedItem[setAttribute] = null;
    }
    items2.splice(index, 1);
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || EMPTY_MATRIX).join(" ");
    this[setAttribute](this[cache].attributeValue);
    return removedItem;
  }
  /**
   * Appends an item to the end of the list.
   *
   * @param newItem The item to add to the list.
   * @returns The item being appended.
   */
  appendItem(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGTransformList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGTransformList': 1 argument required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGTransform)) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGTransformList': parameter 1 is not of type 'SVGTransform'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    items2.push(newItem);
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || EMPTY_MATRIX).join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || EMPTY_MATRIX).join(" ");
    this[setAttribute](this[cache].attributeValue);
    return newItem;
  }
  /**
   * Returns item list from attribute value.
   *
   * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
   */
  [getItemList]() {
    const attributeValue2 = this[getAttribute]() ?? "";
    const cache2 = this[cache];
    if (cache2.attributeValue === attributeValue2) {
      return cache2.items;
    }
    if (cache2.items.length) {
      for (const item of cache2.items) {
        item[getAttribute] = null;
        item[setAttribute] = null;
      }
    }
    const items2 = [];
    const trimmed = attributeValue2.trim();
    if (trimmed) {
      const regexp = new RegExp(TRANSFORM_REGEXP4);
      let match;
      while (match = regexp.exec(trimmed)) {
        const item = new SVGTransform(illegalConstructor, this[window], {
          readOnly: this[readOnly],
          getAttribute: () => item[attributeValue],
          setAttribute: () => {
            this[cache].attributeValue = this[getItemList]().map((item2) => item2[attributeValue] || EMPTY_MATRIX).join(" ");
            this[setAttribute](this[cache].attributeValue);
          }
        });
        item[attributeValue] = `${match[1]}(${match[2]})`;
        items2.push(item);
      }
    }
    cache2.attributeValue = attributeValue2;
    cache2.items = items2;
    return items2;
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedTransformList.js
var SVGAnimatedTransformList = class {
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [baseVal] = null;
  [animVal] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    if (!this[animVal]) {
      this[animVal] = new SVGTransformList(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: this[getAttribute],
        setAttribute: () => {
        }
      });
    }
    return this[animVal];
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    if (!this[baseVal]) {
      this[baseVal] = new SVGTransformList(illegalConstructor, this[window], {
        getAttribute: this[getAttribute],
        setAttribute: this[setAttribute]
      });
    }
    return this[baseVal];
  }
  /**
   * Returns base value.
   *
   * @param value Base value.
   */
  set baseVal(_value) {
  }
};

// node_modules/happy-dom/lib/nodes/svg-graphics-element/SVGGraphicsElement.js
var SVGGraphicsElement = class extends SVGElement {
  // Internal properties
  [requiredExtensions] = null;
  [systemLanguage] = null;
  [transform] = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get oncopy() {
    return ElementEventAttributeUtility.getEventListener(this, "oncopy");
  }
  set oncopy(value2) {
    this[propertyEventListeners].set("oncopy", value2);
  }
  get oncut() {
    return ElementEventAttributeUtility.getEventListener(this, "oncut");
  }
  set oncut(value2) {
    this[propertyEventListeners].set("oncut", value2);
  }
  get onpaste() {
    return ElementEventAttributeUtility.getEventListener(this, "onpaste");
  }
  set onpaste(value2) {
    this[propertyEventListeners].set("onpaste", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns required extensions.
   *
   * @returns Required extensions.
   */
  get requiredExtensions() {
    if (!this[requiredExtensions]) {
      this[requiredExtensions] = new SVGStringList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("requiredExtensions"),
        setAttribute: (value2) => this.setAttribute("requiredExtensions", value2)
      });
    }
    return this[requiredExtensions];
  }
  /**
   * Returns system language.
   *
   * @returns System language.
   */
  get systemLanguage() {
    if (!this[systemLanguage]) {
      this[systemLanguage] = new SVGStringList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("systemLanguage"),
        setAttribute: (value2) => this.setAttribute("systemLanguage", value2)
      });
    }
    return this[systemLanguage];
  }
  /**
   * Returns transform.
   *
   * @returns Transform.
   */
  get transform() {
    if (!this[transform]) {
      this[transform] = new SVGAnimatedTransformList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("transform"),
        setAttribute: (value2) => this.setAttribute("transform", value2)
      });
    }
    return this[transform];
  }
  /**
   * Returns DOM rect.
   *
   * @returns DOM rect.
   */
  getBBox() {
    return new DOMRect();
  }
  /**
   * Returns CTM.
   *
   * @returns CTM.
   */
  getCTM() {
    return new DOMMatrix();
  }
  /**
   * Returns screen CTM.
   *
   * @returns Screen CTM.
   */
  getScreenCTM() {
    return new DOMMatrix();
  }
};

// node_modules/happy-dom/lib/svg/SVGRect.js
var SVGRect = class {
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [attributeValue] = null;
  [readOnly] = false;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.readOnly] Read only.
   * @param [options.getAttribute] Get attribute.
   * @param [options.setAttribute] Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    if (options2) {
      this[readOnly] = !!options2.readOnly;
      this[getAttribute] = options2.getAttribute || null;
      this[setAttribute] = options2.setAttribute || null;
    }
  }
  /**
   * Returns x value.
   *
   * @returns X value.
   */
  get x() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    if (!attributeValue2) {
      return 0;
    }
    const parts = attributeValue2.split(/\s+/);
    const value2 = Number(parts[0]);
    return isNaN(value2) ? 0 : value2;
  }
  /**
   * Sets x value.
   *
   * @param value X value.
   */
  set x(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'x' property on 'SVGRect': The object is read-only.`);
    }
    this[attributeValue] = `${String(typeof value2 === "number" ? value2 : parseFloat(value2))} ${this.y} ${this.width} ${this.height}`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Returns y value.
   *
   * @returns Y value.
   */
  get y() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    if (!attributeValue2) {
      return 0;
    }
    const parts = attributeValue2.split(/\s+/);
    const value2 = Number(parts[1]);
    return isNaN(value2) ? 0 : value2;
  }
  /**
   * Sets y value.
   *
   * @param value Y value.
   */
  set y(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'y' property on 'SVGRect': The object is read-only.`);
    }
    this[attributeValue] = `${this.x} ${String(typeof value2 === "number" ? value2 : parseFloat(value2))} ${this.width} ${this.height}`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Returns width value.
   *
   * @returns Width value.
   */
  get width() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    if (!attributeValue2) {
      return 0;
    }
    const parts = attributeValue2.split(/\s+/);
    const value2 = Number(parts[2]);
    return isNaN(value2) ? 0 : value2;
  }
  /**
   * Sets width value.
   *
   * @param value Width value.
   */
  set width(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'width' property on 'SVGRect': The object is read-only.`);
    }
    this[attributeValue] = `${this.x} ${this.y} ${String(typeof value2 === "number" ? value2 : parseFloat(value2))} ${this.height}`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Returns height value.
   *
   * @returns Height value.
   */
  get height() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    if (!attributeValue2) {
      return 0;
    }
    const parts = attributeValue2.split(/\s+/);
    const value2 = Number(parts[3]);
    return isNaN(value2) ? 0 : value2;
  }
  /**
   * Sets height value.
   *
   * @param value Height value.
   */
  set height(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'height' property on 'SVGRect': The object is read-only.`);
    }
    this[attributeValue] = `${this.x} ${this.y} ${this.width} ${String(typeof value2 === "number" ? value2 : parseFloat(value2))}`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
};

// node_modules/happy-dom/lib/svg/SVGPoint.js
var ATTRIBUTE_SEPARATOR_REGEXP = /[\t\f\n\r, ]+/;
var SVGPoint = class {
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [attributeValue] = null;
  [readOnly] = false;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.readOnly] Read only.
   * @param [options.getAttribute] Get attribute.
   * @param [options.setAttribute] Set attribute
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    if (options2) {
      this[readOnly] = !!options2.readOnly;
      this[getAttribute] = options2.getAttribute || null;
      this[setAttribute] = options2.setAttribute || null;
    }
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    const parts = (attributeValue2 || "").split(ATTRIBUTE_SEPARATOR_REGEXP);
    return !!parts[0] ? parseFloat(parts[0]) : 0;
  }
  /**
   * Sets x.
   *
   * @param value X.
   */
  set x(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'x' property on 'SVGPoint': The object is read-only.`);
    }
    this[attributeValue] = `${value2} ${this.y}`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    const parts = (attributeValue2 || "").split(ATTRIBUTE_SEPARATOR_REGEXP);
    return !!parts[1] ? parseFloat(parts[1]) : 0;
  }
  /**
   * Sets y.
   *
   * @param value Y.
   */
  set y(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'y' property on 'SVGPoint': The object is read-only.`);
    }
    this[attributeValue] = `${this.x} ${value2}`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
};

// node_modules/happy-dom/lib/svg/SVGLengthTypeEnum.js
var SVGLengthTypeEnum;
(function(SVGLengthTypeEnum2) {
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["unknown"] = 0] = "unknown";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["number"] = 1] = "number";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["percentage"] = 2] = "percentage";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["ems"] = 3] = "ems";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["exs"] = 4] = "exs";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["px"] = 5] = "px";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["cm"] = 6] = "cm";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["mm"] = 7] = "mm";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["in"] = 8] = "in";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["pt"] = 9] = "pt";
  SVGLengthTypeEnum2[SVGLengthTypeEnum2["pc"] = 10] = "pc";
})(SVGLengthTypeEnum || (SVGLengthTypeEnum = {}));
var SVGLengthTypeEnum_default = SVGLengthTypeEnum;

// node_modules/happy-dom/lib/svg/SVGLength.js
var ATTRIBUTE_REGEXP3 = /^(\d+|\d+\.\d+)(px|em|ex|cm|mm|in|pt|pc|%|)$/;
var SVGLength = class {
  // Static properties
  static SVG_LENGTHTYPE_UNKNOWN = SVGLengthTypeEnum_default.unknown;
  static SVG_LENGTHTYPE_NUMBER = SVGLengthTypeEnum_default.number;
  static SVG_LENGTHTYPE_PERCENTAGE = SVGLengthTypeEnum_default.percentage;
  static SVG_LENGTHTYPE_EMS = SVGLengthTypeEnum_default.ems;
  static SVG_LENGTHTYPE_EXS = SVGLengthTypeEnum_default.exs;
  static SVG_LENGTHTYPE_PX = SVGLengthTypeEnum_default.px;
  static SVG_LENGTHTYPE_CM = SVGLengthTypeEnum_default.cm;
  static SVG_LENGTHTYPE_MM = SVGLengthTypeEnum_default.mm;
  static SVG_LENGTHTYPE_IN = SVGLengthTypeEnum_default.in;
  static SVG_LENGTHTYPE_PT = SVGLengthTypeEnum_default.pt;
  static SVG_LENGTHTYPE_PC = SVGLengthTypeEnum_default.pc;
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [attributeValue] = null;
  [readOnly] = false;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.readOnly] Read only.
   * @param [options.getAttribute] Get attribute.
   * @param [options.setAttribute] Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    if (options2) {
      this[readOnly] = !!options2.readOnly;
      this[getAttribute] = options2.getAttribute || null;
      this[setAttribute] = options2.setAttribute || null;
    }
  }
  /**
   * Returns unit type.
   *
   * @returns Unit type.
   */
  get unitType() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() || "" : this[attributeValue] || "";
    const match = attributeValue2.match(ATTRIBUTE_REGEXP3);
    if (!match) {
      return SVGLengthTypeEnum_default.unknown;
    }
    if (isNaN(parseFloat(match[1]))) {
      return SVGLengthTypeEnum_default.unknown;
    }
    switch (match[2]) {
      case "":
        return SVGLengthTypeEnum_default.number;
      case "px":
        return SVGLengthTypeEnum_default.px;
      case "cm":
        return SVGLengthTypeEnum_default.cm;
      case "mm":
        return SVGLengthTypeEnum_default.mm;
      case "in":
        return SVGLengthTypeEnum_default.in;
      case "pt":
        return SVGLengthTypeEnum_default.pt;
      case "pc":
        return SVGLengthTypeEnum_default.pc;
      case "em":
      case "ex":
      case "%":
        throw new this[window].TypeError(`Failed to execute 'value' on 'SVGLength': Could not resolve relative length.`);
      default:
        return SVGLengthTypeEnum_default.unknown;
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() || "" : this[attributeValue] || "";
    const match = attributeValue2.match(ATTRIBUTE_REGEXP3);
    if (!match) {
      return 0;
    }
    const parsedValue = parseFloat(match[1]);
    if (isNaN(parsedValue)) {
      return 0;
    }
    switch (match[2]) {
      case "":
        return parsedValue;
      case "px":
        return parsedValue;
      case "cm":
        return parsedValue / 2.54 * 96;
      case "mm":
        return parsedValue / 25.4 * 96;
      case "in":
        return parsedValue * 96;
      case "pt":
        return parsedValue * 72;
      case "pc":
        return parsedValue * 6;
      case "em":
      case "ex":
      case "%":
        throw new this[window].TypeError(`Failed to execute 'value' on 'SVGLength': Could not resolve relative length.`);
      default:
        return 0;
    }
  }
  /**
   * Sets value.
   *
   * @param value Value in pixels.
   */
  set value(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'value' property on 'SVGLength': The object is read-only.`);
    }
    value2 = typeof value2 !== "number" ? parseFloat(String(value2)) : value2;
    if (isNaN(value2)) {
      throw new this[window].TypeError(`Failed to set the 'value' property on 'SVGLength': The provided float value is non-finite.`);
    }
    let unitType2 = "";
    let valueInSpecifiedUnits = value2;
    switch (this.unitType) {
      case SVGLengthTypeEnum_default.number:
        valueInSpecifiedUnits = value2;
        unitType2 = "";
        break;
      case SVGLengthTypeEnum_default.px:
        valueInSpecifiedUnits = value2;
        unitType2 = "px";
        break;
      case SVGLengthTypeEnum_default.cm:
        valueInSpecifiedUnits = value2 / 96 * 2.54;
        unitType2 = "cm";
        break;
      case SVGLengthTypeEnum_default.mm:
        valueInSpecifiedUnits = value2 / 96 * 25.4;
        unitType2 = "mm";
        break;
      case SVGLengthTypeEnum_default.in:
        valueInSpecifiedUnits = value2 / 96;
        unitType2 = "in";
        break;
      case SVGLengthTypeEnum_default.pt:
        valueInSpecifiedUnits = value2 / 72;
        unitType2 = "pt";
        break;
      case SVGLengthTypeEnum_default.pc:
        valueInSpecifiedUnits = value2 / 6;
        unitType2 = "pc";
        break;
      case SVGLengthTypeEnum_default.percentage:
      case SVGLengthTypeEnum_default.ems:
      case SVGLengthTypeEnum_default.exs:
        throw new this[window].TypeError(`Failed to set the 'value' property on 'SVGLength': Could not resolve relative length.`);
      default:
        break;
    }
    this[attributeValue] = String(valueInSpecifiedUnits) + unitType2;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Returns value as string.
   *
   * @returns Value as string.
   */
  get valueAsString() {
    return this[getAttribute] ? this[getAttribute]() || "0" : this[attributeValue] || "0";
  }
  /**
   * Returns value in specified units.
   *
   * @returns Value in specified units.
   */
  get valueInSpecifiedUnits() {
    const attributeValue2 = this.valueAsString;
    return parseFloat(attributeValue2) || 0;
  }
  /**
   * New value specific units.
   *
   * @param unitType
   * @param value
   */
  newValueSpecifiedUnits(unitType2, value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'newValueSpecifiedUnits' on 'SVGLength': The object is read-only.`);
    }
    if (typeof unitType2 !== "number") {
      throw new this[window].TypeError(`Failed to execute 'newValueSpecifiedUnits' on 'SVGLength': parameter 1 ('unitType') is not of type 'number'.`);
    }
    value2 = typeof value2 !== "number" ? parseFloat(String(value2)) : value2;
    if (isNaN(value2)) {
      throw new this[window].TypeError(`Failed to execute 'newValueSpecifiedUnits' on 'SVGLength': The provided float value is non-finite.`);
    }
    let unit = "";
    switch (unitType2) {
      case SVGLengthTypeEnum_default.number:
        unit = "";
        break;
      case SVGLengthTypeEnum_default.px:
        unit = "px";
        break;
      case SVGLengthTypeEnum_default.cm:
        unit = "cm";
        break;
      case SVGLengthTypeEnum_default.mm:
        unit = "mm";
        break;
      case SVGLengthTypeEnum_default.in:
        unit = "in";
        break;
      case SVGLengthTypeEnum_default.pt:
        unit = "pt";
        break;
      case SVGLengthTypeEnum_default.pc:
        unit = "pc";
        break;
      case SVGLengthTypeEnum_default.ems:
      case SVGLengthTypeEnum_default.exs:
      case SVGLengthTypeEnum_default.percentage:
        throw new this[window].TypeError(`Failed to execute 'newValueSpecifiedUnits' on 'SVGLength': Could not resolve relative length.`);
      default:
        break;
    }
    this[attributeValue] = String(value2) + unit;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Convert to specific units.
   * @param unitType
   */
  convertToSpecifiedUnits(unitType2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'convertToSpecifiedUnits' on 'SVGLength': The object is read-only.`);
    }
    if (typeof unitType2 !== "number") {
      throw new this[window].TypeError(`Failed to execute 'convertToSpecifiedUnits' on 'SVGLength': parameter 1 ('unitType') is not of type 'number'.`);
    }
    let value2 = this.value;
    let unit = "";
    switch (unitType2) {
      case SVGLengthTypeEnum_default.number:
        unit = "";
        break;
      case SVGLengthTypeEnum_default.px:
        unit = "px";
        break;
      case SVGLengthTypeEnum_default.cm:
        value2 = value2 / 96 * 2.54;
        unit = "cm";
        break;
      case SVGLengthTypeEnum_default.mm:
        value2 = value2 / 96 * 25.4;
        unit = "mm";
        break;
      case SVGLengthTypeEnum_default.in:
        value2 = value2 / 96;
        unit = "in";
        break;
      case SVGLengthTypeEnum_default.pt:
        value2 = value2 / 72;
        unit = "pt";
        break;
      case SVGLengthTypeEnum_default.pc:
        value2 = value2 / 6;
        unit = "pc";
        break;
      case SVGLengthTypeEnum_default.percentage:
      case SVGLengthTypeEnum_default.ems:
      case SVGLengthTypeEnum_default.exs:
        throw new this[window].TypeError(`Failed to execute 'convertToSpecifiedUnits' on 'SVGLength': Could not resolve relative length.`);
      default:
        break;
    }
    this[attributeValue] = String(value2) + unit;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
};

// node_modules/happy-dom/lib/svg/SVGAngleTypeEnum.js
var SVGAngleTypeEnum;
(function(SVGAngleTypeEnum2) {
  SVGAngleTypeEnum2[SVGAngleTypeEnum2["unknown"] = 0] = "unknown";
  SVGAngleTypeEnum2[SVGAngleTypeEnum2["unspecified"] = 1] = "unspecified";
  SVGAngleTypeEnum2[SVGAngleTypeEnum2["deg"] = 2] = "deg";
  SVGAngleTypeEnum2[SVGAngleTypeEnum2["rad"] = 3] = "rad";
  SVGAngleTypeEnum2[SVGAngleTypeEnum2["grad"] = 4] = "grad";
})(SVGAngleTypeEnum || (SVGAngleTypeEnum = {}));
var SVGAngleTypeEnum_default = SVGAngleTypeEnum;

// node_modules/happy-dom/lib/svg/SVGAngle.js
var ATTRIBUTE_REGEXP4 = /^(\d+|\d+\.\d+)(deg|rad|grad|turn|)$/;
var SVGAngle = class {
  // Static properties
  static SVG_ANGLETYPE_UNKNOWN = SVGAngleTypeEnum_default.unknown;
  static SVG_ANGLETYPE_UNSPECIFIED = SVGAngleTypeEnum_default.unspecified;
  static SVG_ANGLETYPE_DEG = SVGAngleTypeEnum_default.deg;
  static SVG_ANGLETYPE_RAD = SVGAngleTypeEnum_default.rad;
  static SVG_ANGLETYPE_GRAD = SVGAngleTypeEnum_default.grad;
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [attributeValue] = "";
  [readOnly] = false;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.readOnly] Read only.
   * @param [options.getAttribute] Get attribute.
   * @param [options.setAttribute] Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    if (options2) {
      this[readOnly] = !!options2.readOnly;
      this[getAttribute] = options2.getAttribute || null;
      this[setAttribute] = options2.setAttribute || null;
    }
  }
  /**
   * Returns unit type.
   *
   * @returns Unit type.
   */
  get unitType() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    const match = attributeValue2?.match(ATTRIBUTE_REGEXP4);
    if (!match) {
      return SVGAngleTypeEnum_default.unknown;
    }
    if (isNaN(parseFloat(match[1]))) {
      return SVGAngleTypeEnum_default.unknown;
    }
    switch (match[2]) {
      case "":
        return SVGAngleTypeEnum_default.unspecified;
      case "deg":
        return SVGAngleTypeEnum_default.deg;
      case "rad":
        return SVGAngleTypeEnum_default.rad;
      case "grad":
        return SVGAngleTypeEnum_default.grad;
      case "turn":
        return SVGAngleTypeEnum_default.unknown;
      default:
        return SVGAngleTypeEnum_default.unspecified;
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    const match = attributeValue2?.match(ATTRIBUTE_REGEXP4);
    if (!match) {
      return 0;
    }
    const parsedValue = parseFloat(match[1]);
    if (isNaN(parsedValue)) {
      return 0;
    }
    switch (match[2]) {
      case "":
        return parsedValue;
      case "deg":
        return parsedValue;
      case "rad":
        return parsedValue * (180 / Math.PI);
      case "grad":
        return parsedValue * (180 / 200);
      case "turn":
        return parsedValue * 360;
      default:
        return parsedValue;
    }
  }
  /**
   * Sets value.
   *
   * @param value Value in pixels.
   */
  set value(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'value' property on 'SVGAngle': The object is read-only.`);
    }
    value2 = typeof value2 !== "number" ? parseFloat(String(value2)) : value2;
    if (isNaN(value2)) {
      throw new this[window].TypeError(`Failed to set the 'value' property on 'SVGAngle': The provided float value is non-finite.`);
    }
    let unitType2 = "";
    let valueInSpecifiedUnits = value2;
    switch (this.unitType) {
      case SVGAngleTypeEnum_default.unspecified:
        valueInSpecifiedUnits = value2;
        unitType2 = "";
        break;
      case SVGAngleTypeEnum_default.deg:
        valueInSpecifiedUnits = value2;
        unitType2 = "deg";
        break;
      case SVGAngleTypeEnum_default.rad:
        valueInSpecifiedUnits = value2 / (180 / Math.PI);
        unitType2 = "rad";
        break;
      case SVGAngleTypeEnum_default.grad:
        valueInSpecifiedUnits = value2 / (180 / 200);
        unitType2 = "grad";
        break;
      case SVGAngleTypeEnum_default.unknown:
        valueInSpecifiedUnits = value2 / 360;
        unitType2 = "turn";
      default:
        break;
    }
    this[attributeValue] = String(valueInSpecifiedUnits) + unitType2;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Returns value as string.
   *
   * @returns Value as string.
   */
  get valueAsString() {
    return this[getAttribute] ? this[getAttribute]() || "0" : this[attributeValue] || "0";
  }
  /**
   * Returns value in specified units.
   *
   * @returns Value in specified units.
   */
  get valueInSpecifiedUnits() {
    const attributeValue2 = this.valueAsString;
    return parseFloat(attributeValue2) || 0;
  }
  /**
   * New value specific units.
   * @param unitType
   * @param value
   */
  newValueSpecifiedUnits(unitType2, value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'newValueSpecifiedUnits' on 'SVGAngle': The object is read-only.`);
    }
    if (typeof unitType2 !== "number") {
      throw new this[window].TypeError(`Failed to execute 'newValueSpecifiedUnits' on 'SVGAngle': parameter 1 ('unitType') is not of type 'number'.`);
    }
    value2 = typeof value2 !== "number" ? parseFloat(value2) : value2;
    if (isNaN(value2)) {
      throw new this[window].TypeError(`Failed to execute 'newValueSpecifiedUnits' on 'SVGAngle': The provided float value is non-finite.`);
    }
    let unit = "";
    switch (unitType2) {
      case SVGAngleTypeEnum_default.unspecified:
        unit = "";
        break;
      case SVGAngleTypeEnum_default.deg:
        unit = "deg";
        break;
      case SVGAngleTypeEnum_default.rad:
        unit = "rad";
        break;
      case SVGAngleTypeEnum_default.grad:
        unit = "grad";
        break;
      case SVGAngleTypeEnum_default.unknown:
        unit = "turn";
        break;
      default:
        break;
    }
    this[attributeValue] = String(value2) + unit;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Convert to specific units.
   * @param unitType
   */
  convertToSpecifiedUnits(unitType2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'convertToSpecifiedUnits' on 'SVGAngle': The object is read-only.`);
    }
    if (typeof unitType2 !== "number") {
      throw new this[window].TypeError(`Failed to execute 'convertToSpecifiedUnits' on 'SVGAngle': parameter 1 ('unitType') is not of type 'number'.`);
    }
    let value2 = this.value;
    let unit = "";
    switch (unitType2) {
      case SVGAngleTypeEnum_default.unspecified:
        unit = "";
        break;
      case SVGAngleTypeEnum_default.deg:
        unit = "deg";
        break;
      case SVGAngleTypeEnum_default.rad:
        unit = "rad";
        value2 = value2 / (180 / Math.PI);
        break;
      case SVGAngleTypeEnum_default.grad:
        unit = "grad";
        value2 = value2 / (180 / 200);
        break;
      case SVGAngleTypeEnum_default.unknown:
        unit = "turn";
        value2 = value2 / 360;
        break;
      default:
        break;
    }
    this[attributeValue] = String(value2) + unit;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
};

// node_modules/happy-dom/lib/svg/SVGNumber.js
var SVGNumber = class {
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [attributeValue] = null;
  [readOnly] = false;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.readOnly] Read only.
   * @param [options.getAttribute] Get attribute.
   * @param [options.setAttribute] Set attribute
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    if (options2) {
      this[readOnly] = !!options2.readOnly;
      this[getAttribute] = options2.getAttribute || null;
      this[setAttribute] = options2.setAttribute || null;
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    return parseFloat(attributeValue2 || "0");
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    if (this[readOnly]) {
      throw new TypeError(`Failed to set the 'value' property on 'SVGNumber': The object is read-only.`);
    }
    const parsedValue = typeof value2 !== "number" ? parseFloat(String(value2)) : value2;
    if (isNaN(parsedValue)) {
      throw new TypeError(`Failed to set the 'value' property on 'SVGNumber': The provided value is not a number.`);
    }
    this[attributeValue] = String(value2);
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue] || "");
    }
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedRect.js
var SVGAnimatedRect = class {
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [baseVal] = null;
  [animVal] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    if (!this[animVal]) {
      this[animVal] = new SVGRect(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: this[getAttribute]
      });
    }
    return this[animVal];
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    if (!this[baseVal]) {
      this[baseVal] = new SVGRect(illegalConstructor, this[window], {
        getAttribute: this[getAttribute],
        setAttribute: this[setAttribute]
      });
    }
    return this[baseVal];
  }
  /**
   * Returns base value.
   *
   * @param value Base value.
   */
  set baseVal(_value) {
  }
};

// node_modules/happy-dom/lib/svg/SVGPreserveAspectRatioMeetOrSliceEnum.js
var SVGPreserveAspectRatioMeetOrSliceEnum;
(function(SVGPreserveAspectRatioMeetOrSliceEnum2) {
  SVGPreserveAspectRatioMeetOrSliceEnum2[SVGPreserveAspectRatioMeetOrSliceEnum2["unknown"] = 0] = "unknown";
  SVGPreserveAspectRatioMeetOrSliceEnum2[SVGPreserveAspectRatioMeetOrSliceEnum2["meet"] = 1] = "meet";
  SVGPreserveAspectRatioMeetOrSliceEnum2[SVGPreserveAspectRatioMeetOrSliceEnum2["slice"] = 2] = "slice";
})(SVGPreserveAspectRatioMeetOrSliceEnum || (SVGPreserveAspectRatioMeetOrSliceEnum = {}));
var SVGPreserveAspectRatioMeetOrSliceEnum_default = SVGPreserveAspectRatioMeetOrSliceEnum;

// node_modules/happy-dom/lib/svg/SVGPreserveAspectRatioAlignEnum.js
var SVGPreserveAspectRatioAlignEnum;
(function(SVGPreserveAspectRatioAlignEnum2) {
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["unknown"] = 0] = "unknown";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["none"] = 1] = "none";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMinYMin"] = 2] = "xMinYMin";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMidYMin"] = 3] = "xMidYMin";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMaxYMin"] = 4] = "xMaxYMin";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMinYMid"] = 5] = "xMinYMid";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMidYMid"] = 6] = "xMidYMid";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMaxYMid"] = 7] = "xMaxYMid";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMinYMax"] = 8] = "xMinYMax";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMidYMax"] = 9] = "xMidYMax";
  SVGPreserveAspectRatioAlignEnum2[SVGPreserveAspectRatioAlignEnum2["xMaxYMax"] = 10] = "xMaxYMax";
})(SVGPreserveAspectRatioAlignEnum || (SVGPreserveAspectRatioAlignEnum = {}));
var SVGPreserveAspectRatioAlignEnum_default = SVGPreserveAspectRatioAlignEnum;

// node_modules/happy-dom/lib/svg/SVGPreserveAspectRatio.js
var ALIGN_KEYS = Object.values(SVGPreserveAspectRatioAlignEnum_default);
ALIGN_KEYS.length = ALIGN_KEYS.indexOf(0);
var MEET_OR_SLICE_KEYS = Object.values(SVGPreserveAspectRatioMeetOrSliceEnum_default);
MEET_OR_SLICE_KEYS.length = MEET_OR_SLICE_KEYS.indexOf(0);
var SVGPreserveAspectRatio = class {
  // Static properties
  static SVG_MEETORSLICE_UNKNOWN = SVGPreserveAspectRatioMeetOrSliceEnum_default.unknown;
  static SVG_MEETORSLICE_MEET = SVGPreserveAspectRatioMeetOrSliceEnum_default.meet;
  static SVG_MEETORSLICE_SLICE = SVGPreserveAspectRatioMeetOrSliceEnum_default.slice;
  static SVG_PRESERVEASPECTRATIO_UNKNOWN = SVGPreserveAspectRatioAlignEnum_default.unknown;
  static SVG_PRESERVEASPECTRATIO_NONE = SVGPreserveAspectRatioAlignEnum_default.none;
  static SVG_PRESERVEASPECTRATIO_XMINYMIN = SVGPreserveAspectRatioAlignEnum_default.xMinYMin;
  static SVG_PRESERVEASPECTRATIO_XMIDYMIN = SVGPreserveAspectRatioAlignEnum_default.xMidYMin;
  static SVG_PRESERVEASPECTRATIO_XMAXYMIN = SVGPreserveAspectRatioAlignEnum_default.xMaxYMin;
  static SVG_PRESERVEASPECTRATIO_XMINYMID = SVGPreserveAspectRatioAlignEnum_default.xMinYMid;
  static SVG_PRESERVEASPECTRATIO_XMIDYMID = SVGPreserveAspectRatioAlignEnum_default.xMidYMid;
  static SVG_PRESERVEASPECTRATIO_XMAXYMID = SVGPreserveAspectRatioAlignEnum_default.xMaxYMid;
  static SVG_PRESERVEASPECTRATIO_XMINYMAX = SVGPreserveAspectRatioAlignEnum_default.xMinYMax;
  static SVG_PRESERVEASPECTRATIO_XMIDYMAX = SVGPreserveAspectRatioAlignEnum_default.xMidYMax;
  static SVG_PRESERVEASPECTRATIO_XMAXYMAX = SVGPreserveAspectRatioAlignEnum_default.xMaxYMax;
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [attributeValue] = null;
  [readOnly] = false;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param [options] Options.
   * @param [options.readOnly] Read only.
   * @param [options.getAttribute] Get attribute.
   * @param [options.setAttribute] Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    if (options2) {
      this[readOnly] = !!options2.readOnly;
      this[getAttribute] = options2.getAttribute || null;
      this[setAttribute] = options2.setAttribute || null;
    }
  }
  /**
   * Returns align.
   *
   * @returns Align.
   */
  get align() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    if (!attributeValue2) {
      return SVGPreserveAspectRatioAlignEnum_default.xMidYMid;
    }
    const align = attributeValue2.split(/\s+/)[0];
    if (SVGPreserveAspectRatioAlignEnum_default[align] === void 0) {
      return SVGPreserveAspectRatioAlignEnum_default.xMidYMid;
    }
    return SVGPreserveAspectRatioAlignEnum_default[align];
  }
  /**
   * Sets align.
   *
   * @param value Align.
   */
  set align(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'align' property on 'SVGPreserveAspectRatio': The object is read-only.`);
    }
    const parsedValue = Number(value2);
    if (isNaN(parsedValue) || parsedValue < 1 || parsedValue > ALIGN_KEYS.length) {
      throw new this[window].TypeError(`Failed to set the 'align' property on 'SVGPreserveAspectRatio': The alignment provided is invalid.`);
    }
    this[attributeValue] = `${ALIGN_KEYS[parsedValue]} ${MEET_OR_SLICE_KEYS[this.meetOrSlice]}`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
  /**
   * Returns meet or slice.
   *
   * @returns Meet or slice.
   */
  get meetOrSlice() {
    const attributeValue2 = this[getAttribute] ? this[getAttribute]() : this[attributeValue];
    if (!attributeValue2) {
      return SVGPreserveAspectRatioMeetOrSliceEnum_default.meet;
    }
    const meetOrSlice = attributeValue2.split(/\s+/)[1];
    if (!meetOrSlice || SVGPreserveAspectRatioMeetOrSliceEnum_default[meetOrSlice] === void 0) {
      return SVGPreserveAspectRatioMeetOrSliceEnum_default.meet;
    }
    return SVGPreserveAspectRatioMeetOrSliceEnum_default[meetOrSlice];
  }
  /**
   * Sets meet or slice.
   *
   * @param value Meet or slice.
   */
  set meetOrSlice(value2) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to set the 'meetOrSlice' property on 'SVGPreserveAspectRatio': The object is read-only.`);
    }
    const parsedValue = Number(value2);
    if (isNaN(parsedValue) || parsedValue < 1 || parsedValue > 2) {
      throw new this[window].TypeError(`Failed to set the 'meetOrSlice' property on 'SVGPreserveAspectRatio': The meetOrSlice provided is invalid.`);
    }
    this[attributeValue] = `${ALIGN_KEYS[this.align]} ${MEET_OR_SLICE_KEYS[parsedValue]}`;
    if (this[setAttribute]) {
      this[setAttribute](this[attributeValue]);
    }
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedPreserveAspectRatio.js
var SVGAnimatedPreserveAspectRatio = class {
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [baseVal] = null;
  [animVal] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    if (!this[animVal]) {
      this[animVal] = new SVGPreserveAspectRatio(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: this[getAttribute]
      });
    }
    return this[animVal];
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    if (!this[baseVal]) {
      this[baseVal] = new SVGPreserveAspectRatio(illegalConstructor, this[window], {
        getAttribute: this[getAttribute],
        setAttribute: this[setAttribute]
      });
    }
    return this[baseVal];
  }
  /**
   * Returns base value.
   *
   * @param value Base value.
   */
  set baseVal(_value) {
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedLength.js
var SVGAnimatedLength = class {
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [baseVal] = null;
  [animVal] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    if (!this[animVal]) {
      this[animVal] = new SVGLength(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: this[getAttribute]
      });
    }
    return this[animVal];
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    if (!this[baseVal]) {
      this[baseVal] = new SVGLength(illegalConstructor, this[window], {
        getAttribute: this[getAttribute],
        setAttribute: this[setAttribute]
      });
    }
    return this[baseVal];
  }
  /**
   * Returns base value.
   *
   * @param value Base value.
   */
  set baseVal(_value) {
  }
};

// node_modules/happy-dom/lib/nodes/svg-svg-element/SVGSVGElement.js
var SVGSVGElement = class extends SVGGraphicsElement {
  // Internal properties
  [preserveAspectRatio] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  [height] = null;
  [currentScale] = 1;
  [viewBox] = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onafterprint() {
    return ElementEventAttributeUtility.getEventListener(this, "onafterprint");
  }
  set onafterprint(value2) {
    this[propertyEventListeners].set("onafterprint", value2);
  }
  get onbeforeprint() {
    return ElementEventAttributeUtility.getEventListener(this, "onbeforeprint");
  }
  set onbeforeprint(value2) {
    this[propertyEventListeners].set("onbeforeprint", value2);
  }
  get onbeforeunload() {
    return ElementEventAttributeUtility.getEventListener(this, "onbeforeunload");
  }
  set onbeforeunload(value2) {
    this[propertyEventListeners].set("onbeforeunload", value2);
  }
  get ongamepadconnected() {
    return ElementEventAttributeUtility.getEventListener(this, "ongamepadconnected");
  }
  set ongamepadconnected(value2) {
    this[propertyEventListeners].set("ongamepadconnected", value2);
  }
  get ongamepaddisconnected() {
    return ElementEventAttributeUtility.getEventListener(this, "ongamepaddisconnected");
  }
  set ongamepaddisconnected(value2) {
    this[propertyEventListeners].set("ongamepaddisconnected", value2);
  }
  get onhashchange() {
    return ElementEventAttributeUtility.getEventListener(this, "onhashchange");
  }
  set onhashchange(value2) {
    this[propertyEventListeners].set("onhashchange", value2);
  }
  get onlanguagechange() {
    return ElementEventAttributeUtility.getEventListener(this, "onlanguagechange");
  }
  set onlanguagechange(value2) {
    this[propertyEventListeners].set("onlanguagechange", value2);
  }
  get onmessage() {
    return ElementEventAttributeUtility.getEventListener(this, "onmessage");
  }
  set onmessage(value2) {
    this[propertyEventListeners].set("onmessage", value2);
  }
  get onmessageerror() {
    return ElementEventAttributeUtility.getEventListener(this, "onmessageerror");
  }
  set onmessageerror(value2) {
    this[propertyEventListeners].set("onmessageerror", value2);
  }
  get onoffline() {
    return ElementEventAttributeUtility.getEventListener(this, "onoffline");
  }
  set onoffline(value2) {
    this[propertyEventListeners].set("onoffline", value2);
  }
  get ononline() {
    return ElementEventAttributeUtility.getEventListener(this, "ononline");
  }
  set ononline(value2) {
    this[propertyEventListeners].set("ononline", value2);
  }
  get onpagehide() {
    return ElementEventAttributeUtility.getEventListener(this, "onpagehide");
  }
  set onpagehide(value2) {
    this[propertyEventListeners].set("onpagehide", value2);
  }
  get onpageshow() {
    return ElementEventAttributeUtility.getEventListener(this, "onpageshow");
  }
  set onpageshow(value2) {
    this[propertyEventListeners].set("onpageshow", value2);
  }
  get onpopstate() {
    return ElementEventAttributeUtility.getEventListener(this, "onpopstate");
  }
  set onpopstate(value2) {
    this[propertyEventListeners].set("onpopstate", value2);
  }
  get onrejectionhandled() {
    return ElementEventAttributeUtility.getEventListener(this, "onrejectionhandled");
  }
  set onrejectionhandled(value2) {
    this[propertyEventListeners].set("onrejectionhandled", value2);
  }
  get onstorage() {
    return ElementEventAttributeUtility.getEventListener(this, "onstorage");
  }
  set onstorage(value2) {
    this[propertyEventListeners].set("onstorage", value2);
  }
  get onunhandledrejection() {
    return ElementEventAttributeUtility.getEventListener(this, "onunhandledrejection");
  }
  set onunhandledrejection(value2) {
    this[propertyEventListeners].set("onunhandledrejection", value2);
  }
  get onunload() {
    return ElementEventAttributeUtility.getEventListener(this, "onunload");
  }
  set onunload(value2) {
    this[propertyEventListeners].set("onunload", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns preserve aspect ratio.
   *
   * @returns Preserve aspect ratio.
   */
  get preserveAspectRatio() {
    if (!this[preserveAspectRatio]) {
      this[preserveAspectRatio] = new SVGAnimatedPreserveAspectRatio(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("preserveAspectRatio"),
        setAttribute: (value2) => this.setAttribute("preserveAspectRatio", value2)
      });
    }
    return this[preserveAspectRatio];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Returns currentScale.
   *
   * @returns CurrentScale.
   */
  get currentScale() {
    return this[currentScale];
  }
  /**
   * Sets currentScale.
   *
   * @param currentScale CurrentScale.
   */
  set currentScale(currentScale2) {
    const parsed = typeof currentScale2 !== "number" ? parseFloat(String(currentScale2)) : currentScale2;
    if (isNaN(parsed)) {
      throw this[window].TypeError(`Failed to set the 'currentScale' property on 'SVGSVGElement': The provided float value is non-finite.`);
    }
    if (parsed < 1) {
      return;
    }
    this[currentScale] = parsed;
  }
  /**
   * Returns current translate.
   *
   * @returns SVG point.
   */
  get currentTranslate() {
    return new SVGPoint(illegalConstructor, this[window]);
  }
  /**
   * Returns view box.
   *
   * @returns View box.
   */
  get viewBox() {
    if (!this[viewBox]) {
      this[viewBox] = new SVGAnimatedRect(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("viewBox"),
        setAttribute: (value2) => this.setAttribute("viewBox", value2)
      });
    }
    return this[viewBox];
  }
  /**
   * Pauses animation.
   */
  pauseAnimations() {
  }
  /**
   * Unpauses animation.
   */
  unpauseAnimations() {
  }
  /**
   * Returns "true" if animation is paused.
   *
   * @returns "true" if animation is paused.
   */
  animationsPaused() {
    return false;
  }
  /**
   * Returns the current time in seconds relative to the start time for the current SVG document fragment.
   *
   * @returns Current time in seconds.
   */
  getCurrentTime() {
    return 0;
  }
  /**
   * Sets current time.
   *
   * @param _seconds Seconds.
   */
  setCurrentTime(_seconds) {
  }
  /**
   * Returns intersection list.
   *
   * @param _rect SVG Rect.
   * @param _element SVG Element.
   * @returns Intersection list.
   */
  getIntersectionList(_rect, _element) {
    return new NodeList_default(illegalConstructor, []);
  }
  /**
   * Returns enclousure list.
   *
   * @param _rect SVG Rect.
   * @param _element SVG Element.
   * @returns Enclousure list.
   */
  getEnclosureList(_rect, _element) {
    return new NodeList_default(illegalConstructor, []);
  }
  /**
   * Returns true if the rendered content of the given element intersects the supplied rectangle.
   *
   * @param _element SVG Element.
   * @param _rect SVG Rect.
   * @returns Intersection state.
   */
  checkIntersection(_element, _rect) {
    return false;
  }
  /**
   * Returns true if the rendered content of the given element is entirely contained within the supplied rectangle.
   *
   * @param _element SVG Element.
   * @param _rect SVG Rect.
   * @returns Enclousure state.
   */
  checkEnclosure(_element, _rect) {
    return false;
  }
  /**
   * Unselects any selected objects, including any selections of text strings and type-in bars.
   */
  deselectAll() {
  }
  /**
   * Returns a number.
   *
   * @returns Number.
   */
  createSVGNumber() {
    return new SVGNumber(illegalConstructor, this[window]);
  }
  /**
   * Returns a length.
   *
   * @returns Length.
   */
  createSVGLength() {
    return new SVGLength(illegalConstructor, this[window]);
  }
  /**
   * Returns a angle.
   *
   * @returns Angle.
   */
  createSVGAngle() {
    return new SVGAngle(illegalConstructor, this[window]);
  }
  /**
   * Returns a point.
   *
   * @returns Point.
   */
  createSVGPoint() {
    return new SVGPoint(illegalConstructor, this[window]);
  }
  /**
   * Returns a matrix.
   *
   * @returns Matrix.
   */
  createSVGMatrix() {
    return new SVGMatrix(illegalConstructor, this[window]);
  }
  /**
   * Returns a rect.
   *
   * @returns Rect.
   */
  createSVGRect() {
    return new SVGRect(illegalConstructor, this[window]);
  }
  /**
   * Returns a transform.
   *
   * @returns Transform.
   */
  createSVGTransform() {
    return new SVGTransform(illegalConstructor, this[window]);
  }
  /**
   * Returns a transform from a matrix.
   *
   * @param matrix Matrix.
   */
  createSVGTransformFromMatrix(matrix2) {
    const transform2 = new SVGTransform(illegalConstructor, this[window]);
    transform2.setMatrix(matrix2);
    return transform2;
  }
  /**
   * Returns an elements by class name.
   *
   * @param className Tag name.
   * @returns Matching element.
   */
  getElementsByClassName(className) {
    return ParentNodeUtility.getElementsByClassName(this, className);
  }
  /**
   * Returns an elements by tag name.
   *
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagName(tagName2) {
    return ParentNodeUtility.getElementsByTagName(this, tagName2);
  }
  /**
   * Returns an elements by tag name and namespace.
   *
   * @param namespaceURI Namespace URI.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagNameNS(namespaceURI2, tagName2) {
    return ParentNodeUtility.getElementsByTagNameNS(this, namespaceURI2, tagName2);
  }
  /**
   * Returns an element by ID.
   *
   * @param id ID.
   * @returns Matching element.
   */
  getElementById(id2) {
    return ParentNodeUtility.getElementById(this, id2);
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
};

// node_modules/happy-dom/lib/nodes/svg-animation-element/SVGAnimationElement.js
var SVGAnimationElement = class extends SVGElement {
  // Internal properties
  [requiredExtensions] = null;
  [systemLanguage] = null;
  // Events
  /* eslint-disable jsdoc/require-jsdoc */
  get onbegin() {
    return ElementEventAttributeUtility.getEventListener(this, "onbegin");
  }
  set onbegin(value2) {
    this[propertyEventListeners].set("onbegin", value2);
  }
  get onend() {
    return ElementEventAttributeUtility.getEventListener(this, "onend");
  }
  set onend(value2) {
    this[propertyEventListeners].set("onend", value2);
  }
  get onrepeat() {
    return ElementEventAttributeUtility.getEventListener(this, "onrepeat");
  }
  set onrepeat(value2) {
    this[propertyEventListeners].set("onrepeat", value2);
  }
  /* eslint-enable jsdoc/require-jsdoc */
  /**
   * Returns required extensions.
   *
   * @returns Required extensions.
   */
  get requiredExtensions() {
    if (!this[requiredExtensions]) {
      this[requiredExtensions] = new SVGStringList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("requiredExtensions"),
        setAttribute: (value2) => this.setAttribute("requiredExtensions", value2)
      });
    }
    return this[requiredExtensions];
  }
  /**
   * Returns system language.
   *
   * @returns System language.
   */
  get systemLanguage() {
    if (!this[systemLanguage]) {
      this[systemLanguage] = new SVGStringList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("systemLanguage"),
        setAttribute: (value2) => this.setAttribute("systemLanguage", value2)
      });
    }
    return this[systemLanguage];
  }
  /**
   * Returns target element.
   *
   * @returns Target element.
   */
  get targetElement() {
    return null;
  }
};

// node_modules/happy-dom/lib/nodes/svg-animate-element/SVGAnimateElement.js
var SVGAnimateElement = class extends SVGAnimationElement {
};

// node_modules/happy-dom/lib/nodes/svg-animate-motion-element/SVGAnimateMotionElement.js
var SVGAnimateMotionElement = class extends SVGAnimationElement {
};

// node_modules/happy-dom/lib/nodes/svg-animate-transform-element/SVGAnimateTransformElement.js
var SVGAnimateTransformElement = class extends SVGAnimationElement {
};

// node_modules/happy-dom/lib/svg/SVGAnimatedNumber.js
var SVGAnimatedNumber = class {
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [defaultValue] = 0;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   * @param options.defaultValue
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
    this[defaultValue] = options2.defaultValue || 0;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    return this.baseVal;
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    const attributeValue2 = this[getAttribute]();
    if (!attributeValue2) {
      return this[defaultValue];
    }
    const value2 = parseFloat(attributeValue2);
    if (isNaN(value2)) {
      return this[defaultValue];
    }
    return value2;
  }
  /**
   * Sets base value.
   *
   * @param value Base value.
   */
  set baseVal(value2) {
    const parsedValue = typeof value2 !== "number" ? parseFloat(value2) : value2;
    if (isNaN(parsedValue)) {
      throw new this[window].TypeError(`TypeError: Failed to set the 'baseVal' property on 'SVGAnimatedNumber': The provided float value is non-finite.`);
    }
    this[setAttribute](String(parsedValue));
  }
};

// node_modules/happy-dom/lib/nodes/svg-geometry-element/SVGGeometryElement.js
var SVGGeometryElement = class extends SVGGraphicsElement {
  // Internal properties
  [pathLength] = null;
  /**
   * Returns path length.
   *
   * @returns Path length.
   */
  get pathLength() {
    if (!this[pathLength]) {
      this[pathLength] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("pathLength"),
        setAttribute: (value2) => this.setAttribute("pathLength", value2)
      });
    }
    return this[pathLength];
  }
  /**
   * Returns true if the point is in the fill of the element.
   *
   * Not implemented yet.
   *
   * @param point Point.
   * @returns True if the point is in the fill of the element.
   */
  isPointInFill(point) {
    if (!(point instanceof SVGPoint)) {
      throw new TypeError(`Failed to execute 'isPointInFill' on 'SVGGeometryElement': parameter 1 is not of type 'SVGPoint'.`);
    }
    return false;
  }
  /**
   * Returns true if the point is in the stroke of the element.
   *
   * Not implemented yet.
   *
   * @param point Point.
   * @returns True if the point is in the stroke of the element.
   */
  isPointInStroke(point) {
    if (!(point instanceof SVGPoint)) {
      throw new TypeError(`Failed to execute 'isPointInFill' on 'SVGGeometryElement': parameter 1 is not of type 'SVGPoint'.`);
    }
    return false;
  }
  /**
   * Returns total length.
   *
   * Not implemented yet.
   *
   * @returns Total length.
   */
  getTotalLength() {
    return 0;
  }
  /**
   * Returns point at length.
   *
   * Not implemented yet.
   *
   * @param _distance Distance.
   * @returns Point at length.
   */
  getPointAtLength(_distance) {
    return new SVGPoint(illegalConstructor, this[window]);
  }
};

// node_modules/happy-dom/lib/nodes/svg-circle-element/SVGCircleElement.js
var SVGCircleElement = class extends SVGGeometryElement {
  // Internal properties
  [cx] = null;
  [cy] = null;
  [r] = null;
  /**
   * Returns cx.
   *
   * @returns Cx.
   */
  get cx() {
    if (!this[cx]) {
      this[cx] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("cx"),
        setAttribute: (value2) => this.setAttribute("cx", value2)
      });
    }
    return this[cx];
  }
  /**
   * Returns cy.
   *
   * @returns Cy.
   */
  get cy() {
    if (!this[cy]) {
      this[cy] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("cy"),
        setAttribute: (value2) => this.setAttribute("cy", value2)
      });
    }
    return this[cy];
  }
  /**
   * Returns r.
   *
   * @returns R.
   */
  get r() {
    if (!this[r]) {
      this[r] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("r"),
        setAttribute: (value2) => this.setAttribute("r", value2)
      });
    }
    return this[r];
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedEnumeration.js
var SVGAnimatedEnumeration = class {
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [values];
  [defaultValue];
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   * @param options.values Values.
   * @param options.defaultValue Default value.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
    this[values] = options2.values;
    this[defaultValue] = options2.defaultValue;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    return this.baseVal;
  }
  /**
   * Returns animated value.
   *
   * @param _value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    const value2 = this[getAttribute]();
    if (!value2) {
      return this[values].indexOf(this[defaultValue]) + 1;
    }
    const index = this[values].indexOf(value2);
    if (index === -1) {
      const anyValueIndex = this[values].indexOf(null);
      return anyValueIndex !== -1 ? anyValueIndex + 1 : 0;
    }
    return index + 1;
  }
  /**
   * Sets base value.
   *
   * @param value Base value.
   */
  set baseVal(value2) {
    let parsedValue = Number(value2);
    if (isNaN(parsedValue)) {
      parsedValue = 0;
    }
    if (parsedValue < 1) {
      throw new TypeError(`Failed to set the 'baseVal' property on 'SVGAnimatedEnumeration': The enumeration value provided is ${parsedValue}, which is not settable.`);
    }
    if (parsedValue > this[values].length) {
      throw new TypeError(`Failed to set the 'baseVal' property on 'SVGAnimatedEnumeration': The enumeration value provided (${parsedValue}) is larger than the largest allowed value (${this[values].length}).`);
    }
    const currentValue = this[getAttribute]();
    const isAnyValue = this[values][parsedValue - 1] === null;
    const newValue = isAnyValue ? "0" : this[values][parsedValue - 1];
    if (!currentValue || isAnyValue && this[values].includes(currentValue) || !isAnyValue && currentValue !== newValue) {
      this[setAttribute](newValue);
    }
  }
};

// node_modules/happy-dom/lib/nodes/svg-clip-path-element/SVGClipPathElement.js
var SVGClipPathElement = class extends SVGElement {
  // Internal properties
  [clipPathUnits] = null;
  /**
   * Returns clipPathUnits.
   *
   * @returns ClipPathUnits.
   */
  get clipPathUnits() {
    if (!this[clipPathUnits]) {
      this[clipPathUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("clipPathUnits"),
        setAttribute: (value2) => this.setAttribute("clipPathUnits", value2),
        values: ["userSpaceOnUse", "objectBoundingBox"],
        defaultValue: "userSpaceOnUse"
      });
    }
    return this[clipPathUnits];
  }
};

// node_modules/happy-dom/lib/nodes/svg-defs-element/SVGDefsElement.js
var SVGDefsElement = class extends SVGGraphicsElement {
};

// node_modules/happy-dom/lib/nodes/svg-desc-element/SVGDescElement.js
var SVGDescElement = class extends SVGElement {
};

// node_modules/happy-dom/lib/nodes/svg-ellipse-element/SVGEllipseElement.js
var SVGEllipseElement = class extends SVGGeometryElement {
  // Internal properties
  [cx] = null;
  [cy] = null;
  [rx] = null;
  [ry] = null;
  /**
   * Returns cx.
   *
   * @returns Cx.
   */
  get cx() {
    if (!this[cx]) {
      this[cx] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("cx"),
        setAttribute: (value2) => this.setAttribute("cx", value2)
      });
    }
    return this[cx];
  }
  /**
   * Returns cy.
   *
   * @returns Cy.
   */
  get cy() {
    if (!this[cy]) {
      this[cy] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("cy"),
        setAttribute: (value2) => this.setAttribute("cy", value2)
      });
    }
    return this[cy];
  }
  /**
   * Returns rx.
   *
   * @returns Rx.
   */
  get rx() {
    if (!this[rx]) {
      this[rx] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("rx"),
        setAttribute: (value2) => this.setAttribute("rx", value2)
      });
    }
    return this[rx];
  }
  /**
   * Returns ry.
   *
   * @returns Ry.
   */
  get ry() {
    if (!this[ry]) {
      this[ry] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("ry"),
        setAttribute: (value2) => this.setAttribute("ry", value2)
      });
    }
    return this[ry];
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedString.js
var SVGAnimatedString = class {
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    return this.baseVal;
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    const attributeValue2 = this[getAttribute]();
    if (!attributeValue2) {
      return "";
    }
    return attributeValue2;
  }
  /**
   * Sets base value.
   *
   * @param value Base value.
   */
  set baseVal(value2) {
    this[setAttribute](String(value2));
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-blend-element/SVGFEBlendElement.js
var SVGFEBlendElement = class extends SVGElement {
  // Static properties
  static SVG_FEBLEND_MODE_UNKNOWN = 0;
  static SVG_FEBLEND_MODE_NORMAL = 1;
  static SVG_FEBLEND_MODE_MULTIPLY = 2;
  static SVG_FEBLEND_MODE_SCREEN = 3;
  static SVG_FEBLEND_MODE_DARKEN = 4;
  static SVG_FEBLEND_MODE_LIGHTEN = 5;
  static SVG_FEBLEND_MODE_OVERLAY = 6;
  static SVG_FEBLEND_MODE_COLOR_DODGE = 7;
  static SVG_FEBLEND_MODE_COLOR_BURN = 8;
  static SVG_FEBLEND_MODE_HARD_LIGHT = 9;
  static SVG_FEBLEND_MODE_SOFT_LIGHT = 10;
  static SVG_FEBLEND_MODE_DIFFERENCE = 11;
  static SVG_FEBLEND_MODE_EXCLUSION = 12;
  static SVG_FEBLEND_MODE_HUE = 13;
  static SVG_FEBLEND_MODE_SATURATION = 14;
  static SVG_FEBLEND_MODE_COLOR = 15;
  static SVG_FEBLEND_MODE_LUMINOSITY = 16;
  // Internal properties
  [height] = null;
  [in1] = null;
  [in2] = null;
  [mode] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns in2.
   *
   * @returns In2.
   */
  get in2() {
    if (!this[in2]) {
      this[in2] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in2"),
        setAttribute: (value2) => this.setAttribute("in2", value2)
      });
    }
    return this[in2];
  }
  /**
   * Returns mode.
   *
   * @returns Mode.
   */
  get mode() {
    if (!this[mode]) {
      this[mode] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("mode"),
        setAttribute: (value2) => this.setAttribute("mode", value2),
        values: [
          "normal",
          "multiply",
          "screen",
          "darken",
          "lighten",
          "overlay",
          "color-dodge",
          "color-burn",
          "hard-light",
          "soft-light",
          "difference",
          "exclusion",
          "hue",
          "saturation",
          "color",
          "luminosity"
        ],
        defaultValue: "normal"
      });
    }
    return this[mode];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/svg/SVGNumberList.js
var ATTRIBUTE_SEPARATOR_REGEXP2 = /[\t\f\n\r, ]+/;
var SVGNumberList = class _SVGNumberList {
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [readOnly] = false;
  [cache] = {
    items: [],
    attributeValue: ""
  };
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param [options.readOnly] Read only.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[readOnly] = !!options2.readOnly;
    this[getAttribute] = options2.getAttribute || null;
    this[setAttribute] = options2.setAttribute || null;
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    const methodBinder = new ClassMethodBinder(this, [_SVGNumberList]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property === "length" || property === "numberOfItems") {
          return target2[getItemList]().length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return target2[getItemList]()[index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys(target2) {
        return Object.keys(target2[getItemList]());
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        return !isNaN(index) && index >= 0 && index < target2[getItemList]().length;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        const items2 = target2[getItemList]();
        if (!isNaN(index) && items2[index]) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[getItemList]().length;
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get numberOfItems() {
    return this[getItemList]().length;
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  [Symbol.iterator]() {
    return this[getItemList]().values();
  }
  /**
   * Clears all items from the list.
   */
  clear() {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'clear' on 'SVGNumberList': The object is read-only.`);
    }
    for (const item of this[cache].items) {
      item[getAttribute] = null;
      item[setAttribute] = null;
    }
    this[cache].items = [];
    this[cache].attributeValue = "";
    this[setAttribute]("");
  }
  /**
   * Replace Token.
   *
   * @param newItem New item.
   * @returns The item being replaced.
   */
  initialize(newItem) {
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGNumberList': 1 arguments required, but only ${arguments.length} present.`);
    }
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGNumberList': The object is read-only.`);
    }
    for (const item of this[cache].items) {
      item[getAttribute] = null;
      item[setAttribute] = null;
    }
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || "0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].items = [newItem];
    this[cache].attributeValue = newItem[attributeValue];
    this[setAttribute](newItem[attributeValue]);
    return newItem;
  }
  /**
   * Returns item at index.
   *
   * @param index Index.
   * @returns The item at the index.
   **/
  getItem(index) {
    const items2 = this[getItemList]();
    if (typeof index === "number") {
      return items2[index] ? items2[index] : null;
    }
    index = Number(index);
    index = isNaN(index) ? 0 : index;
    return items2[index] ? items2[index] : null;
  }
  /**
   * Inserts a new item into the list at the specified position. The first item is number 0. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to insert before is before the removal of the item. If the index is equal to 0, then the new item is inserted at the front of the list. If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being inserted.
   */
  insertItemBefore(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGNumberList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGNumberList': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGNumber)) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGNumberList': parameter 1 is not of type 'SVGNumber'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index > items2.length) {
      index = items2.length;
    }
    items2.splice(index, 0, newItem);
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || "0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || "0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return newItem;
  }
  /**
   * Replaces an existing item in the list with a new item. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to replace is before the removal of the item.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being replaced.
   */
  replaceItem(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGNumberList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGNumberList': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGNumber)) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGNumberList': parameter 1 is not of type 'SVGNumber'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex === index) {
      return newItem;
    }
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index >= items2.length) {
      index = items2.length - 1;
    }
    if (items2[index]) {
      items2[index][getAttribute] = null;
      items2[index][setAttribute] = null;
    }
    const replacedItem = items2[index];
    items2[index] = newItem;
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || "0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || "0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return replacedItem;
  }
  /**
   * Removes an existing item from the list.
   *
   * @param index Index.
   * @returns The removed item.
   */
  removeItem(index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGNumberList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGNumberList': 1 argument required, but only ${arguments.length} present.`);
    }
    const items2 = this[getItemList]();
    index = Number(index);
    if (isNaN(index)) {
      index = 0;
    }
    if (index >= items2.length) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGNumberList':  The index provided (${index}) is greater than the maximum bound.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index < 0) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGNumberList':  The index provided (${index}) is negative.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const removedItem = items2[index];
    if (removedItem) {
      removedItem[getAttribute] = null;
      removedItem[setAttribute] = null;
    }
    items2.splice(index, 1);
    this[setAttribute](items2.map((item) => item[attributeValue] || "0").join(" "));
    return removedItem;
  }
  /**
   * Appends an item to the end of the list.
   *
   * @param newItem The item to add to the list.
   * @returns The item being appended.
   */
  appendItem(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGNumberList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGNumberList': 1 argument required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGNumber)) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGNumberList': parameter 1 is not of type 'SVGNumber'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    items2.push(newItem);
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || "0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || "0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return newItem;
  }
  /**
   * Returns item list from attribute value.
   *
   * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
   */
  [getItemList]() {
    const attributeValue2 = this[getAttribute]() ?? "";
    const cache2 = this[cache];
    if (cache2.attributeValue === attributeValue2) {
      return cache2.items;
    }
    if (cache2.items.length) {
      for (const item of cache2.items) {
        item[getAttribute] = null;
        item[setAttribute] = null;
      }
    }
    const items2 = [];
    const trimmed = attributeValue2.trim();
    if (trimmed) {
      const parts = trimmed.split(ATTRIBUTE_SEPARATOR_REGEXP2);
      for (let i = 0, max = parts.length; i < max; i++) {
        const item = new SVGNumber(illegalConstructor, this[window], {
          readOnly: this[readOnly],
          getAttribute: () => item[attributeValue],
          setAttribute: () => {
            this[cache].attributeValue = this[getItemList]().map((item2) => item2[attributeValue] || "0").join(" ");
            this[setAttribute](this[cache].attributeValue);
          }
        });
        item[attributeValue] = String(parseFloat(parts[i]));
        items2.push(item);
      }
    }
    cache2.attributeValue = attributeValue2;
    cache2.items = items2;
    return items2;
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedNumberList.js
var SVGAnimatedNumberList = class {
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [baseVal] = null;
  [animVal] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    if (!this[animVal]) {
      this[animVal] = new SVGNumberList(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: this[getAttribute],
        setAttribute: () => {
        }
      });
    }
    return this[animVal];
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    if (!this[baseVal]) {
      this[baseVal] = new SVGNumberList(illegalConstructor, this[window], {
        getAttribute: this[getAttribute],
        setAttribute: this[setAttribute]
      });
    }
    return this[baseVal];
  }
  /**
   * Sets base value.
   *
   * @param value Base value.
   */
  set baseVal(_value) {
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-color-matrix-element/SVGFEColorMatrixElement.js
var SVGFEColorMatrixElement = class extends SVGElement {
  // Static properties
  static SVG_FEBLEND_TYPE_UNKNOWN = 0;
  static SVG_FEBLEND_TYPE_MATRIX = 1;
  static SVG_FEBLEND_TYPE_SATURATE = 2;
  static SVG_FEBLEND_TYPE_HUEROTATE = 3;
  static SVG_FEBLEND_TYPE_LUMINANCETOALPHA = 4;
  // Internal properties
  [height] = null;
  [in1] = null;
  [in2] = null;
  [result] = null;
  [type] = null;
  [values] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns in2.
   *
   * @returns In2.
   */
  get in2() {
    if (!this[in2]) {
      this[in2] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in2"),
        setAttribute: (value2) => this.setAttribute("in2", value2)
      });
    }
    return this[in2];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    if (!this[type]) {
      this[type] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("type"),
        setAttribute: (value2) => this.setAttribute("type", value2),
        values: ["matrix", "saturate", "huerotate", "luminancetoalpha"],
        defaultValue: "matrix"
      });
    }
    return this[type];
  }
  /**
   * Returns values.
   *
   * @returns Values.
   */
  get values() {
    if (!this[values]) {
      this[values] = new SVGAnimatedNumberList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("values"),
        setAttribute: (value2) => this.setAttribute("values", value2)
      });
    }
    return this[values];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-component-transfer-element/SVGFEComponentTransferElement.js
var SVGFEComponentTransferElement = class extends SVGElement {
  // Internal properties
  [height] = null;
  [in1] = null;
  [result] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-composite-element/SVGFECompositeElement.js
var SVGFECompositeElement = class extends SVGElement {
  // Static properties
  static SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;
  static SVG_FECOMPOSITE_OPERATOR_OVER = 1;
  static SVG_FECOMPOSITE_OPERATOR_IN = 2;
  static SVG_FECOMPOSITE_OPERATOR_OUT = 3;
  static SVG_FECOMPOSITE_OPERATOR_ATOP = 4;
  static SVG_FECOMPOSITE_OPERATOR_XOR = 5;
  static SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;
  // Internal properties
  [height] = null;
  [in1] = null;
  [result] = null;
  [type] = null;
  [values] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    if (!this[type]) {
      this[type] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("type"),
        setAttribute: (value2) => this.setAttribute("type", value2),
        values: ["over", "in", "out", "atop", "xor", "arithmetic"],
        defaultValue: "over"
      });
    }
    return this[type];
  }
  /**
   * Returns values.
   *
   * @returns Values.
   */
  get values() {
    if (!this[values]) {
      this[values] = new SVGAnimatedNumberList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("values"),
        setAttribute: (value2) => this.setAttribute("values", value2)
      });
    }
    return this[values];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedBoolean.js
var SVGAnimatedBoolean = class {
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    return this.baseVal;
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    const attributeValue2 = this[getAttribute]();
    return attributeValue2 === "true";
  }
  /**
   * Sets base value.
   *
   * @param value Base value.
   */
  set baseVal(value2) {
    this[setAttribute](typeof value2 !== "boolean" ? String(Boolean(value2)) : String(value2));
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedInteger.js
var SVGAnimatedInteger = class {
  // Internal properties
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    return this.baseVal;
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    const attributeValue2 = this[getAttribute]();
    if (!attributeValue2) {
      return 0;
    }
    const value2 = parseInt(attributeValue2);
    if (isNaN(value2)) {
      return 0;
    }
    return value2;
  }
  /**
   * Sets base value.
   *
   * @param value Base value.
   */
  set baseVal(value2) {
    const parsedValue = parseInt(String(value2));
    if (isNaN(parsedValue)) {
      throw new this[window].TypeError(`TypeError: Failed to set the 'baseVal' property on 'SVGAnimatedInteger': The provided float value is non-finite.`);
    }
    this[setAttribute](String(parsedValue));
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-convolve-matrix-element/SVGFEConvolveMatrixElement.js
var SVGFEConvolveMatrixElement = class extends SVGElement {
  // Static properties
  static SVG_EDGEMODE_UNKNOWN = 0;
  static SVG_EDGEMODE_DUPLICATE = 1;
  static SVG_EDGEMODE_WRAP = 2;
  static SVG_EDGEMODE_NONE = 3;
  // Internal properties
  [bias] = null;
  [divisor] = null;
  [edgeMode] = null;
  [height] = null;
  [in1] = null;
  [kernelMatrix] = null;
  [kernelUnitLengthX] = null;
  [kernelUnitLengthY] = null;
  [orderX] = null;
  [orderY] = null;
  [preserveAlpha] = null;
  [result] = null;
  [targetX] = null;
  [targetY] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns bias.
   *
   * @returns Bias.
   */
  get bias() {
    if (!this[bias]) {
      this[bias] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("bias"),
        setAttribute: (value2) => this.setAttribute("bias", value2)
      });
    }
    return this[bias];
  }
  /**
   * Returns divisor.
   *
   * @returns Divisor.
   */
  get divisor() {
    if (!this[divisor]) {
      this[divisor] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("divisor"),
        setAttribute: (value2) => this.setAttribute("divisor", value2)
      });
    }
    return this[divisor];
  }
  /**
   * Returns edge mode.
   *
   * @returns Edge mode.
   */
  get edgeMode() {
    if (!this[edgeMode]) {
      this[edgeMode] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("edgeMode"),
        setAttribute: (value2) => this.setAttribute("edgeMode", value2),
        values: ["duplicate", "wrap", "none"],
        defaultValue: "duplicate"
      });
    }
    return this[edgeMode];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns kernel matrix.
   *
   * @returns Kernel matrix.
   */
  get kernelMatrix() {
    if (!this[kernelMatrix]) {
      this[kernelMatrix] = new SVGAnimatedNumberList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("kernelMatrix"),
        setAttribute: (value2) => this.setAttribute("kernelMatrix", value2)
      });
    }
    return this[kernelMatrix];
  }
  /**
   * Returns kernel unit length x.
   *
   * @returns Kernel unit length x.
   */
  get kernelUnitLengthX() {
    if (!this[kernelUnitLengthX]) {
      this[kernelUnitLengthX] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("kernelUnitLengthX"),
        setAttribute: (value2) => this.setAttribute("kernelUnitLengthX", value2)
      });
    }
    return this[kernelUnitLengthX];
  }
  /**
   * Returns kernel unit length y.
   *
   * @returns Kernel unit length y.
   */
  get kernelUnitLengthY() {
    if (!this[kernelUnitLengthY]) {
      this[kernelUnitLengthY] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("kernelUnitLengthY"),
        setAttribute: (value2) => this.setAttribute("kernelUnitLengthY", value2)
      });
    }
    return this[kernelUnitLengthY];
  }
  /**
   * Returns order x.
   *
   * @returns Order x.
   */
  get orderX() {
    if (!this[orderX]) {
      this[orderX] = new SVGAnimatedInteger(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("orderX"),
        setAttribute: (value2) => this.setAttribute("orderX", value2)
      });
    }
    return this[orderX];
  }
  /**
   * Returns order y.
   *
   * @returns Order y.
   */
  get orderY() {
    if (!this[orderY]) {
      this[orderY] = new SVGAnimatedInteger(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("orderY"),
        setAttribute: (value2) => this.setAttribute("orderY", value2)
      });
    }
    return this[orderY];
  }
  /**
   * Returns preserve alpha.
   *
   * @returns Preserve alpha.
   */
  get preserveAlpha() {
    if (!this[preserveAlpha]) {
      this[preserveAlpha] = new SVGAnimatedBoolean(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("preserveAlpha"),
        setAttribute: (value2) => this.setAttribute("preserveAlpha", value2)
      });
    }
    return this[preserveAlpha];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns target x.
   *
   * @returns Target x.
   */
  get targetX() {
    if (!this[targetX]) {
      this[targetX] = new SVGAnimatedInteger(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("targetX"),
        setAttribute: (value2) => this.setAttribute("targetX", value2)
      });
    }
    return this[targetX];
  }
  /**
   * Returns target y.
   *
   * @returns Target y.
   */
  get targetY() {
    if (!this[targetY]) {
      this[targetY] = new SVGAnimatedInteger(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("targetY"),
        setAttribute: (value2) => this.setAttribute("targetY", value2)
      });
    }
    return this[targetY];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-diffuse-lighting-element/SVGFEDiffuseLightingElement.js
var SVGFEDiffuseLightingElement = class extends SVGElement {
  // Internal properties
  [diffuseConstant] = null;
  [height] = null;
  [in1] = null;
  [kernelUnitLengthX] = null;
  [kernelUnitLengthY] = null;
  [result] = null;
  [surfaceScale] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns diffuse constant.
   *
   * @returns Diffuse constant.
   */
  get diffuseConstant() {
    if (!this[diffuseConstant]) {
      this[diffuseConstant] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("diffuseConstant"),
        setAttribute: (value2) => this.setAttribute("diffuseConstant", value2)
      });
    }
    return this[diffuseConstant];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns kernel unit length x.
   *
   * @returns Kernel unit length x.
   */
  get kernelUnitLengthX() {
    if (!this[kernelUnitLengthX]) {
      this[kernelUnitLengthX] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("kernelUnitLengthX"),
        setAttribute: (value2) => this.setAttribute("kernelUnitLengthX", value2)
      });
    }
    return this[kernelUnitLengthX];
  }
  /**
   * Returns kernel unit length y.
   *
   * @returns Kernel unit length y.
   */
  get kernelUnitLengthY() {
    if (!this[kernelUnitLengthY]) {
      this[kernelUnitLengthY] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("kernelUnitLengthY"),
        setAttribute: (value2) => this.setAttribute("kernelUnitLengthY", value2)
      });
    }
    return this[kernelUnitLengthY];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns surface scale.
   *
   * @returns Surface scale.
   */
  get surfaceScale() {
    if (!this[surfaceScale]) {
      this[surfaceScale] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("surfaceScale"),
        setAttribute: (value2) => this.setAttribute("surfaceScale", value2)
      });
    }
    return this[surfaceScale];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-displacement-map-element/SVGFEDisplacementMapElement.js
var SVGFEDisplacementMapElement = class extends SVGElement {
  // Static properties
  static SVG_CHANNEL_UNKNOWN = 0;
  static SVG_CHANNEL_R = 1;
  static SVG_CHANNEL_G = 2;
  static SVG_CHANNEL_B = 3;
  static SVG_CHANNEL_A = 4;
  // Internal properties
  [height] = null;
  [in1] = null;
  [in2] = null;
  [result] = null;
  [scale] = null;
  [width] = null;
  [x] = null;
  [xChannelSelector] = null;
  [y] = null;
  [yChannelSelector] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns in2.
   *
   * @returns In2.
   */
  get in2() {
    if (!this[in2]) {
      this[in2] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in2"),
        setAttribute: (value2) => this.setAttribute("in2", value2)
      });
    }
    return this[in2];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns scale.
   *
   * @returns Scale.
   */
  get scale() {
    if (!this[scale]) {
      this[scale] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("scale"),
        setAttribute: (value2) => this.setAttribute("scale", value2)
      });
    }
    return this[scale];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns x channel selector.
   *
   * @returns X channel selector.
   */
  get xChannelSelector() {
    if (!this[xChannelSelector]) {
      this[xChannelSelector] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("xChannelSelector"),
        setAttribute: (value2) => this.setAttribute("xChannelSelector", value2),
        values: ["r", "g", "b", "a"],
        defaultValue: "r"
      });
    }
    return this[xChannelSelector];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Returns y channel selector.
   *
   * @returns Y channel selector.
   */
  get yChannelSelector() {
    if (!this[yChannelSelector]) {
      this[yChannelSelector] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("yChannelSelector"),
        setAttribute: (value2) => this.setAttribute("yChannelSelector", value2),
        values: ["r", "g", "b", "a"],
        defaultValue: "r"
      });
    }
    return this[yChannelSelector];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-distant-light-element/SVGFEDistantLightElement.js
var SVGFEDistantLightElement = class extends SVGElement {
  // Internal properties
  [azimuth] = null;
  [elevation] = null;
  /**
   * Returns azimuth.
   *
   * @returns Azimuth.
   */
  get azimuth() {
    if (!this[azimuth]) {
      this[azimuth] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("azimuth"),
        setAttribute: (value2) => this.setAttribute("azimuth", value2)
      });
    }
    return this[azimuth];
  }
  /**
   * Returns elevation.
   *
   * @returns Elevation.
   */
  get elevation() {
    if (!this[elevation]) {
      this[elevation] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("elevation"),
        setAttribute: (value2) => this.setAttribute("elevation", value2)
      });
    }
    return this[elevation];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-drop-shadow-element/SVGFEDropShadowElement.js
var SVGFEDropShadowElement = class extends SVGElement {
  // Internal properties
  [dx] = null;
  [dy] = null;
  [height] = null;
  [in1] = null;
  [result] = null;
  [stdDeviationX] = null;
  [stdDeviationY] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns dx.
   *
   * @returns Dx.
   */
  get dx() {
    if (!this[dx]) {
      this[dx] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("dx"),
        setAttribute: (value2) => this.setAttribute("dx", value2)
      });
    }
    return this[dx];
  }
  /**
   * Returns dy.
   *
   * @returns Dy.
   */
  get dy() {
    if (!this[dy]) {
      this[dy] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("dy"),
        setAttribute: (value2) => this.setAttribute("dy", value2)
      });
    }
    return this[dy];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns stdDeviationX.
   *
   * @returns StdDeviationX.
   */
  get stdDeviationX() {
    if (!this[stdDeviationX]) {
      this[stdDeviationX] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("stdDeviationX"),
        setAttribute: (value2) => this.setAttribute("stdDeviationX", value2),
        defaultValue: 2
      });
    }
    return this[stdDeviationX];
  }
  /**
   * Returns stdDeviationY.
   *
   * @returns StdDeviationY.
   */
  get stdDeviationY() {
    if (!this[stdDeviationY]) {
      this[stdDeviationY] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("stdDeviationY"),
        setAttribute: (value2) => this.setAttribute("stdDeviationY", value2),
        defaultValue: 2
      });
    }
    return this[stdDeviationY];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Sets stdDeviation.
   *
   * @param x X.
   * @param y Y.
   */
  setStdDeviation(x3, y3) {
    this.stdDeviationX.baseVal = x3;
    this.stdDeviationY.baseVal = y3;
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-flood-element/SVGFEFloodElement.js
var SVGFEFloodElement = class extends SVGElement {
  // Internal properties
  [height] = null;
  [result] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-component-transfer-function-element/SVGComponentTransferFunctionElement.js
var SVGComponentTransferFunctionElement = class extends SVGElement {
  // Static properties
  static SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0;
  static SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1;
  static SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2;
  static SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3;
  static SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4;
  static SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5;
  // Internal properties
  [type] = null;
  [tableValues] = null;
  [slope] = null;
  [intercept] = null;
  [amplitude] = null;
  [exponent] = null;
  [offset] = null;
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    if (!this[type]) {
      this[type] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("type"),
        setAttribute: (value2) => this.setAttribute("type", value2),
        values: ["identity", "table", "discrete", "linear", "gamma"],
        defaultValue: "identity"
      });
    }
    return this[type];
  }
  /**
   * Returns table values.
   *
   * @returns Table values.
   */
  get tableValues() {
    if (!this[tableValues]) {
      this[tableValues] = new SVGAnimatedNumberList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("tableValues"),
        setAttribute: (value2) => this.setAttribute("tableValues", value2)
      });
    }
    return this[tableValues];
  }
  /**
   * Returns slope.
   *
   * @returns Slope.
   */
  get slope() {
    if (!this[slope]) {
      this[slope] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("slope"),
        setAttribute: (value2) => this.setAttribute("slope", value2),
        defaultValue: 1
      });
    }
    return this[slope];
  }
  /**
   * Returns intercept.
   *
   * @returns Intercept.
   */
  get intercept() {
    if (!this[intercept]) {
      this[intercept] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("intercept"),
        setAttribute: (value2) => this.setAttribute("intercept", value2)
      });
    }
    return this[intercept];
  }
  /**
   * Returns amplitude.
   *
   * @returns Amplitude.
   */
  get amplitude() {
    if (!this[amplitude]) {
      this[amplitude] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("amplitude"),
        setAttribute: (value2) => this.setAttribute("amplitude", value2),
        defaultValue: 1
      });
    }
    return this[amplitude];
  }
  /**
   * Returns exponent.
   *
   * @returns Exponent.
   */
  get exponent() {
    if (!this[exponent]) {
      this[exponent] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("exponent"),
        setAttribute: (value2) => this.setAttribute("exponent", value2),
        defaultValue: 1
      });
    }
    return this[exponent];
  }
  /**
   * Returns offset.
   *
   * @returns Offset.
   */
  get offset() {
    if (!this[offset]) {
      this[offset] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("offset"),
        setAttribute: (value2) => this.setAttribute("offset", value2)
      });
    }
    return this[offset];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-func-a-element/SVGFEFuncAElement.js
var SVGFEFuncAElement = class extends SVGComponentTransferFunctionElement {
};

// node_modules/happy-dom/lib/nodes/svg-fe-func-b-element/SVGFEFuncBElement.js
var SVGFEFuncBElement = class extends SVGComponentTransferFunctionElement {
};

// node_modules/happy-dom/lib/nodes/svg-fe-func-g-element/SVGFEFuncGElement.js
var SVGFEFuncGElement = class extends SVGComponentTransferFunctionElement {
};

// node_modules/happy-dom/lib/nodes/svg-fe-func-r-element/SVGFEFuncRElement.js
var SVGFEFuncRElement = class extends SVGComponentTransferFunctionElement {
};

// node_modules/happy-dom/lib/nodes/svg-fe-gaussian-blur-element/SVGFEGaussianBlurElement.js
var SVGFEGaussianBlurElement = class extends SVGElement {
  // Static properties
  static SVG_EDGEMODE_UNKNOWN = 0;
  static SVG_EDGEMODE_DUPLICATE = 1;
  static SVG_EDGEMODE_WRAP = 2;
  static SVG_EDGEMODE_NONE = 3;
  // Internal properties
  [edgeMode] = null;
  [height] = null;
  [in1] = null;
  [result] = null;
  [stdDeviationX] = null;
  [stdDeviationY] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns edge mode.
   *
   * @returns Edge mode.
   */
  get edgeMode() {
    if (!this[edgeMode]) {
      this[edgeMode] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("edgeMode"),
        setAttribute: (value2) => this.setAttribute("edgeMode", value2),
        values: ["duplicate", "wrap", "none"],
        defaultValue: "duplicate"
      });
    }
    return this[edgeMode];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns stdDeviationX.
   *
   * @returns StdDeviationX.
   */
  get stdDeviationX() {
    if (!this[stdDeviationX]) {
      this[stdDeviationX] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("stdDeviationX") || "2",
        setAttribute: (value2) => this.setAttribute("stdDeviationX", value2)
      });
    }
    return this[stdDeviationX];
  }
  /**
   * Returns stdDeviationY.
   *
   * @returns StdDeviationY.
   */
  get stdDeviationY() {
    if (!this[stdDeviationY]) {
      this[stdDeviationY] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("stdDeviationY") || "2",
        setAttribute: (value2) => this.setAttribute("stdDeviationY", value2)
      });
    }
    return this[stdDeviationY];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Sets stdDeviation.
   *
   * @param x X.
   * @param y Y.
   */
  setStdDeviation(x3, y3) {
    this.stdDeviationX.baseVal = x3;
    this.stdDeviationY.baseVal = y3;
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-image-element/SVGFEImageElement.js
var SVGFEImageElement = class extends SVGElement {
  // Internal properties
  [crossOrigin] = null;
  [height] = null;
  [href] = null;
  [preserveAspectRatio] = null;
  [result] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns "crossorigin" attribute.
   *
   * @returns Cross origin.
   */
  get crossOrigin() {
    return this.getAttribute("crossorigin");
  }
  /**
   * Sets "crossorigin" attribute.
   *
   * @param value Cross origin.
   */
  set crossOrigin(value2) {
    this.setAttribute("crossorigin", value2);
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
  /**
   * Returns preserveAspectRatio.
   *
   * @returns PreserveAspectRatio.
   */
  get preserveAspectRatio() {
    if (!this[preserveAspectRatio]) {
      this[preserveAspectRatio] = new SVGAnimatedPreserveAspectRatio(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("preserveAspectRatio"),
        setAttribute: (value2) => this.setAttribute("preserveAspectRatio", value2)
      });
    }
    return this[preserveAspectRatio];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-merge-element/SVGFEMergeElement.js
var SVGFEMergeElement = class extends SVGElement {
  // Internal properties
  [height] = null;
  [result] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-merge-node-element/SVGFEMergeNodeElement.js
var SVGFEMergeNodeElement = class extends SVGElement {
  // Internal properties
  [in1] = null;
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-morphology-element/SVGFEMorphologyElement.js
var SVGFEMorphologyElement = class extends SVGElement {
  // Static properties
  static SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;
  static SVG_MORPHOLOGY_OPERATOR_ERODE = 1;
  static SVG_MORPHOLOGY_OPERATOR_DILATE = 2;
  // Internal properties
  [height] = null;
  [in1] = null;
  [operator] = null;
  [radiusX] = null;
  [radiusY] = null;
  [result] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns operator.
   *
   * @returns Operator.
   */
  get operator() {
    if (!this[operator]) {
      this[operator] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("operator"),
        setAttribute: (value2) => this.setAttribute("operator", value2),
        values: ["erode", "dilate"],
        defaultValue: "erode"
      });
    }
    return this[operator];
  }
  /**
   * Returns radiusX.
   *
   * @returns RadiusX.
   */
  get radiusX() {
    if (!this[radiusX]) {
      this[radiusX] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("radiusX"),
        setAttribute: (value2) => this.setAttribute("radiusX", value2)
      });
    }
    return this[radiusX];
  }
  /**
   * Returns radiusY.
   *
   * @returns RadiusY.
   */
  get radiusY() {
    if (!this[radiusY]) {
      this[radiusY] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("radiusY"),
        setAttribute: (value2) => this.setAttribute("radiusY", value2)
      });
    }
    return this[radiusY];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-offset-element/SVGFEOffsetElement.js
var SVGFEOffsetElement = class extends SVGElement {
  // Internal properties
  [height] = null;
  [in1] = null;
  [dx] = null;
  [dy] = null;
  [result] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns dx.
   *
   * @returns Dx.
   */
  get dx() {
    if (!this[dx]) {
      this[dx] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("dx"),
        setAttribute: (value2) => this.setAttribute("dx", value2)
      });
    }
    return this[dx];
  }
  /**
   * Returns dy.
   *
   * @returns Dy.
   */
  get dy() {
    if (!this[dy]) {
      this[dy] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("dy"),
        setAttribute: (value2) => this.setAttribute("dy", value2)
      });
    }
    return this[dy];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-point-light-element/SVGFEPointLightElement.js
var SVGFEPointLightElement = class extends SVGElement {
  // Internal properties
  [x] = null;
  [y] = null;
  [z] = null;
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Returns z.
   *
   * @returns Z.
   */
  get z() {
    if (!this[z]) {
      this[z] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("z"),
        setAttribute: (value2) => this.setAttribute("z", value2)
      });
    }
    return this[z];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-specular-lighting-element/SVGFESpecularLightingElement.js
var SVGFESpecularLightingElement = class extends SVGElement {
  // Internal properties
  [height] = null;
  [in1] = null;
  [kernelUnitLengthX] = null;
  [kernelUnitLengthY] = null;
  [result] = null;
  [specularConstant] = null;
  [specularExponent] = null;
  [surfaceScale] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns kernelUnitLengthX.
   *
   * @returns KernelUnitLengthX.
   */
  get kernelUnitLengthX() {
    if (!this[kernelUnitLengthX]) {
      this[kernelUnitLengthX] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("kernelUnitLengthX"),
        setAttribute: (value2) => this.setAttribute("kernelUnitLengthX", value2)
      });
    }
    return this[kernelUnitLengthX];
  }
  /**
   * Returns kernelUnitLengthY.
   *
   * @returns KernelUnitLengthY.
   */
  get kernelUnitLengthY() {
    if (!this[kernelUnitLengthY]) {
      this[kernelUnitLengthY] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("kernelUnitLengthY"),
        setAttribute: (value2) => this.setAttribute("kernelUnitLengthY", value2)
      });
    }
    return this[kernelUnitLengthY];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns specularConstant.
   *
   * @returns SpecularConstant.
   */
  get specularConstant() {
    if (!this[specularConstant]) {
      this[specularConstant] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("specularConstant"),
        setAttribute: (value2) => this.setAttribute("specularConstant", value2),
        defaultValue: 1
      });
    }
    return this[specularConstant];
  }
  /**
   * Returns specularExponent.
   *
   * @returns SpecularExponent.
   */
  get specularExponent() {
    if (!this[specularExponent]) {
      this[specularExponent] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("specularExponent"),
        setAttribute: (value2) => this.setAttribute("specularExponent", value2),
        defaultValue: 1
      });
    }
    return this[specularExponent];
  }
  /**
   * Returns surfaceScale.
   *
   * @returns SurfaceScale.
   */
  get surfaceScale() {
    if (!this[surfaceScale]) {
      this[surfaceScale] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("surfaceScale"),
        setAttribute: (value2) => this.setAttribute("surfaceScale", value2),
        defaultValue: 1
      });
    }
    return this[surfaceScale];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-spot-light-element/SVGFESpotLightElement.js
var SVGFESpotLightElement = class extends SVGElement {
  // Internal properties
  [x] = null;
  [y] = null;
  [z] = null;
  [pointsAtX] = null;
  [pointsAtY] = null;
  [pointsAtZ] = null;
  [specularExponent] = null;
  [limitingConeAngle] = null;
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Returns z.
   *
   * @returns Z.
   */
  get z() {
    if (!this[z]) {
      this[z] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("z"),
        setAttribute: (value2) => this.setAttribute("z", value2)
      });
    }
    return this[z];
  }
  /**
   * Returns pointsAtX.
   *
   * @returns PointsAtX.
   */
  get pointsAtX() {
    if (!this[pointsAtX]) {
      this[pointsAtX] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("pointsAtX"),
        setAttribute: (value2) => this.setAttribute("pointsAtX", value2)
      });
    }
    return this[pointsAtX];
  }
  /**
   * Returns pointsAtY.
   *
   * @returns PointsAtY.
   */
  get pointsAtY() {
    if (!this[pointsAtY]) {
      this[pointsAtY] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("pointsAtY"),
        setAttribute: (value2) => this.setAttribute("pointsAtY", value2)
      });
    }
    return this[pointsAtY];
  }
  /**
   * Returns pointsAtZ.
   *
   * @returns PointsAtZ.
   */
  get pointsAtZ() {
    if (!this[pointsAtZ]) {
      this[pointsAtZ] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("pointsAtZ"),
        setAttribute: (value2) => this.setAttribute("pointsAtZ", value2)
      });
    }
    return this[pointsAtZ];
  }
  /**
   * Returns specularExponent.
   *
   * @returns SpecularExponent.
   */
  get specularExponent() {
    if (!this[specularExponent]) {
      this[specularExponent] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("specularExponent"),
        setAttribute: (value2) => this.setAttribute("specularExponent", value2),
        defaultValue: 1
      });
    }
    return this[specularExponent];
  }
  /**
   * Returns limitingConeAngle.
   *
   * @returns LimitingConeAngle.
   */
  get limitingConeAngle() {
    if (!this[limitingConeAngle]) {
      this[limitingConeAngle] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("limitingConeAngle"),
        setAttribute: (value2) => this.setAttribute("limitingConeAngle", value2)
      });
    }
    return this[limitingConeAngle];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-tile-element/SVGFETileElement.js
var SVGFETileElement = class extends SVGElement {
  // Internal properties
  [height] = null;
  [in1] = null;
  [result] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns in1.
   *
   * @returns In1.
   */
  get in1() {
    if (!this[in1]) {
      this[in1] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("in"),
        setAttribute: (value2) => this.setAttribute("in", value2)
      });
    }
    return this[in1];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-fe-turbulence-element/SVGFETurbulenceElement.js
var SVGFETurbulenceElement = class extends SVGElement {
  // Static properties
  static SVG_TURBULENCE_TYPE_UNKNOWN = 0;
  static SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;
  static SVG_TURBULENCE_TYPE_TURBULENCE = 2;
  static SVG_STITCHTYPE_UNKNOWN = 0;
  static SVG_STITCHTYPE_STITCH = 1;
  static SVG_STITCHTYPE_NOSTITCH = 2;
  // Internal properties
  [baseFrequencyX] = null;
  [baseFrequencyY] = null;
  [height] = null;
  [numOctaves] = null;
  [result] = null;
  [seed] = null;
  [stitchTiles] = null;
  [type] = null;
  [width] = null;
  [x] = null;
  [y] = null;
  /**
   * Returns baseFrequencyX.
   *
   * @returns Base frequency x.
   */
  get baseFrequencyX() {
    if (!this[baseFrequencyX]) {
      this[baseFrequencyX] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("baseFrequencyX"),
        setAttribute: (value2) => this.setAttribute("baseFrequencyX", value2)
      });
    }
    return this[baseFrequencyX];
  }
  /**
   * Returns baseFrequencyY.
   *
   * @returns Base frequency y.
   */
  get baseFrequencyY() {
    if (!this[baseFrequencyY]) {
      this[baseFrequencyY] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("baseFrequencyY"),
        setAttribute: (value2) => this.setAttribute("baseFrequencyY", value2)
      });
    }
    return this[baseFrequencyY];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns numOctaves.
   *
   * @returns Num octaves.
   */
  get numOctaves() {
    if (!this[numOctaves]) {
      this[numOctaves] = new SVGAnimatedInteger(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("numOctaves"),
        setAttribute: (value2) => this.setAttribute("numOctaves", value2)
      });
    }
    return this[numOctaves];
  }
  /**
   * Returns result.
   *
   * @returns Result.
   */
  get result() {
    if (!this[result]) {
      this[result] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("result"),
        setAttribute: (value2) => this.setAttribute("result", value2)
      });
    }
    return this[result];
  }
  /**
   * Returns seed.
   *
   * @returns Seed.
   */
  get seed() {
    if (!this[seed]) {
      this[seed] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("seed"),
        setAttribute: (value2) => this.setAttribute("seed", value2)
      });
    }
    return this[seed];
  }
  /**
   * Returns stitchTiles.
   *
   * @returns Stitch tiles.
   */
  get stitchTiles() {
    if (!this[stitchTiles]) {
      this[stitchTiles] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("stitchTiles"),
        setAttribute: (value2) => this.setAttribute("stitchTiles", value2),
        values: ["stitch", "noStitch"],
        defaultValue: "stitch"
      });
    }
    return this[stitchTiles];
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    if (!this[type]) {
      this[type] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("type"),
        setAttribute: (value2) => this.setAttribute("type", value2),
        values: ["fractalNoise", "turbulence"],
        defaultValue: "turbulence"
      });
    }
    return this[type];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-filter-element/SVGFilterElement.js
var SVGFilterElement = class extends SVGElement {
  // Internal properties
  [href] = null;
  [filterUnits] = null;
  [primitiveUnits] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  [height] = null;
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
  /**
   * Returns filter units.
   *
   * @returns Filter units.
   */
  get filterUnits() {
    if (!this[filterUnits]) {
      this[filterUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("filterUnits"),
        setAttribute: (value2) => this.setAttribute("filterUnits", value2),
        values: ["userSpaceOnUse", "objectBoundingBox"],
        defaultValue: "userSpaceOnUse"
      });
    }
    return this[filterUnits];
  }
  /**
   * Returns primitive units.
   *
   * @returns Primitive units.
   */
  get primitiveUnits() {
    if (!this[primitiveUnits]) {
      this[primitiveUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("primitiveUnits"),
        setAttribute: (value2) => this.setAttribute("primitiveUnits", value2),
        values: ["userSpaceOnUse", "objectBoundingBox"],
        defaultValue: "userSpaceOnUse"
      });
    }
    return this[primitiveUnits];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-foreign-object-element/SVGForeignObjectElement.js
var SVGForeignObjectElement = class extends SVGGraphicsElement {
  // Internal properties
  [x] = null;
  [y] = null;
  [width] = null;
  [height] = null;
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-g-element/SVGGElement.js
var SVGGElement = class extends SVGGraphicsElement {
};

// node_modules/happy-dom/lib/nodes/svg-image-element/SVGImageElement.js
var SVGImageElement = class extends SVGGraphicsElement {
  // Internal properties
  [href] = null;
  [preserveAspectRatio] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  [height] = null;
  /**
   * Returns "crossorigin" attribute.
   *
   * @returns Cross origin.
   */
  get crossOrigin() {
    return this.getAttribute("crossorigin");
  }
  /**
   * Sets "crossorigin" attribute.
   *
   * @param value Cross origin.
   */
  set crossOrigin(value2) {
    this.setAttribute("crossorigin", value2);
  }
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
  /**
   * Returns decoding.
   *
   * @returns Decoding.
   */
  get decoding() {
    const value2 = this.getAttribute("decoding");
    switch (value2) {
      case "sync":
      case "async":
      case "auto":
        return value2;
      default:
        return "auto";
    }
  }
  /**
   * Sets decoding.
   *
   * @param value Decoding.
   */
  set decoding(value2) {
    this.setAttribute("decoding", value2);
  }
  /**
   * Returns preserve aspect ratio.
   *
   * @returns Preserve aspect ratio.
   */
  get preserveAspectRatio() {
    if (!this[preserveAspectRatio]) {
      this[preserveAspectRatio] = new SVGAnimatedPreserveAspectRatio(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("preserveAspectRatio"),
        setAttribute: (value2) => this.setAttribute("preserveAspectRatio", value2)
      });
    }
    return this[preserveAspectRatio];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Decodes the image.
   *
   * @returns Promise.
   */
  decode() {
    return Promise.resolve();
  }
};

// node_modules/happy-dom/lib/nodes/svg-line-element/SVGLineElement.js
var SVGLineElement = class extends SVGGeometryElement {
  // Internal properties
  [x1] = null;
  [y1] = null;
  [x2] = null;
  [y2] = null;
  /**
   * Returns x1 position.
   *
   * @returns X1 position.
   */
  get x1() {
    if (!this[x1]) {
      this[x1] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x1"),
        setAttribute: (value2) => this.setAttribute("x1", value2)
      });
    }
    return this[x1];
  }
  /**
   * Returns y1 position.
   *
   * @returns Y1 position.
   */
  get y1() {
    if (!this[y1]) {
      this[y1] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y1"),
        setAttribute: (value2) => this.setAttribute("y1", value2)
      });
    }
    return this[y1];
  }
  /**
   * Returns x2 position.
   *
   * @returns X2 position.
   */
  get x2() {
    if (!this[x2]) {
      this[x2] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x2"),
        setAttribute: (value2) => this.setAttribute("x2", value2)
      });
    }
    return this[x2];
  }
  /**
   * Returns y2 position.
   *
   * @returns Y2 position.
   */
  get y2() {
    if (!this[y2]) {
      this[y2] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y2"),
        setAttribute: (value2) => this.setAttribute("y2", value2)
      });
    }
    return this[y2];
  }
};

// node_modules/happy-dom/lib/nodes/svg-gradient-element/SVGGradientElement.js
var SVGGradientElement = class extends SVGGraphicsElement {
  // Public static properties
  static SVG_SPREADMETHOD_UNKNOWN = 0;
  static SVG_SPREADMETHOD_PAD = 1;
  static SVG_SPREADMETHOD_REFLECT = 2;
  static SVG_SPREADMETHOD_REPEAT = 3;
  // Internal properties
  [href] = null;
  [gradientUnits] = null;
  [gradientTransform] = null;
  [spreadMethod] = null;
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
  /**
   * Returns gradient units.
   *
   * @returns Gradient units.
   */
  get gradientUnits() {
    if (!this[gradientUnits]) {
      this[gradientUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("gradientUnits"),
        setAttribute: (value2) => this.setAttribute("gradientUnits", value2),
        values: ["userSpaceOnUse", "objectBoundingBox"],
        defaultValue: "objectBoundingBox"
      });
    }
    return this[gradientUnits];
  }
  /**
   * Returns gradient transform.
   *
   * @returns Gradient transform.
   */
  get gradientTransform() {
    if (!this[gradientTransform]) {
      this[gradientTransform] = new SVGAnimatedTransformList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("gradientTransform"),
        setAttribute: (value2) => this.setAttribute("gradientTransform", value2)
      });
    }
    return this[gradientTransform];
  }
  /**
   * Returns spread method.
   *
   * @returns Spread method.
   */
  get spreadMethod() {
    if (!this[spreadMethod]) {
      this[spreadMethod] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("spreadMethod"),
        setAttribute: (value2) => this.setAttribute("spreadMethod", value2),
        values: ["pad", "reflect", "repeat"],
        defaultValue: "pad"
      });
    }
    return this[spreadMethod];
  }
};

// node_modules/happy-dom/lib/nodes/svg-linear-gradient-element/SVGLinearGradientElement.js
var SVGLinearGradientElement = class extends SVGGradientElement {
  // Internal properties
  [x1] = null;
  [y1] = null;
  [x2] = null;
  [y2] = null;
  /**
   * Returns x1 position.
   *
   * @returns X1 position.
   */
  get x1() {
    if (!this[x1]) {
      this[x1] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x1"),
        setAttribute: (value2) => this.setAttribute("x1", value2)
      });
    }
    return this[x1];
  }
  /**
   * Returns y1 position.
   *
   * @returns Y1 position.
   */
  get y1() {
    if (!this[y1]) {
      this[y1] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y1"),
        setAttribute: (value2) => this.setAttribute("y1", value2)
      });
    }
    return this[y1];
  }
  /**
   * Returns x2 position.
   *
   * @returns X2 position.
   */
  get x2() {
    if (!this[x2]) {
      this[x2] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x2"),
        setAttribute: (value2) => this.setAttribute("x2", value2)
      });
    }
    return this[x2];
  }
  /**
   * Returns y2 position.
   *
   * @returns Y2 position.
   */
  get y2() {
    if (!this[y2]) {
      this[y2] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y2"),
        setAttribute: (value2) => this.setAttribute("y2", value2)
      });
    }
    return this[y2];
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedAngle.js
var SVGAnimatedAngle = class {
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [baseVal] = null;
  [animVal] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    if (!this[animVal]) {
      this[animVal] = new SVGAngle(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: this[getAttribute]
      });
    }
    return this[animVal];
  }
  /**
   * Sets animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    if (!this[baseVal]) {
      this[baseVal] = new SVGAngle(illegalConstructor, this[window], {
        getAttribute: this[getAttribute],
        setAttribute: this[setAttribute]
      });
    }
    return this[baseVal];
  }
  /**
   * Sets base value.
   *
   * @param value Base value.
   */
  set baseVal(_value) {
  }
};

// node_modules/happy-dom/lib/nodes/svg-marker-element/SVGMarkerElement.js
var SVGMarkerElement = class extends SVGElement {
  // Static properties
  static SVG_MARKER_ORIENT_UNKNOWN = 0;
  static SVG_MARKER_ORIENT_AUTO = 1;
  static SVG_MARKER_ORIENT_ANGLE = 2;
  static SVG_MARKERUNITS_UNKNOWN = 0;
  static SVG_MARKERUNITS_USERSPACEONUSE = 1;
  static SVG_MARKERUNITS_STROKEWIDTH = 2;
  // Public properties
  SVG_MARKER_ORIENT_UNKNOWN = 0;
  SVG_MARKER_ORIENT_AUTO = 1;
  SVG_MARKER_ORIENT_ANGLE = 2;
  // Internal properties
  [markerUnits] = null;
  [markerWidth] = null;
  [markerHeight] = null;
  [orientType] = null;
  [orientAngle] = null;
  [refX] = null;
  [refY] = null;
  [viewBox] = null;
  [preserveAspectRatio] = null;
  /**
   * Returns marker units.
   *
   * @returns Marker units.
   */
  get markerUnits() {
    if (!this[markerUnits]) {
      this[markerUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("markerUnits"),
        setAttribute: (value2) => this.setAttribute("markerUnits", value2),
        values: ["userSpaceOnUse", "strokeWidth"],
        defaultValue: "strokeWidth"
      });
    }
    return this[markerUnits];
  }
  /**
   * Returns marker width.
   *
   * @returns Marker width.
   */
  get markerWidth() {
    if (!this[markerWidth]) {
      this[markerWidth] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("markerWidth"),
        setAttribute: (value2) => this.setAttribute("markerWidth", value2)
      });
    }
    return this[markerWidth];
  }
  /**
   * Returns marker height.
   *
   * @returns Marker height.
   */
  get markerHeight() {
    if (!this[markerHeight]) {
      this[markerHeight] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("markerHeight"),
        setAttribute: (value2) => this.setAttribute("markerHeight", value2)
      });
    }
    return this[markerHeight];
  }
  /**
   * Returns orient type.
   *
   * @returns Orient type.
   */
  get orientType() {
    if (!this[orientType]) {
      this[orientType] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("orient"),
        setAttribute: (value2) => this.setAttribute("orient", value2),
        values: ["auto", null],
        defaultValue: "auto"
      });
    }
    return this[orientType];
  }
  /**
   * Returns orient angle.
   *
   * @returns Orient angle.
   */
  get orientAngle() {
    if (!this[orientAngle]) {
      this[orientAngle] = new SVGAnimatedAngle(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("orient"),
        setAttribute: (value2) => this.setAttribute("orient", value2)
      });
    }
    return this[orientAngle];
  }
  /**
   * Returns ref x.
   *
   * @returns Ref x.
   */
  get refX() {
    if (!this[refX]) {
      this[refX] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("refX"),
        setAttribute: (value2) => this.setAttribute("refX", value2)
      });
    }
    return this[refX];
  }
  /**
   * Returns ref y.
   *
   * @returns Ref y.
   */
  get refY() {
    if (!this[refY]) {
      this[refY] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("refY"),
        setAttribute: (value2) => this.setAttribute("refY", value2)
      });
    }
    return this[refY];
  }
  /**
   * Returns view box.
   *
   * @returns View box.
   */
  get viewBox() {
    if (!this[viewBox]) {
      this[viewBox] = new SVGAnimatedRect(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("viewBox"),
        setAttribute: (value2) => this.setAttribute("viewBox", value2)
      });
    }
    return this[viewBox];
  }
  /**
   * Returns preserve aspect ratio.
   *
   * @returns Preserve aspect ratio.
   */
  get preserveAspectRatio() {
    if (!this[preserveAspectRatio]) {
      this[preserveAspectRatio] = new SVGAnimatedPreserveAspectRatio(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("preserveAspectRatio"),
        setAttribute: (value2) => this.setAttribute("preserveAspectRatio", value2)
      });
    }
    return this[preserveAspectRatio];
  }
  /**
   * Sets the value of the orient attribute to auto.
   */
  setOrientToAuto() {
    this.setAttribute("orient", "auto");
  }
  /**
   * Sets the value of the orient attribute to an angle.
   *
   * @param angle Angle.
   */
  setOrientToAngle(angle2) {
    this.setAttribute("orient", angle2.valueAsString);
  }
};

// node_modules/happy-dom/lib/nodes/svg-mask-element/SVGMaskElement.js
var SVGMaskElement = class extends SVGElement {
  // Internal properties
  [maskUnits] = null;
  [maskContentUnits] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  [height] = null;
  /**
   * Returns mask units.
   *
   * @returns Mask units.
   */
  get maskUnits() {
    if (!this[maskUnits]) {
      this[maskUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("maskUnits"),
        setAttribute: (value2) => this.setAttribute("maskUnits", value2),
        values: ["userSpaceOnUse", "objectBoundingBox"],
        defaultValue: "userSpaceOnUse"
      });
    }
    return this[maskUnits];
  }
  /**
   * Returns mask content units.
   *
   * @returns Mask content units.
   */
  get maskContentUnits() {
    if (!this[maskContentUnits]) {
      this[maskContentUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("maskContentUnits"),
        setAttribute: (value2) => this.setAttribute("maskContentUnits", value2),
        values: ["userSpaceOnUse", "objectBoundingBox"],
        defaultValue: "userSpaceOnUse"
      });
    }
    return this[maskContentUnits];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/nodes/svg-metadata-element/SVGMetadataElement.js
var SVGMetadataElement = class extends SVGElement {
};

// node_modules/happy-dom/lib/nodes/svg-m-path-element/SVGMPathElement.js
var SVGMPathElement = class extends SVGElement {
  // Internal properties
  [href] = null;
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
};

// node_modules/happy-dom/lib/nodes/svg-path-element/SVGPathElement.js
var SVGPathElement = class extends SVGGeometryElement {
};

// node_modules/happy-dom/lib/nodes/svg-pattern-element/SVGPatternElement.js
var SVGPatternElement = class extends SVGElement {
  // Internal properties
  [href] = null;
  [patternUnits] = null;
  [patternContentUnits] = null;
  [patternTransform] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  [height] = null;
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
  /**
   * Returns pattern units.
   *
   * @returns Pattern units.
   */
  get patternUnits() {
    if (!this[patternUnits]) {
      this[patternUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("patternUnits"),
        setAttribute: (value2) => this.setAttribute("patternUnits", value2),
        values: ["userSpaceOnUse", "objectBoundingBox"],
        defaultValue: "objectBoundingBox"
      });
    }
    return this[patternUnits];
  }
  /**
   * Returns pattern content units.
   *
   * @returns Pattern content units.
   */
  get patternContentUnits() {
    if (!this[patternContentUnits]) {
      this[patternContentUnits] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("patternContentUnits"),
        setAttribute: (value2) => this.setAttribute("patternContentUnits", value2),
        values: ["userSpaceOnUse", "objectBoundingBox"],
        defaultValue: "userSpaceOnUse"
      });
    }
    return this[patternContentUnits];
  }
  /**
   * Returns pattern transform.
   *
   * @returns Pattern transform.
   */
  get patternTransform() {
    if (!this[patternTransform]) {
      this[patternTransform] = new SVGAnimatedTransformList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("patternTransform"),
        setAttribute: (value2) => this.setAttribute("patternTransform", value2)
      });
    }
    return this[patternTransform];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
};

// node_modules/happy-dom/lib/svg/SVGPointList.js
var ATTRIBUTE_SEPARATOR_REGEXP3 = /[\t\f\n\r, ]+/;
var SVGPointList = class _SVGPointList {
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [readOnly] = false;
  [cache] = {
    items: [],
    attributeValue: ""
  };
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   * @param [options.readOnly] Read only.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[readOnly] = !!options2.readOnly;
    this[getAttribute] = options2.getAttribute || null;
    this[setAttribute] = options2.setAttribute || null;
    const methodBinder = new ClassMethodBinder(this, [_SVGPointList]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property === "length" || property === "numberOfItems") {
          return target2[getItemList]().length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return target2[getItemList]()[index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys(target2) {
        return Object.keys(target2[getItemList]());
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        return !isNaN(index) && index >= 0 && index < target2[getItemList]().length;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        const items2 = target2[getItemList]();
        if (!isNaN(index) && items2[index]) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[getItemList]().length;
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get numberOfItems() {
    return this[getItemList]().length;
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  [Symbol.iterator]() {
    return this[getItemList]().values();
  }
  /**
   * Clears all items from the list.
   */
  clear() {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'clear' on 'SVGPointList': The object is read-only.`);
    }
    for (const item of this[cache].items) {
      item[getAttribute] = null;
      item[setAttribute] = null;
    }
    this[cache].items = [];
    this[cache].attributeValue = "";
    this[setAttribute]("");
  }
  /**
   * Replace Token.
   *
   * @param newItem New item.
   * @returns The item being replaced.
   */
  initialize(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGPointList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGPointList': 1 arguments required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGPoint)) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGPointList': parameter 1 is not of type 'SVGPoint'.`);
    }
    for (const item of this[cache].items) {
      item[getAttribute] = null;
      item[setAttribute] = null;
    }
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || "0 0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].items = [newItem];
    this[cache].attributeValue = newItem[attributeValue];
    this[setAttribute](newItem[attributeValue]);
    return newItem;
  }
  /**
   * Returns item at index.
   *
   * @param index Index.
   * @returns The item at the index.
   **/
  getItem(index) {
    const items2 = this[getItemList]();
    if (typeof index === "number") {
      return items2[index] ? items2[index] : null;
    }
    index = Number(index);
    index = isNaN(index) ? 0 : index;
    return items2[index] ? items2[index] : null;
  }
  /**
   * Inserts a new item into the list at the specified position. The first item is number 0. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to insert before is before the removal of the item. If the index is equal to 0, then the new item is inserted at the front of the list. If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being inserted.
   */
  insertItemBefore(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGPointList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGPointList': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGPoint)) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGPointList': parameter 1 is not of type 'SVGPoint'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index > items2.length) {
      index = items2.length;
    }
    items2.splice(index, 0, newItem);
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || "0 0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || "0 0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return newItem;
  }
  /**
   * Replaces an existing item in the list with a new item. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to replace is before the removal of the item.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being replaced.
   */
  replaceItem(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGPointList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGPointList': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGPoint)) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGPointList': parameter 1 is not of type 'SVGPoint'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex === index) {
      return newItem;
    }
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index >= items2.length) {
      index = items2.length - 1;
    }
    if (items2[index]) {
      items2[index][getAttribute] = null;
      items2[index][setAttribute] = null;
    }
    const replacedItem = items2[index];
    items2[index] = newItem;
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || "0 0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || "0 0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return replacedItem;
  }
  /**
   * Removes an existing item from the list.
   *
   * @param index Index.
   * @returns The removed item.
   */
  removeItem(index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGPointList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGPointList': 1 argument required, but only ${arguments.length} present.`);
    }
    const items2 = this[getItemList]();
    index = Number(index);
    if (isNaN(index)) {
      index = 0;
    }
    if (index >= items2.length) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGPointList':  The index provided (${index}) is greater than the maximum bound.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index < 0) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGPointList':  The index provided (${index}) is negative.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const removedItem = items2[index];
    if (removedItem) {
      removedItem[getAttribute] = null;
      removedItem[setAttribute] = null;
    }
    items2.splice(index, 1);
    this[setAttribute](items2.map((item) => item[attributeValue] || "0 0").join(" "));
    return removedItem;
  }
  /**
   * Appends an item to the end of the list.
   *
   * @param newItem The item to add to the list.
   * @returns The item being appended.
   */
  appendItem(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGPointList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGPointList': 1 argument required, but only ${arguments.length} present.`);
    }
    if (!(newItem instanceof SVGPoint)) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGPointList': parameter 1 is not of type 'SVGPoint'.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    items2.push(newItem);
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] || "0 0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] || "0 0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return newItem;
  }
  /**
   * Returns item list from attribute value.
   *
   * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
   */
  [getItemList]() {
    const attributeValue2 = this[getAttribute]() ?? "";
    const cache2 = this[cache];
    if (cache2.attributeValue === attributeValue2) {
      return cache2.items;
    }
    if (cache2.items.length) {
      for (const item of cache2.items) {
        item[getAttribute] = null;
        item[setAttribute] = null;
      }
    }
    const items2 = [];
    const trimmed = attributeValue2.trim();
    if (trimmed) {
      const parts = trimmed.split(ATTRIBUTE_SEPARATOR_REGEXP3);
      for (let i = 0, max = parts.length; i < max; i += 2) {
        const x3 = parseFloat(parts[i]);
        const y3 = parts[i + 1] !== void 0 ? " " + parseFloat(parts[i + 1]) : "";
        const item = new SVGPoint(illegalConstructor, this[window], {
          readOnly: this[readOnly],
          getAttribute: () => item[attributeValue],
          setAttribute: () => {
            this[cache].attributeValue = this[getItemList]().map((item2) => item2[attributeValue] || "0 0").join(" ");
            this[setAttribute](this[cache].attributeValue);
          }
        });
        item[attributeValue] = `${x3}${y3}`;
        items2.push(item);
      }
    }
    cache2.attributeValue = attributeValue2;
    cache2.items = items2;
    return items2;
  }
};

// node_modules/happy-dom/lib/nodes/svg-polygon-element/SVGPolygonElement.js
var SVGPolygonElement = class extends SVGGeometryElement {
  // Internal properties
  [animatedPoints] = null;
  [points] = null;
  /**
   * Returns animated points.
   *
   * @returns Animated points.
   */
  get animatedPoints() {
    if (!this[animatedPoints]) {
      this[animatedPoints] = new SVGPointList(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: () => this.getAttribute("points"),
        setAttribute: () => {
        }
      });
    }
    return this[animatedPoints];
  }
  /**
   * Returns points.
   *
   * @returns Points.
   */
  get points() {
    if (!this[points]) {
      this[points] = new SVGPointList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("points"),
        setAttribute: (value2) => this.setAttribute("points", value2)
      });
    }
    return this[points];
  }
};

// node_modules/happy-dom/lib/nodes/svg-polyline-element/SVGPolylineElement.js
var SVGPolylineElement = class extends SVGGeometryElement {
  // Internal properties
  [animatedPoints] = null;
  [points] = null;
  /**
   * Returns animated points.
   *
   * @returns Animated points.
   */
  get animatedPoints() {
    if (!this[animatedPoints]) {
      this[animatedPoints] = new SVGPointList(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: () => this.getAttribute("points"),
        setAttribute: () => {
        }
      });
    }
    return this[animatedPoints];
  }
  /**
   * Returns points.
   *
   * @returns Points.
   */
  get points() {
    if (!this[points]) {
      this[points] = new SVGPointList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("points"),
        setAttribute: (value2) => this.setAttribute("points", value2)
      });
    }
    return this[points];
  }
};

// node_modules/happy-dom/lib/nodes/svg-radial-gradient-element/SVGRadialGradientElement.js
var SVGRadialGradientElement = class extends SVGGradientElement {
  // Internal properties
  [cx] = null;
  [cy] = null;
  [r] = null;
  [fx] = null;
  [fy] = null;
  /**
   * Returns cx.
   *
   * @returns Cx.
   */
  get cx() {
    if (!this[cx]) {
      this[cx] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("cx"),
        setAttribute: (value2) => this.setAttribute("cx", value2)
      });
    }
    return this[cx];
  }
  /**
   * Returns cy.
   *
   * @returns Cy.
   */
  get cy() {
    if (!this[cy]) {
      this[cy] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("cy"),
        setAttribute: (value2) => this.setAttribute("cy", value2)
      });
    }
    return this[cy];
  }
  /**
   * Returns r.
   *
   * @returns R.
   */
  get r() {
    if (!this[r]) {
      this[r] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("r"),
        setAttribute: (value2) => this.setAttribute("r", value2)
      });
    }
    return this[r];
  }
  /**
   * Returns fx.
   *
   * @returns Fx.
   */
  get fx() {
    if (!this[fx]) {
      this[fx] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("fx"),
        setAttribute: (value2) => this.setAttribute("fx", value2)
      });
    }
    return this[fx];
  }
  /**
   * Returns fy.
   *
   * @returns Fy.
   */
  get fy() {
    if (!this[fy]) {
      this[fy] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("fy"),
        setAttribute: (value2) => this.setAttribute("fy", value2)
      });
    }
    return this[fy];
  }
};

// node_modules/happy-dom/lib/nodes/svg-rect-element/SVGRectElement.js
var SVGRectElement = class extends SVGGeometryElement {
  // Internal properties
  [x] = null;
  [y] = null;
  [width] = null;
  [height] = null;
  [rx] = null;
  [ry] = null;
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns rx.
   *
   * @returns Rx.
   */
  get rx() {
    if (!this[rx]) {
      this[rx] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("rx"),
        setAttribute: (value2) => this.setAttribute("rx", value2)
      });
    }
    return this[rx];
  }
  /**
   * Returns ry.
   *
   * @returns Ry.
   */
  get ry() {
    if (!this[ry]) {
      this[ry] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("ry"),
        setAttribute: (value2) => this.setAttribute("ry", value2)
      });
    }
    return this[ry];
  }
};

// node_modules/happy-dom/lib/nodes/svg-script-element/SVGScriptElement.js
var SVGScriptElement = class extends SVGGraphicsElement {
  // Internal properties
  [href] = null;
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param value New value.
   */
  set type(value2) {
    this.setAttribute("type", value2);
  }
};

// node_modules/happy-dom/lib/nodes/svg-set-element/SVGSetElement.js
var SVGSetElement = class extends SVGAnimationElement {
};

// node_modules/happy-dom/lib/nodes/svg-stop-element/SVGStopElement.js
var SVGStopElement = class extends SVGElement {
  // Internal properties
  [offset] = null;
  /**
   * Returns offset.
   *
   * @returns Offset.
   */
  get offset() {
    if (!this[offset]) {
      this[offset] = new SVGAnimatedNumber(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("offset"),
        setAttribute: (value2) => this.setAttribute("offset", value2)
      });
    }
    return this[offset];
  }
};

// node_modules/happy-dom/lib/nodes/svg-style-element/SVGStyleElement.js
var SVGStyleElement = class extends SVGElement {
  // Internal properties
  [sheet] = null;
  [styleNode] = this;
  [disabled] = false;
  /**
   * Returns media.
   *
   * @returns Media.
   */
  get media() {
    return this.getAttribute("media") || "all";
  }
  /**
   * Sets media.
   *
   * @param media Media.
   */
  set media(media) {
    this.setAttribute("media", media);
  }
  /**
   * Returns type.
   *
   * @deprecated
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "text/css";
  }
  /**
   * Sets type.
   *
   * @deprecated
   * @param type Type.
   */
  set type(type2) {
    this.setAttribute("type", type2);
  }
  /**
   * Returns title.
   *
   * @returns Title.
   */
  get title() {
    return this.getAttribute("title") || "";
  }
  /**
   * Sets title.
   *
   * @param title Title.
   */
  set title(title) {
    this.setAttribute("title", title);
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this[disabled];
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled2) {
    this[disabled] = Boolean(disabled2);
  }
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get sheet() {
    if (!this[isConnected]) {
      return null;
    }
    if (!this[sheet]) {
      this[sheet] = new this[ownerDocument][window].CSSStyleSheet();
      this[sheet].replaceSync(this.textContent);
    }
    return this[sheet];
  }
  /**
   * @override
   */
  [disconnectedFromDocument]() {
    super[disconnectedFromDocument]();
    this[sheet] = null;
  }
  /**
   * Updates the CSSStyleSheet with the text content.
   */
  [updateSheet]() {
    if (this[sheet]) {
      this[sheet].replaceSync(this.textContent);
    }
  }
};

// node_modules/happy-dom/lib/nodes/svg-switch-element/SVGSwitchElement.js
var SVGSwitchElement = class extends SVGGraphicsElement {
};

// node_modules/happy-dom/lib/nodes/svg-symbol-element/SVGSymbolElement.js
var SVGSymbolElement = class extends SVGGraphicsElement {
};

// node_modules/happy-dom/lib/nodes/svg-text-content-element/SVGTextContentElement.js
var SVGTextContentElement = class extends SVGGraphicsElement {
  // Public static properties
  static LENGTHADJUST_UNKNOWN = 0;
  static LENGTHADJUST_SPACING = 1;
  static LENGTHADJUST_SPACINGANDGLYPHS = 2;
  // Internal properties
  [textLength] = null;
  [lengthAdjust] = null;
  /**
   * Returns textLength.
   *
   * @returns Text length.
   */
  get textLength() {
    if (!this[textLength]) {
      this[textLength] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("textLength"),
        setAttribute: (value2) => this.setAttribute("textLength", value2)
      });
    }
    return this[textLength];
  }
  /**
   * Returns lengthAdjust.
   *
   * @returns Length adjust.
   */
  get lengthAdjust() {
    if (!this[lengthAdjust]) {
      this[lengthAdjust] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("lengthAdjust"),
        setAttribute: (value2) => this.setAttribute("lengthAdjust", value2),
        values: ["spacing", "spacingAndGlyphs"],
        defaultValue: "spacing"
      });
    }
    return this[lengthAdjust];
  }
  /**
   * Returns the number of characters available for rendering.
   *
   * @returns Number of characters.
   */
  getNumberOfChars() {
    return 0;
  }
  /**
   * Returns a float representing the computed length for the text within the element.
   *
   * @returns Computed text length.
   */
  getComputedTextLength() {
    return 0;
  }
  /**
   * Returns a float representing the computed length of the formatted text advance distance for a substring of text within the element. Note that this method only accounts for the widths of the glyphs in the substring and any extra spacing inserted by the CSS 'letter-spacing' and 'word-spacing' properties. Visual spacing adjustments made by the 'x' attribute is ignored.
   *
   * @param _charnum The index of the first character in the substring.
   * @param _nchars The number of characters in the substring.
   */
  getSubStringLength(_charnum, _nchars) {
    return 0;
  }
  /**
   * Returns a SVGPoint representing the position of a typographic character after text layout has been performed.
   *
   * @param _charnum The index of the character.
   */
  getStartPositionOfChar(_charnum) {
    return new SVGPoint(illegalConstructor, this[window]);
  }
  /**
   * Returns a SVGPoint representing the trailing position of a typographic character after text layout has been performed.
   *
   * @param _charnum The index of the character.
   */
  getEndPositionOfChar(_charnum) {
    return new SVGPoint(illegalConstructor, this[window]);
  }
  /**
   * Returns a SVGRect representing the computed tight bounding box of the glyph cell that corresponds to a given typographic character.
   *
   * @param _charnum The index of the character.
   */
  getExtentOfChar(_charnum) {
    return new SVGRect(illegalConstructor, this[window]);
  }
  /**
   * Returns a float representing the rotation of typographic character.
   *
   * @param _charnum The index of the character.
   */
  getRotationOfChar(_charnum) {
    return 0;
  }
  /**
   * Returns a long representing the character which caused a text glyph to be rendered at a given position in the coordinate system. Because the relationship between characters and glyphs is not one-to-one, only the first character of the relevant typographic character is returned
   *
   * @param _point The point to be tested.
   */
  getCharNumAtPosition(_point) {
    return 0;
  }
};

// node_modules/happy-dom/lib/svg/SVGLengthList.js
var ATTRIBUTE_SEPARATOR_REGEXP4 = /[\t\f\n\r, ]+/;
var SVGLengthList = class _SVGLengthList {
  [window];
  [getAttribute] = null;
  [setAttribute] = null;
  [readOnly] = false;
  [cache] = {
    items: [],
    attributeValue: ""
  };
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   * @param [options.readOnly] Read only.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[readOnly] = !!options2.readOnly;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
    const methodBinder = new ClassMethodBinder(this, [_SVGLengthList]);
    return new Proxy(this, {
      get: (target2, property) => {
        if (property === "length" || property === "numberOfItems") {
          return target2[getItemList]().length;
        }
        if (property in target2 || typeof property === "symbol") {
          methodBinder.bind(property);
          return target2[property];
        }
        const index = Number(property);
        if (!isNaN(index)) {
          return target2[getItemList]()[index];
        }
      },
      set(target2, property, newValue) {
        methodBinder.bind(property);
        if (typeof property === "symbol") {
          target2[property] = newValue;
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          target2[property] = newValue;
        }
        return true;
      },
      deleteProperty(target2, property) {
        if (typeof property === "symbol") {
          delete target2[property];
          return true;
        }
        const index = Number(property);
        if (isNaN(index)) {
          delete target2[property];
        }
        return true;
      },
      ownKeys(target2) {
        return Object.keys(target2[getItemList]());
      },
      has(target2, property) {
        if (property in target2) {
          return true;
        }
        if (typeof property === "symbol") {
          return false;
        }
        const index = Number(property);
        return !isNaN(index) && index >= 0 && index < target2[getItemList]().length;
      },
      defineProperty(target2, property, descriptor) {
        methodBinder.preventBinding(property);
        if (property in target2) {
          Object.defineProperty(target2, property, descriptor);
          return true;
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, property) {
        if (property in target2 || typeof property === "symbol") {
          return;
        }
        const index = Number(property);
        const items2 = target2[getItemList]();
        if (!isNaN(index) && items2[index]) {
          return {
            value: items2[index],
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    });
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[getItemList]().length;
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get numberOfItems() {
    return this[getItemList]().length;
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  [Symbol.iterator]() {
    return this[getItemList]().values();
  }
  /**
   * Clears all items from the list.
   */
  clear() {
    this[setAttribute]("");
  }
  /**
   * Replace Token.
   *
   * @param newItem New item.
   * @returns The item being replaced.
   */
  initialize(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGLengthList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'initialize' on 'SVGLengthList': 1 arguments required, but only ${arguments.length} present.`);
    }
    for (const item of this[cache].items) {
      item[getAttribute] = null;
      item[setAttribute] = null;
    }
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] ?? "0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].items = [newItem];
    this[cache].attributeValue = newItem[attributeValue];
    this[setAttribute](newItem[attributeValue]);
    return newItem;
  }
  /**
   * Returns item at index.
   *
   * @param index Index.
   * @returns The item at the index.
   **/
  getItem(index) {
    const items2 = this[getItemList]();
    if (typeof index === "number") {
      return items2[index] ? items2[index] : null;
    }
    index = Number(index);
    index = isNaN(index) ? 0 : index;
    return items2[index] ? items2[index] : null;
  }
  /**
   * Inserts a new item into the list at the specified position. The first item is number 0. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to insert before is before the removal of the item. If the index is equal to 0, then the new item is inserted at the front of the list. If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being inserted.
   */
  insertItemBefore(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGLengthList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'insertItemBefore' on 'SVGLengthList': 2 arguments required, but only ${arguments.length} present.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index > items2.length) {
      index = items2.length;
    }
    items2.splice(index, 0, newItem);
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] ?? "0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] ?? "0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return newItem;
  }
  /**
   * Replaces an existing item in the list with a new item. If newItem is already in a list, it is removed from its previous list before it is inserted into this list. The inserted item is the item itself and not a copy. If the item is already in this list, note that the index of the item to replace is before the removal of the item.
   *
   * @param newItem The item to insert into the list.
   * @param index Index.
   * @returns The item being replaced.
   */
  replaceItem(newItem, index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGLengthList': The object is read-only.`);
    }
    if (arguments.length < 2) {
      throw new this[window].TypeError(`Failed to execute 'replaceItem' on 'SVGLengthList': 2 arguments required, but only ${arguments.length} present.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex === index) {
      return newItem;
    }
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    if (index < 0) {
      index = 0;
    } else if (index >= items2.length) {
      index = items2.length - 1;
    }
    if (items2[index]) {
      items2[index][getAttribute] = null;
      items2[index][setAttribute] = null;
    }
    const replacedItem = items2[index];
    items2[index] = newItem;
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] ?? "0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] ?? "0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return replacedItem;
  }
  /**
   * Removes an existing item from the list.
   *
   * @param index Index.
   * @returns The removed item.
   */
  removeItem(index) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGLengthList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'removeItem' on 'SVGLengthList': 1 argument required, but only ${arguments.length} present.`);
    }
    const items2 = this[getItemList]();
    index = Number(index);
    if (isNaN(index)) {
      index = 0;
    }
    if (index >= items2.length) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGLengthList':  The index provided (${index}) is greater than the maximum bound.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    if (index < 0) {
      throw new this[window].DOMException(`Failed to execute 'removeItem' on 'SVGLengthList':  The index provided (${index}) is negative.`, DOMExceptionNameEnum_default.indexSizeError);
    }
    const removedItem = items2[index];
    if (removedItem) {
      removedItem[getAttribute] = null;
      removedItem[setAttribute] = null;
    }
    items2.splice(index, 1);
    this[setAttribute](items2.map((item) => item[attributeValue] ?? "0").join(" "));
    return removedItem;
  }
  /**
   * Appends an item to the end of the list.
   *
   * @param newItem The item to add to the list.
   * @returns The item being appended.
   */
  appendItem(newItem) {
    if (this[readOnly]) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGLengthList': The object is read-only.`);
    }
    if (arguments.length < 1) {
      throw new this[window].TypeError(`Failed to execute 'appendItem' on 'SVGLengthList': 1 argument required, but only ${arguments.length} present.`);
    }
    const items2 = this[getItemList]();
    const existingIndex = items2.indexOf(newItem);
    if (existingIndex !== -1) {
      items2.splice(existingIndex, 1);
    }
    items2.push(newItem);
    newItem[getAttribute] = () => newItem[attributeValue];
    newItem[setAttribute] = () => {
      this[cache].attributeValue = this[getItemList]().map((item) => item[attributeValue] ?? "0").join(" ");
      this[setAttribute](this[cache].attributeValue);
    };
    this[cache].attributeValue = items2.map((item) => item[attributeValue] ?? "0").join(" ");
    this[setAttribute](this[cache].attributeValue);
    return newItem;
  }
  /**
   * Returns item list from attribute value.
   *
   * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
   */
  [getItemList]() {
    const attributeValue2 = this[getAttribute]() ?? "";
    const cache2 = this[cache];
    if (cache2.attributeValue === attributeValue2) {
      return cache2.items;
    }
    if (cache2.items.length) {
      for (const item of cache2.items) {
        item[getAttribute] = null;
        item[setAttribute] = null;
      }
    }
    const items2 = [];
    const trimmed = attributeValue2.trim();
    if (trimmed) {
      const parts = trimmed.split(ATTRIBUTE_SEPARATOR_REGEXP4);
      for (let i = 0, max = parts.length; i < max; i++) {
        const item = new SVGLength(illegalConstructor, this[window], {
          readOnly: this[readOnly],
          getAttribute: () => item[attributeValue],
          setAttribute: (value2) => {
            item[attributeValue] = value2;
            const newAttributeValue = items2.map((item2) => item2[attributeValue] ?? "0").join(" ");
            cache2.attributeValue = newAttributeValue;
            this[setAttribute](newAttributeValue);
          }
        });
        item[attributeValue] = parts[i];
        items2.push(item);
      }
    }
    cache2.attributeValue = attributeValue2;
    cache2.items = items2;
    return items2;
  }
};

// node_modules/happy-dom/lib/svg/SVGAnimatedLengthList.js
var SVGAnimatedLengthList = class {
  // Internal properties
  [window];
  [getAttribute];
  [setAttribute];
  [baseVal] = null;
  [animVal] = null;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   * @param window Window.
   * @param options Options.
   * @param options.getAttribute Get attribute.
   * @param options.setAttribute Set attribute.
   */
  constructor(illegalConstructorSymbol, window2, options2) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
    this[window] = window2;
    this[getAttribute] = options2.getAttribute;
    this[setAttribute] = options2.setAttribute;
  }
  /**
   * Returns animated value.
   *
   * @returns Animated value.
   */
  get animVal() {
    if (!this[animVal]) {
      this[animVal] = new SVGLengthList(illegalConstructor, this[window], {
        readOnly: true,
        getAttribute: this[getAttribute],
        setAttribute: this[setAttribute]
      });
    }
    return this[animVal];
  }
  /**
   * Returns animated value.
   *
   * @param value Animated value.
   */
  set animVal(_value) {
  }
  /**
   * Returns base value.
   *
   * @returns Base value.
   */
  get baseVal() {
    if (!this[baseVal]) {
      this[baseVal] = new SVGLengthList(illegalConstructor, this[window], {
        getAttribute: this[getAttribute],
        setAttribute: this[setAttribute]
      });
    }
    return this[baseVal];
  }
  /**
   * Returns base value.
   *
   * @param value Base value.
   */
  set baseVal(_value) {
  }
};

// node_modules/happy-dom/lib/nodes/svg-text-positioning-element/SVGTextPositioningElement.js
var SVGTextPositioningElement = class extends SVGTextContentElement {
  // Internal properties
  [x] = null;
  [y] = null;
  [dx] = null;
  [dy] = null;
  [rotate] = null;
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLengthList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLengthList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Returns dx.
   *
   * @returns DX.
   */
  get dx() {
    if (!this[dx]) {
      this[dx] = new SVGAnimatedLengthList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("dx"),
        setAttribute: (value2) => this.setAttribute("dx", value2)
      });
    }
    return this[dx];
  }
  /**
   * Returns dy.
   *
   * @returns DY.
   */
  get dy() {
    if (!this[dy]) {
      this[dy] = new SVGAnimatedLengthList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("dy"),
        setAttribute: (value2) => this.setAttribute("dy", value2)
      });
    }
    return this[dy];
  }
  /**
   * Returns rotate.
   *
   * @returns Rotate.
   */
  get rotate() {
    if (!this[rotate]) {
      this[rotate] = new SVGAnimatedNumberList(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("rotate"),
        setAttribute: (value2) => this.setAttribute("rotate", value2)
      });
    }
    return this[rotate];
  }
};

// node_modules/happy-dom/lib/nodes/svg-text-element/SVGTextElement.js
var SVGTextElement = class extends SVGTextPositioningElement {
};

// node_modules/happy-dom/lib/nodes/svg-text-path-element/SVGTextPathElement.js
var SVGTextPathElement = class extends SVGTextContentElement {
  // Public static properties
  static TEXTPATH_METHODTYPE_UNKNOWN = 0;
  static TEXTPATH_METHODTYPE_ALIGN = 1;
  static TEXTPATH_METHODTYPE_STRETCH = 2;
  static TEXTPATH_SPACINGTYPE_UNKNOWN = 0;
  static TEXTPATH_SPACINGTYPE_AUTO = 1;
  static TEXTPATH_SPACINGTYPE_EXACT = 2;
  // Internal properties
  [href] = null;
  [startOffset] = null;
  [method] = null;
  [spacing] = null;
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
  /**
   * Returns start offset.
   *
   * @returns Start offset.
   */
  get startOffset() {
    if (!this[startOffset]) {
      this[startOffset] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("startOffset"),
        setAttribute: (value2) => this.setAttribute("startOffset", value2)
      });
    }
    return this[startOffset];
  }
  /**
   * Returns method.
   *
   * @returns ClipPathUnits.
   */
  get method() {
    if (!this[method]) {
      this[method] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("method"),
        setAttribute: (value2) => this.setAttribute("method", value2),
        values: ["align", "stretch"],
        defaultValue: "align"
      });
    }
    return this[method];
  }
  /**
   * Returns spacing.
   *
   * @returns Spacing.
   */
  get spacing() {
    if (!this[spacing]) {
      this[spacing] = new SVGAnimatedEnumeration(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("spacing"),
        setAttribute: (value2) => this.setAttribute("spacing", value2),
        values: ["auto", "exact"],
        defaultValue: "exact"
      });
    }
    return this[spacing];
  }
};

// node_modules/happy-dom/lib/nodes/svg-title-element/SVGTitleElement.js
var SVGTitleElement = class extends SVGElement {
};

// node_modules/happy-dom/lib/nodes/svg-t-span-element/SVGTSpanElement.js
var SVGTSpanElement = class extends SVGTextPositioningElement {
};

// node_modules/happy-dom/lib/nodes/svg-use-element/SVGUseElement.js
var SVGUseElement = class extends SVGGraphicsElement {
  // Internal properties
  [href] = null;
  [x] = null;
  [y] = null;
  [width] = null;
  [height] = null;
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this[href]) {
      this[href] = new SVGAnimatedString(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("href"),
        setAttribute: (value2) => this.setAttribute("href", value2)
      });
    }
    return this[href];
  }
  /**
   * Returns x position.
   *
   * @returns X position.
   */
  get x() {
    if (!this[x]) {
      this[x] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("x"),
        setAttribute: (value2) => this.setAttribute("x", value2)
      });
    }
    return this[x];
  }
  /**
   * Returns y position.
   *
   * @returns Y position.
   */
  get y() {
    if (!this[y]) {
      this[y] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("y"),
        setAttribute: (value2) => this.setAttribute("y", value2)
      });
    }
    return this[y];
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    if (!this[width]) {
      this[width] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("width"),
        setAttribute: (value2) => this.setAttribute("width", value2)
      });
    }
    return this[width];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    if (!this[height]) {
      this[height] = new SVGAnimatedLength(illegalConstructor, this[window], {
        getAttribute: () => this.getAttribute("height"),
        setAttribute: (value2) => this.setAttribute("height", value2)
      });
    }
    return this[height];
  }
};

// node_modules/happy-dom/lib/nodes/svg-view-element/SVGViewElement.js
var SVGViewElement = class extends SVGElement {
};

// node_modules/happy-dom/lib/svg/SVGUnitTypes.js
var SVGUnitTypes = class {
  static SVG_UNIT_TYPE_UNKNOWN = 0;
  static SVG_UNIT_TYPE_USERSPACEONUSE = 1;
  static SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;
  SVG_UNIT_TYPE_UNKNOWN = 0;
  SVG_UNIT_TYPE_USERSPACEONUSE = 1;
  SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;
  /**
   * Constructor.
   *
   * @param illegalConstructorSymbol Illegal constructor symbol.
   */
  constructor(illegalConstructorSymbol) {
    if (illegalConstructorSymbol !== illegalConstructor) {
      throw new TypeError("Illegal constructor");
    }
  }
};

// node_modules/happy-dom/lib/custom-element/CustomElementReactionStack.js
var CustomElementReactionStack = class {
  window;
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    this.window = window2;
  }
  /**
   * Enqueues a custom element reaction.
   *
   * @see https://html.spec.whatwg.org/multipage/custom-elements.html#enqueue-a-custom-element-callback-reaction
   * @see https://html.spec.whatwg.org/multipage/custom-elements.html#enqueue-an-element-on-the-appropriate-element-queue
   * @param element Element.
   * @param callbackName Callback name.
   * @param [args] Arguments.
   */
  enqueueReaction(element, callbackName, args) {
    const definition = this.window.customElements[registry]?.get(element.localName);
    if (!definition) {
      return;
    }
    if (element[ownerDocument] !== this.window.document) {
      return;
    }
    switch (callbackName) {
      case "connectedCallback":
        if (definition.livecycleCallbacks.connectedCallback) {
          const returnValue2 = definition.livecycleCallbacks.connectedCallback.call(element);
          if (returnValue2 instanceof Promise) {
            const asyncTaskManager2 = new WindowBrowserContext(this.window).getAsyncTaskManager();
            if (asyncTaskManager2) {
              const taskID = asyncTaskManager2.startTask();
              returnValue2.then(() => asyncTaskManager2.endTask(taskID)).catch(() => asyncTaskManager2.endTask(taskID));
            }
          }
        }
        break;
      case "disconnectedCallback":
        if (definition.livecycleCallbacks.disconnectedCallback) {
          definition.livecycleCallbacks.disconnectedCallback.call(element);
        }
        break;
      case "attributeChangedCallback":
        if (definition.livecycleCallbacks.attributeChangedCallback && definition.observedAttributes.has(args[0])) {
          definition.livecycleCallbacks.attributeChangedCallback.apply(element, args);
        }
        break;
    }
  }
};

// node_modules/happy-dom/lib/window/BrowserWindow.js
var TIMER2 = {
  setTimeout: globalThis.setTimeout.bind(globalThis),
  clearTimeout: globalThis.clearTimeout.bind(globalThis),
  setInterval: globalThis.setInterval.bind(globalThis),
  clearInterval: globalThis.clearInterval.bind(globalThis),
  queueMicrotask: globalThis.queueMicrotask.bind(globalThis),
  setImmediate: globalThis.setImmediate.bind(globalThis),
  clearImmediate: globalThis.clearImmediate.bind(globalThis)
};
var IS_NODE_JS_TIMEOUT_ENVIRONMENT = setTimeout.toString().includes("new Timeout");
var PerformanceObserverEntryList = class {
  /**
   * Constructor.
   */
  constructor() {
    throw new TypeError("Illegal constructor");
  }
};
var Timeout = class {
  callback;
  /**
   * Constructor.
   * @param callback Callback.
   */
  constructor(callback) {
    this.callback = callback;
  }
};
var BrowserWindow = class _BrowserWindow extends EventTarget {
  // Nodes
  Node = Node;
  Attr = Attr;
  ShadowRoot = ShadowRoot;
  ProcessingInstruction = ProcessingInstruction;
  Element = Element;
  CharacterData = CharacterData;
  DocumentType = DocumentType;
  // HTML Element classes
  HTMLAnchorElement = HTMLAnchorElement;
  HTMLButtonElement = HTMLButtonElement;
  HTMLOptGroupElement = HTMLOptGroupElement;
  HTMLOptionElement = HTMLOptionElement;
  HTMLElement = HTMLElement;
  HTMLUnknownElement = HTMLUnknownElement;
  HTMLTemplateElement = HTMLTemplateElement;
  HTMLInputElement = HTMLInputElement;
  HTMLSelectElement = HTMLSelectElement;
  HTMLTextAreaElement = HTMLTextAreaElement;
  HTMLImageElement = HTMLImageElement;
  HTMLStyleElement = HTMLStyleElement;
  HTMLLabelElement = HTMLLabelElement;
  HTMLSlotElement = HTMLSlotElement_default;
  HTMLMetaElement = HTMLMetaElement;
  HTMLMediaElement = HTMLMediaElement;
  HTMLAudioElement = HTMLAudioElement;
  HTMLVideoElement = HTMLVideoElement;
  HTMLBaseElement = HTMLBaseElement;
  HTMLDialogElement = HTMLDialogElement;
  HTMLScriptElement = HTMLScriptElement;
  HTMLLinkElement = HTMLLinkElement;
  HTMLIFrameElement = HTMLIFrameElement;
  HTMLFormElement = HTMLFormElement;
  HTMLUListElement = HTMLUListElement;
  HTMLTrackElement = HTMLTrackElement;
  HTMLTableRowElement = HTMLTableRowElement;
  HTMLTitleElement = HTMLTitleElement;
  HTMLTimeElement = HTMLTimeElement;
  HTMLTableSectionElement = HTMLTableSectionElement;
  HTMLTableCellElement = HTMLTableCellElement;
  HTMLTableElement = HTMLTableElement;
  HTMLSpanElement = HTMLSpanElement;
  HTMLSourceElement = HTMLSourceElement;
  HTMLQuoteElement = HTMLQuoteElement;
  HTMLProgressElement = HTMLProgressElement;
  HTMLPreElement = HTMLPreElement;
  HTMLPictureElement = HTMLPictureElement;
  HTMLParamElement = HTMLParamElement;
  HTMLParagraphElement = HTMLParagraphElement;
  HTMLOutputElement = HTMLOutputElement;
  HTMLOListElement = HTMLOListElement;
  HTMLObjectElement = HTMLObjectElement;
  HTMLMeterElement = HTMLMeterElement;
  HTMLMenuElement = HTMLMenuElement;
  HTMLMapElement = HTMLMapElement;
  HTMLLIElement = HTMLLIElement;
  HTMLLegendElement = HTMLLegendElement;
  HTMLModElement = HTMLModElement;
  HTMLHtmlElement = HTMLHtmlElement;
  HTMLHRElement = HTMLHRElement;
  HTMLHeadElement = HTMLHeadElement;
  HTMLHeadingElement = HTMLHeadingElement;
  HTMLFieldSetElement = HTMLFieldSetElement;
  HTMLEmbedElement = HTMLEmbedElement;
  HTMLDListElement = HTMLDListElement;
  HTMLDivElement = HTMLDivElement;
  HTMLDetailsElement = HTMLDetailsElement;
  HTMLDataListElement = HTMLDataListElement;
  HTMLDataElement = HTMLDataElement;
  HTMLTableColElement = HTMLTableColElement;
  HTMLTableCaptionElement = HTMLTableCaptionElement;
  HTMLCanvasElement = HTMLCanvasElement;
  HTMLBRElement = HTMLBRElement;
  HTMLBodyElement = HTMLBodyElement;
  HTMLAreaElement = HTMLAreaElement;
  // SVG Element classes
  SVGSVGElement = SVGSVGElement;
  SVGAnimateElement = SVGAnimateElement;
  SVGAnimateMotionElement = SVGAnimateMotionElement;
  SVGAnimateTransformElement = SVGAnimateTransformElement;
  SVGCircleElement = SVGCircleElement;
  SVGClipPathElement = SVGClipPathElement;
  SVGDefsElement = SVGDefsElement;
  SVGDescElement = SVGDescElement;
  SVGEllipseElement = SVGEllipseElement;
  SVGFEBlendElement = SVGFEBlendElement;
  SVGFEColorMatrixElement = SVGFEColorMatrixElement;
  SVGFEComponentTransferElement = SVGFEComponentTransferElement;
  SVGFECompositeElement = SVGFECompositeElement;
  SVGFEConvolveMatrixElement = SVGFEConvolveMatrixElement;
  SVGFEDiffuseLightingElement = SVGFEDiffuseLightingElement;
  SVGFEDisplacementMapElement = SVGFEDisplacementMapElement;
  SVGFEDistantLightElement = SVGFEDistantLightElement;
  SVGFEDropShadowElement = SVGFEDropShadowElement;
  SVGFEFloodElement = SVGFEFloodElement;
  SVGFEFuncAElement = SVGFEFuncAElement;
  SVGFEFuncBElement = SVGFEFuncBElement;
  SVGFEFuncGElement = SVGFEFuncGElement;
  SVGFEFuncRElement = SVGFEFuncRElement;
  SVGFEGaussianBlurElement = SVGFEGaussianBlurElement;
  SVGFEImageElement = SVGFEImageElement;
  SVGFEMergeElement = SVGFEMergeElement;
  SVGFEMergeNodeElement = SVGFEMergeNodeElement;
  SVGFEMorphologyElement = SVGFEMorphologyElement;
  SVGFEOffsetElement = SVGFEOffsetElement;
  SVGFEPointLightElement = SVGFEPointLightElement;
  SVGFESpecularLightingElement = SVGFESpecularLightingElement;
  SVGFESpotLightElement = SVGFESpotLightElement;
  SVGFETileElement = SVGFETileElement;
  SVGFETurbulenceElement = SVGFETurbulenceElement;
  SVGFilterElement = SVGFilterElement;
  SVGForeignObjectElement = SVGForeignObjectElement;
  SVGGElement = SVGGElement;
  SVGImageElement = SVGImageElement;
  SVGLineElement = SVGLineElement;
  SVGLinearGradientElement = SVGLinearGradientElement;
  SVGMarkerElement = SVGMarkerElement;
  SVGMaskElement = SVGMaskElement;
  SVGMetadataElement = SVGMetadataElement;
  SVGMPathElement = SVGMPathElement;
  SVGPathElement = SVGPathElement;
  SVGPatternElement = SVGPatternElement;
  SVGPolygonElement = SVGPolygonElement;
  SVGPolylineElement = SVGPolylineElement;
  SVGRadialGradientElement = SVGRadialGradientElement;
  SVGRectElement = SVGRectElement;
  SVGScriptElement = SVGScriptElement;
  SVGSetElement = SVGSetElement;
  SVGStopElement = SVGStopElement;
  SVGStyleElement = SVGStyleElement;
  SVGSwitchElement = SVGSwitchElement;
  SVGSymbolElement = SVGSymbolElement;
  SVGTextElement = SVGTextElement;
  SVGTextPathElement = SVGTextPathElement;
  SVGTitleElement = SVGTitleElement;
  SVGTSpanElement = SVGTSpanElement;
  SVGUseElement = SVGUseElement;
  SVGViewElement = SVGViewElement;
  // Abstract SVG Element classes
  SVGElement = SVGElement;
  SVGAnimationElement = SVGAnimationElement;
  SVGComponentTransferFunctionElement = SVGComponentTransferFunctionElement;
  SVGGeometryElement = SVGGeometryElement;
  SVGGradientElement = SVGGradientElement;
  SVGTextPositioningElement = SVGTextPositioningElement;
  SVGGraphicsElement = SVGGraphicsElement;
  // Event classes
  Event = Event;
  UIEvent = UIEvent;
  CustomEvent = CustomEvent;
  AnimationEvent = AnimationEvent;
  KeyboardEvent = KeyboardEvent;
  MessageEvent = MessageEvent;
  MouseEvent = MouseEvent;
  PointerEvent = PointerEvent;
  FocusEvent = FocusEvent;
  WheelEvent = WheelEvent;
  InputEvent = InputEvent;
  ErrorEvent = ErrorEvent;
  StorageEvent = StorageEvent;
  SubmitEvent = SubmitEvent;
  ProgressEvent = ProgressEvent;
  MediaQueryListEvent = MediaQueryListEvent;
  HashChangeEvent = HashChangeEvent;
  ClipboardEvent = ClipboardEvent;
  TouchEvent = TouchEvent;
  Touch = Touch;
  // Non-implemented event classes
  AudioProcessingEvent = Event;
  BeforeInputEvent = Event;
  BeforeUnloadEvent = Event;
  BlobEvent = Event;
  CloseEvent = Event;
  CompositionEvent = Event;
  CSSFontFaceLoadEvent = Event;
  DeviceLightEvent = Event;
  DeviceMotionEvent = Event;
  DeviceOrientationEvent = Event;
  DeviceProximityEvent = Event;
  DOMTransactionEvent = Event;
  DragEvent = Event;
  EditingBeforeInputEvent = Event;
  FetchEvent = Event;
  GamepadEvent = Event;
  IDBVersionChangeEvent = Event;
  MediaStreamEvent = Event;
  MutationEvent = Event;
  OfflineAudioCompletionEvent = Event;
  OverconstrainedError = Event;
  PageTransitionEvent = Event;
  PaymentRequestUpdateEvent = Event;
  PopStateEvent = Event;
  RelatedEvent = Event;
  RTCDataChannelEvent = Event;
  RTCIdentityErrorEvent = Event;
  RTCIdentityEvent = Event;
  RTCPeerConnectionIceEvent = Event;
  SensorEvent = Event;
  SVGEvent = Event;
  SVGZoomEvent = Event;
  TimeEvent = Event;
  TrackEvent = Event;
  TransitionEvent = Event;
  UserProximityEvent = Event;
  WebGLContextEvent = Event;
  TextEvent = Event;
  // Other classes that don't have to be bound to the Window context
  Permissions = Permissions;
  History = History;
  Navigator = Navigator;
  Clipboard = Clipboard;
  TimeRanges = TimeRanges;
  TextTrackCueList = TextTrackCueList;
  ValidityState = ValidityState;
  MutationRecord = MutationRecord;
  IntersectionObserver = IntersectionObserver;
  IntersectionObserverEntry = IntersectionObserverEntry;
  CSSStyleDeclaration = CSSStyleDeclaration;
  CSSRule = CSSRule;
  CSSContainerRule = CSSContainerRule;
  CSSFontFaceRule = CSSFontFaceRule;
  CSSKeyframeRule = CSSKeyframeRule;
  CSSKeyframesRule = CSSKeyframesRule;
  CSSMediaRule = CSSMediaRule;
  CSSStyleRule = CSSStyleRule;
  CSSSupportsRule = CSSSupportsRule;
  DOMRect = DOMRect;
  DOMRectReadOnly = DOMRectReadOnly;
  Plugin = Plugin;
  PluginArray = PluginArray;
  Location = Location;
  CustomElementRegistry = CustomElementRegistry;
  ResizeObserver = ResizeObserver;
  URL = URL2;
  Blob = Blob;
  File = File;
  Storage = Storage;
  MimeType = MimeType;
  MimeTypeArray = MimeTypeArray;
  NodeFilter = NodeFilter_default;
  HTMLCollection = HTMLCollection;
  HTMLFormControlCollection = HTMLFormControlsCollection;
  HTMLOptionsCollection = HTMLOptionsCollection;
  NodeList = NodeList_default;
  RadioNodeList = RadioNodeList;
  FileList = FileList;
  Screen = Screen;
  DOMMatrixReadOnly = DOMMatrixReadOnly;
  DOMMatrix = DOMMatrix;
  SVGAngle = SVGAngle;
  SVGAnimatedAngle = SVGAnimatedAngle;
  SVGAnimatedBoolean = SVGAnimatedBoolean;
  SVGAnimatedEnumeration = SVGAnimatedEnumeration;
  SVGAnimatedInteger = SVGAnimatedInteger;
  SVGAnimatedLength = SVGAnimatedLength;
  SVGAnimatedNumber = SVGAnimatedNumber;
  SVGAnimatedNumberList = SVGAnimatedNumberList;
  SVGAnimatedPreserveAspectRatio = SVGAnimatedPreserveAspectRatio;
  SVGAnimatedRect = SVGAnimatedRect;
  SVGAnimatedString = SVGAnimatedString;
  SVGAnimatedTransformList = SVGAnimatedTransformList;
  SVGLength = SVGLength;
  SVGLengthList = SVGLengthList;
  SVGMatrix = SVGMatrix;
  SVGNumber = SVGNumber;
  SVGNumberList = SVGNumberList;
  SVGPoint = SVGPoint;
  SVGPointList = SVGPointList;
  SVGPreserveAspectRatio = SVGPreserveAspectRatio;
  SVGRect = SVGRect;
  SVGStringList = SVGStringList;
  SVGTransform = SVGTransform;
  SVGTransformList = SVGTransformList;
  SVGAnimatedLengthList = SVGAnimatedLengthList;
  SVGUnitTypes = SVGUnitTypes;
  DOMPoint = DOMPoint;
  Window = this.constructor;
  // Node.js Classes
  URLSearchParams = URLSearchParams4;
  WritableStream = Stream3.Writable;
  ReadableStream = ReadableStream4;
  TransformStream = Stream3.Transform;
  PerformanceObserver = PerformanceObserver;
  PerformanceEntry = PerformanceEntry;
  PerformanceObserverEntryList = PerformanceObserverEntryList;
  // Events
  onload = null;
  onerror = null;
  // Public properties.
  document;
  customElements = new CustomElementRegistry(this);
  window = this;
  globalThis = this;
  performance = performance;
  screenLeft = 0;
  screenTop = 0;
  screenX = 0;
  screenY = 0;
  crypto = webcrypto;
  TextEncoder = TextEncoder;
  TextDecoder = TextDecoder2;
  closed = false;
  console;
  name = "";
  Buffer = Buffer8;
  // Public internal properties
  // Used for tracking capture event listeners to improve performance when they are not used.
  // See EventTarget class.
  [mutationObservers] = [];
  [readyStateManager] = new DocumentReadyStateManager(this);
  [location];
  [history];
  [navigator];
  [screen];
  [sessionStorage];
  [localStorage];
  [self] = this;
  [top] = this;
  [parent] = this;
  [window] = this;
  [internalId] = -1;
  [customElementReactionStack] = new CustomElementReactionStack(this);
  [modules] = {
    json: /* @__PURE__ */ new Map(),
    css: /* @__PURE__ */ new Map(),
    esm: /* @__PURE__ */ new Map()
  };
  [moduleImportMap] = null;
  // Private properties
  #browserFrame;
  #innerWidth = null;
  #innerHeight = null;
  #outerWidth = null;
  #outerHeight = null;
  #devicePixelRatio = null;
  #zeroDelayTimeout = { timeouts: null };
  #timerLoopStacks = [];
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   * @param [options] Options.
   * @param [options.url] URL.
   */
  constructor(browserFrame, options2) {
    super();
    this.#browserFrame = browserFrame;
    this.console = browserFrame.page.console;
    this[navigator] = new Navigator(this);
    this[screen] = new Screen();
    this[sessionStorage] = new Storage();
    this[localStorage] = new Storage();
    this[location] = new Location(this.#browserFrame, options2?.url ?? "about:blank");
    this[history] = new History(this.#browserFrame, this);
    WindowBrowserContext.setWindowBrowserFrameRelation(this, this.#browserFrame);
    this[setupVMContext]();
    WindowContextClassExtender.extendClasses(this);
    this.document = new this.HTMLDocument();
    this.document[defaultView] = this;
    this[readyStateManager].waitUntilComplete().then(() => {
      this.document[readyState] = DocumentReadyStateEnum_default.complete;
      this.document.dispatchEvent(new Event("readystatechange"));
      const loadEvent = new Event("load");
      loadEvent[currentTarget] = this;
      loadEvent[target] = this.document;
      loadEvent[eventPhase] = EventPhaseEnum_default.atTarget;
      this.dispatchEvent(loadEvent);
      loadEvent[currentTarget] = null;
      loadEvent[eventPhase] = EventPhaseEnum_default.none;
      loadEvent[dispatching] = false;
    });
    this[bindMethods]();
  }
  /**
   * Returns self.
   *
   * @returns Self.
   */
  get self() {
    return this[self];
  }
  /**
   * Returns self.
   *
   * @param self Self.
   */
  set self(self2) {
    this[self] = self2;
  }
  /**
   * Returns top.
   *
   * @returns Top.
   */
  get top() {
    return this[top];
  }
  /**
   * Returns parent.
   *
   * @returns Parent.
   */
  get parent() {
    return this[parent];
  }
  /**
   * Returns parent.
   *
   * @param parent Parent.
   */
  set parent(parent2) {
    this[parent] = parent2;
  }
  /**
   * Returns location.
   */
  get location() {
    return this[location];
  }
  /**
   * Returns location.
   *
   * @param href Href.
   */
  set location(href2) {
    this[location].href = href2;
  }
  /**
   * Returns history.
   */
  get history() {
    return this[history];
  }
  /**
   * Returns navigator.
   */
  get navigator() {
    return this[navigator];
  }
  /**
   * Returns screen.
   */
  get screen() {
    return this[screen];
  }
  /**
   * Returns session storage.
   */
  get sessionStorage() {
    return this[sessionStorage];
  }
  /**
   * Returns local storage.
   */
  get localStorage() {
    return this[localStorage];
  }
  /**
   * Returns opener.
   *
   * @returns Opener.
   */
  get opener() {
    return this.#browserFrame[openerWindow];
  }
  /**
   * The number of pixels that the document is currently scrolled horizontally.
   *
   * @returns Scroll X.
   */
  get scrollX() {
    return this.document?.documentElement?.scrollLeft ?? 0;
  }
  /**
   * The read-only Window property pageXOffset is an alias for scrollX.
   *
   * @returns Scroll X.
   */
  get pageXOffset() {
    return this.scrollX;
  }
  /**
   * The number of pixels that the document is currently scrolled vertically.
   *
   * @returns Scroll Y.
   */
  get scrollY() {
    return this.document?.documentElement?.scrollTop ?? 0;
  }
  /**
   * The read-only Window property pageYOffset is an alias for scrollY.
   *
   * @returns Scroll Y.
   */
  get pageYOffset() {
    return this.scrollY;
  }
  /**
   * The CSS interface holds useful CSS-related methods.
   *
   * @returns CSS interface.
   */
  get CSS() {
    return new CSS();
  }
  /**
   * Returns inner width.
   *
   * @returns Inner width.
   */
  get innerWidth() {
    if (this.#innerWidth === null) {
      return this.#browserFrame.page.viewport.width;
    }
    return this.#innerWidth;
  }
  /**
   * Sets inner width.
   *
   * @param value Inner width.
   */
  set innerWidth(value2) {
    this.#innerWidth = value2;
  }
  /**
   * Returns inner height.
   *
   * @returns Inner height.
   */
  get innerHeight() {
    if (this.#innerHeight === null) {
      return this.#browserFrame.page.viewport.height;
    }
    return this.#innerHeight;
  }
  /**
   * Sets inner height.
   *
   * @param value Inner height.
   */
  set innerHeight(value2) {
    this.#innerHeight = value2;
  }
  /**
   * Returns outer width.
   *
   * @returns Outer width.
   */
  get outerWidth() {
    if (this.#outerWidth === null) {
      return this.#browserFrame.page.viewport.width;
    }
    return this.#outerWidth;
  }
  /**
   * Sets outer width.
   *
   * @param value Outer width.
   */
  set outerWidth(value2) {
    this.#outerWidth = value2;
  }
  /**
   * Returns outer height.
   *
   * @returns Outer height.
   */
  get outerHeight() {
    if (this.#outerHeight === null) {
      return this.#browserFrame.page.viewport.height;
    }
    return this.#outerHeight;
  }
  /**
   * Sets outer height.
   *
   * @param value Outer height.
   */
  set outerHeight(value2) {
    this.#outerHeight = value2;
  }
  /**
   * Returns device pixel ratio.
   *
   * @returns Device pixel ratio.
   */
  get devicePixelRatio() {
    if (this.#devicePixelRatio === null) {
      return this.#browserFrame.page.viewport.devicePixelRatio;
    }
    return this.#devicePixelRatio;
  }
  /**
   * Sets device pixel ratio.
   *
   * @param value Device pixel ratio.
   */
  set devicePixelRatio(value2) {
    this.#devicePixelRatio = value2;
  }
  /**
   * Returns an object containing the values of all CSS properties of an element.
   *
   * @param element Element.
   * @returns CSS style declaration.
   */
  getComputedStyle(element) {
    element[computedStyle] = element[computedStyle] || new CSSStyleDeclaration(illegalConstructor, this, { element, computed: true });
    return element[computedStyle];
  }
  /**
   * Returns selection.
   *
   * @returns Selection.
   */
  getSelection() {
    return this.document.getSelection();
  }
  /**
   * Scrolls to a particular set of coordinates.
   *
   * @param x X position or options object.
   * @param y Y position.
   */
  scroll(x3, y3) {
    if (typeof x3 !== "object" && arguments.length === 1) {
      throw new this.TypeError("Failed to execute 'scroll' on 'Window': The provided value is not of type 'ScrollToOptions'.");
    }
    const options2 = typeof x3 === "object" ? x3 : { left: x3, top: y3 };
    if (options2.behavior === "smooth") {
      this.setTimeout(() => {
        if (options2.top !== void 0) {
          const top2 = Number(options2.top);
          this.document.documentElement.scrollTop = isNaN(top2) ? 0 : top2;
        }
        if (options2.left !== void 0) {
          const left = Number(options2.left);
          this.document.documentElement.scrollLeft = isNaN(left) ? 0 : left;
        }
      });
    } else {
      if (options2.top !== void 0) {
        const top2 = Number(options2.top);
        this.document.documentElement.scrollTop = isNaN(top2) ? 0 : top2;
      }
      if (options2.left !== void 0) {
        const left = Number(options2.left);
        this.document.documentElement.scrollLeft = isNaN(left) ? 0 : left;
      }
    }
  }
  /**
   * Scrolls to a particular set of coordinates.
   *
   * @param x X position or options object.
   * @param y Y position.
   */
  scrollTo(x3, y3) {
    if (typeof x3 !== "object" && arguments.length === 1) {
      throw new this.TypeError("Failed to execute 'scrollTo' on 'Window': The provided value is not of type 'ScrollToOptions'.");
    }
    this.scroll(x3, y3);
  }
  /**
   * Scrolls by a relative amount from the current position.
   *
   * @param x Pixels to scroll by from top or scroll options object.
   * @param y Pixels to scroll by from left.
   */
  scrollBy(x3, y3) {
    if (typeof x3 !== "object" && arguments.length === 1) {
      throw new this.TypeError("Failed to execute 'scrollBy' on 'Window': The provided value is not of type 'ScrollToOptions'.");
    }
    const options2 = typeof x3 === "object" ? x3 : { left: x3, top: y3 };
    this.scroll({
      left: this.document.documentElement.scrollLeft + (options2.left ?? 0),
      top: this.document.documentElement.scrollTop + (options2.top ?? 0),
      behavior: options2.behavior
    });
  }
  /**
   * Shifts focus away from the window.
   */
  blur() {
  }
  /**
   * Gives focus to the window.
   */
  focus() {
  }
  /**
   * Loads a specified resource into a new or existing browsing context (that is, a tab, a window, or an iframe) under a specified name.
   *
   * @param [url] URL.
   * @param [target] Target.
   * @param [features] Window features.
   * @returns Window.
   */
  open(url2, target2, features) {
    return WindowPageOpenUtility.openPage(this.#browserFrame, {
      url: url2,
      target: target2,
      features
    });
  }
  /**
   * Closes the window.
   */
  close() {
    if (this.#browserFrame.page?.mainFrame === this.#browserFrame) {
      this[destroy]();
      this.#browserFrame.page.close();
    }
  }
  /**
   * Returns a new MediaQueryList object that can then be used to determine if the document matches the media query string.
   *
   * @param mediaQueryString A string specifying the media query to parse into a MediaQueryList.
   * @returns A new MediaQueryList.
   */
  matchMedia(mediaQueryString) {
    return new MediaQueryList({ window: this, media: mediaQueryString });
  }
  /**
   * Sets a timer which executes a function once the timer expires.
   *
   * @param callback Function to be executed.
   * @param [delay=0] Delay in ms.
   * @param args Arguments passed to the callback function.
   * @returns Timeout ID.
   */
  setTimeout(callback, delay = 0, ...args) {
    if (this.closed) {
      return;
    }
    const settings2 = this.#browserFrame.page?.context?.browser?.settings;
    if (settings2.timer.preventTimerLoops) {
      const stack = new Error().stack;
      const timerLoopStacks = this.#timerLoopStacks;
      if (timerLoopStacks.includes(stack)) {
        return;
      }
      timerLoopStacks.push(stack);
    }
    if (!delay) {
      const zeroDelayTimeout = this.#zeroDelayTimeout;
      if (!zeroDelayTimeout.timeouts) {
        const useTryCatch2 = !settings2 || !settings2.disableErrorCapturing && settings2.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch;
        const id3 = TIMER2.setTimeout(() => {
          this.#browserFrame[asyncTaskManager].endTimer(id3);
          const timeouts = zeroDelayTimeout.timeouts;
          zeroDelayTimeout.timeouts = null;
          for (const timeout2 of timeouts) {
            if (useTryCatch2) {
              let result2;
              try {
                result2 = timeout2.callback();
              } catch (error2) {
                this[dispatchError](error2);
              }
              if (result2 instanceof Promise) {
                result2.catch((error2) => this[dispatchError](error2));
              }
            } else {
              timeout2.callback();
            }
          }
        }, 0);
        zeroDelayTimeout.timeouts = [];
        this.#browserFrame[asyncTaskManager].startTimer(id3);
      }
      const timeout = new Timeout(() => callback(...args));
      zeroDelayTimeout.timeouts.push(timeout);
      return timeout;
    }
    const useTryCatch = !settings2 || !settings2.disableErrorCapturing && settings2.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch;
    const id2 = TIMER2.setTimeout(() => {
      this.#browserFrame[asyncTaskManager].endTimer(id2);
      if (useTryCatch) {
        let result2;
        try {
          result2 = callback(...args);
        } catch (error2) {
          this[dispatchError](error2);
        }
        if (result2 instanceof Promise) {
          result2.catch((error2) => this[dispatchError](error2));
        }
      } else {
        callback(...args);
      }
    }, settings2?.timer.maxTimeout !== -1 && delay && delay > settings2?.timer.maxTimeout ? settings2?.timer.maxTimeout : delay);
    this.#browserFrame[asyncTaskManager].startTimer(id2);
    return id2;
  }
  /**
   * Cancels a timeout previously established by calling setTimeout().
   *
   * @param id ID of the timeout.
   */
  clearTimeout(id2) {
    if (id2 && id2 instanceof Timeout) {
      const zeroDelayTimeout = this.#zeroDelayTimeout;
      if (!zeroDelayTimeout.timeouts) {
        return;
      }
      const index = zeroDelayTimeout.timeouts.indexOf(id2);
      if (index !== -1) {
        zeroDelayTimeout.timeouts.splice(index, 1);
      }
      return;
    }
    if (IS_NODE_JS_TIMEOUT_ENVIRONMENT && (!id2 || id2.constructor.name !== "Timeout")) {
      return;
    }
    TIMER2.clearTimeout(id2);
    this.#browserFrame[asyncTaskManager].endTimer(id2);
  }
  /**
   * Calls a function with a fixed time delay between each call.
   *
   * @param callback Function to be executed.
   * @param [delay=0] Delay in ms.
   * @param args Arguments passed to the callback function.
   * @returns Interval ID.
   */
  setInterval(callback, delay = 0, ...args) {
    if (this.closed) {
      return;
    }
    const settings2 = this.#browserFrame.page?.context?.browser?.settings;
    const useTryCatch = !settings2 || !settings2.disableErrorCapturing && settings2.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch;
    let iterations = 0;
    const id2 = TIMER2.setInterval(() => {
      if (useTryCatch) {
        let result2;
        try {
          result2 = callback(...args);
        } catch (error2) {
          this.clearInterval(id2);
          this[dispatchError](error2);
        }
        if (result2 instanceof Promise) {
          result2.catch((error2) => {
            this.clearInterval(id2);
            this[dispatchError](error2);
          });
        }
      } else {
        callback(...args);
      }
      if (settings2?.timer.maxIntervalIterations !== -1) {
        if (iterations >= settings2?.timer.maxIntervalIterations) {
          this.clearInterval(id2);
        }
        iterations++;
      }
    }, settings2?.timer.maxIntervalTime !== -1 && delay && delay > settings2?.timer.maxIntervalTime ? settings2?.timer.maxIntervalTime : delay);
    this.#browserFrame[asyncTaskManager].startTimer(id2);
    return id2;
  }
  /**
   * Cancels a timed repeating action which was previously established by a call to setInterval().
   *
   * @param id ID of the interval.
   */
  clearInterval(id2) {
    if (IS_NODE_JS_TIMEOUT_ENVIRONMENT && (!id2 || id2.constructor.name !== "Timeout")) {
      return;
    }
    TIMER2.clearInterval(id2);
    this.#browserFrame[asyncTaskManager].endTimer(id2);
  }
  /**
   * Mock animation frames with timeouts.
   *
   * @param callback Callback.
   * @returns ID.
   */
  requestAnimationFrame(callback) {
    if (this.closed) {
      return;
    }
    const settings2 = this.#browserFrame.page?.context?.browser?.settings;
    if (settings2.timer.preventTimerLoops) {
      const stack = new Error().stack;
      const timerLoopStacks = this.#timerLoopStacks;
      if (timerLoopStacks.includes(stack)) {
        return;
      }
      timerLoopStacks.push(stack);
    }
    const useTryCatch = !settings2 || !settings2.disableErrorCapturing && settings2.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch;
    const id2 = TIMER2.setImmediate(() => {
      this.#browserFrame[asyncTaskManager].endImmediate(id2);
      if (useTryCatch) {
        let result2;
        try {
          result2 = callback(this.performance.now());
        } catch (error2) {
          this[dispatchError](error2);
        }
        if (result2 instanceof Promise) {
          result2.catch((error2) => this[dispatchError](error2));
        }
      } else {
        callback(this.performance.now());
      }
    });
    this.#browserFrame[asyncTaskManager].startImmediate(id2);
    return id2;
  }
  /**
   * Mock animation frames with timeouts.
   *
   * @param id ID.
   */
  cancelAnimationFrame(id2) {
    if (IS_NODE_JS_TIMEOUT_ENVIRONMENT && (!id2 || id2.constructor.name !== "Immediate")) {
      return;
    }
    TIMER2.clearImmediate(id2);
    this.#browserFrame[asyncTaskManager].endImmediate(id2);
  }
  /**
   * Queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.
   *
   * @param callback Function to be executed.
   */
  queueMicrotask(callback) {
    if (this.closed) {
      return;
    }
    let isAborted = false;
    const taskId = this.#browserFrame[asyncTaskManager].startTask(() => isAborted = true);
    const settings2 = this.#browserFrame.page?.context?.browser?.settings;
    const useTryCatch = !settings2 || !settings2.disableErrorCapturing && settings2.errorCapture === BrowserErrorCaptureEnum_default.tryAndCatch;
    TIMER2.queueMicrotask(() => {
      if (!isAborted) {
        this.#browserFrame[asyncTaskManager].endTask(taskId);
        if (useTryCatch) {
          let result2;
          try {
            result2 = callback();
          } catch (error2) {
            this[dispatchError](error2);
          }
          if (result2 instanceof Promise) {
            result2.catch((error2) => this[dispatchError](error2));
          }
        } else {
          callback();
        }
      }
    });
  }
  /**
   * This method provides an easy, logical way to fetch resources asynchronously across the network.
   *
   * @param url URL.
   * @param [init] Init.
   * @returns Promise.
   */
  async fetch(url2, init) {
    if (this.closed) {
      return Promise.reject(new this.DOMException("Failed to execute 'fetch' on 'Window': The window is closed.", DOMExceptionNameEnum_default.invalidStateError));
    }
    return await new Fetch({
      browserFrame: this.#browserFrame,
      window: this,
      url: url2,
      init
    }).send();
  }
  /**
   * Creates a Base64-encoded ASCII string from a binary string (i.e., a string in which each character in the string is treated as a byte of binary data).
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/btoa
   * @param data Binay data.
   * @returns Base64-encoded string.
   */
  btoa(data2) {
    return Base64.btoa(data2);
  }
  /**
   * Decodes a string of data which has been encoded using Base64 encoding.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/atob
   * @see https://infra.spec.whatwg.org/#forgiving-base64-encode.
   * @see Https://html.spec.whatwg.org/multipage/webappapis.html#btoa.
   * @param data Binay string.
   * @returns An ASCII string containing decoded data from encodedData.
   */
  atob(data2) {
    return Base64.atob(data2);
  }
  /**
   * Safely enables cross-origin communication between Window objects; e.g., between a page and a pop-up that it spawned, or between a page and an iframe embedded within it.
   *
   * @param message Message.
   * @param [targetOrigin=*] Target origin.
   * @param _transfer Transfer. Not implemented.
   */
  postMessage(message, targetOrigin = "*", _transfer) {
    if (this.closed) {
      return;
    }
    if (targetOrigin && targetOrigin !== "*" && this.location.origin !== targetOrigin) {
      throw new this.DOMException(`Failed to execute 'postMessage' on 'Window': The target origin provided ('${targetOrigin}') does not match the recipient window's origin ('${this.location.origin}').`, DOMExceptionNameEnum_default.securityError);
    }
    try {
      JSON.stringify(message);
    } catch (error2) {
      throw new this.DOMException(`Failed to execute 'postMessage' on 'Window': The provided message cannot be serialized.`, DOMExceptionNameEnum_default.invalidStateError);
    }
    this.setTimeout(() => this.dispatchEvent(new MessageEvent("message", {
      data: message,
      origin: this.#browserFrame.parentFrame ? this.#browserFrame.parentFrame.window.location.origin : this.#browserFrame.window.location.origin,
      source: this.#browserFrame.parentFrame ? this.#browserFrame.parentFrame.window : this.#browserFrame.window,
      lastEventId: ""
    })));
  }
  /**
   * Resizes the window.
   *
   * @param width Width.
   * @param height Height.
   */
  resizeTo(width2, height2) {
    if (this.closed) {
      return;
    }
    if (!width2 || !height2) {
      throw new this.DOMException(`Failed to execute 'resizeTo' on 'Window': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (this.#browserFrame[popup]) {
      this.#browserFrame.page.setViewport({ width: width2, height: height2 });
    }
  }
  /**
   * Resizes the current window by a specified amount.
   *
   * @param width Width.
   * @param height Height.
   */
  resizeBy(width2, height2) {
    if (this.closed) {
      return;
    }
    if (!width2 || !height2) {
      throw new this.DOMException(`Failed to execute 'resizeBy' on 'Window': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (this.#browserFrame[popup]) {
      const viewport = this.#browserFrame.page.viewport;
      this.#browserFrame.page.setViewport({
        width: viewport.width + width2,
        height: viewport.height + height2
      });
    }
  }
  /**
   * Dispatches an error event and outputs the error to the console.
   *
   * @param error Error.
   */
  [dispatchError](error2) {
    this.#browserFrame?.page?.console.error(error2);
    this.dispatchEvent(new ErrorEvent("error", { message: error2.message, error: error2 }));
  }
  /**
   * Setup of VM context.
   */
  [setupVMContext]() {
    if (!VM.isContext(this)) {
      VM.createContext(this);
      VMGlobalPropertyScript_default.runInContext(this);
    }
  }
  /**
   * Destroys the window.
   */
  [destroy]() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    const mutationObservers2 = this[mutationObservers];
    for (const mutationObserver of mutationObservers2) {
      if (mutationObserver[destroy]) {
        mutationObserver[destroy]();
      }
    }
    this[mutationObservers] = [];
    this[asyncTaskManager] = null;
    this[mutationObservers] = [];
    const childNodes2 = this.document[nodeArray];
    while (childNodes2.length > 0) {
      if (childNodes2[0].disconnectedCallback) {
        delete childNodes2[0].disconnectedCallback;
      }
      this.document[removeChild](childNodes2[0]);
    }
    const htmlElement = this.document.createElement("html");
    const headElement = this.document.createElement("head");
    const bodyElement = this.document.createElement("body");
    htmlElement.appendChild(headElement);
    htmlElement.appendChild(bodyElement);
    this.document[appendChild](htmlElement);
    if (this.location[destroy]) {
      this.location[destroy]();
    }
    if (this.customElements[destroy]) {
      this.customElements[destroy]();
    }
    if (this.history[destroy]) {
      this.history[destroy]();
    }
    this[modules].json.clear();
    this[modules].css.clear();
    this[modules].esm.clear();
    this.document[preloads].clear();
    this.document[activeElement] = null;
    this.document[nextActiveElement] = null;
    this.document[currentScript] = null;
    this.document[selection] = null;
    WindowBrowserContext.removeWindowBrowserFrameRelation(this);
  }
  /**
   * Binds methods to a window as scope.
   */
  [bindMethods]() {
    for (const _class of [_BrowserWindow, EventTarget]) {
      const propertyDescriptors = Object.getOwnPropertyDescriptors(_class.prototype);
      const keys = Object.keys(propertyDescriptors);
      for (const key of keys) {
        const descriptor = propertyDescriptors[key];
        if (descriptor.get || descriptor.set) {
          Object.defineProperty(this, key, {
            ...descriptor,
            get: descriptor.get?.bind(this),
            set: descriptor.set?.bind(this)
          });
        } else if (key !== "constructor" && typeof descriptor.value === "function" && !descriptor.value.toString().startsWith("class ")) {
          Object.defineProperty(this, key, {
            ...descriptor,
            value: descriptor.value.bind(this)
          });
        }
      }
    }
  }
};

// node_modules/happy-dom/lib/browser/BrowserFrame.js
var BrowserFrame = class {
  childFrames = [];
  parentFrame = null;
  page;
  window;
  [asyncTaskManager] = new AsyncTaskManager(this);
  [listeners] = { navigation: [] };
  [openerFrame] = null;
  [openerWindow] = null;
  [popup] = false;
  [history] = [
    {
      title: "",
      href: "about:blank",
      state: null,
      scrollRestoration: HistoryScrollRestorationEnum_default.auto,
      method: "GET",
      formData: null,
      isCurrent: true
    }
  ];
  /**
   * Constructor.
   *
   * @param page Page.
   */
  constructor(page) {
    this.page = page;
    this.window = new BrowserWindow(this);
    if (page.context.browser[exceptionObserver]) {
      page.context.browser[exceptionObserver].observe(this.window);
    }
  }
  /**
   * Returns the content.
   *
   * @returns Content.
   */
  get content() {
    return this.window.document.documentElement.outerHTML;
  }
  /**
   * Sets the content.
   *
   * @param content Content.
   */
  set content(content2) {
    this.window.document[isFirstWrite] = true;
    this.window.document[isFirstWriteAfterOpen] = false;
    this.window.document.open();
    this.window.document.write(content2);
  }
  /**
   * Returns the URL.
   *
   * @returns URL.
   */
  get url() {
    return this.window.location.href;
  }
  /**
   * Sets the content.
   *
   * @param url URL.
   */
  set url(url2) {
    this.window[location][setURL](this, BrowserFrameURL.getRelativeURL(this, url2).href);
  }
  /**
   * Returns document.
   *
   * @returns Document.
   */
  get document() {
    return this.window?.document ?? null;
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   */
  async waitUntilComplete() {
    await Promise.all([
      this[asyncTaskManager].waitUntilComplete(),
      ...this.childFrames.map((frame) => frame.waitUntilComplete())
    ]);
  }
  /**
   * Returns a promise that is resolved when the frame has navigated and the response HTML has been written to the document.
   */
  waitForNavigation() {
    return new Promise((resolve) => this[listeners].navigation.push(resolve));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    if (!this.childFrames.length) {
      return this[asyncTaskManager].abort();
    }
    return new Promise((resolve, reject) => {
      Promise.all(this.childFrames.map((frame) => frame.abort()).concat([this[asyncTaskManager].abort()])).then(() => resolve()).catch(reject);
    });
  }
  /**
   * Evaluates code or a VM Script in the page's context.
   *
   * @param script Script.
   * @returns Result.
   */
  evaluate(script) {
    return BrowserFrameScriptEvaluator.evaluate(this, script);
  }
  /**
   * Go to a page.
   *
   * @param url URL.
   * @param [options] Options.
   * @returns Response.
   */
  goto(url2, options2) {
    return BrowserFrameNavigator.navigate({
      windowClass: BrowserWindow,
      frame: this,
      url: url2,
      goToOptions: options2
    });
  }
  /**
   * Navigates back in history.
   *
   * @param [options] Options.
   */
  goBack(options2) {
    return BrowserFrameNavigator.navigateBack({
      windowClass: BrowserWindow,
      frame: this,
      goToOptions: options2
    });
  }
  /**
   * Navigates forward in history.
   *
   * @param [options] Options.
   */
  goForward(options2) {
    return BrowserFrameNavigator.navigateForward({
      windowClass: BrowserWindow,
      frame: this,
      goToOptions: options2
    });
  }
  /**
   * Navigates a delta in history.
   *
   * @param steps Steps.
   * @param [options] Options.
   */
  goSteps(steps, options2) {
    return BrowserFrameNavigator.navigateSteps({
      windowClass: BrowserWindow,
      frame: this,
      steps,
      goToOptions: options2
    });
  }
  /**
   * Reloads the current frame.
   *
   * @param [options] Options.
   * @returns Response.
   */
  reload(options2) {
    return BrowserFrameNavigator.reload({
      windowClass: BrowserWindow,
      frame: this,
      goToOptions: options2
    });
  }
};

// node_modules/happy-dom/lib/console/VirtualConsole.js
var VirtualConsole = class {
  // This is needed as the interface for the NodeJS Console also have a reference to the ConsoleConstructor class as a property for some reason.
  // This is not part of the browser specs.
  Console;
  #printer;
  #count = {};
  #time = {};
  #groupID = 0;
  #groups = [];
  /**
   * Constructor.
   *
   * @param printer Console printer.
   */
  constructor(printer) {
    this.#printer = printer;
  }
  /**
   * Writes an error message to the console if the assertion is false. If the assertion is true, nothing happens.
   *
   * @param assertion Assertion.
   * @param message Message.
   * @param args Arguments.
   */
  assert(assertion, message, ...args) {
    if (!assertion) {
      this.#printer.print({
        type: VirtualConsoleLogTypeEnum_default.assert,
        level: VirtualConsoleLogLevelEnum_default.error,
        message: ["Assertion failed:", ...message ? [message, ...args] : args],
        group: this.#groups[this.#groups.length - 1] || null
      });
    }
  }
  /**
   * Clears the console.
   */
  clear() {
    this.#printer.clear();
  }
  /**
   * Logs the number of times that this particular call to count() has been called.
   *
   * @param [label='default'] Label.
   */
  count(label2 = "default") {
    if (!this.#count[label2]) {
      this.#count[label2] = 0;
    }
    this.#count[label2]++;
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.count,
      level: VirtualConsoleLogLevelEnum_default.info,
      message: [`${label2}: ${this.#count[label2]}`],
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Resets the counter.
   *
   * @param [label='default'] Label.
   */
  countReset(label2 = "default") {
    delete this.#count[label2];
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.countReset,
      level: VirtualConsoleLogLevelEnum_default.warn,
      message: [`${label2}: 0`],
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Outputs a message to the web console at the "debug" log level.
   *
   * @param message Message.
   * @param args Arguments.
   */
  debug(message, ...args) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.debug,
      level: VirtualConsoleLogLevelEnum_default.log,
      message: message ? [message, ...args] : args,
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Displays an interactive list of the properties of the specified JavaScript object.
   *
   * @param data Data.
   */
  dir(data2) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.dir,
      level: VirtualConsoleLogLevelEnum_default.log,
      message: [data2],
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Displays an interactive tree of the descendant elements of the specified XML/HTML element.
   *
   * @param data Data.
   */
  dirxml(data2) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.dirxml,
      level: VirtualConsoleLogLevelEnum_default.log,
      message: [data2],
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Outputs an error message to the console.
   *
   * @param message Message.
   * @param args Arguments.
   */
  error(message, ...args) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.error,
      level: VirtualConsoleLogLevelEnum_default.error,
      message: message ? [message, ...args] : args,
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Alias for error().
   *
   * @deprecated
   * @alias error()
   * @param args Arguments.
   */
  exception(...args) {
    this.error(...args);
  }
  /**
   * Creates a new inline group in the console, causing any subsequent console messages to be indented by an additional level, until console.groupEnd() is called.
   *
   * @param [label] Label.
   */
  group(label2) {
    this.#groupID++;
    const group = {
      id: this.#groupID,
      label: label2 || "default",
      collapsed: false,
      parent: this.#groups[this.#groups.length - 1] || null
    };
    this.#groups.push(group);
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.group,
      level: VirtualConsoleLogLevelEnum_default.log,
      message: [label2 || "default"],
      group
    });
  }
  /**
   * Creates a new inline group in the console, but prints it as collapsed, requiring the use of a disclosure button to expand it.
   *
   * @param [label] Label.
   */
  groupCollapsed(label2) {
    this.#groupID++;
    const group = {
      id: this.#groupID,
      label: label2 || "default",
      collapsed: true,
      parent: this.#groups[this.#groups.length - 1] || null
    };
    this.#groups.push(group);
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.groupCollapsed,
      level: VirtualConsoleLogLevelEnum_default.log,
      message: [label2 || "default"],
      group
    });
  }
  /**
   * Exits the current inline group in the console.
   */
  groupEnd() {
    if (this.#groups.length === 0) {
      return;
    }
    this.#groups.pop();
  }
  /**
   * Outputs an informational message to the console.
   *
   * @param message Message.
   * @param args Arguments.
   */
  info(message, ...args) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.info,
      level: VirtualConsoleLogLevelEnum_default.info,
      message: message ? [message, ...args] : args,
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Outputs a message to the console.
   *
   * @param message Message.
   * @param args Arguments.
   */
  log(message, ...args) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.log,
      level: VirtualConsoleLogLevelEnum_default.log,
      message: message ? [message, ...args] : args,
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Starts recording a performance profile.
   *
   * TODO: Implement this.
   */
  profile() {
    throw new Error("Method not implemented.");
  }
  /**
   * Stops recording a performance profile.
   *
   * TODO: Implement this.
   */
  profileEnd() {
    throw new Error("Method not implemented.");
  }
  /**
   * Displays tabular data as a table.
   *
   * @param data Data.
   */
  table(data2) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.table,
      level: VirtualConsoleLogLevelEnum_default.log,
      message: [data2],
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Starts a timer you can use to track how long an operation takes.
   *
   * @param [label=default] Label.
   */
  time(label2 = "default") {
    this.#time[label2] = performance.now();
  }
  /**
   * Stops a timer that was previously started by calling console.time().
   * The method logs the elapsed time in milliseconds.
   *
   * @param [label=default] Label.
   */
  timeEnd(label2 = "default") {
    const time = this.#time[label2];
    if (time) {
      const duration2 = performance.now() - time;
      this.#printer.print({
        type: VirtualConsoleLogTypeEnum_default.timeEnd,
        level: VirtualConsoleLogLevelEnum_default.info,
        message: [`${label2}: ${duration2}ms - timer ended`],
        group: this.#groups[this.#groups.length - 1] || null
      });
    }
  }
  /**
   * Logs the current value of a timer that was previously started by calling console.time().
   * The method logs the elapsed time in milliseconds.
   *
   * @param [label=default] Label.
   * @param [args] Arguments.
   */
  timeLog(label2 = "default", ...args) {
    const time = this.#time[label2];
    if (time) {
      const duration2 = performance.now() - time;
      this.#printer.print({
        type: VirtualConsoleLogTypeEnum_default.timeLog,
        level: VirtualConsoleLogLevelEnum_default.info,
        message: [`${label2}: ${duration2}ms`, ...args],
        group: this.#groups[this.#groups.length - 1] || null
      });
    }
  }
  /**
   * Adds a single marker to the browser's Performance tool.
   *
   * TODO: Implement this.
   */
  timeStamp() {
    throw new Error("Method not implemented.");
  }
  /**
   * Outputs a stack trace to the console.
   *
   * @param message Message.
   * @param args Arguments.
   */
  trace(message, ...args) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.trace,
      level: VirtualConsoleLogLevelEnum_default.log,
      message: [
        ...message ? [message, ...args] : args,
        new Error("stack").stack.replace("Error: stack", "")
      ],
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
  /**
   * Outputs a warning message to the console.
   *
   * @param message Message.
   * @param args Arguments.
   */
  warn(message, ...args) {
    this.#printer.print({
      type: VirtualConsoleLogTypeEnum_default.warn,
      level: VirtualConsoleLogLevelEnum_default.warn,
      message: message ? [message, ...args] : args,
      group: this.#groups[this.#groups.length - 1] || null
    });
  }
};

// node_modules/happy-dom/lib/browser/utilities/BrowserPageUtility.js
var BrowserPageUtility = class {
  /**
   * Returns frames for a page.
   *
   * @param page Page.
   * @returns Frames.
   */
  static getFrames(page) {
    return this.findFrames(page.mainFrame);
  }
  /**
   * Aborts all ongoing operations and destroys the page.
   *
   * @param page Page.
   */
  static closePage(page) {
    return new Promise((resolve, reject) => {
      if (!page.mainFrame) {
        resolve();
        return;
      }
      const index = page.context.pages.indexOf(page);
      if (index !== -1) {
        page.context.pages.splice(index, 1);
      }
      BrowserFrameFactory.destroyFrame(page.mainFrame).then(() => {
        page.virtualConsolePrinter = null;
        page.mainFrame = null;
        page.context = null;
        resolve();
      }).catch((error2) => reject(error2));
    });
  }
  /**
   * Returns all frames.
   *
   * @param parentFrame Parent frame.
   * @returns Frames, including the parent.
   */
  static findFrames(parentFrame) {
    let frames = [parentFrame];
    for (const frame of parentFrame.childFrames) {
      frames = frames.concat(this.findFrames(frame));
    }
    return frames;
  }
};

// node_modules/happy-dom/lib/browser/DefaultBrowserPageViewport.js
var DefaultBrowserPageViewport_default = {
  width: 1024,
  height: 768,
  devicePixelRatio: 1
};

// node_modules/happy-dom/lib/browser/BrowserPage.js
var BrowserPage = class {
  virtualConsolePrinter = new VirtualConsolePrinter();
  mainFrame;
  context;
  console;
  viewport = Object.assign({}, DefaultBrowserPageViewport_default);
  /**
   * Constructor.
   *
   * @param context Browser context.
   */
  constructor(context) {
    this.context = context;
    this.console = context.browser.console ?? new VirtualConsole(this.virtualConsolePrinter);
    this.mainFrame = new BrowserFrame(this);
  }
  /**
   * Returns frames.
   */
  get frames() {
    return BrowserPageUtility.getFrames(this);
  }
  /**
   * Returns the viewport.
   */
  get content() {
    return this.mainFrame.content;
  }
  /**
   * Sets the content.
   *
   * @param content Content.
   */
  set content(content2) {
    this.mainFrame.content = content2;
  }
  /**
   * Returns the URL.
   *
   * @returns URL.
   */
  get url() {
    return this.mainFrame.url;
  }
  /**
   * Sets the content.
   *
   * @param url URL.
   */
  set url(url2) {
    this.mainFrame.url = url2;
  }
  /**
   * Aborts all ongoing operations and destroys the page.
   */
  close() {
    return BrowserPageUtility.closePage(this);
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   */
  waitUntilComplete() {
    return this.mainFrame.waitUntilComplete();
  }
  /**
   * Returns a promise that is resolved when the page has navigated and the response HTML has been written to the document.
   */
  waitForNavigation() {
    return this.mainFrame.waitForNavigation();
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return this.mainFrame.abort();
  }
  /**
   * Evaluates code or a VM Script in the page's context.
   *
   * @param script Script.
   * @returns Result.
   */
  evaluate(script) {
    return this.mainFrame.evaluate(script);
  }
  /**
   * Sets the viewport.
   *
   * @param viewport Viewport.
   */
  setViewport(viewport) {
    const previousViewport = Object.assign({}, this.viewport);
    Object.assign(this.viewport, viewport);
    if (previousViewport.width !== this.viewport.width || previousViewport.height !== this.viewport.height || previousViewport.devicePixelRatio !== this.viewport.devicePixelRatio) {
      this.mainFrame.window.dispatchEvent(new Event("resize"));
    }
  }
  /**
   * Go to a page.
   *
   * @param url URL.
   * @param [options] Options.
   * @returns Response.
   */
  goto(url2, options2) {
    return this.mainFrame.goto(url2, options2);
  }
  /**
   * Navigates back in history.
   *
   * @param [options] Options.
   */
  goBack(options2) {
    return this.mainFrame.goBack(options2);
  }
  /**
   * Navigates forward in history.
   *
   * @param [options] Options.
   */
  goForward(options2) {
    return this.mainFrame.goForward(options2);
  }
  /**
   * Navigates a delta in history.
   *
   * @param delta Delta.
   * @param steps
   * @param [options] Options.
   */
  goSteps(steps, options2) {
    return this.mainFrame.goSteps(steps, options2);
  }
  /**
   * Reloads the current page.
   *
   * @param [options] Options.
   * @returns Response.
   */
  reload(options2) {
    return this.mainFrame.reload(options2);
  }
};

// node_modules/happy-dom/lib/fetch/cache/preflight/PreflightResponseCache.js
var PreflightResponseCache = class {
  #entries = {};
  /**
   * Returns cached response.
   *
   * @param request Request.
   * @returns Cached response.
   */
  get(request) {
    const cachedResponse2 = this.#entries[request.url];
    if (cachedResponse2) {
      if (cachedResponse2.expires < Date.now()) {
        delete this.#entries[request.url];
        return null;
      }
      return cachedResponse2;
    }
    return null;
  }
  /**
   * Adds a cache entity.
   *
   * @param request Request.
   * @param response Response.
   * @returns Cached response.
   */
  add(request, response) {
    delete this.#entries[request.url];
    if (request.headers.get("Cache-Control")?.includes("no-cache")) {
      return null;
    }
    if (response.status < 200 || response.status >= 300) {
      return null;
    }
    const maxAge = response.headers.get("Access-Control-Max-Age");
    const allowOrigin = response.headers.get("Access-Control-Allow-Origin");
    if (!maxAge || !allowOrigin) {
      return null;
    }
    const allowMethods = [];
    if (response.headers.has("Access-Control-Allow-Methods")) {
      const allowMethodsHeader = response.headers.get("Access-Control-Allow-Methods");
      if (allowMethodsHeader !== "*") {
        for (const method2 of response.headers.get("Access-Control-Allow-Methods").split(",")) {
          allowMethods.push(method2.trim().toUpperCase());
        }
      }
    }
    const cachedResponse2 = {
      allowOrigin,
      allowMethods,
      expires: Date.now() + parseInt(maxAge) * 1e3
    };
    if (isNaN(cachedResponse2.expires) || cachedResponse2.expires < Date.now()) {
      return null;
    }
    this.#entries[request.url] = cachedResponse2;
    return cachedResponse2;
  }
  /**
   * Clears the cache.
   */
  clear() {
    this.#entries = {};
  }
};

// node_modules/happy-dom/lib/browser/BrowserContext.js
var BrowserContext = class {
  pages = [];
  browser;
  cookieContainer = new CookieContainer();
  responseCache = new ResponseCache();
  preflightResponseCache = new PreflightResponseCache();
  /**
   * Constructor.
   *
   * @param browser
   */
  constructor(browser) {
    this.browser = browser;
  }
  /**
   * Aborts all ongoing operations and destroys the context.
   */
  async close() {
    if (!this.browser) {
      return;
    }
    await Promise.all(this.pages.slice().map((page) => page.close()));
    const browser = this.browser;
    const index = browser.contexts.indexOf(this);
    if (index !== -1) {
      browser.contexts.splice(index, 1);
    }
    this.pages = [];
    this.browser = null;
    this.cookieContainer = null;
    this.responseCache.clear();
    this.preflightResponseCache.clear();
    this.responseCache = null;
    this.preflightResponseCache = null;
    if (browser.contexts.length === 0) {
      browser.close();
    }
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   *
   * @returns Promise.
   */
  async waitUntilComplete() {
    await Promise.all(this.pages.map((page) => page.waitUntilComplete()));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return new Promise((resolve, reject) => {
      if (!this.pages.length) {
        resolve();
        return;
      }
      Promise.all(this.pages.slice().map((page) => page.abort())).then(() => resolve()).catch((error2) => reject(error2));
    });
  }
  /**
   * Creates a new page.
   *
   * @returns Page.
   */
  newPage() {
    const page = new BrowserPage(this);
    this.pages.push(page);
    return page;
  }
};

// node_modules/happy-dom/lib/version.js
var version_default = { version: "0.0.0" };

// node_modules/happy-dom/lib/browser/DefaultBrowserSettings.js
var DefaultBrowserSettings_default = {
  disableJavaScriptEvaluation: false,
  disableJavaScriptFileLoading: false,
  disableCSSFileLoading: false,
  disableIframePageLoading: false,
  disableComputedStyleRendering: false,
  disableErrorCapturing: false,
  errorCapture: BrowserErrorCaptureEnum_default.tryAndCatch,
  enableFileSystemHttpRequests: false,
  timer: {
    maxTimeout: -1,
    maxIntervalTime: -1,
    maxIntervalIterations: -1,
    preventTimerLoops: false
  },
  fetch: {
    disableSameOriginPolicy: false,
    interceptor: null,
    virtualServers: null
  },
  navigation: {
    disableMainFrameNavigation: false,
    disableChildFrameNavigation: false,
    disableChildPageNavigation: false,
    disableFallbackToSetURL: false,
    crossOriginPolicy: BrowserNavigationCrossOriginPolicyEnum_default.anyOrigin
  },
  navigator: {
    userAgent: `Mozilla/5.0 (X11; ${process.platform.charAt(0).toUpperCase() + process.platform.slice(1) + " " + process.arch}) AppleWebKit/537.36 (KHTML, like Gecko) HappyDOM/${version_default.version}`,
    maxTouchPoints: 0
  },
  device: {
    prefersColorScheme: "light",
    prefersReducedMotion: "no-preference",
    mediaType: "screen",
    forcedColors: "none"
  },
  debug: {
    traceWaitUntilComplete: -1
  }
};

// node_modules/happy-dom/lib/browser/BrowserSettingsFactory.js
var BrowserSettingsFactory = class {
  /**
   * Returns browser settings.
   *
   * @param [settings] Browser settings.
   * @param [freezeObject] "true" to freeze the object.
   * @returns Settings.
   */
  static createSettings(settings2) {
    return {
      ...DefaultBrowserSettings_default,
      ...settings2,
      navigation: {
        ...DefaultBrowserSettings_default.navigation,
        ...settings2?.navigation
      },
      navigator: {
        ...DefaultBrowserSettings_default.navigator,
        ...settings2?.navigator
      },
      timer: {
        ...DefaultBrowserSettings_default.timer,
        ...settings2?.timer
      },
      fetch: {
        ...DefaultBrowserSettings_default.fetch,
        ...settings2?.fetch
      },
      device: {
        ...DefaultBrowserSettings_default.device,
        ...settings2?.device
      },
      debug: {
        ...DefaultBrowserSettings_default.debug,
        ...settings2?.debug
      }
    };
  }
};

// node_modules/happy-dom/lib/browser/utilities/BrowserExceptionObserver.js
var BrowserExceptionObserver = class {
  static listenerCount = 0;
  observedWindows = [];
  uncaughtExceptionListener = null;
  uncaughtRejectionListener = null;
  /**
   * Observes the Node process for uncaught exceptions.
   *
   * @param window Browser window.
   */
  observe(window2) {
    if (this.observedWindows.includes(window2)) {
      throw new Error("Browser window is already being observed.");
    }
    this.observedWindows.push(window2);
    if (this.uncaughtExceptionListener) {
      return;
    }
    this.uncaughtExceptionListener = (error2, origin) => {
      if (origin === "unhandledRejection") {
        return;
      }
      let targetWindow = null;
      for (const window3 of this.observedWindows) {
        if (error2 instanceof window3.Error || error2 instanceof window3.DOMException) {
          targetWindow = window3;
          break;
        }
      }
      if (targetWindow) {
        targetWindow.console.error(error2);
        targetWindow.dispatchEvent(new targetWindow.ErrorEvent("error", {
          error: error2,
          message: error2.message
        }));
      } else if (process.listenerCount("uncaughtException") === this.constructor.listenerCount) {
        console.error(error2);
        process.exit(1);
      }
    };
    this.uncaughtRejectionListener = (error2) => {
      let targetWindow = null;
      for (const window3 of this.observedWindows) {
        if (error2 instanceof window3.Error || error2 instanceof window3.DOMException) {
          targetWindow = window3;
          break;
        }
      }
      if (targetWindow) {
        targetWindow.console.error(error2);
        targetWindow.dispatchEvent(new targetWindow.ErrorEvent("error", {
          error: error2,
          message: error2.message
        }));
      } else if (process.listenerCount("unhandledRejection") === this.constructor.listenerCount) {
        console.error(error2);
        process.exit(1);
      }
    };
    this.constructor.listenerCount++;
    process.on("uncaughtException", this.uncaughtExceptionListener);
    process.on("unhandledRejection", this.uncaughtRejectionListener);
  }
  /**
   * Disconnects observer.
   *
   * @param window Browser window.
   */
  disconnect(window2) {
    const index = this.observedWindows.indexOf(window2);
    if (index === -1) {
      return;
    }
    this.observedWindows.splice(index, 1);
    if (this.observedWindows.length === 0 && this.uncaughtExceptionListener) {
      this.constructor.listenerCount--;
      process.off("uncaughtException", this.uncaughtExceptionListener);
      if (this.uncaughtRejectionListener) {
        process.off("unhandledRejection", this.uncaughtRejectionListener);
      }
      this.uncaughtExceptionListener = null;
      this.uncaughtRejectionListener = null;
    }
  }
};

// node_modules/happy-dom/lib/browser/Browser.js
var Browser = class {
  contexts;
  settings;
  console;
  [exceptionObserver] = null;
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.settings] Browser settings.
   * @param [options.console] Console.
   */
  constructor(options2) {
    this.console = options2?.console || null;
    this.settings = BrowserSettingsFactory.createSettings(options2?.settings);
    if (this.settings.errorCapture === BrowserErrorCaptureEnum_default.processLevel) {
      this[exceptionObserver] = new BrowserExceptionObserver();
    }
    this.contexts = [new BrowserContext(this)];
  }
  /**
   * Returns the default context.
   *
   * @returns Default context.
   */
  get defaultContext() {
    if (this.contexts.length === 0) {
      throw new Error("No default context. The browser has been closed.");
    }
    return this.contexts[0];
  }
  /**
   * Aborts all ongoing operations and destroys the browser.
   */
  async close() {
    await Promise.all(this.contexts.slice().map((context) => context.close()));
    this.contexts = [];
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   *
   * @returns Promise.
   */
  async waitUntilComplete() {
    if (this.contexts.length === 0) {
      throw new Error("No default context. The browser has been closed.");
    }
    await Promise.all(this.contexts.map((page) => page.waitUntilComplete()));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return new Promise((resolve, reject) => {
      if (!this.contexts.length) {
        resolve();
        return;
      }
      Promise.all(this.contexts.slice().map((context) => context.abort())).then(() => resolve()).catch((error2) => reject(error2));
    });
  }
  /**
   * Creates a new incognito context.
   *
   * @returns Context.
   */
  newIncognitoContext() {
    if (this.contexts.length === 0) {
      throw new Error("No default context. The browser has been closed.");
    }
    const context = new BrowserContext(this);
    this.contexts.push(context);
    return context;
  }
  /**
   * Creates a new page.
   *
   * @returns Page.
   */
  newPage() {
    if (this.contexts.length === 0) {
      throw new Error("No default context. The browser has been closed.");
    }
    return this.contexts[0].newPage();
  }
};

// node_modules/happy-dom/lib/browser/detached-browser/DetachedBrowserPage.js
var DetachedBrowserPage = class {
  virtualConsolePrinter = new VirtualConsolePrinter();
  mainFrame;
  context;
  console;
  viewport = Object.assign({}, DefaultBrowserPageViewport_default);
  /**
   * Constructor.
   *
   * @param context Browser context.
   */
  constructor(context) {
    this.context = context;
    this.console = context.browser.console ?? new VirtualConsole(this.virtualConsolePrinter);
    this.mainFrame = new DetachedBrowserFrame(this);
  }
  /**
   * Returns frames.
   */
  get frames() {
    return BrowserPageUtility.getFrames(this);
  }
  /**
   * Returns the viewport.
   */
  get content() {
    return this.mainFrame.content;
  }
  /**
   * Sets the content.
   *
   * @param content Content.
   */
  set content(content2) {
    this.mainFrame.content = content2;
  }
  /**
   * Returns the URL.
   *
   * @returns URL.
   */
  get url() {
    return this.mainFrame.url;
  }
  /**
   * Sets the content.
   *
   * @param url URL.
   */
  set url(url2) {
    this.mainFrame.url = url2;
  }
  /**
   * Aborts all ongoing operations and destroys the page.
   */
  close() {
    return new Promise((resolve, reject) => {
      const context = this.context;
      BrowserPageUtility.closePage(this).then(() => {
        if (context.pages[0] === this) {
          context.close().then(resolve).catch(reject);
        } else {
          resolve();
        }
      }).catch(reject);
    });
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   */
  waitUntilComplete() {
    return this.mainFrame.waitUntilComplete();
  }
  /**
   * Returns a promise that is resolved when the page has navigated and the response HTML has been written to the document.
   */
  waitForNavigation() {
    return this.mainFrame.waitForNavigation();
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return this.mainFrame.abort();
  }
  /**
   * Evaluates code or a VM Script in the page's context.
   *
   * @param script Script.
   * @returns Result.
   */
  evaluate(script) {
    return this.mainFrame.evaluate(script);
  }
  /**
   * Sets the viewport.
   *
   * @param viewport Viewport.
   */
  setViewport(viewport) {
    const previousViewport = Object.assign({}, this.viewport);
    Object.assign(this.viewport, viewport);
    if (previousViewport.width !== this.viewport.width || previousViewport.height !== this.viewport.height || previousViewport.devicePixelRatio !== this.viewport.devicePixelRatio) {
      this.mainFrame.window.dispatchEvent(new Event("resize"));
    }
  }
  /**
   * Go to a page.
   *
   * @param url URL.
   * @param [options] Options.
   * @returns Response.
   */
  goto(url2, options2) {
    return this.mainFrame.goto(url2, options2);
  }
  /**
   * Navigates back in history.
   *
   * @param [options] Options.
   */
  goBack(options2) {
    return this.mainFrame.goBack(options2);
  }
  /**
   * Navigates forward in history.
   *
   * @param [options] Options.
   */
  goForward(options2) {
    return this.mainFrame.goForward(options2);
  }
  /**
   * Navigates a delta in history.
   *
   * @param delta Delta.
   * @param steps
   * @param [options] Options.
   */
  goSteps(steps, options2) {
    return this.mainFrame.goSteps(steps, options2);
  }
  /**
   * Reloads the current page.
   *
   * @param [options] Options.
   * @returns Response.
   */
  reload(options2) {
    return this.mainFrame.reload(options2);
  }
};

// node_modules/happy-dom/lib/browser/detached-browser/DetachedBrowserContext.js
var DetachedBrowserContext = class {
  pages;
  browser;
  cookieContainer = new CookieContainer();
  responseCache = new ResponseCache();
  preflightResponseCache = new PreflightResponseCache();
  /**
   * Constructor.
   *
   * @param browser Browser.
   */
  constructor(browser) {
    this.browser = browser;
    this.pages = [];
    this.pages.push(new DetachedBrowserPage(this));
  }
  /**
   * Aborts all ongoing operations and destroys the context.
   */
  async close() {
    if (!this.browser) {
      return;
    }
    await Promise.all(this.pages.slice().map((page) => page.close()));
    const browser = this.browser;
    const index = browser.contexts.indexOf(this);
    if (index !== -1) {
      browser.contexts.splice(index, 1);
    }
    this.pages = [];
    this.browser = null;
    this.cookieContainer = null;
    this.responseCache.clear();
    this.preflightResponseCache.clear();
    this.responseCache = null;
    this.preflightResponseCache = null;
    if (browser.contexts.length === 0) {
      browser.close();
    }
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   *
   * @returns Promise.
   */
  async waitUntilComplete() {
    await Promise.all(this.pages.map((page) => page.waitUntilComplete()));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return new Promise((resolve, reject) => {
      if (!this.pages.length) {
        resolve();
        return;
      }
      Promise.all(this.pages.slice().map((page) => page.abort())).then(() => resolve()).catch((error2) => reject(error2));
    });
  }
  /**
   * Creates a new page.
   *
   * @param [opener] Opener.
   * @returns Page.
   */
  newPage() {
    const page = new DetachedBrowserPage(this);
    this.pages.push(page);
    return page;
  }
};

// node_modules/happy-dom/lib/browser/detached-browser/DetachedBrowser.js
var DetachedBrowser = class {
  contexts;
  settings;
  console;
  windowClass;
  [exceptionObserver] = null;
  /**
   * Constructor.
   *
   * @param windowClass Window class.
   * @param [options] Options.
   * @param [options.settings] Browser settings.
   * @param [options.console] Console.
   */
  constructor(windowClass, options2) {
    this.windowClass = windowClass;
    this.console = options2?.console || null;
    this.settings = BrowserSettingsFactory.createSettings(options2?.settings);
    if (this.settings.errorCapture === BrowserErrorCaptureEnum_default.processLevel) {
      this[exceptionObserver] = new BrowserExceptionObserver();
    }
    this.contexts = [];
    this.contexts.push(new DetachedBrowserContext(this));
  }
  /**
   * Returns the default context.
   *
   * @returns Default context.
   */
  get defaultContext() {
    if (this.contexts.length === 0) {
      throw new Error("No default context. The browser has been closed.");
    }
    return this.contexts[0];
  }
  /**
   * Aborts all ongoing operations and destroys the browser.
   */
  async close() {
    await Promise.all(this.contexts.slice().map((context) => context.close()));
    this.contexts = [];
    this.console = null;
    this.windowClass = null;
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   *
   * @returns Promise.
   */
  async waitUntilComplete() {
    await Promise.all(this.contexts.map((page) => page.waitUntilComplete()));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return new Promise((resolve, reject) => {
      if (!this.contexts.length) {
        resolve();
        return;
      }
      Promise.all(this.contexts.slice().map((context) => context.abort())).then(() => resolve()).catch((error2) => reject(error2));
    });
  }
  /**
   * Creates a new incognito context.
   */
  newIncognitoContext() {
    throw new Error("Not possible to create a new context on a detached browser.");
  }
  /**
   * Creates a new page.
   *
   * @returns Page.
   */
  newPage() {
    if (this.contexts.length === 0) {
      throw new Error("No default context. The browser has been closed.");
    }
    return this.contexts[0].newPage();
  }
};

// node_modules/happy-dom/lib/window/DetachedWindowAPI.js
var DetachedWindowAPI = class {
  #browserFrame;
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   */
  constructor(browserFrame) {
    this.#browserFrame = browserFrame;
  }
  /**
   * Returns settings.
   *
   * @returns Settings.
   */
  get settings() {
    return this.#browserFrame.page.context.browser.settings;
  }
  /**
   * Returns virtual console printer.
   *
   * @returns Virtual console printer.
   */
  get virtualConsolePrinter() {
    return this.#browserFrame.page.virtualConsolePrinter;
  }
  /**
   * Waits for all async tasks to complete.
   *
   * @returns Promise.
   */
  waitUntilComplete() {
    return this.#browserFrame.waitUntilComplete();
  }
  /**
   * Waits for all async tasks to complete.
   *
   * @deprecated Use waitUntilComplete() instead.
   * @returns Promise.
   */
  whenAsyncComplete() {
    return this.waitUntilComplete();
  }
  /**
   * Aborts all async tasks.
   */
  abort() {
    return this.#browserFrame.abort();
  }
  /**
   * Aborts all async tasks.
   *
   * @deprecated Use abort() instead.
   */
  cancelAsync() {
    return this.abort();
  }
  /**
   * Aborts all async tasks and closes the window.
   */
  close() {
    return this.#browserFrame.page.close();
  }
  /**
   * Sets the URL without navigating the browser.
   *
   * @param url URL.
   */
  setURL(url2) {
    this.#browserFrame.url = url2;
  }
  /**
   * Sets the viewport.
   *
   * @param viewport Viewport.
   */
  setViewport(viewport) {
    this.#browserFrame.page.setViewport(viewport);
  }
  /**
   * Sets the window size.
   *
   * @deprecated Use setViewport() instead.
   * @param options Options.
   * @param options.width Width.
   * @param options.height Height.
   */
  setWindowSize(options2) {
    this.setViewport({
      width: options2?.width,
      height: options2?.height
    });
  }
  /**
   * Sets the window width.
   *
   * @deprecated Use setViewport() instead.
   * @param width Width.
   */
  setInnerWidth(width2) {
    this.setViewport({ width: width2 });
  }
  /**
   * Sets the window height.
   *
   * @deprecated Use setViewport() instead.
   * @param height Height.
   */
  setInnerHeight(height2) {
    this.setViewport({ height: height2 });
  }
};

// node_modules/happy-dom/lib/window/Window.js
var Window = class extends BrowserWindow {
  // Detached Window API.
  happyDOM;
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.width] Window width. Defaults to "1024".
   * @param [options.height] Window height. Defaults to "768".
   * @param [options.innerWidth] Inner width. Deprecated. Defaults to "1024".
   * @param [options.innerHeight] Inner height. Deprecated. Defaults to "768".
   * @param [options.url] URL.
   * @param [options.console] Console.
   * @param [options.settings] Settings.
   */
  constructor(options2) {
    const browser = new DetachedBrowser(BrowserWindow, {
      console: options2?.console,
      settings: options2?.settings
    });
    const browserPage = browser.defaultContext.pages[0];
    const browserFrame = browserPage.mainFrame;
    if (options2 && (options2.width || options2.height || options2.innerWidth || options2.innerHeight)) {
      Object.assign(browserPage.viewport, {
        width: options2.width || options2.innerWidth || browserPage.viewport.width,
        height: options2.height || options2.innerHeight || browserPage.viewport.height
      });
    }
    super(browserFrame, {
      url: options2?.url
    });
    browserFrame.window = this;
    this.happyDOM = new DetachedWindowAPI(browserFrame);
  }
};

// node_modules/happy-dom/lib/window/GlobalWindow.js
import { Buffer as Buffer9 } from "buffer";
var GlobalWindow = class extends Window {
  // Node.js Globals
  Array = globalThis.Array;
  ArrayBuffer = globalThis.ArrayBuffer;
  Boolean = globalThis.Boolean;
  Buffer = Buffer9;
  DataView = globalThis.DataView;
  Date = globalThis.Date;
  Error = globalThis.Error;
  EvalError = globalThis.EvalError;
  Float32Array = globalThis.Float32Array;
  Float64Array = globalThis.Float64Array;
  Function = globalThis.Function;
  Infinity = globalThis.Infinity;
  Int16Array = globalThis.Int16Array;
  Int32Array = globalThis.Int32Array;
  Int8Array = globalThis.Int8Array;
  Intl = globalThis.Intl;
  JSON = globalThis.JSON;
  Map = globalThis.Map;
  Math = globalThis.Math;
  NaN = globalThis.NaN;
  Number = globalThis.Number;
  Object = globalThis.Object;
  Promise = globalThis.Promise;
  RangeError = globalThis.RangeError;
  ReferenceError = globalThis.ReferenceError;
  RegExp = globalThis.RegExp;
  Set = globalThis.Set;
  String = globalThis.String;
  Symbol = globalThis.Symbol;
  SyntaxError = globalThis.SyntaxError;
  TypeError = globalThis.TypeError;
  URIError = globalThis.URIError;
  Uint16Array = globalThis.Uint16Array;
  Uint32Array = globalThis.Uint32Array;
  Uint8Array = globalThis.Uint8Array;
  Uint8ClampedArray = globalThis.Uint8ClampedArray;
  WeakMap = globalThis.WeakMap;
  WeakSet = globalThis.WeakSet;
  decodeURI = globalThis.decodeURI;
  decodeURIComponent = globalThis.decodeURIComponent;
  encodeURI = globalThis.encodeURI;
  encodeURIComponent = globalThis.encodeURIComponent;
  eval = globalThis.eval;
  /**
   * @deprecated
   */
  escape = globalThis.escape;
  global = globalThis;
  isFinite = globalThis.isFinite;
  isNaN = globalThis.isNaN;
  parseFloat = globalThis.parseFloat;
  parseInt = globalThis.parseInt;
  undefined = globalThis.undefined;
  /**
   * @deprecated
   */
  unescape = globalThis.unescape;
  gc = globalThis.gc;
  v8debug = globalThis.v8debug;
  /**
   * Setup of VM context.
   */
  [setupVMContext]() {
  }
};

// node_modules/@happy-dom/global-registrator/lib/GlobalRegistrator.js
var IGNORE_LIST = ["constructor", "undefined", "NaN", "global", "globalThis"];
var GlobalRegistrator = class {
  static #registered = null;
  /**
   * Returns the registered state.
   *
   * @returns Registered state.
   */
  static get isRegistered() {
    return this.#registered !== null;
  }
  /**
   * Registers Happy DOM globally.
   *
   * @param [options] Options.
   * @param [options.width] Window width. Defaults to "1024".
   * @param [options.height] Window height. Defaults to "768".
   * @param [options.url] URL.
   * @param [options.settings] Settings.
   */
  static register(options2) {
    if (this.#registered !== null) {
      throw new Error("Failed to register. Happy DOM has already been globally registered.");
    }
    const window2 = new GlobalWindow({ ...options2, console: globalThis.console });
    this.#registered = {};
    const propertyDescriptors = Object.getOwnPropertyDescriptors(window2);
    for (const key of Object.keys(propertyDescriptors)) {
      if (!IGNORE_LIST.includes(key)) {
        const windowPropertyDescriptor = propertyDescriptors[key];
        const globalPropertyDescriptor = Object.getOwnPropertyDescriptor(globalThis, key);
        if (globalPropertyDescriptor?.value === void 0 || globalPropertyDescriptor?.value !== windowPropertyDescriptor.value) {
          this.#registered[key] = globalPropertyDescriptor || null;
          if (windowPropertyDescriptor.value === window2) {
            window2[key] = globalThis;
            windowPropertyDescriptor.value = globalThis;
          }
          Object.defineProperty(globalThis, key, {
            ...windowPropertyDescriptor,
            configurable: true
          });
        }
      }
    }
    const propertySymbols = Object.getOwnPropertySymbols(window2);
    for (const key of propertySymbols) {
      const propertyDescriptor = Object.getOwnPropertyDescriptor(window2, key);
      this.#registered[key] = null;
      if (propertyDescriptor.value === window2) {
        window2[key] = globalThis;
        propertyDescriptor.value = globalThis;
      }
      Object.defineProperty(globalThis, key, {
        ...propertyDescriptor,
        configurable: true
      });
    }
    globalThis.document[PropertySymbol_exports.defaultView] = globalThis;
  }
  /**
   * Closes the window and unregisters Happy DOM from being global.
   */
  static async unregister() {
    if (this.#registered === null) {
      throw new Error("Failed to unregister. Happy DOM has not previously been globally registered.");
    }
    const happyDOM = globalThis.happyDOM;
    for (const key of Object.keys(this.#registered)) {
      if (this.#registered[key] !== null) {
        Object.defineProperty(globalThis, key, this.#registered[key]);
      } else {
        delete globalThis[key];
      }
    }
    this.#registered = null;
    if (happyDOM) {
      await happyDOM.close();
    }
  }
};

// index.mjs
function register(options2) {
  return GlobalRegistrator.register(options2);
}
function unregister() {
  return GlobalRegistrator.unregister();
}
function isRegistered() {
  return GlobalRegistrator.isRegistered;
}
export {
  isRegistered,
  register,
  unregister
};
